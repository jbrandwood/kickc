Fixing pointer addition (word*~) bsearch16u::$7 ← (word*) bsearch16u::items + (byte~) bsearch16u::$6
Fixing pointer addition (word*~) bsearch16u::$15 ← (word*) bsearch16u::pivot + (number) 1
Fixing pointer addition (word*~) bsearch16u::$1 ← (word*) bsearch16u::items - (number) 1
Fixing pointer array-indexing *((word*) utoa::digit_values + (byte) utoa::digit)
Fixing pointer array-indexing *((dword*) ultoa::digit_values + (byte) ultoa::digit)
Warning! Adding boolean cast to non-boolean condition *((byte*) strcpy::src)
Warning! Adding boolean cast to non-boolean sub-expression *((byte*) main::sieve_i)
Warning! Adding boolean cast to non-boolean sub-expression *((byte*) sieve + (word) main::i)
Identified constant variable (byte*) HEAP_TOP
Identified constant variable (byte*) sieve
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call (byte~) main::$0 ← call toD018 (byte*) SCREEN (byte*)(number) $1800 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) memset::@5
Culled Empty Block (label) memset::@3
Culled Empty Block (label) @3
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) clock::@1
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) divr16u::@7
Culled Empty Block (label) @13
Culled Empty Block (label) @14
Culled Empty Block (label) div32u16u::@1
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) @18
Culled Empty Block (label) @19
Culled Empty Block (label) @20
Culled Empty Block (label) @21
Culled Empty Block (label) utoa::@13
Culled Empty Block (label) utoa::@5
Culled Empty Block (label) utoa::@14
Culled Empty Block (label) utoa::@6
Culled Empty Block (label) utoa::@15
Culled Empty Block (label) utoa::@7
Culled Empty Block (label) utoa::@16
Culled Empty Block (label) utoa::@17
Culled Empty Block (label) @23
Culled Empty Block (label) utoa_append::@4
Culled Empty Block (label) utoa_append::@5
Culled Empty Block (label) utoa_append::@6
Culled Empty Block (label) utoa_append::@7
Culled Empty Block (label) ultoa::@13
Culled Empty Block (label) ultoa::@5
Culled Empty Block (label) ultoa::@14
Culled Empty Block (label) ultoa::@6
Culled Empty Block (label) ultoa::@15
Culled Empty Block (label) ultoa::@7
Culled Empty Block (label) ultoa::@16
Culled Empty Block (label) ultoa::@17
Culled Empty Block (label) @25
Culled Empty Block (label) ultoa_append::@4
Culled Empty Block (label) ultoa_append::@5
Culled Empty Block (label) ultoa_append::@6
Culled Empty Block (label) ultoa_append::@7
Culled Empty Block (label) @27
Culled Empty Block (label) @28
Culled Empty Block (label) print_str::@4
Culled Empty Block (label) print_str::@3
Culled Empty Block (label) print_str::@5
Culled Empty Block (label) print_str::@6
Culled Empty Block (label) @29
Culled Empty Block (label) @30
Culled Empty Block (label) @31
Culled Empty Block (label) @32
Culled Empty Block (label) @33
Culled Empty Block (label) @34
Culled Empty Block (label) @35
Culled Empty Block (label) @37
Culled Empty Block (label) @38
Culled Empty Block (label) @40
Culled Empty Block (label) @41
Culled Empty Block (label) @42
Culled Empty Block (label) @43
Culled Empty Block (label) @44
Culled Empty Block (label) @45
Culled Empty Block (label) @46
Culled Empty Block (label) @47
Culled Empty Block (label) @48
Culled Empty Block (label) main::toD0181_@1
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@12
Culled Empty Block (label) main::@8
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@9
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@22
Culled Empty Block (label) main::@21
Culled Empty Block (label) main::@23
Culled Empty Block (label) main::@24

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@4
memset: scope:[memset]  from main::@31 print_cls
  (byte) memset::c#4 ← phi( main::@31/(byte) memset::c#1 print_cls/(byte) memset::c#0 )
  (void*) memset::str#4 ← phi( main::@31/(void*) memset::str#1 print_cls/(void*) memset::str#0 )
  (word) memset::num#2 ← phi( main::@31/(word) memset::num#1 print_cls/(word) memset::num#0 )
  (bool~) memset::$0 ← (word) memset::num#2 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@4
  (void*) memset::str#2 ← phi( memset/(void*) memset::str#4 memset::@4/(void*) memset::str#5 )
  (void*) memset::return#0 ← (void*) memset::str#2
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#3 ← phi( memset/(byte) memset::c#4 )
  (word) memset::num#3 ← phi( memset/(word) memset::num#2 )
  (void*) memset::str#3 ← phi( memset/(void*) memset::str#4 )
  (byte*~) memset::$2 ← ((byte*)) (void*) memset::str#3
  (byte*~) memset::$3 ← (byte*~) memset::$2 + (word) memset::num#3
  (byte*) memset::end#0 ← (byte*~) memset::$3
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#3
  to:memset::@4
memset::@4: scope:[memset]  from memset::@2 memset::@4
  (void*) memset::str#5 ← phi( memset::@2/(void*) memset::str#3 memset::@4/(void*) memset::str#5 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@4/(byte*) memset::end#1 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@4/(byte*) memset::dst#1 )
  (byte) memset::c#2 ← phi( memset::@2/(byte) memset::c#3 memset::@4/(byte) memset::c#2 )
  *((byte*) memset::dst#2) ← (byte) memset::c#2
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  (bool~) memset::$4 ← (byte*) memset::dst#1 != (byte*) memset::end#1
  if((bool~) memset::$4) goto memset::@4
  to:memset::@1
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#4 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#4
  return 
  to:@return
@4: scope:[]  from @begin
  (byte*) D018#0 ← ((byte*)) (number) $d018
  (dword*) CIA2_TIMER_AB#0 ← ((dword*)) (number) $dd04
  (byte*) CIA2_TIMER_A_CONTROL#0 ← ((byte*)) (number) $dd0e
  (byte*) CIA2_TIMER_B_CONTROL#0 ← ((byte*)) (number) $dd0f
  (byte) CIA_TIMER_CONTROL_STOP#0 ← (number) 0
  (byte) CIA_TIMER_CONTROL_START#0 ← (number) 1
  (byte) CIA_TIMER_CONTROL_CONTINUOUS#0 ← (number) 0
  (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 ← (number) 0
  (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 ← (number) $40
  to:@8
@8: scope:[]  from @4
  (word) CLOCKS_PER_FRAME#0 ← (number) $4cc8
  (byte) FRAMES_PER_SEC#0 ← (number) $3c
  (word~) $0 ← (word) CLOCKS_PER_FRAME#0 * (byte) FRAMES_PER_SEC#0
  (dword) CLOCKS_PER_SEC#0 ← (word~) $0
  (dword) CLOCKS_PER_INIT#0 ← (number) $12
  to:@12
clock: scope:[clock]  from main::@3
  (number~) clock::$0 ← (number) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
  (dword) clock::return#0 ← (number~) clock::$0
  to:clock::@return
clock::@return: scope:[clock]  from clock
  (dword) clock::return#3 ← phi( clock/(dword) clock::return#0 )
  (dword) clock::return#1 ← (dword) clock::return#3
  return 
  to:@return
clock_start: scope:[clock_start]  from main::@32
  (byte~) clock_start::$0 ← (byte) CIA_TIMER_CONTROL_STOP#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$1 ← (byte~) clock_start::$0 | (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
  *((byte*) CIA2_TIMER_A_CONTROL#0) ← (byte~) clock_start::$1
  (byte~) clock_start::$2 ← (byte) CIA_TIMER_CONTROL_STOP#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$3 ← (byte~) clock_start::$2 | (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  *((byte*) CIA2_TIMER_B_CONTROL#0) ← (byte~) clock_start::$3
  *((dword*) CIA2_TIMER_AB#0) ← (number) $ffffffff
  (byte~) clock_start::$4 ← (byte) CIA_TIMER_CONTROL_START#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$5 ← (byte~) clock_start::$4 | (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  *((byte*) CIA2_TIMER_B_CONTROL#0) ← (byte~) clock_start::$5
  (byte~) clock_start::$6 ← (byte) CIA_TIMER_CONTROL_START#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  (byte~) clock_start::$7 ← (byte~) clock_start::$6 | (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
  *((byte*) CIA2_TIMER_A_CONTROL#0) ← (byte~) clock_start::$7
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  return 
  to:@return
@12: scope:[]  from @8
  (word) rem16u#0 ← (number) 0
  to:@22
divr16u: scope:[divr16u]  from div32u16u div32u16u::@2
  (word) divr16u::divisor#6 ← phi( div32u16u/(word) divr16u::divisor#0 div32u16u::@2/(word) divr16u::divisor#1 )
  (word) divr16u::dividend#5 ← phi( div32u16u/(word) divr16u::dividend#1 div32u16u::@2/(word) divr16u::dividend#2 )
  (word) divr16u::rem#10 ← phi( div32u16u/(word) divr16u::rem#3 div32u16u::@2/(word) divr16u::rem#4 )
  (word) divr16u::quotient#0 ← (number) 0
  (byte) divr16u::i#0 ← (byte) 0
  to:divr16u::@1
divr16u::@1: scope:[divr16u]  from divr16u divr16u::@3
  (byte) divr16u::i#5 ← phi( divr16u/(byte) divr16u::i#0 divr16u::@3/(byte) divr16u::i#1 )
  (word) divr16u::divisor#4 ← phi( divr16u/(word) divr16u::divisor#6 divr16u::@3/(word) divr16u::divisor#7 )
  (word) divr16u::quotient#6 ← phi( divr16u/(word) divr16u::quotient#0 divr16u::@3/(word) divr16u::quotient#8 )
  (word) divr16u::dividend#3 ← phi( divr16u/(word) divr16u::dividend#5 divr16u::@3/(word) divr16u::dividend#6 )
  (word) divr16u::rem#5 ← phi( divr16u/(word) divr16u::rem#10 divr16u::@3/(word) divr16u::rem#11 )
  (word~) divr16u::$0 ← (word) divr16u::rem#5 << (number) 1
  (word) divr16u::rem#0 ← (word~) divr16u::$0
  (byte~) divr16u::$1 ← > (word) divr16u::dividend#3
  (number~) divr16u::$2 ← (byte~) divr16u::$1 & (number) $80
  (bool~) divr16u::$3 ← (number~) divr16u::$2 != (number) 0
  (bool~) divr16u::$4 ← ! (bool~) divr16u::$3
  if((bool~) divr16u::$4) goto divr16u::@2
  to:divr16u::@4
divr16u::@2: scope:[divr16u]  from divr16u::@1 divr16u::@4
  (byte) divr16u::i#3 ← phi( divr16u::@1/(byte) divr16u::i#5 divr16u::@4/(byte) divr16u::i#6 )
  (word) divr16u::divisor#2 ← phi( divr16u::@1/(word) divr16u::divisor#4 divr16u::@4/(word) divr16u::divisor#5 )
  (word) divr16u::rem#6 ← phi( divr16u::@1/(word) divr16u::rem#0 divr16u::@4/(word) divr16u::rem#1 )
  (word) divr16u::quotient#3 ← phi( divr16u::@1/(word) divr16u::quotient#6 divr16u::@4/(word) divr16u::quotient#7 )
  (word) divr16u::dividend#4 ← phi( divr16u::@1/(word) divr16u::dividend#3 divr16u::@4/(word) divr16u::dividend#7 )
  (word~) divr16u::$6 ← (word) divr16u::dividend#4 << (number) 1
  (word) divr16u::dividend#0 ← (word~) divr16u::$6
  (word~) divr16u::$7 ← (word) divr16u::quotient#3 << (number) 1
  (word) divr16u::quotient#1 ← (word~) divr16u::$7
  (bool~) divr16u::$8 ← (word) divr16u::rem#6 >= (word) divr16u::divisor#2
  (bool~) divr16u::$9 ← ! (bool~) divr16u::$8
  if((bool~) divr16u::$9) goto divr16u::@3
  to:divr16u::@5
divr16u::@4: scope:[divr16u]  from divr16u::@1
  (byte) divr16u::i#6 ← phi( divr16u::@1/(byte) divr16u::i#5 )
  (word) divr16u::divisor#5 ← phi( divr16u::@1/(word) divr16u::divisor#4 )
  (word) divr16u::quotient#7 ← phi( divr16u::@1/(word) divr16u::quotient#6 )
  (word) divr16u::dividend#7 ← phi( divr16u::@1/(word) divr16u::dividend#3 )
  (word) divr16u::rem#7 ← phi( divr16u::@1/(word) divr16u::rem#0 )
  (number~) divr16u::$5 ← (word) divr16u::rem#7 | (number) 1
  (word) divr16u::rem#1 ← (number~) divr16u::$5
  to:divr16u::@2
divr16u::@3: scope:[divr16u]  from divr16u::@2 divr16u::@5
  (word) divr16u::divisor#7 ← phi( divr16u::@2/(word) divr16u::divisor#2 divr16u::@5/(word) divr16u::divisor#3 )
  (word) divr16u::quotient#8 ← phi( divr16u::@2/(word) divr16u::quotient#1 divr16u::@5/(word) divr16u::quotient#2 )
  (word) divr16u::dividend#6 ← phi( divr16u::@2/(word) divr16u::dividend#0 divr16u::@5/(word) divr16u::dividend#8 )
  (word) divr16u::rem#11 ← phi( divr16u::@2/(word) divr16u::rem#6 divr16u::@5/(word) divr16u::rem#2 )
  (byte) divr16u::i#2 ← phi( divr16u::@2/(byte) divr16u::i#3 divr16u::@5/(byte) divr16u::i#4 )
  (byte) divr16u::i#1 ← (byte) divr16u::i#2 + rangenext(0,$f)
  (bool~) divr16u::$11 ← (byte) divr16u::i#1 != rangelast(0,$f)
  if((bool~) divr16u::$11) goto divr16u::@1
  to:divr16u::@6
divr16u::@5: scope:[divr16u]  from divr16u::@2
  (word) divr16u::dividend#8 ← phi( divr16u::@2/(word) divr16u::dividend#0 )
  (byte) divr16u::i#4 ← phi( divr16u::@2/(byte) divr16u::i#3 )
  (word) divr16u::divisor#3 ← phi( divr16u::@2/(word) divr16u::divisor#2 )
  (word) divr16u::rem#8 ← phi( divr16u::@2/(word) divr16u::rem#6 )
  (word) divr16u::quotient#4 ← phi( divr16u::@2/(word) divr16u::quotient#1 )
  (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#4
  (word~) divr16u::$10 ← (word) divr16u::rem#8 - (word) divr16u::divisor#3
  (word) divr16u::rem#2 ← (word~) divr16u::$10
  to:divr16u::@3
divr16u::@6: scope:[divr16u]  from divr16u::@3
  (word) divr16u::quotient#5 ← phi( divr16u::@3/(word) divr16u::quotient#8 )
  (word) divr16u::rem#9 ← phi( divr16u::@3/(word) divr16u::rem#11 )
  (word) rem16u#1 ← (word) divr16u::rem#9
  (word) divr16u::return#0 ← (word) divr16u::quotient#5
  to:divr16u::@return
divr16u::@return: scope:[divr16u]  from divr16u::@6
  (word) rem16u#9 ← phi( divr16u::@6/(word) rem16u#1 )
  (word) divr16u::return#4 ← phi( divr16u::@6/(word) divr16u::return#0 )
  (word) divr16u::return#1 ← (word) divr16u::return#4
  (word) rem16u#2 ← (word) rem16u#9
  return 
  to:@return
div32u16u: scope:[div32u16u]  from main::@34
  (word) rem16u#16 ← phi( main::@34/(word) rem16u#17 )
  (word) div32u16u::divisor#1 ← phi( main::@34/(word) div32u16u::divisor#0 )
  (dword) div32u16u::dividend#1 ← phi( main::@34/(dword) div32u16u::dividend#0 )
  (word~) div32u16u::$0 ← > (dword) div32u16u::dividend#1
  (word) divr16u::dividend#1 ← (word~) div32u16u::$0
  (word) divr16u::divisor#0 ← (word) div32u16u::divisor#1
  (word) divr16u::rem#3 ← (number) 0
  call divr16u 
  (word) divr16u::return#2 ← (word) divr16u::return#1
  to:div32u16u::@2
div32u16u::@2: scope:[div32u16u]  from div32u16u
  (word) div32u16u::divisor#2 ← phi( div32u16u/(word) div32u16u::divisor#1 )
  (dword) div32u16u::dividend#2 ← phi( div32u16u/(dword) div32u16u::dividend#1 )
  (word) rem16u#10 ← phi( div32u16u/(word) rem16u#2 )
  (word) divr16u::return#5 ← phi( div32u16u/(word) divr16u::return#2 )
  (word~) div32u16u::$1 ← (word) divr16u::return#5
  (word) rem16u#3 ← (word) rem16u#10
  (word) div32u16u::quotient_hi#0 ← (word~) div32u16u::$1
  (word~) div32u16u::$2 ← < (dword) div32u16u::dividend#2
  (word) divr16u::dividend#2 ← (word~) div32u16u::$2
  (word) divr16u::divisor#1 ← (word) div32u16u::divisor#2
  (word) divr16u::rem#4 ← (word) rem16u#3
  call divr16u 
  (word) divr16u::return#3 ← (word) divr16u::return#1
  to:div32u16u::@3
div32u16u::@3: scope:[div32u16u]  from div32u16u::@2
  (word) div32u16u::quotient_hi#1 ← phi( div32u16u::@2/(word) div32u16u::quotient_hi#0 )
  (word) rem16u#11 ← phi( div32u16u::@2/(word) rem16u#2 )
  (word) divr16u::return#6 ← phi( div32u16u::@2/(word) divr16u::return#3 )
  (word~) div32u16u::$3 ← (word) divr16u::return#6
  (word) rem16u#4 ← (word) rem16u#11
  (word) div32u16u::quotient_lo#0 ← (word~) div32u16u::$3
  (dword) div32u16u::quotient#0 ← ((dword)) { (word) div32u16u::quotient_hi#1, (word) div32u16u::quotient_lo#0 }
  (dword) div32u16u::return#0 ← (dword) div32u16u::quotient#0
  to:div32u16u::@return
div32u16u::@return: scope:[div32u16u]  from div32u16u::@3
  (word) rem16u#12 ← phi( div32u16u::@3/(word) rem16u#4 )
  (dword) div32u16u::return#3 ← phi( div32u16u::@3/(dword) div32u16u::return#0 )
  (dword) div32u16u::return#1 ← (dword) div32u16u::return#3
  (word) rem16u#5 ← (word) rem16u#12
  return 
  to:@return
@22: scope:[]  from @12
  (word) rem16u#43 ← phi( @12/(word) rem16u#0 )
  (byte[]) DIGITS#0 ← (const string) $1
  (word[]) RADIX_BINARY_VALUES#0 ← { (number) $8000, (number) $4000, (number) $2000, (number) $1000, (number) $800, (number) $400, (number) $200, (number) $100, (number) $80, (number) $40, (number) $20, (number) $10, (number) 8, (number) 4, (number) 2 }
  (word[]) RADIX_OCTAL_VALUES#0 ← { (number) $8000, (number) $1000, (number) $200, (number) $40, (number) 8 }
  (word[]) RADIX_DECIMAL_VALUES#0 ← { (number) $2710, (number) $3e8, (number) $64, (number) $a }
  (word[]) RADIX_HEXADECIMAL_VALUES#0 ← { (number) $1000, (number) $100, (number) $10 }
  to:@24
utoa: scope:[utoa]  from print_word_decimal
  (byte*) utoa::buffer#20 ← phi( print_word_decimal/(byte*) utoa::buffer#5 )
  (word) utoa::value#11 ← phi( print_word_decimal/(word) utoa::value#1 )
  (byte) utoa::radix#1 ← phi( print_word_decimal/(byte) utoa::radix#0 )
  (byte) utoa::max_digits#0 ← (byte) 0
  (word*) utoa::digit_values#0 ← (word*) 0
  (bool~) utoa::$0 ← (byte) utoa::radix#1 == (const byte) DECIMAL
  if((bool~) utoa::$0) goto utoa::@1
  to:utoa::@9
utoa::@1: scope:[utoa]  from utoa
  (byte*) utoa::buffer#16 ← phi( utoa/(byte*) utoa::buffer#20 )
  (word) utoa::value#7 ← phi( utoa/(word) utoa::value#11 )
  (byte) utoa::max_digits#1 ← (number) 5
  (word*) utoa::digit_values#1 ← (word[]) RADIX_DECIMAL_VALUES#0
  to:utoa::@8
utoa::@9: scope:[utoa]  from utoa
  (byte*) utoa::buffer#15 ← phi( utoa/(byte*) utoa::buffer#20 )
  (word) utoa::value#12 ← phi( utoa/(word) utoa::value#11 )
  (byte) utoa::radix#2 ← phi( utoa/(byte) utoa::radix#1 )
  (bool~) utoa::$1 ← (byte) utoa::radix#2 == (const byte) HEXADECIMAL
  if((bool~) utoa::$1) goto utoa::@2
  to:utoa::@10
utoa::@2: scope:[utoa]  from utoa::@9
  (byte*) utoa::buffer#17 ← phi( utoa::@9/(byte*) utoa::buffer#15 )
  (word) utoa::value#8 ← phi( utoa::@9/(word) utoa::value#12 )
  (byte) utoa::max_digits#2 ← (number) 4
  (word*) utoa::digit_values#2 ← (word[]) RADIX_HEXADECIMAL_VALUES#0
  to:utoa::@8
utoa::@10: scope:[utoa]  from utoa::@9
  (word) utoa::value#13 ← phi( utoa::@9/(word) utoa::value#12 )
  (byte*) utoa::buffer#13 ← phi( utoa::@9/(byte*) utoa::buffer#15 )
  (byte) utoa::radix#3 ← phi( utoa::@9/(byte) utoa::radix#2 )
  (bool~) utoa::$2 ← (byte) utoa::radix#3 == (const byte) OCTAL
  if((bool~) utoa::$2) goto utoa::@3
  to:utoa::@11
utoa::@3: scope:[utoa]  from utoa::@10
  (byte*) utoa::buffer#18 ← phi( utoa::@10/(byte*) utoa::buffer#13 )
  (word) utoa::value#9 ← phi( utoa::@10/(word) utoa::value#13 )
  (byte) utoa::max_digits#3 ← (number) 6
  (word*) utoa::digit_values#3 ← (word[]) RADIX_OCTAL_VALUES#0
  to:utoa::@8
utoa::@11: scope:[utoa]  from utoa::@10
  (word) utoa::value#14 ← phi( utoa::@10/(word) utoa::value#13 )
  (byte*) utoa::buffer#10 ← phi( utoa::@10/(byte*) utoa::buffer#13 )
  (byte) utoa::radix#4 ← phi( utoa::@10/(byte) utoa::radix#3 )
  (bool~) utoa::$3 ← (byte) utoa::radix#4 == (const byte) BINARY
  if((bool~) utoa::$3) goto utoa::@4
  to:utoa::@12
utoa::@4: scope:[utoa]  from utoa::@11
  (byte*) utoa::buffer#19 ← phi( utoa::@11/(byte*) utoa::buffer#10 )
  (word) utoa::value#10 ← phi( utoa::@11/(word) utoa::value#14 )
  (byte) utoa::max_digits#4 ← (number) $10
  (word*) utoa::digit_values#4 ← (word[]) RADIX_BINARY_VALUES#0
  to:utoa::@8
utoa::@12: scope:[utoa]  from utoa::@11
  (byte*) utoa::buffer#6 ← phi( utoa::@11/(byte*) utoa::buffer#10 )
  *((byte*) utoa::buffer#6) ← (byte) 'e'
  (byte*) utoa::buffer#0 ← ++ (byte*) utoa::buffer#6
  *((byte*) utoa::buffer#0) ← (byte) 'r'
  (byte*) utoa::buffer#1 ← ++ (byte*) utoa::buffer#0
  *((byte*) utoa::buffer#1) ← (byte) 'r'
  (byte*) utoa::buffer#2 ← ++ (byte*) utoa::buffer#1
  *((byte*) utoa::buffer#2) ← (number) 0
  to:utoa::@return
utoa::@return: scope:[utoa]  from utoa::@12 utoa::@21
  return 
  to:@return
utoa::@8: scope:[utoa]  from utoa::@1 utoa::@2 utoa::@3 utoa::@4
  (byte*) utoa::buffer#14 ← phi( utoa::@1/(byte*) utoa::buffer#16 utoa::@2/(byte*) utoa::buffer#17 utoa::@3/(byte*) utoa::buffer#18 utoa::@4/(byte*) utoa::buffer#19 )
  (byte) utoa::max_digits#8 ← phi( utoa::@1/(byte) utoa::max_digits#1 utoa::@2/(byte) utoa::max_digits#2 utoa::@3/(byte) utoa::max_digits#3 utoa::@4/(byte) utoa::max_digits#4 )
  (word) utoa::value#6 ← phi( utoa::@1/(word) utoa::value#7 utoa::@2/(word) utoa::value#8 utoa::@3/(word) utoa::value#9 utoa::@4/(word) utoa::value#10 )
  (word*) utoa::digit_values#7 ← phi( utoa::@1/(word*) utoa::digit_values#1 utoa::@2/(word*) utoa::digit_values#2 utoa::@3/(word*) utoa::digit_values#3 utoa::@4/(word*) utoa::digit_values#4 )
  (byte) utoa::started#0 ← (number) 0
  (byte) utoa::digit#0 ← (number) 0
  to:utoa::@18
utoa::@18: scope:[utoa]  from utoa::@19 utoa::@8
  (byte*) utoa::buffer#11 ← phi( utoa::@19/(byte*) utoa::buffer#12 utoa::@8/(byte*) utoa::buffer#14 )
  (byte) utoa::max_digits#6 ← phi( utoa::@19/(byte) utoa::max_digits#5 utoa::@8/(byte) utoa::max_digits#8 )
  (byte) utoa::started#2 ← phi( utoa::@19/(byte) utoa::started#3 utoa::@8/(byte) utoa::started#0 )
  (word) utoa::value#2 ← phi( utoa::@19/(word) utoa::value#5 utoa::@8/(word) utoa::value#6 )
  (word*) utoa::digit_values#5 ← phi( utoa::@19/(word*) utoa::digit_values#6 utoa::@8/(word*) utoa::digit_values#7 )
  (byte) utoa::digit#2 ← phi( utoa::@19/(byte) utoa::digit#1 utoa::@8/(byte) utoa::digit#0 )
  (byte~) utoa::$11 ← (byte) utoa::digit#2 * (const byte) SIZEOF_WORD
  (word) utoa::digit_value#0 ← *((word*) utoa::digit_values#5 + (byte~) utoa::$11)
  (bool~) utoa::$5 ← (word) utoa::value#2 >= (word) utoa::digit_value#0
  (bool~) utoa::$6 ← (byte) utoa::started#2 || (bool~) utoa::$5
  (bool~) utoa::$7 ← ! (bool~) utoa::$6
  if((bool~) utoa::$7) goto utoa::@19
  to:utoa::@20
utoa::@19: scope:[utoa]  from utoa::@18 utoa::@22
  (byte*) utoa::buffer#12 ← phi( utoa::@18/(byte*) utoa::buffer#11 utoa::@22/(byte*) utoa::buffer#3 )
  (byte) utoa::started#3 ← phi( utoa::@18/(byte) utoa::started#2 utoa::@22/(byte) utoa::started#1 )
  (word) utoa::value#5 ← phi( utoa::@18/(word) utoa::value#2 utoa::@22/(word) utoa::value#0 )
  (word*) utoa::digit_values#6 ← phi( utoa::@18/(word*) utoa::digit_values#5 utoa::@22/(word*) utoa::digit_values#8 )
  (byte) utoa::max_digits#5 ← phi( utoa::@18/(byte) utoa::max_digits#6 utoa::@22/(byte) utoa::max_digits#7 )
  (byte) utoa::digit#3 ← phi( utoa::@18/(byte) utoa::digit#2 utoa::@22/(byte) utoa::digit#4 )
  (byte) utoa::digit#1 ← ++ (byte) utoa::digit#3
  (number~) utoa::$9 ← (byte) utoa::max_digits#5 - (number) 1
  (bool~) utoa::$10 ← (byte) utoa::digit#1 < (number~) utoa::$9
  if((bool~) utoa::$10) goto utoa::@18
  to:utoa::@21
utoa::@20: scope:[utoa]  from utoa::@18
  (word*) utoa::digit_values#9 ← phi( utoa::@18/(word*) utoa::digit_values#5 )
  (byte) utoa::max_digits#9 ← phi( utoa::@18/(byte) utoa::max_digits#6 )
  (byte) utoa::digit#5 ← phi( utoa::@18/(byte) utoa::digit#2 )
  (word) utoa::digit_value#1 ← phi( utoa::@18/(word) utoa::digit_value#0 )
  (word) utoa::value#3 ← phi( utoa::@18/(word) utoa::value#2 )
  (byte*) utoa::buffer#7 ← phi( utoa::@18/(byte*) utoa::buffer#11 )
  (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#7
  (word) utoa_append::value#0 ← (word) utoa::value#3
  (word) utoa_append::sub#0 ← (word) utoa::digit_value#1
  call utoa_append 
  (word) utoa_append::return#0 ← (word) utoa_append::return#2
  to:utoa::@22
utoa::@22: scope:[utoa]  from utoa::@20
  (word*) utoa::digit_values#8 ← phi( utoa::@20/(word*) utoa::digit_values#9 )
  (byte) utoa::max_digits#7 ← phi( utoa::@20/(byte) utoa::max_digits#9 )
  (byte) utoa::digit#4 ← phi( utoa::@20/(byte) utoa::digit#5 )
  (byte*) utoa::buffer#8 ← phi( utoa::@20/(byte*) utoa::buffer#7 )
  (word) utoa_append::return#3 ← phi( utoa::@20/(word) utoa_append::return#0 )
  (word~) utoa::$8 ← (word) utoa_append::return#3
  (word) utoa::value#0 ← (word~) utoa::$8
  (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#8
  (byte) utoa::started#1 ← (number) 1
  to:utoa::@19
utoa::@21: scope:[utoa]  from utoa::@19
  (byte*) utoa::buffer#9 ← phi( utoa::@19/(byte*) utoa::buffer#12 )
  (word) utoa::value#4 ← phi( utoa::@19/(word) utoa::value#5 )
  (byte~) utoa::$4 ← ((byte)) (word) utoa::value#4
  *((byte*) utoa::buffer#9) ← *((byte[]) DIGITS#0 + (byte~) utoa::$4)
  (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#9
  *((byte*) utoa::buffer#4) ← (number) 0
  to:utoa::@return
utoa_append: scope:[utoa_append]  from utoa::@20
  (byte*) utoa_append::buffer#3 ← phi( utoa::@20/(byte*) utoa_append::buffer#0 )
  (word) utoa_append::sub#3 ← phi( utoa::@20/(word) utoa_append::sub#0 )
  (word) utoa_append::value#5 ← phi( utoa::@20/(word) utoa_append::value#0 )
  (byte) utoa_append::digit#0 ← (number) 0
  to:utoa_append::@1
utoa_append::@1: scope:[utoa_append]  from utoa_append utoa_append::@2
  (byte*) utoa_append::buffer#2 ← phi( utoa_append/(byte*) utoa_append::buffer#3 utoa_append::@2/(byte*) utoa_append::buffer#4 )
  (byte) utoa_append::digit#4 ← phi( utoa_append/(byte) utoa_append::digit#0 utoa_append::@2/(byte) utoa_append::digit#1 )
  (word) utoa_append::sub#1 ← phi( utoa_append/(word) utoa_append::sub#3 utoa_append::@2/(word) utoa_append::sub#2 )
  (word) utoa_append::value#2 ← phi( utoa_append/(word) utoa_append::value#5 utoa_append::@2/(word) utoa_append::value#1 )
  (bool~) utoa_append::$0 ← (word) utoa_append::value#2 >= (word) utoa_append::sub#1
  if((bool~) utoa_append::$0) goto utoa_append::@2
  to:utoa_append::@3
utoa_append::@2: scope:[utoa_append]  from utoa_append::@1
  (byte*) utoa_append::buffer#4 ← phi( utoa_append::@1/(byte*) utoa_append::buffer#2 )
  (word) utoa_append::sub#2 ← phi( utoa_append::@1/(word) utoa_append::sub#1 )
  (word) utoa_append::value#3 ← phi( utoa_append::@1/(word) utoa_append::value#2 )
  (byte) utoa_append::digit#2 ← phi( utoa_append::@1/(byte) utoa_append::digit#4 )
  (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2
  (word) utoa_append::value#1 ← (word) utoa_append::value#3 - (word) utoa_append::sub#2
  to:utoa_append::@1
utoa_append::@3: scope:[utoa_append]  from utoa_append::@1
  (word) utoa_append::value#4 ← phi( utoa_append::@1/(word) utoa_append::value#2 )
  (byte*) utoa_append::buffer#1 ← phi( utoa_append::@1/(byte*) utoa_append::buffer#2 )
  (byte) utoa_append::digit#3 ← phi( utoa_append::@1/(byte) utoa_append::digit#4 )
  *((byte*) utoa_append::buffer#1) ← *((byte[]) DIGITS#0 + (byte) utoa_append::digit#3)
  (word) utoa_append::return#1 ← (word) utoa_append::value#4
  to:utoa_append::@return
utoa_append::@return: scope:[utoa_append]  from utoa_append::@3
  (word) utoa_append::return#4 ← phi( utoa_append::@3/(word) utoa_append::return#1 )
  (word) utoa_append::return#2 ← (word) utoa_append::return#4
  return 
  to:@return
@24: scope:[]  from @22
  (word) rem16u#37 ← phi( @22/(word) rem16u#43 )
  (dword[]) RADIX_BINARY_VALUES_LONG#0 ← { (number) $80000000, (number) $40000000, (number) $20000000, (number) $10000000, (number) $8000000, (number) $4000000, (number) $2000000, (number) $1000000, (number) $800000, (number) $400000, (number) $200000, (number) $100000, (number) $80000, (number) $40000, (number) $20000, (number) $10000, (number) $8000, (number) $4000, (number) $2000, (number) $1000, (number) $800, (number) $400, (number) $200, (number) $100, (number) $80, (number) $40, (number) $20, (number) $10, (number) 8, (number) 4, (number) 2 }
  (dword[]) RADIX_OCTAL_VALUES_LONG#0 ← { (number) $40000000, (number) $8000000, (number) $1000000, (number) $200000, (number) $40000, (number) $8000, (number) $1000, (number) $200, (number) $40, (number) 8 }
  (dword[]) RADIX_DECIMAL_VALUES_LONG#0 ← { (number) $3b9aca00, (number) $5f5e100, (number) $989680, (number) $f4240, (number) $186a0, (number) $2710, (number) $3e8, (number) $64, (number) $a }
  (dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0 ← { (number) $10000000, (number) $1000000, (number) $100000, (number) $10000, (number) $1000, (number) $100, (number) $10 }
  to:@26
ultoa: scope:[ultoa]  from print_dword_decimal
  (byte*) ultoa::buffer#20 ← phi( print_dword_decimal/(byte*) ultoa::buffer#5 )
  (dword) ultoa::value#11 ← phi( print_dword_decimal/(dword) ultoa::value#1 )
  (byte) ultoa::radix#1 ← phi( print_dword_decimal/(byte) ultoa::radix#0 )
  (byte) ultoa::max_digits#0 ← (byte) 0
  (dword*) ultoa::digit_values#0 ← (dword*) 0
  (bool~) ultoa::$0 ← (byte) ultoa::radix#1 == (const byte) DECIMAL
  if((bool~) ultoa::$0) goto ultoa::@1
  to:ultoa::@9
ultoa::@1: scope:[ultoa]  from ultoa
  (byte*) ultoa::buffer#16 ← phi( ultoa/(byte*) ultoa::buffer#20 )
  (dword) ultoa::value#7 ← phi( ultoa/(dword) ultoa::value#11 )
  (byte) ultoa::max_digits#1 ← (number) $a
  (dword*) ultoa::digit_values#1 ← (dword[]) RADIX_DECIMAL_VALUES_LONG#0
  to:ultoa::@8
ultoa::@9: scope:[ultoa]  from ultoa
  (byte*) ultoa::buffer#15 ← phi( ultoa/(byte*) ultoa::buffer#20 )
  (dword) ultoa::value#12 ← phi( ultoa/(dword) ultoa::value#11 )
  (byte) ultoa::radix#2 ← phi( ultoa/(byte) ultoa::radix#1 )
  (bool~) ultoa::$1 ← (byte) ultoa::radix#2 == (const byte) HEXADECIMAL
  if((bool~) ultoa::$1) goto ultoa::@2
  to:ultoa::@10
ultoa::@2: scope:[ultoa]  from ultoa::@9
  (byte*) ultoa::buffer#17 ← phi( ultoa::@9/(byte*) ultoa::buffer#15 )
  (dword) ultoa::value#8 ← phi( ultoa::@9/(dword) ultoa::value#12 )
  (byte) ultoa::max_digits#2 ← (number) 8
  (dword*) ultoa::digit_values#2 ← (dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0
  to:ultoa::@8
ultoa::@10: scope:[ultoa]  from ultoa::@9
  (dword) ultoa::value#13 ← phi( ultoa::@9/(dword) ultoa::value#12 )
  (byte*) ultoa::buffer#13 ← phi( ultoa::@9/(byte*) ultoa::buffer#15 )
  (byte) ultoa::radix#3 ← phi( ultoa::@9/(byte) ultoa::radix#2 )
  (bool~) ultoa::$2 ← (byte) ultoa::radix#3 == (const byte) OCTAL
  if((bool~) ultoa::$2) goto ultoa::@3
  to:ultoa::@11
ultoa::@3: scope:[ultoa]  from ultoa::@10
  (byte*) ultoa::buffer#18 ← phi( ultoa::@10/(byte*) ultoa::buffer#13 )
  (dword) ultoa::value#9 ← phi( ultoa::@10/(dword) ultoa::value#13 )
  (byte) ultoa::max_digits#3 ← (number) $b
  (dword*) ultoa::digit_values#3 ← (dword[]) RADIX_OCTAL_VALUES_LONG#0
  to:ultoa::@8
ultoa::@11: scope:[ultoa]  from ultoa::@10
  (dword) ultoa::value#14 ← phi( ultoa::@10/(dword) ultoa::value#13 )
  (byte*) ultoa::buffer#10 ← phi( ultoa::@10/(byte*) ultoa::buffer#13 )
  (byte) ultoa::radix#4 ← phi( ultoa::@10/(byte) ultoa::radix#3 )
  (bool~) ultoa::$3 ← (byte) ultoa::radix#4 == (const byte) BINARY
  if((bool~) ultoa::$3) goto ultoa::@4
  to:ultoa::@12
ultoa::@4: scope:[ultoa]  from ultoa::@11
  (byte*) ultoa::buffer#19 ← phi( ultoa::@11/(byte*) ultoa::buffer#10 )
  (dword) ultoa::value#10 ← phi( ultoa::@11/(dword) ultoa::value#14 )
  (byte) ultoa::max_digits#4 ← (number) $20
  (dword*) ultoa::digit_values#4 ← (dword[]) RADIX_BINARY_VALUES_LONG#0
  to:ultoa::@8
ultoa::@12: scope:[ultoa]  from ultoa::@11
  (byte*) ultoa::buffer#6 ← phi( ultoa::@11/(byte*) ultoa::buffer#10 )
  *((byte*) ultoa::buffer#6) ← (byte) 'e'
  (byte*) ultoa::buffer#0 ← ++ (byte*) ultoa::buffer#6
  *((byte*) ultoa::buffer#0) ← (byte) 'r'
  (byte*) ultoa::buffer#1 ← ++ (byte*) ultoa::buffer#0
  *((byte*) ultoa::buffer#1) ← (byte) 'r'
  (byte*) ultoa::buffer#2 ← ++ (byte*) ultoa::buffer#1
  *((byte*) ultoa::buffer#2) ← (number) 0
  to:ultoa::@return
ultoa::@return: scope:[ultoa]  from ultoa::@12 ultoa::@21
  return 
  to:@return
ultoa::@8: scope:[ultoa]  from ultoa::@1 ultoa::@2 ultoa::@3 ultoa::@4
  (byte*) ultoa::buffer#14 ← phi( ultoa::@1/(byte*) ultoa::buffer#16 ultoa::@2/(byte*) ultoa::buffer#17 ultoa::@3/(byte*) ultoa::buffer#18 ultoa::@4/(byte*) ultoa::buffer#19 )
  (byte) ultoa::max_digits#8 ← phi( ultoa::@1/(byte) ultoa::max_digits#1 ultoa::@2/(byte) ultoa::max_digits#2 ultoa::@3/(byte) ultoa::max_digits#3 ultoa::@4/(byte) ultoa::max_digits#4 )
  (dword) ultoa::value#6 ← phi( ultoa::@1/(dword) ultoa::value#7 ultoa::@2/(dword) ultoa::value#8 ultoa::@3/(dword) ultoa::value#9 ultoa::@4/(dword) ultoa::value#10 )
  (dword*) ultoa::digit_values#7 ← phi( ultoa::@1/(dword*) ultoa::digit_values#1 ultoa::@2/(dword*) ultoa::digit_values#2 ultoa::@3/(dword*) ultoa::digit_values#3 ultoa::@4/(dword*) ultoa::digit_values#4 )
  (byte) ultoa::started#0 ← (number) 0
  (byte) ultoa::digit#0 ← (number) 0
  to:ultoa::@18
ultoa::@18: scope:[ultoa]  from ultoa::@19 ultoa::@8
  (byte*) ultoa::buffer#11 ← phi( ultoa::@19/(byte*) ultoa::buffer#12 ultoa::@8/(byte*) ultoa::buffer#14 )
  (byte) ultoa::max_digits#6 ← phi( ultoa::@19/(byte) ultoa::max_digits#5 ultoa::@8/(byte) ultoa::max_digits#8 )
  (byte) ultoa::started#2 ← phi( ultoa::@19/(byte) ultoa::started#3 ultoa::@8/(byte) ultoa::started#0 )
  (dword) ultoa::value#2 ← phi( ultoa::@19/(dword) ultoa::value#5 ultoa::@8/(dword) ultoa::value#6 )
  (dword*) ultoa::digit_values#5 ← phi( ultoa::@19/(dword*) ultoa::digit_values#6 ultoa::@8/(dword*) ultoa::digit_values#7 )
  (byte) ultoa::digit#2 ← phi( ultoa::@19/(byte) ultoa::digit#1 ultoa::@8/(byte) ultoa::digit#0 )
  (byte~) ultoa::$11 ← (byte) ultoa::digit#2 * (const byte) SIZEOF_DWORD
  (dword) ultoa::digit_value#0 ← *((dword*) ultoa::digit_values#5 + (byte~) ultoa::$11)
  (bool~) ultoa::$5 ← (dword) ultoa::value#2 >= (dword) ultoa::digit_value#0
  (bool~) ultoa::$6 ← (byte) ultoa::started#2 || (bool~) ultoa::$5
  (bool~) ultoa::$7 ← ! (bool~) ultoa::$6
  if((bool~) ultoa::$7) goto ultoa::@19
  to:ultoa::@20
ultoa::@19: scope:[ultoa]  from ultoa::@18 ultoa::@22
  (byte*) ultoa::buffer#12 ← phi( ultoa::@18/(byte*) ultoa::buffer#11 ultoa::@22/(byte*) ultoa::buffer#3 )
  (byte) ultoa::started#3 ← phi( ultoa::@18/(byte) ultoa::started#2 ultoa::@22/(byte) ultoa::started#1 )
  (dword) ultoa::value#5 ← phi( ultoa::@18/(dword) ultoa::value#2 ultoa::@22/(dword) ultoa::value#0 )
  (dword*) ultoa::digit_values#6 ← phi( ultoa::@18/(dword*) ultoa::digit_values#5 ultoa::@22/(dword*) ultoa::digit_values#8 )
  (byte) ultoa::max_digits#5 ← phi( ultoa::@18/(byte) ultoa::max_digits#6 ultoa::@22/(byte) ultoa::max_digits#7 )
  (byte) ultoa::digit#3 ← phi( ultoa::@18/(byte) ultoa::digit#2 ultoa::@22/(byte) ultoa::digit#4 )
  (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#3
  (number~) ultoa::$9 ← (byte) ultoa::max_digits#5 - (number) 1
  (bool~) ultoa::$10 ← (byte) ultoa::digit#1 < (number~) ultoa::$9
  if((bool~) ultoa::$10) goto ultoa::@18
  to:ultoa::@21
ultoa::@20: scope:[ultoa]  from ultoa::@18
  (dword*) ultoa::digit_values#9 ← phi( ultoa::@18/(dword*) ultoa::digit_values#5 )
  (byte) ultoa::max_digits#9 ← phi( ultoa::@18/(byte) ultoa::max_digits#6 )
  (byte) ultoa::digit#5 ← phi( ultoa::@18/(byte) ultoa::digit#2 )
  (dword) ultoa::digit_value#1 ← phi( ultoa::@18/(dword) ultoa::digit_value#0 )
  (dword) ultoa::value#3 ← phi( ultoa::@18/(dword) ultoa::value#2 )
  (byte*) ultoa::buffer#7 ← phi( ultoa::@18/(byte*) ultoa::buffer#11 )
  (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#7
  (dword) ultoa_append::value#0 ← (dword) ultoa::value#3
  (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#1
  call ultoa_append 
  (dword) ultoa_append::return#0 ← (dword) ultoa_append::return#2
  to:ultoa::@22
ultoa::@22: scope:[ultoa]  from ultoa::@20
  (dword*) ultoa::digit_values#8 ← phi( ultoa::@20/(dword*) ultoa::digit_values#9 )
  (byte) ultoa::max_digits#7 ← phi( ultoa::@20/(byte) ultoa::max_digits#9 )
  (byte) ultoa::digit#4 ← phi( ultoa::@20/(byte) ultoa::digit#5 )
  (byte*) ultoa::buffer#8 ← phi( ultoa::@20/(byte*) ultoa::buffer#7 )
  (dword) ultoa_append::return#3 ← phi( ultoa::@20/(dword) ultoa_append::return#0 )
  (dword~) ultoa::$8 ← (dword) ultoa_append::return#3
  (dword) ultoa::value#0 ← (dword~) ultoa::$8
  (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#8
  (byte) ultoa::started#1 ← (number) 1
  to:ultoa::@19
ultoa::@21: scope:[ultoa]  from ultoa::@19
  (byte*) ultoa::buffer#9 ← phi( ultoa::@19/(byte*) ultoa::buffer#12 )
  (dword) ultoa::value#4 ← phi( ultoa::@19/(dword) ultoa::value#5 )
  (byte~) ultoa::$4 ← ((byte)) (dword) ultoa::value#4
  *((byte*) ultoa::buffer#9) ← *((byte[]) DIGITS#0 + (byte~) ultoa::$4)
  (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#9
  *((byte*) ultoa::buffer#4) ← (number) 0
  to:ultoa::@return
ultoa_append: scope:[ultoa_append]  from ultoa::@20
  (byte*) ultoa_append::buffer#3 ← phi( ultoa::@20/(byte*) ultoa_append::buffer#0 )
  (dword) ultoa_append::sub#3 ← phi( ultoa::@20/(dword) ultoa_append::sub#0 )
  (dword) ultoa_append::value#5 ← phi( ultoa::@20/(dword) ultoa_append::value#0 )
  (byte) ultoa_append::digit#0 ← (number) 0
  to:ultoa_append::@1
ultoa_append::@1: scope:[ultoa_append]  from ultoa_append ultoa_append::@2
  (byte*) ultoa_append::buffer#2 ← phi( ultoa_append/(byte*) ultoa_append::buffer#3 ultoa_append::@2/(byte*) ultoa_append::buffer#4 )
  (byte) ultoa_append::digit#4 ← phi( ultoa_append/(byte) ultoa_append::digit#0 ultoa_append::@2/(byte) ultoa_append::digit#1 )
  (dword) ultoa_append::sub#1 ← phi( ultoa_append/(dword) ultoa_append::sub#3 ultoa_append::@2/(dword) ultoa_append::sub#2 )
  (dword) ultoa_append::value#2 ← phi( ultoa_append/(dword) ultoa_append::value#5 ultoa_append::@2/(dword) ultoa_append::value#1 )
  (bool~) ultoa_append::$0 ← (dword) ultoa_append::value#2 >= (dword) ultoa_append::sub#1
  if((bool~) ultoa_append::$0) goto ultoa_append::@2
  to:ultoa_append::@3
ultoa_append::@2: scope:[ultoa_append]  from ultoa_append::@1
  (byte*) ultoa_append::buffer#4 ← phi( ultoa_append::@1/(byte*) ultoa_append::buffer#2 )
  (dword) ultoa_append::sub#2 ← phi( ultoa_append::@1/(dword) ultoa_append::sub#1 )
  (dword) ultoa_append::value#3 ← phi( ultoa_append::@1/(dword) ultoa_append::value#2 )
  (byte) ultoa_append::digit#2 ← phi( ultoa_append::@1/(byte) ultoa_append::digit#4 )
  (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2
  (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#3 - (dword) ultoa_append::sub#2
  to:ultoa_append::@1
ultoa_append::@3: scope:[ultoa_append]  from ultoa_append::@1
  (dword) ultoa_append::value#4 ← phi( ultoa_append::@1/(dword) ultoa_append::value#2 )
  (byte*) ultoa_append::buffer#1 ← phi( ultoa_append::@1/(byte*) ultoa_append::buffer#2 )
  (byte) ultoa_append::digit#3 ← phi( ultoa_append::@1/(byte) ultoa_append::digit#4 )
  *((byte*) ultoa_append::buffer#1) ← *((byte[]) DIGITS#0 + (byte) ultoa_append::digit#3)
  (dword) ultoa_append::return#1 ← (dword) ultoa_append::value#4
  to:ultoa_append::@return
ultoa_append::@return: scope:[ultoa_append]  from ultoa_append::@3
  (dword) ultoa_append::return#4 ← phi( ultoa_append::@3/(dword) ultoa_append::return#1 )
  (dword) ultoa_append::return#2 ← (dword) ultoa_append::return#4
  return 
  to:@return
@26: scope:[]  from @24
  (word) rem16u#31 ← phi( @24/(word) rem16u#37 )
  (byte*) print_screen#0 ← ((byte*)) (number) $400
  (byte*) print_line_cursor#0 ← (byte*) print_screen#0
  (byte*) print_char_cursor#0 ← (byte*) print_line_cursor#0
  to:@36
print_str: scope:[print_str]  from main::@18 main::@26 main::@28 main::@35 main::@37 print_dword_decimal::@1 print_word_decimal::@1
  (byte*) print_char_cursor#66 ← phi( main::@18/(byte*) print_char_cursor#63 main::@26/(byte*) print_char_cursor#13 main::@28/(byte*) print_char_cursor#15 main::@35/(byte*) print_char_cursor#61 main::@37/(byte*) print_char_cursor#20 print_dword_decimal::@1/(byte*) print_char_cursor#59 print_word_decimal::@1/(byte*) print_char_cursor#58 )
  (byte*) print_str::str#10 ← phi( main::@18/(byte*) print_str::str#7 main::@26/(byte*) print_str::str#3 main::@28/(byte*) print_str::str#4 main::@35/(byte*) print_str::str#5 main::@37/(byte*) print_str::str#6 print_dword_decimal::@1/(byte*) print_str::str#2 print_word_decimal::@1/(byte*) print_str::str#1 )
  to:print_str::@1
print_str::@1: scope:[print_str]  from print_str print_str::@2
  (byte*) print_char_cursor#56 ← phi( print_str/(byte*) print_char_cursor#66 print_str::@2/(byte*) print_char_cursor#1 )
  (byte*) print_str::str#8 ← phi( print_str/(byte*) print_str::str#10 print_str::@2/(byte*) print_str::str#0 )
  (bool~) print_str::$0 ← *((byte*) print_str::str#8) != (byte) '@'
  if((bool~) print_str::$0) goto print_str::@2
  to:print_str::@return
print_str::@2: scope:[print_str]  from print_str::@1
  (byte*) print_char_cursor#29 ← phi( print_str::@1/(byte*) print_char_cursor#56 )
  (byte*) print_str::str#9 ← phi( print_str::@1/(byte*) print_str::str#8 )
  *((byte*) print_char_cursor#29) ← *((byte*) print_str::str#9)
  (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#29
  (byte*) print_str::str#0 ← ++ (byte*) print_str::str#9
  to:print_str::@1
print_str::@return: scope:[print_str]  from print_str::@1
  (byte*) print_char_cursor#30 ← phi( print_str::@1/(byte*) print_char_cursor#56 )
  (byte*) print_char_cursor#2 ← (byte*) print_char_cursor#30
  return 
  to:@return
print_ln: scope:[print_ln]  from main::@27 main::@30 main::@39
  (byte*) print_char_cursor#57 ← phi( main::@27/(byte*) print_char_cursor#14 main::@30/(byte*) print_char_cursor#17 main::@39/(byte*) print_char_cursor#22 )
  (byte*) print_line_cursor#21 ← phi( main::@27/(byte*) print_line_cursor#23 main::@30/(byte*) print_line_cursor#24 main::@39/(byte*) print_line_cursor#25 )
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  (byte*) print_char_cursor#31 ← phi( print_ln/(byte*) print_char_cursor#57 print_ln::@1/(byte*) print_char_cursor#31 )
  (byte*) print_line_cursor#11 ← phi( print_ln/(byte*) print_line_cursor#21 print_ln::@1/(byte*) print_line_cursor#1 )
  (byte*~) print_ln::$0 ← (byte*) print_line_cursor#11 + (number) $28
  (byte*) print_line_cursor#1 ← (byte*~) print_ln::$0
  (bool~) print_ln::$1 ← (byte*) print_line_cursor#1 < (byte*) print_char_cursor#31
  if((bool~) print_ln::$1) goto print_ln::@1
  to:print_ln::@2
print_ln::@2: scope:[print_ln]  from print_ln::@1
  (byte*) print_line_cursor#12 ← phi( print_ln::@1/(byte*) print_line_cursor#1 )
  (byte*) print_char_cursor#3 ← (byte*) print_line_cursor#12
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@2
  (byte*) print_char_cursor#32 ← phi( print_ln::@2/(byte*) print_char_cursor#3 )
  (byte*) print_line_cursor#13 ← phi( print_ln::@2/(byte*) print_line_cursor#12 )
  (byte*) print_line_cursor#2 ← (byte*) print_line_cursor#13
  (byte*) print_char_cursor#4 ← (byte*) print_char_cursor#32
  return 
  to:@return
@36: scope:[]  from @26
  (byte*) print_screen#10 ← phi( @26/(byte*) print_screen#0 )
  (word) rem16u#27 ← phi( @26/(word) rem16u#31 )
  (byte*) print_char_cursor#78 ← phi( @26/(byte*) print_char_cursor#0 )
  (byte*) print_line_cursor#38 ← phi( @26/(byte*) print_line_cursor#0 )
  (byte[6]) decimal_digits#0 ← { fill( 6, 0) }
  to:@39
print_word_decimal: scope:[print_word_decimal]  from main::@17 main::@29 main::@36
  (byte*) print_char_cursor#67 ← phi( main::@17/(byte*) print_char_cursor#62 main::@29/(byte*) print_char_cursor#16 main::@36/(byte*) print_char_cursor#19 )
  (word) print_word_decimal::w#3 ← phi( main::@17/(word) print_word_decimal::w#2 main::@29/(word) print_word_decimal::w#0 main::@36/(word) print_word_decimal::w#1 )
  (word) utoa::value#1 ← (word) print_word_decimal::w#3
  (byte*) utoa::buffer#5 ← (byte[6]) decimal_digits#0
  (byte) utoa::radix#0 ← (const byte) DECIMAL
  call utoa 
  to:print_word_decimal::@1
print_word_decimal::@1: scope:[print_word_decimal]  from print_word_decimal
  (byte*) print_char_cursor#58 ← phi( print_word_decimal/(byte*) print_char_cursor#67 )
  (byte*) print_str::str#1 ← (byte[6]) decimal_digits#0
  call print_str 
  to:print_word_decimal::@2
print_word_decimal::@2: scope:[print_word_decimal]  from print_word_decimal::@1
  (byte*) print_char_cursor#33 ← phi( print_word_decimal::@1/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#5 ← (byte*) print_char_cursor#33
  to:print_word_decimal::@return
print_word_decimal::@return: scope:[print_word_decimal]  from print_word_decimal::@2
  (byte*) print_char_cursor#34 ← phi( print_word_decimal::@2/(byte*) print_char_cursor#5 )
  (byte*) print_char_cursor#6 ← (byte*) print_char_cursor#34
  return 
  to:@return
@39: scope:[]  from @36
  (byte*) print_screen#9 ← phi( @36/(byte*) print_screen#10 )
  (word) rem16u#24 ← phi( @36/(word) rem16u#27 )
  (byte*) print_char_cursor#75 ← phi( @36/(byte*) print_char_cursor#78 )
  (byte*) print_line_cursor#34 ← phi( @36/(byte*) print_line_cursor#38 )
  (byte[$b]) decimal_digits_long#0 ← { fill( $b, 0) }
  to:@49
print_dword_decimal: scope:[print_dword_decimal]  from main::@38
  (byte*) print_char_cursor#68 ← phi( main::@38/(byte*) print_char_cursor#21 )
  (dword) print_dword_decimal::w#1 ← phi( main::@38/(dword) print_dword_decimal::w#0 )
  (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#1
  (byte*) ultoa::buffer#5 ← (byte[$b]) decimal_digits_long#0
  (byte) ultoa::radix#0 ← (const byte) DECIMAL
  call ultoa 
  to:print_dword_decimal::@1
print_dword_decimal::@1: scope:[print_dword_decimal]  from print_dword_decimal
  (byte*) print_char_cursor#59 ← phi( print_dword_decimal/(byte*) print_char_cursor#68 )
  (byte*) print_str::str#2 ← (byte[$b]) decimal_digits_long#0
  call print_str 
  to:print_dword_decimal::@2
print_dword_decimal::@2: scope:[print_dword_decimal]  from print_dword_decimal::@1
  (byte*) print_char_cursor#35 ← phi( print_dword_decimal::@1/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#7 ← (byte*) print_char_cursor#35
  to:print_dword_decimal::@return
print_dword_decimal::@return: scope:[print_dword_decimal]  from print_dword_decimal::@2
  (byte*) print_char_cursor#36 ← phi( print_dword_decimal::@2/(byte*) print_char_cursor#7 )
  (byte*) print_char_cursor#8 ← (byte*) print_char_cursor#36
  return 
  to:@return
print_char: scope:[print_char]  from main::@41
  (byte*) print_char_cursor#37 ← phi( main::@41/(byte*) print_char_cursor#24 )
  (byte) print_char::ch#1 ← phi( main::@41/(byte) print_char::ch#0 )
  *((byte*) print_char_cursor#37) ← (byte) print_char::ch#1
  (byte*) print_char_cursor#9 ← ++ (byte*) print_char_cursor#37
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  (byte*) print_char_cursor#38 ← phi( print_char/(byte*) print_char_cursor#9 )
  (byte*) print_char_cursor#10 ← (byte*) print_char_cursor#38
  return 
  to:@return
print_cls: scope:[print_cls]  from main::@25
  (byte*) print_screen#1 ← phi( main::@25/(byte*) print_screen#3 )
  (void*) memset::str#0 ← (void*)(byte*) print_screen#1
  (byte) memset::c#0 ← (byte) ' '
  (word) memset::num#0 ← (number) $3e8
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:print_cls::@1
print_cls::@1: scope:[print_cls]  from print_cls
  (byte*) print_screen#2 ← phi( print_cls/(byte*) print_screen#1 )
  (byte*) print_line_cursor#3 ← (byte*) print_screen#2
  (byte*) print_char_cursor#11 ← (byte*) print_line_cursor#3
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls::@1
  (byte*) print_char_cursor#39 ← phi( print_cls::@1/(byte*) print_char_cursor#11 )
  (byte*) print_line_cursor#14 ← phi( print_cls::@1/(byte*) print_line_cursor#3 )
  (byte*) print_line_cursor#4 ← (byte*) print_line_cursor#14
  (byte*) print_char_cursor#12 ← (byte*) print_char_cursor#39
  return 
  to:@return
@49: scope:[]  from @39
  (byte*) print_screen#8 ← phi( @39/(byte*) print_screen#9 )
  (word) rem16u#23 ← phi( @39/(word) rem16u#24 )
  (byte*) print_char_cursor#74 ← phi( @39/(byte*) print_char_cursor#75 )
  (byte*) print_line_cursor#33 ← phi( @39/(byte*) print_line_cursor#34 )
  (byte*) SCREEN#0 ← ((byte*)) (number) $400
  (word) COUNT#0 ← (number) $4000
  (byte) SQRT_COUNT#0 ← (number) $80
  (byte*) sieve#0 ← ((byte*)) (number) $1000
  to:@50
main: scope:[main]  from @50
  (word) rem16u#57 ← phi( @50/(word) rem16u#19 )
  (byte*) print_char_cursor#79 ← phi( @50/(byte*) print_char_cursor#65 )
  (byte*) print_line_cursor#39 ← phi( @50/(byte*) print_line_cursor#27 )
  (byte*) print_screen#6 ← phi( @50/(byte*) print_screen#7 )
  (byte*) main::toD0181_screen#0 ← (byte*) SCREEN#0
  (byte*) main::toD0181_gfx#0 ← (byte*)(number) $1800
  to:main::toD0181
main::toD0181: scope:[main]  from main
  (word) rem16u#56 ← phi( main/(word) rem16u#57 )
  (byte*) print_char_cursor#76 ← phi( main/(byte*) print_char_cursor#79 )
  (byte*) print_line_cursor#35 ← phi( main/(byte*) print_line_cursor#39 )
  (byte*) print_screen#5 ← phi( main/(byte*) print_screen#6 )
  (byte*) main::toD0181_gfx#1 ← phi( main/(byte*) main::toD0181_gfx#0 )
  (byte*) main::toD0181_screen#1 ← phi( main/(byte*) main::toD0181_screen#0 )
  (word~) main::toD0181_$0#0 ← ((word)) (byte*) main::toD0181_screen#1
  (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (number) $3fff
  (number~) main::toD0181_$2#0 ← (number~) main::toD0181_$1#0 * (number) 4
  (number~) main::toD0181_$3#0 ← > (number~) main::toD0181_$2#0
  (word~) main::toD0181_$4#0 ← ((word)) (byte*) main::toD0181_gfx#1
  (byte~) main::toD0181_$5#0 ← > (word~) main::toD0181_$4#0
  (number~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (number) 4
  (number~) main::toD0181_$7#0 ← (number~) main::toD0181_$6#0 & (number) $f
  (number~) main::toD0181_$8#0 ← (number~) main::toD0181_$3#0 | (number~) main::toD0181_$7#0
  (byte) main::toD0181_return#0 ← (number~) main::toD0181_$8#0
  to:main::toD0181_@return
main::toD0181_@return: scope:[main]  from main::toD0181
  (word) rem16u#55 ← phi( main::toD0181/(word) rem16u#56 )
  (byte*) print_char_cursor#69 ← phi( main::toD0181/(byte*) print_char_cursor#76 )
  (byte*) print_line_cursor#28 ← phi( main::toD0181/(byte*) print_line_cursor#35 )
  (byte*) print_screen#4 ← phi( main::toD0181/(byte*) print_screen#5 )
  (byte) main::toD0181_return#2 ← phi( main::toD0181/(byte) main::toD0181_return#0 )
  (byte) main::toD0181_return#1 ← (byte) main::toD0181_return#2
  to:main::@25
main::@25: scope:[main]  from main::toD0181_@return
  (word) rem16u#54 ← phi( main::toD0181_@return/(word) rem16u#55 )
  (byte*) print_char_cursor#60 ← phi( main::toD0181_@return/(byte*) print_char_cursor#69 )
  (byte*) print_line_cursor#22 ← phi( main::toD0181_@return/(byte*) print_line_cursor#28 )
  (byte*) print_screen#3 ← phi( main::toD0181_@return/(byte*) print_screen#4 )
  (byte) main::toD0181_return#3 ← phi( main::toD0181_@return/(byte) main::toD0181_return#1 )
  (byte~) main::$0 ← (byte) main::toD0181_return#3
  *((byte*) D018#0) ← (byte~) main::$0
  call print_cls 
  to:main::@26
main::@26: scope:[main]  from main::@25
  (word) rem16u#53 ← phi( main::@25/(word) rem16u#54 )
  (byte*) print_char_cursor#40 ← phi( main::@25/(byte*) print_char_cursor#12 )
  (byte*) print_line_cursor#15 ← phi( main::@25/(byte*) print_line_cursor#4 )
  (byte*) print_line_cursor#5 ← (byte*) print_line_cursor#15
  (byte*) print_char_cursor#13 ← (byte*) print_char_cursor#40
  (byte*) print_str::str#3 ← (const string) main::str
  call print_str 
  to:main::@27
main::@27: scope:[main]  from main::@26
  (word) rem16u#51 ← phi( main::@26/(word) rem16u#53 )
  (byte*) print_line_cursor#23 ← phi( main::@26/(byte*) print_line_cursor#5 )
  (byte*) print_char_cursor#41 ← phi( main::@26/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#14 ← (byte*) print_char_cursor#41
  call print_ln 
  to:main::@28
main::@28: scope:[main]  from main::@27
  (word) rem16u#49 ← phi( main::@27/(word) rem16u#51 )
  (byte*) print_char_cursor#42 ← phi( main::@27/(byte*) print_char_cursor#4 )
  (byte*) print_line_cursor#16 ← phi( main::@27/(byte*) print_line_cursor#2 )
  (byte*) print_line_cursor#6 ← (byte*) print_line_cursor#16
  (byte*) print_char_cursor#15 ← (byte*) print_char_cursor#42
  (byte*) print_str::str#4 ← (const string) main::str1
  call print_str 
  to:main::@29
main::@29: scope:[main]  from main::@28
  (word) rem16u#47 ← phi( main::@28/(word) rem16u#49 )
  (byte*) print_line_cursor#29 ← phi( main::@28/(byte*) print_line_cursor#6 )
  (byte*) print_char_cursor#43 ← phi( main::@28/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#16 ← (byte*) print_char_cursor#43
  (word) print_word_decimal::w#0 ← (word) COUNT#0
  call print_word_decimal 
  to:main::@30
main::@30: scope:[main]  from main::@29
  (word) rem16u#44 ← phi( main::@29/(word) rem16u#47 )
  (byte*) print_line_cursor#24 ← phi( main::@29/(byte*) print_line_cursor#29 )
  (byte*) print_char_cursor#44 ← phi( main::@29/(byte*) print_char_cursor#6 )
  (byte*) print_char_cursor#17 ← (byte*) print_char_cursor#44
  call print_ln 
  to:main::@31
main::@31: scope:[main]  from main::@30
  (word) rem16u#38 ← phi( main::@30/(word) rem16u#44 )
  (byte*) print_char_cursor#45 ← phi( main::@30/(byte*) print_char_cursor#4 )
  (byte*) print_line_cursor#17 ← phi( main::@30/(byte*) print_line_cursor#2 )
  (byte*) print_line_cursor#7 ← (byte*) print_line_cursor#17
  (byte*) print_char_cursor#18 ← (byte*) print_char_cursor#45
  (void*) memset::str#1 ← (void*)(byte*) sieve#0
  (byte) memset::c#1 ← (number) 0
  (word) memset::num#1 ← (word) COUNT#0
  call memset 
  (void*) memset::return#3 ← (void*) memset::return#1
  to:main::@32
main::@32: scope:[main]  from main::@31
  (byte*) print_line_cursor#52 ← phi( main::@31/(byte*) print_line_cursor#7 )
  (byte*) print_char_cursor#83 ← phi( main::@31/(byte*) print_char_cursor#18 )
  (word) rem16u#32 ← phi( main::@31/(word) rem16u#38 )
  call clock_start 
  to:main::@33
main::@33: scope:[main]  from main::@32
  (byte*) print_line_cursor#50 ← phi( main::@32/(byte*) print_line_cursor#52 )
  (byte*) print_char_cursor#81 ← phi( main::@32/(byte*) print_char_cursor#83 )
  (word) rem16u#28 ← phi( main::@32/(word) rem16u#32 )
  (word) main::i#0 ← (number) 2
  (byte*~) main::$9 ← (byte*) sieve#0 + (word) main::i#0
  (byte*) main::sieve_i#0 ← (byte*~) main::$9
  to:main::@1
main::@1: scope:[main]  from main::@33 main::@4
  (byte*) print_line_cursor#49 ← phi( main::@33/(byte*) print_line_cursor#50 main::@4/(byte*) print_line_cursor#51 )
  (byte*) print_char_cursor#80 ← phi( main::@33/(byte*) print_char_cursor#81 main::@4/(byte*) print_char_cursor#82 )
  (word) rem16u#25 ← phi( main::@33/(word) rem16u#28 main::@4/(word) rem16u#29 )
  (byte*) main::sieve_i#4 ← phi( main::@33/(byte*) main::sieve_i#0 main::@4/(byte*) main::sieve_i#1 )
  (word) main::i#4 ← phi( main::@33/(word) main::i#0 main::@4/(word) main::i#2 )
  (bool~) main::$22 ← (word) main::i#4 < (byte) SQRT_COUNT#0
  if((bool~) main::$22) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) print_line_cursor#53 ← phi( main::@1/(byte*) print_line_cursor#49 )
  (byte*) print_char_cursor#84 ← phi( main::@1/(byte*) print_char_cursor#80 )
  (word) rem16u#33 ← phi( main::@1/(word) rem16u#25 )
  (word) main::i#11 ← phi( main::@1/(word) main::i#4 )
  (byte*) main::sieve_i#2 ← phi( main::@1/(byte*) main::sieve_i#4 )
  (bool~) main::$36 ← (number) 0 != *((byte*) main::sieve_i#2)
  (bool~) main::$23 ← ! (bool~) main::$36
  (bool~) main::$24 ← ! (bool~) main::$23
  if((bool~) main::$24) goto main::@4
  to:main::@13
main::@3: scope:[main]  from main::@1
  (byte*) print_line_cursor#47 ← phi( main::@1/(byte*) print_line_cursor#49 )
  (byte*) print_char_cursor#77 ← phi( main::@1/(byte*) print_char_cursor#80 )
  (word) rem16u#20 ← phi( main::@1/(word) rem16u#25 )
  call clock 
  (dword) clock::return#2 ← (dword) clock::return#1
  to:main::@34
main::@34: scope:[main]  from main::@3
  (byte*) print_line_cursor#45 ← phi( main::@3/(byte*) print_line_cursor#47 )
  (byte*) print_char_cursor#70 ← phi( main::@3/(byte*) print_char_cursor#77 )
  (word) rem16u#17 ← phi( main::@3/(word) rem16u#20 )
  (dword) clock::return#4 ← phi( main::@3/(dword) clock::return#2 )
  (dword~) main::$10 ← (dword) clock::return#4
  (dword~) main::$11 ← (dword~) main::$10 - (dword) CLOCKS_PER_INIT#0
  (dword) main::cyclecount#0 ← (dword~) main::$11
  (number~) main::$12 ← (dword) CLOCKS_PER_SEC#0 / (number) $64
  (word~) main::$13 ← ((word)) (number~) main::$12
  (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
  (word) div32u16u::divisor#0 ← (word~) main::$13
  call div32u16u 
  (dword) div32u16u::return#2 ← (dword) div32u16u::return#1
  to:main::@35
main::@35: scope:[main]  from main::@34
  (byte*) print_line_cursor#42 ← phi( main::@34/(byte*) print_line_cursor#45 )
  (dword) main::cyclecount#4 ← phi( main::@34/(dword) main::cyclecount#0 )
  (byte*) print_char_cursor#61 ← phi( main::@34/(byte*) print_char_cursor#70 )
  (word) rem16u#13 ← phi( main::@34/(word) rem16u#5 )
  (dword) div32u16u::return#4 ← phi( main::@34/(dword) div32u16u::return#2 )
  (dword~) main::$14 ← (dword) div32u16u::return#4
  (word) rem16u#6 ← (word) rem16u#13
  (word~) main::$15 ← ((word)) (dword~) main::$14
  (word) main::sec100s#0 ← (word~) main::$15
  (byte*) print_str::str#5 ← (const string) main::str2
  call print_str 
  to:main::@36
main::@36: scope:[main]  from main::@35
  (word) rem16u#52 ← phi( main::@35/(word) rem16u#6 )
  (byte*) print_line_cursor#40 ← phi( main::@35/(byte*) print_line_cursor#42 )
  (dword) main::cyclecount#3 ← phi( main::@35/(dword) main::cyclecount#4 )
  (word) main::sec100s#1 ← phi( main::@35/(word) main::sec100s#0 )
  (byte*) print_char_cursor#46 ← phi( main::@35/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#19 ← (byte*) print_char_cursor#46
  (word) print_word_decimal::w#1 ← (word) main::sec100s#1
  call print_word_decimal 
  to:main::@37
main::@37: scope:[main]  from main::@36
  (word) rem16u#50 ← phi( main::@36/(word) rem16u#52 )
  (byte*) print_line_cursor#36 ← phi( main::@36/(byte*) print_line_cursor#40 )
  (dword) main::cyclecount#2 ← phi( main::@36/(dword) main::cyclecount#3 )
  (byte*) print_char_cursor#47 ← phi( main::@36/(byte*) print_char_cursor#6 )
  (byte*) print_char_cursor#20 ← (byte*) print_char_cursor#47
  (byte*) print_str::str#6 ← (const string) main::str3
  call print_str 
  to:main::@38
main::@38: scope:[main]  from main::@37
  (word) rem16u#48 ← phi( main::@37/(word) rem16u#50 )
  (byte*) print_line_cursor#30 ← phi( main::@37/(byte*) print_line_cursor#36 )
  (dword) main::cyclecount#1 ← phi( main::@37/(dword) main::cyclecount#2 )
  (byte*) print_char_cursor#48 ← phi( main::@37/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#21 ← (byte*) print_char_cursor#48
  (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#1
  call print_dword_decimal 
  to:main::@39
main::@39: scope:[main]  from main::@38
  (word) rem16u#45 ← phi( main::@38/(word) rem16u#48 )
  (byte*) print_line_cursor#25 ← phi( main::@38/(byte*) print_line_cursor#30 )
  (byte*) print_char_cursor#49 ← phi( main::@38/(byte*) print_char_cursor#8 )
  (byte*) print_char_cursor#22 ← (byte*) print_char_cursor#49
  call print_ln 
  to:main::@40
main::@40: scope:[main]  from main::@39
  (word) rem16u#41 ← phi( main::@39/(word) rem16u#45 )
  (byte*) print_char_cursor#50 ← phi( main::@39/(byte*) print_char_cursor#4 )
  (byte*) print_line_cursor#18 ← phi( main::@39/(byte*) print_line_cursor#2 )
  (byte*) print_line_cursor#8 ← (byte*) print_line_cursor#18
  (byte*) print_char_cursor#23 ← (byte*) print_char_cursor#50
  (word) main::i#1 ← (number) 2
  to:main::@15
main::@4: scope:[main]  from main::@2 main::@5
  (byte*) print_line_cursor#51 ← phi( main::@2/(byte*) print_line_cursor#53 main::@5/(byte*) print_line_cursor#54 )
  (byte*) print_char_cursor#82 ← phi( main::@2/(byte*) print_char_cursor#84 main::@5/(byte*) print_char_cursor#85 )
  (word) rem16u#29 ← phi( main::@2/(word) rem16u#33 main::@5/(word) rem16u#34 )
  (byte*) main::sieve_i#3 ← phi( main::@2/(byte*) main::sieve_i#2 main::@5/(byte*) main::sieve_i#5 )
  (word) main::i#5 ← phi( main::@2/(word) main::i#11 main::@5/(word) main::i#12 )
  (word) main::i#2 ← ++ (word) main::i#5
  (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#3
  to:main::@1
main::@13: scope:[main]  from main::@2
  (byte*) print_line_cursor#55 ← phi( main::@2/(byte*) print_line_cursor#53 )
  (byte*) print_char_cursor#86 ← phi( main::@2/(byte*) print_char_cursor#84 )
  (word) rem16u#39 ← phi( main::@2/(word) rem16u#33 )
  (byte*) main::sieve_i#6 ← phi( main::@2/(byte*) main::sieve_i#2 )
  (word) main::i#6 ← phi( main::@2/(word) main::i#11 )
  (number~) main::$25 ← (word) main::i#6 * (number) 2
  (word) main::j#0 ← (number~) main::$25
  (byte*~) main::$26 ← (byte*) sieve#0 + (word) main::j#0
  (byte*) main::s#0 ← (byte*~) main::$26
  to:main::@5
main::@5: scope:[main]  from main::@13 main::@6
  (byte*) print_line_cursor#54 ← phi( main::@13/(byte*) print_line_cursor#55 main::@6/(byte*) print_line_cursor#56 )
  (byte*) print_char_cursor#85 ← phi( main::@13/(byte*) print_char_cursor#86 main::@6/(byte*) print_char_cursor#87 )
  (word) rem16u#34 ← phi( main::@13/(word) rem16u#39 main::@6/(word) rem16u#40 )
  (byte*) main::s#3 ← phi( main::@13/(byte*) main::s#0 main::@6/(byte*) main::s#1 )
  (byte*) main::sieve_i#5 ← phi( main::@13/(byte*) main::sieve_i#6 main::@6/(byte*) main::sieve_i#7 )
  (word) main::i#12 ← phi( main::@13/(word) main::i#6 main::@6/(word) main::i#7 )
  (word) main::j#2 ← phi( main::@13/(word) main::j#0 main::@6/(word) main::j#1 )
  (bool~) main::$27 ← (word) main::j#2 < (word) COUNT#0
  if((bool~) main::$27) goto main::@6
  to:main::@4
main::@6: scope:[main]  from main::@5
  (byte*) print_line_cursor#56 ← phi( main::@5/(byte*) print_line_cursor#54 )
  (byte*) print_char_cursor#87 ← phi( main::@5/(byte*) print_char_cursor#85 )
  (word) rem16u#40 ← phi( main::@5/(word) rem16u#34 )
  (byte*) main::sieve_i#7 ← phi( main::@5/(byte*) main::sieve_i#5 )
  (word) main::j#3 ← phi( main::@5/(word) main::j#2 )
  (word) main::i#7 ← phi( main::@5/(word) main::i#12 )
  (byte*) main::s#2 ← phi( main::@5/(byte*) main::s#3 )
  *((byte*) main::s#2) ← (number) 1
  (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#7
  (word) main::j#1 ← (word) main::j#3 + (word) main::i#7
  to:main::@5
main::@15: scope:[main]  from main::@16 main::@40
  (word) rem16u#35 ← phi( main::@16/(word) rem16u#30 main::@40/(word) rem16u#41 )
  (byte*) print_line_cursor#43 ← phi( main::@16/(byte*) print_line_cursor#41 main::@40/(byte*) print_line_cursor#8 )
  (byte*) print_char_cursor#71 ← phi( main::@16/(byte*) print_char_cursor#72 main::@40/(byte*) print_char_cursor#23 )
  (word) main::i#8 ← phi( main::@16/(word) main::i#3 main::@40/(word) main::i#1 )
  (bool~) main::$37 ← (number) 0 != *((byte*) sieve#0 + (word) main::i#8)
  (bool~) main::$28 ← ! (bool~) main::$37
  (bool~) main::$29 ← ! (bool~) main::$28
  if((bool~) main::$29) goto main::@16
  to:main::@17
main::@16: scope:[main]  from main::@15 main::@42
  (word) rem16u#30 ← phi( main::@15/(word) rem16u#35 main::@42/(word) rem16u#36 )
  (byte*) print_line_cursor#41 ← phi( main::@15/(byte*) print_line_cursor#43 main::@42/(byte*) print_line_cursor#44 )
  (byte*) print_char_cursor#72 ← phi( main::@15/(byte*) print_char_cursor#71 main::@42/(byte*) print_char_cursor#25 )
  (word) main::i#9 ← phi( main::@15/(word) main::i#8 main::@42/(word) main::i#13 )
  (word) main::i#3 ← ++ (word) main::i#9
  (bool~) main::$32 ← (word) main::i#3 < (number) $514
  if((bool~) main::$32) goto main::@15
  to:main::@18
main::@17: scope:[main]  from main::@15
  (word) rem16u#46 ← phi( main::@15/(word) rem16u#35 )
  (byte*) print_line_cursor#48 ← phi( main::@15/(byte*) print_line_cursor#43 )
  (byte*) print_char_cursor#62 ← phi( main::@15/(byte*) print_char_cursor#71 )
  (word) main::i#10 ← phi( main::@15/(word) main::i#8 )
  (word) print_word_decimal::w#2 ← (word) main::i#10
  call print_word_decimal 
  to:main::@41
main::@41: scope:[main]  from main::@17
  (word) rem16u#42 ← phi( main::@17/(word) rem16u#46 )
  (byte*) print_line_cursor#46 ← phi( main::@17/(byte*) print_line_cursor#48 )
  (word) main::i#14 ← phi( main::@17/(word) main::i#10 )
  (byte*) print_char_cursor#51 ← phi( main::@17/(byte*) print_char_cursor#6 )
  (byte*) print_char_cursor#24 ← (byte*) print_char_cursor#51
  (byte) print_char::ch#0 ← (byte) ' '
  call print_char 
  to:main::@42
main::@42: scope:[main]  from main::@41
  (word) rem16u#36 ← phi( main::@41/(word) rem16u#42 )
  (byte*) print_line_cursor#44 ← phi( main::@41/(byte*) print_line_cursor#46 )
  (word) main::i#13 ← phi( main::@41/(word) main::i#14 )
  (byte*) print_char_cursor#52 ← phi( main::@41/(byte*) print_char_cursor#10 )
  (byte*) print_char_cursor#25 ← (byte*) print_char_cursor#52
  to:main::@16
main::@18: scope:[main]  from main::@16
  (word) rem16u#26 ← phi( main::@16/(word) rem16u#30 )
  (byte*) print_line_cursor#37 ← phi( main::@16/(byte*) print_line_cursor#41 )
  (byte*) print_char_cursor#63 ← phi( main::@16/(byte*) print_char_cursor#72 )
  (byte*) print_str::str#7 ← (const string) main::str4
  call print_str 
  to:main::@43
main::@43: scope:[main]  from main::@18
  (word) rem16u#22 ← phi( main::@18/(word) rem16u#26 )
  (byte*) print_line_cursor#32 ← phi( main::@18/(byte*) print_line_cursor#37 )
  (byte*) print_char_cursor#53 ← phi( main::@18/(byte*) print_char_cursor#2 )
  (byte*) print_char_cursor#26 ← (byte*) print_char_cursor#53
  to:main::@19
main::@19: scope:[main]  from main::@20 main::@43
  (word) rem16u#18 ← phi( main::@20/(word) rem16u#21 main::@43/(word) rem16u#22 )
  (byte*) print_char_cursor#64 ← phi( main::@20/(byte*) print_char_cursor#73 main::@43/(byte*) print_char_cursor#26 )
  (byte*) print_line_cursor#26 ← phi( main::@20/(byte*) print_line_cursor#31 main::@43/(byte*) print_line_cursor#32 )
  if(true) goto main::@20
  to:main::@return
main::@20: scope:[main]  from main::@19
  (word) rem16u#21 ← phi( main::@19/(word) rem16u#18 )
  (byte*) print_char_cursor#73 ← phi( main::@19/(byte*) print_char_cursor#64 )
  (byte*) print_line_cursor#31 ← phi( main::@19/(byte*) print_line_cursor#26 )
  (byte*~) main::$35 ← (byte*) SCREEN#0 + (number) $3e7
  *((byte*~) main::$35) ← ++ *((byte*~) main::$35)
  to:main::@19
main::@return: scope:[main]  from main::@19
  (word) rem16u#14 ← phi( main::@19/(word) rem16u#18 )
  (byte*) print_char_cursor#54 ← phi( main::@19/(byte*) print_char_cursor#64 )
  (byte*) print_line_cursor#19 ← phi( main::@19/(byte*) print_line_cursor#26 )
  (byte*) print_line_cursor#9 ← (byte*) print_line_cursor#19
  (byte*) print_char_cursor#27 ← (byte*) print_char_cursor#54
  (word) rem16u#7 ← (word) rem16u#14
  return 
  to:@return
@50: scope:[]  from @49
  (byte*) print_screen#7 ← phi( @49/(byte*) print_screen#8 )
  (word) rem16u#19 ← phi( @49/(word) rem16u#23 )
  (byte*) print_char_cursor#65 ← phi( @49/(byte*) print_char_cursor#74 )
  (byte*) print_line_cursor#27 ← phi( @49/(byte*) print_line_cursor#33 )
  call main 
  to:@51
@51: scope:[]  from @50
  (word) rem16u#15 ← phi( @50/(word) rem16u#7 )
  (byte*) print_char_cursor#55 ← phi( @50/(byte*) print_char_cursor#27 )
  (byte*) print_line_cursor#20 ← phi( @50/(byte*) print_line_cursor#9 )
  (byte*) print_line_cursor#10 ← (byte*) print_line_cursor#20
  (byte*) print_char_cursor#28 ← (byte*) print_char_cursor#55
  (word) rem16u#8 ← (word) rem16u#15
  to:@end
@end: scope:[]  from @51

SYMBOL TABLE SSA
(word~) $0
(const string) $1 = (string) "0123456789abcdef"
(label) @12
(label) @22
(label) @24
(label) @26
(label) @36
(label) @39
(label) @4
(label) @49
(label) @50
(label) @51
(label) @8
(label) @begin
(label) @end
(const byte) BINARY = (number) 2
(dword*) CIA2_TIMER_AB
(dword*) CIA2_TIMER_AB#0
(byte*) CIA2_TIMER_A_CONTROL
(byte*) CIA2_TIMER_A_CONTROL#0
(byte*) CIA2_TIMER_B_CONTROL
(byte*) CIA2_TIMER_B_CONTROL#0
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(byte) CIA_TIMER_CONTROL_CONTINUOUS#0
(byte) CIA_TIMER_CONTROL_START
(byte) CIA_TIMER_CONTROL_START#0
(byte) CIA_TIMER_CONTROL_STOP
(byte) CIA_TIMER_CONTROL_STOP#0
(word) CLOCKS_PER_FRAME
(word) CLOCKS_PER_FRAME#0
(dword) CLOCKS_PER_INIT
(dword) CLOCKS_PER_INIT#0
(dword) CLOCKS_PER_SEC
(dword) CLOCKS_PER_SEC#0
(word) COUNT
(word) COUNT#0
(byte*) D018
(byte*) D018#0
(const byte) DECIMAL = (number) $a
(byte[]) DIGITS
(byte[]) DIGITS#0
(byte) FRAMES_PER_SEC
(byte) FRAMES_PER_SEC#0
(const byte) HEXADECIMAL = (number) $10
(const byte) OCTAL = (number) 8
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(word[]) RADIX_BINARY_VALUES
(word[]) RADIX_BINARY_VALUES#0
(dword[]) RADIX_BINARY_VALUES_LONG
(dword[]) RADIX_BINARY_VALUES_LONG#0
(word[]) RADIX_DECIMAL_VALUES
(word[]) RADIX_DECIMAL_VALUES#0
(dword[]) RADIX_DECIMAL_VALUES_LONG
(dword[]) RADIX_DECIMAL_VALUES_LONG#0
(word[]) RADIX_HEXADECIMAL_VALUES
(word[]) RADIX_HEXADECIMAL_VALUES#0
(dword[]) RADIX_HEXADECIMAL_VALUES_LONG
(dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0
(word[]) RADIX_OCTAL_VALUES
(word[]) RADIX_OCTAL_VALUES#0
(dword[]) RADIX_OCTAL_VALUES_LONG
(dword[]) RADIX_OCTAL_VALUES_LONG#0
(byte*) SCREEN
(byte*) SCREEN#0
(const byte) SIZEOF_DWORD = (byte) 4
(const byte) SIZEOF_WORD = (byte) 2
(byte) SQRT_COUNT
(byte) SQRT_COUNT#0
(dword()) clock()
(number~) clock::$0
(label) clock::@return
(dword) clock::return
(dword) clock::return#0
(dword) clock::return#1
(dword) clock::return#2
(dword) clock::return#3
(dword) clock::return#4
(void()) clock_start()
(byte~) clock_start::$0
(byte~) clock_start::$1
(byte~) clock_start::$2
(byte~) clock_start::$3
(byte~) clock_start::$4
(byte~) clock_start::$5
(byte~) clock_start::$6
(byte~) clock_start::$7
(label) clock_start::@return
(byte[6]) decimal_digits
(byte[6]) decimal_digits#0
(byte[$b]) decimal_digits_long
(byte[$b]) decimal_digits_long#0
(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
(word~) div32u16u::$0
(word~) div32u16u::$1
(word~) div32u16u::$2
(word~) div32u16u::$3
(label) div32u16u::@2
(label) div32u16u::@3
(label) div32u16u::@return
(dword) div32u16u::dividend
(dword) div32u16u::dividend#0
(dword) div32u16u::dividend#1
(dword) div32u16u::dividend#2
(word) div32u16u::divisor
(word) div32u16u::divisor#0
(word) div32u16u::divisor#1
(word) div32u16u::divisor#2
(dword) div32u16u::quotient
(dword) div32u16u::quotient#0
(word) div32u16u::quotient_hi
(word) div32u16u::quotient_hi#0
(word) div32u16u::quotient_hi#1
(word) div32u16u::quotient_lo
(word) div32u16u::quotient_lo#0
(dword) div32u16u::return
(dword) div32u16u::return#0
(dword) div32u16u::return#1
(dword) div32u16u::return#2
(dword) div32u16u::return#3
(dword) div32u16u::return#4
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(word~) divr16u::$0
(byte~) divr16u::$1
(word~) divr16u::$10
(bool~) divr16u::$11
(number~) divr16u::$2
(bool~) divr16u::$3
(bool~) divr16u::$4
(number~) divr16u::$5
(word~) divr16u::$6
(word~) divr16u::$7
(bool~) divr16u::$8
(bool~) divr16u::$9
(label) divr16u::@1
(label) divr16u::@2
(label) divr16u::@3
(label) divr16u::@4
(label) divr16u::@5
(label) divr16u::@6
(label) divr16u::@return
(word) divr16u::dividend
(word) divr16u::dividend#0
(word) divr16u::dividend#1
(word) divr16u::dividend#2
(word) divr16u::dividend#3
(word) divr16u::dividend#4
(word) divr16u::dividend#5
(word) divr16u::dividend#6
(word) divr16u::dividend#7
(word) divr16u::dividend#8
(word) divr16u::divisor
(word) divr16u::divisor#0
(word) divr16u::divisor#1
(word) divr16u::divisor#2
(word) divr16u::divisor#3
(word) divr16u::divisor#4
(word) divr16u::divisor#5
(word) divr16u::divisor#6
(word) divr16u::divisor#7
(byte) divr16u::i
(byte) divr16u::i#0
(byte) divr16u::i#1
(byte) divr16u::i#2
(byte) divr16u::i#3
(byte) divr16u::i#4
(byte) divr16u::i#5
(byte) divr16u::i#6
(word) divr16u::quotient
(word) divr16u::quotient#0
(word) divr16u::quotient#1
(word) divr16u::quotient#2
(word) divr16u::quotient#3
(word) divr16u::quotient#4
(word) divr16u::quotient#5
(word) divr16u::quotient#6
(word) divr16u::quotient#7
(word) divr16u::quotient#8
(word) divr16u::rem
(word) divr16u::rem#0
(word) divr16u::rem#1
(word) divr16u::rem#10
(word) divr16u::rem#11
(word) divr16u::rem#2
(word) divr16u::rem#3
(word) divr16u::rem#4
(word) divr16u::rem#5
(word) divr16u::rem#6
(word) divr16u::rem#7
(word) divr16u::rem#8
(word) divr16u::rem#9
(word) divr16u::return
(word) divr16u::return#0
(word) divr16u::return#1
(word) divr16u::return#2
(word) divr16u::return#3
(word) divr16u::return#4
(word) divr16u::return#5
(word) divr16u::return#6
(void()) main()
(byte~) main::$0
(dword~) main::$10
(dword~) main::$11
(number~) main::$12
(word~) main::$13
(dword~) main::$14
(word~) main::$15
(bool~) main::$22
(bool~) main::$23
(bool~) main::$24
(number~) main::$25
(byte*~) main::$26
(bool~) main::$27
(bool~) main::$28
(bool~) main::$29
(bool~) main::$32
(byte*~) main::$35
(bool~) main::$36
(bool~) main::$37
(byte*~) main::$9
(label) main::@1
(label) main::@13
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@29
(label) main::@3
(label) main::@30
(label) main::@31
(label) main::@32
(label) main::@33
(label) main::@34
(label) main::@35
(label) main::@36
(label) main::@37
(label) main::@38
(label) main::@39
(label) main::@4
(label) main::@40
(label) main::@41
(label) main::@42
(label) main::@43
(label) main::@5
(label) main::@6
(label) main::@return
(dword) main::cyclecount
(dword) main::cyclecount#0
(dword) main::cyclecount#1
(dword) main::cyclecount#2
(dword) main::cyclecount#3
(dword) main::cyclecount#4
(word) main::i
(word) main::i#0
(word) main::i#1
(word) main::i#10
(word) main::i#11
(word) main::i#12
(word) main::i#13
(word) main::i#14
(word) main::i#2
(word) main::i#3
(word) main::i#4
(word) main::i#5
(word) main::i#6
(word) main::i#7
(word) main::i#8
(word) main::i#9
(word) main::j
(word) main::j#0
(word) main::j#1
(word) main::j#2
(word) main::j#3
(byte*) main::s
(byte*) main::s#0
(byte*) main::s#1
(byte*) main::s#2
(byte*) main::s#3
(word) main::sec100s
(word) main::sec100s#0
(word) main::sec100s#1
(byte*) main::sieve_i
(byte*) main::sieve_i#0
(byte*) main::sieve_i#1
(byte*) main::sieve_i#2
(byte*) main::sieve_i#3
(byte*) main::sieve_i#4
(byte*) main::sieve_i#5
(byte*) main::sieve_i#6
(byte*) main::sieve_i#7
(const string) main::str = (string) "Sieve benchmark - calculating primes@"
(const string) main::str1 = (string) "between 2 and @"
(const string) main::str2 = (string) "100ths seconds used: @"
(const string) main::str3 = (string) " cycles: @"
(const string) main::str4 = (string) "...@"
(label) main::toD0181
(word~) main::toD0181_$0
(word~) main::toD0181_$0#0
(number~) main::toD0181_$1
(number~) main::toD0181_$1#0
(number~) main::toD0181_$2
(number~) main::toD0181_$2#0
(number~) main::toD0181_$3
(number~) main::toD0181_$3#0
(word~) main::toD0181_$4
(word~) main::toD0181_$4#0
(byte~) main::toD0181_$5
(byte~) main::toD0181_$5#0
(number~) main::toD0181_$6
(number~) main::toD0181_$6#0
(number~) main::toD0181_$7
(number~) main::toD0181_$7#0
(number~) main::toD0181_$8
(number~) main::toD0181_$8#0
(label) main::toD0181_@return
(byte*) main::toD0181_gfx
(byte*) main::toD0181_gfx#0
(byte*) main::toD0181_gfx#1
(byte) main::toD0181_return
(byte) main::toD0181_return#0
(byte) main::toD0181_return#1
(byte) main::toD0181_return#2
(byte) main::toD0181_return#3
(byte*) main::toD0181_screen
(byte*) main::toD0181_screen#0
(byte*) main::toD0181_screen#1
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(byte*~) memset::$3
(bool~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@4
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(word) memset::num#3
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::return#4
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(void()) print_char((byte) print_char::ch)
(label) print_char::@return
(byte) print_char::ch
(byte) print_char::ch#0
(byte) print_char::ch#1
(byte*) print_char_cursor
(byte*) print_char_cursor#0
(byte*) print_char_cursor#1
(byte*) print_char_cursor#10
(byte*) print_char_cursor#11
(byte*) print_char_cursor#12
(byte*) print_char_cursor#13
(byte*) print_char_cursor#14
(byte*) print_char_cursor#15
(byte*) print_char_cursor#16
(byte*) print_char_cursor#17
(byte*) print_char_cursor#18
(byte*) print_char_cursor#19
(byte*) print_char_cursor#2
(byte*) print_char_cursor#20
(byte*) print_char_cursor#21
(byte*) print_char_cursor#22
(byte*) print_char_cursor#23
(byte*) print_char_cursor#24
(byte*) print_char_cursor#25
(byte*) print_char_cursor#26
(byte*) print_char_cursor#27
(byte*) print_char_cursor#28
(byte*) print_char_cursor#29
(byte*) print_char_cursor#3
(byte*) print_char_cursor#30
(byte*) print_char_cursor#31
(byte*) print_char_cursor#32
(byte*) print_char_cursor#33
(byte*) print_char_cursor#34
(byte*) print_char_cursor#35
(byte*) print_char_cursor#36
(byte*) print_char_cursor#37
(byte*) print_char_cursor#38
(byte*) print_char_cursor#39
(byte*) print_char_cursor#4
(byte*) print_char_cursor#40
(byte*) print_char_cursor#41
(byte*) print_char_cursor#42
(byte*) print_char_cursor#43
(byte*) print_char_cursor#44
(byte*) print_char_cursor#45
(byte*) print_char_cursor#46
(byte*) print_char_cursor#47
(byte*) print_char_cursor#48
(byte*) print_char_cursor#49
(byte*) print_char_cursor#5
(byte*) print_char_cursor#50
(byte*) print_char_cursor#51
(byte*) print_char_cursor#52
(byte*) print_char_cursor#53
(byte*) print_char_cursor#54
(byte*) print_char_cursor#55
(byte*) print_char_cursor#56
(byte*) print_char_cursor#57
(byte*) print_char_cursor#58
(byte*) print_char_cursor#59
(byte*) print_char_cursor#6
(byte*) print_char_cursor#60
(byte*) print_char_cursor#61
(byte*) print_char_cursor#62
(byte*) print_char_cursor#63
(byte*) print_char_cursor#64
(byte*) print_char_cursor#65
(byte*) print_char_cursor#66
(byte*) print_char_cursor#67
(byte*) print_char_cursor#68
(byte*) print_char_cursor#69
(byte*) print_char_cursor#7
(byte*) print_char_cursor#70
(byte*) print_char_cursor#71
(byte*) print_char_cursor#72
(byte*) print_char_cursor#73
(byte*) print_char_cursor#74
(byte*) print_char_cursor#75
(byte*) print_char_cursor#76
(byte*) print_char_cursor#77
(byte*) print_char_cursor#78
(byte*) print_char_cursor#79
(byte*) print_char_cursor#8
(byte*) print_char_cursor#80
(byte*) print_char_cursor#81
(byte*) print_char_cursor#82
(byte*) print_char_cursor#83
(byte*) print_char_cursor#84
(byte*) print_char_cursor#85
(byte*) print_char_cursor#86
(byte*) print_char_cursor#87
(byte*) print_char_cursor#9
(void()) print_cls()
(label) print_cls::@1
(label) print_cls::@return
(void()) print_dword_decimal((dword) print_dword_decimal::w)
(label) print_dword_decimal::@1
(label) print_dword_decimal::@2
(label) print_dword_decimal::@return
(dword) print_dword_decimal::w
(dword) print_dword_decimal::w#0
(dword) print_dword_decimal::w#1
(byte*) print_line_cursor
(byte*) print_line_cursor#0
(byte*) print_line_cursor#1
(byte*) print_line_cursor#10
(byte*) print_line_cursor#11
(byte*) print_line_cursor#12
(byte*) print_line_cursor#13
(byte*) print_line_cursor#14
(byte*) print_line_cursor#15
(byte*) print_line_cursor#16
(byte*) print_line_cursor#17
(byte*) print_line_cursor#18
(byte*) print_line_cursor#19
(byte*) print_line_cursor#2
(byte*) print_line_cursor#20
(byte*) print_line_cursor#21
(byte*) print_line_cursor#22
(byte*) print_line_cursor#23
(byte*) print_line_cursor#24
(byte*) print_line_cursor#25
(byte*) print_line_cursor#26
(byte*) print_line_cursor#27
(byte*) print_line_cursor#28
(byte*) print_line_cursor#29
(byte*) print_line_cursor#3
(byte*) print_line_cursor#30
(byte*) print_line_cursor#31
(byte*) print_line_cursor#32
(byte*) print_line_cursor#33
(byte*) print_line_cursor#34
(byte*) print_line_cursor#35
(byte*) print_line_cursor#36
(byte*) print_line_cursor#37
(byte*) print_line_cursor#38
(byte*) print_line_cursor#39
(byte*) print_line_cursor#4
(byte*) print_line_cursor#40
(byte*) print_line_cursor#41
(byte*) print_line_cursor#42
(byte*) print_line_cursor#43
(byte*) print_line_cursor#44
(byte*) print_line_cursor#45
(byte*) print_line_cursor#46
(byte*) print_line_cursor#47
(byte*) print_line_cursor#48
(byte*) print_line_cursor#49
(byte*) print_line_cursor#5
(byte*) print_line_cursor#50
(byte*) print_line_cursor#51
(byte*) print_line_cursor#52
(byte*) print_line_cursor#53
(byte*) print_line_cursor#54
(byte*) print_line_cursor#55
(byte*) print_line_cursor#56
(byte*) print_line_cursor#6
(byte*) print_line_cursor#7
(byte*) print_line_cursor#8
(byte*) print_line_cursor#9
(void()) print_ln()
(byte*~) print_ln::$0
(bool~) print_ln::$1
(label) print_ln::@1
(label) print_ln::@2
(label) print_ln::@return
(byte*) print_screen
(byte*) print_screen#0
(byte*) print_screen#1
(byte*) print_screen#10
(byte*) print_screen#2
(byte*) print_screen#3
(byte*) print_screen#4
(byte*) print_screen#5
(byte*) print_screen#6
(byte*) print_screen#7
(byte*) print_screen#8
(byte*) print_screen#9
(void()) print_str((byte*) print_str::str)
(bool~) print_str::$0
(label) print_str::@1
(label) print_str::@2
(label) print_str::@return
(byte*) print_str::str
(byte*) print_str::str#0
(byte*) print_str::str#1
(byte*) print_str::str#10
(byte*) print_str::str#2
(byte*) print_str::str#3
(byte*) print_str::str#4
(byte*) print_str::str#5
(byte*) print_str::str#6
(byte*) print_str::str#7
(byte*) print_str::str#8
(byte*) print_str::str#9
(void()) print_word_decimal((word) print_word_decimal::w)
(label) print_word_decimal::@1
(label) print_word_decimal::@2
(label) print_word_decimal::@return
(word) print_word_decimal::w
(word) print_word_decimal::w#0
(word) print_word_decimal::w#1
(word) print_word_decimal::w#2
(word) print_word_decimal::w#3
(word) rem16u
(word) rem16u#0
(word) rem16u#1
(word) rem16u#10
(word) rem16u#11
(word) rem16u#12
(word) rem16u#13
(word) rem16u#14
(word) rem16u#15
(word) rem16u#16
(word) rem16u#17
(word) rem16u#18
(word) rem16u#19
(word) rem16u#2
(word) rem16u#20
(word) rem16u#21
(word) rem16u#22
(word) rem16u#23
(word) rem16u#24
(word) rem16u#25
(word) rem16u#26
(word) rem16u#27
(word) rem16u#28
(word) rem16u#29
(word) rem16u#3
(word) rem16u#30
(word) rem16u#31
(word) rem16u#32
(word) rem16u#33
(word) rem16u#34
(word) rem16u#35
(word) rem16u#36
(word) rem16u#37
(word) rem16u#38
(word) rem16u#39
(word) rem16u#4
(word) rem16u#40
(word) rem16u#41
(word) rem16u#42
(word) rem16u#43
(word) rem16u#44
(word) rem16u#45
(word) rem16u#46
(word) rem16u#47
(word) rem16u#48
(word) rem16u#49
(word) rem16u#5
(word) rem16u#50
(word) rem16u#51
(word) rem16u#52
(word) rem16u#53
(word) rem16u#54
(word) rem16u#55
(word) rem16u#56
(word) rem16u#57
(word) rem16u#6
(word) rem16u#7
(word) rem16u#8
(word) rem16u#9
(byte*) sieve
(byte*) sieve#0
(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
(bool~) ultoa::$0
(bool~) ultoa::$1
(bool~) ultoa::$10
(byte~) ultoa::$11
(bool~) ultoa::$2
(bool~) ultoa::$3
(byte~) ultoa::$4
(bool~) ultoa::$5
(bool~) ultoa::$6
(bool~) ultoa::$7
(dword~) ultoa::$8
(number~) ultoa::$9
(label) ultoa::@1
(label) ultoa::@10
(label) ultoa::@11
(label) ultoa::@12
(label) ultoa::@18
(label) ultoa::@19
(label) ultoa::@2
(label) ultoa::@20
(label) ultoa::@21
(label) ultoa::@22
(label) ultoa::@3
(label) ultoa::@4
(label) ultoa::@8
(label) ultoa::@9
(label) ultoa::@return
(byte*) ultoa::buffer
(byte*) ultoa::buffer#0
(byte*) ultoa::buffer#1
(byte*) ultoa::buffer#10
(byte*) ultoa::buffer#11
(byte*) ultoa::buffer#12
(byte*) ultoa::buffer#13
(byte*) ultoa::buffer#14
(byte*) ultoa::buffer#15
(byte*) ultoa::buffer#16
(byte*) ultoa::buffer#17
(byte*) ultoa::buffer#18
(byte*) ultoa::buffer#19
(byte*) ultoa::buffer#2
(byte*) ultoa::buffer#20
(byte*) ultoa::buffer#3
(byte*) ultoa::buffer#4
(byte*) ultoa::buffer#5
(byte*) ultoa::buffer#6
(byte*) ultoa::buffer#7
(byte*) ultoa::buffer#8
(byte*) ultoa::buffer#9
(byte) ultoa::digit
(byte) ultoa::digit#0
(byte) ultoa::digit#1
(byte) ultoa::digit#2
(byte) ultoa::digit#3
(byte) ultoa::digit#4
(byte) ultoa::digit#5
(dword) ultoa::digit_value
(dword) ultoa::digit_value#0
(dword) ultoa::digit_value#1
(dword*) ultoa::digit_values
(dword*) ultoa::digit_values#0
(dword*) ultoa::digit_values#1
(dword*) ultoa::digit_values#2
(dword*) ultoa::digit_values#3
(dword*) ultoa::digit_values#4
(dword*) ultoa::digit_values#5
(dword*) ultoa::digit_values#6
(dword*) ultoa::digit_values#7
(dword*) ultoa::digit_values#8
(dword*) ultoa::digit_values#9
(byte) ultoa::max_digits
(byte) ultoa::max_digits#0
(byte) ultoa::max_digits#1
(byte) ultoa::max_digits#2
(byte) ultoa::max_digits#3
(byte) ultoa::max_digits#4
(byte) ultoa::max_digits#5
(byte) ultoa::max_digits#6
(byte) ultoa::max_digits#7
(byte) ultoa::max_digits#8
(byte) ultoa::max_digits#9
(byte) ultoa::radix
(byte) ultoa::radix#0
(byte) ultoa::radix#1
(byte) ultoa::radix#2
(byte) ultoa::radix#3
(byte) ultoa::radix#4
(byte) ultoa::started
(byte) ultoa::started#0
(byte) ultoa::started#1
(byte) ultoa::started#2
(byte) ultoa::started#3
(dword) ultoa::value
(dword) ultoa::value#0
(dword) ultoa::value#1
(dword) ultoa::value#10
(dword) ultoa::value#11
(dword) ultoa::value#12
(dword) ultoa::value#13
(dword) ultoa::value#14
(dword) ultoa::value#2
(dword) ultoa::value#3
(dword) ultoa::value#4
(dword) ultoa::value#5
(dword) ultoa::value#6
(dword) ultoa::value#7
(dword) ultoa::value#8
(dword) ultoa::value#9
(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
(bool~) ultoa_append::$0
(label) ultoa_append::@1
(label) ultoa_append::@2
(label) ultoa_append::@3
(label) ultoa_append::@return
(byte*) ultoa_append::buffer
(byte*) ultoa_append::buffer#0
(byte*) ultoa_append::buffer#1
(byte*) ultoa_append::buffer#2
(byte*) ultoa_append::buffer#3
(byte*) ultoa_append::buffer#4
(byte) ultoa_append::digit
(byte) ultoa_append::digit#0
(byte) ultoa_append::digit#1
(byte) ultoa_append::digit#2
(byte) ultoa_append::digit#3
(byte) ultoa_append::digit#4
(dword) ultoa_append::return
(dword) ultoa_append::return#0
(dword) ultoa_append::return#1
(dword) ultoa_append::return#2
(dword) ultoa_append::return#3
(dword) ultoa_append::return#4
(dword) ultoa_append::sub
(dword) ultoa_append::sub#0
(dword) ultoa_append::sub#1
(dword) ultoa_append::sub#2
(dword) ultoa_append::sub#3
(dword) ultoa_append::value
(dword) ultoa_append::value#0
(dword) ultoa_append::value#1
(dword) ultoa_append::value#2
(dword) ultoa_append::value#3
(dword) ultoa_append::value#4
(dword) ultoa_append::value#5
(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
(bool~) utoa::$0
(bool~) utoa::$1
(bool~) utoa::$10
(byte~) utoa::$11
(bool~) utoa::$2
(bool~) utoa::$3
(byte~) utoa::$4
(bool~) utoa::$5
(bool~) utoa::$6
(bool~) utoa::$7
(word~) utoa::$8
(number~) utoa::$9
(label) utoa::@1
(label) utoa::@10
(label) utoa::@11
(label) utoa::@12
(label) utoa::@18
(label) utoa::@19
(label) utoa::@2
(label) utoa::@20
(label) utoa::@21
(label) utoa::@22
(label) utoa::@3
(label) utoa::@4
(label) utoa::@8
(label) utoa::@9
(label) utoa::@return
(byte*) utoa::buffer
(byte*) utoa::buffer#0
(byte*) utoa::buffer#1
(byte*) utoa::buffer#10
(byte*) utoa::buffer#11
(byte*) utoa::buffer#12
(byte*) utoa::buffer#13
(byte*) utoa::buffer#14
(byte*) utoa::buffer#15
(byte*) utoa::buffer#16
(byte*) utoa::buffer#17
(byte*) utoa::buffer#18
(byte*) utoa::buffer#19
(byte*) utoa::buffer#2
(byte*) utoa::buffer#20
(byte*) utoa::buffer#3
(byte*) utoa::buffer#4
(byte*) utoa::buffer#5
(byte*) utoa::buffer#6
(byte*) utoa::buffer#7
(byte*) utoa::buffer#8
(byte*) utoa::buffer#9
(byte) utoa::digit
(byte) utoa::digit#0
(byte) utoa::digit#1
(byte) utoa::digit#2
(byte) utoa::digit#3
(byte) utoa::digit#4
(byte) utoa::digit#5
(word) utoa::digit_value
(word) utoa::digit_value#0
(word) utoa::digit_value#1
(word*) utoa::digit_values
(word*) utoa::digit_values#0
(word*) utoa::digit_values#1
(word*) utoa::digit_values#2
(word*) utoa::digit_values#3
(word*) utoa::digit_values#4
(word*) utoa::digit_values#5
(word*) utoa::digit_values#6
(word*) utoa::digit_values#7
(word*) utoa::digit_values#8
(word*) utoa::digit_values#9
(byte) utoa::max_digits
(byte) utoa::max_digits#0
(byte) utoa::max_digits#1
(byte) utoa::max_digits#2
(byte) utoa::max_digits#3
(byte) utoa::max_digits#4
(byte) utoa::max_digits#5
(byte) utoa::max_digits#6
(byte) utoa::max_digits#7
(byte) utoa::max_digits#8
(byte) utoa::max_digits#9
(byte) utoa::radix
(byte) utoa::radix#0
(byte) utoa::radix#1
(byte) utoa::radix#2
(byte) utoa::radix#3
(byte) utoa::radix#4
(byte) utoa::started
(byte) utoa::started#0
(byte) utoa::started#1
(byte) utoa::started#2
(byte) utoa::started#3
(word) utoa::value
(word) utoa::value#0
(word) utoa::value#1
(word) utoa::value#10
(word) utoa::value#11
(word) utoa::value#12
(word) utoa::value#13
(word) utoa::value#14
(word) utoa::value#2
(word) utoa::value#3
(word) utoa::value#4
(word) utoa::value#5
(word) utoa::value#6
(word) utoa::value#7
(word) utoa::value#8
(word) utoa::value#9
(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
(bool~) utoa_append::$0
(label) utoa_append::@1
(label) utoa_append::@2
(label) utoa_append::@3
(label) utoa_append::@return
(byte*) utoa_append::buffer
(byte*) utoa_append::buffer#0
(byte*) utoa_append::buffer#1
(byte*) utoa_append::buffer#2
(byte*) utoa_append::buffer#3
(byte*) utoa_append::buffer#4
(byte) utoa_append::digit
(byte) utoa_append::digit#0
(byte) utoa_append::digit#1
(byte) utoa_append::digit#2
(byte) utoa_append::digit#3
(byte) utoa_append::digit#4
(word) utoa_append::return
(word) utoa_append::return#0
(word) utoa_append::return#1
(word) utoa_append::return#2
(word) utoa_append::return#3
(word) utoa_append::return#4
(word) utoa_append::sub
(word) utoa_append::sub#0
(word) utoa_append::sub#1
(word) utoa_append::sub#2
(word) utoa_append::sub#3
(word) utoa_append::value
(word) utoa_append::value#0
(word) utoa_append::value#1
(word) utoa_append::value#2
(word) utoa_append::value#3
(word) utoa_append::value#4
(word) utoa_append::value#5

Fixing inline constructor with div32u16u::$4 ← (word)div32u16u::quotient_hi#1 dw= (word)div32u16u::quotient_lo#0
Successful SSA optimization Pass2FixInlineConstructorsNew
Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#2 > (number) 0
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_STOP#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) CIA_TIMER_CONTROL_START#0 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_CONTINUOUS#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 ← (number) 0
Adding number conversion cast (unumber) $40 in (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 ← (number) $40
Adding number conversion cast (unumber) $4cc8 in (word) CLOCKS_PER_FRAME#0 ← (number) $4cc8
Adding number conversion cast (unumber) $3c in (byte) FRAMES_PER_SEC#0 ← (number) $3c
Adding number conversion cast (unumber) $12 in (dword) CLOCKS_PER_INIT#0 ← (number) $12
Adding number conversion cast (unumber) $ffffffff in (number~) clock::$0 ← (number) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
Adding number conversion cast (unumber) clock::$0 in (number~) clock::$0 ← (unumber)(number) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
Adding number conversion cast (unumber) $ffffffff in *((dword*) CIA2_TIMER_AB#0) ← (number) $ffffffff
Adding number conversion cast (unumber) 0 in (word) rem16u#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (word) divr16u::quotient#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (word~) divr16u::$0 ← (word) divr16u::rem#5 << (number) 1
Adding number conversion cast (unumber) $80 in (number~) divr16u::$2 ← (byte~) divr16u::$1 & (number) $80
Adding number conversion cast (unumber) divr16u::$2 in (number~) divr16u::$2 ← (byte~) divr16u::$1 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) divr16u::$3 ← (unumber~) divr16u::$2 != (number) 0
Adding number conversion cast (unumber) 1 in (word~) divr16u::$6 ← (word) divr16u::dividend#4 << (number) 1
Adding number conversion cast (unumber) 1 in (word~) divr16u::$7 ← (word) divr16u::quotient#3 << (number) 1
Adding number conversion cast (unumber) 1 in (number~) divr16u::$5 ← (word) divr16u::rem#7 | (number) 1
Adding number conversion cast (unumber) divr16u::$5 in (number~) divr16u::$5 ← (word) divr16u::rem#7 | (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (word) divr16u::rem#3 ← (number) 0
Adding number conversion cast (unumber) 5 in (byte) utoa::max_digits#1 ← (number) 5
Adding number conversion cast (unumber) 4 in (byte) utoa::max_digits#2 ← (number) 4
Adding number conversion cast (unumber) 6 in (byte) utoa::max_digits#3 ← (number) 6
Adding number conversion cast (unumber) $10 in (byte) utoa::max_digits#4 ← (number) $10
Adding number conversion cast (unumber) 0 in *((byte*) utoa::buffer#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa::started#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa::digit#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) utoa::$9 ← (byte) utoa::max_digits#5 - (number) 1
Adding number conversion cast (unumber) utoa::$9 in (number~) utoa::$9 ← (byte) utoa::max_digits#5 - (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (byte) utoa::started#1 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) utoa::buffer#4) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) utoa_append::digit#0 ← (number) 0
Adding number conversion cast (unumber) $a in (byte) ultoa::max_digits#1 ← (number) $a
Adding number conversion cast (unumber) 8 in (byte) ultoa::max_digits#2 ← (number) 8
Adding number conversion cast (unumber) $b in (byte) ultoa::max_digits#3 ← (number) $b
Adding number conversion cast (unumber) $20 in (byte) ultoa::max_digits#4 ← (number) $20
Adding number conversion cast (unumber) 0 in *((byte*) ultoa::buffer#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) ultoa::started#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) ultoa::digit#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (number~) ultoa::$9 ← (byte) ultoa::max_digits#5 - (number) 1
Adding number conversion cast (unumber) ultoa::$9 in (number~) ultoa::$9 ← (byte) ultoa::max_digits#5 - (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (byte) ultoa::started#1 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) ultoa::buffer#4) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) ultoa_append::digit#0 ← (number) 0
Adding number conversion cast (unumber) $28 in (byte*~) print_ln::$0 ← (byte*) print_line_cursor#11 + (number) $28
Adding number conversion cast (unumber) $3e8 in (word) memset::num#0 ← (number) $3e8
Adding number conversion cast (unumber) $4000 in (word) COUNT#0 ← (number) $4000
Adding number conversion cast (unumber) $80 in (byte) SQRT_COUNT#0 ← (number) $80
Adding number conversion cast (unumber) $3fff in (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (number) $3fff
Adding number conversion cast (unumber) main::toD0181_$1#0 in (number~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (unumber)(number) $3fff
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$2#0 ← (unumber~) main::toD0181_$1#0 * (number) 4
Adding number conversion cast (unumber) main::toD0181_$2#0 in (number~) main::toD0181_$2#0 ← (unumber~) main::toD0181_$1#0 * (unumber)(number) 4
Adding number conversion cast (unumber) main::toD0181_$3#0 in (number~) main::toD0181_$3#0 ← > (unumber~) main::toD0181_$2#0
Adding number conversion cast (unumber) 4 in (number~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (number) 4
Adding number conversion cast (unumber) main::toD0181_$6#0 in (number~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (unumber)(number) 4
Adding number conversion cast (unumber) $f in (number~) main::toD0181_$7#0 ← (unumber~) main::toD0181_$6#0 & (number) $f
Adding number conversion cast (unumber) main::toD0181_$7#0 in (number~) main::toD0181_$7#0 ← (unumber~) main::toD0181_$6#0 & (unumber)(number) $f
Adding number conversion cast (unumber) main::toD0181_$8#0 in (number~) main::toD0181_$8#0 ← (unumber~) main::toD0181_$3#0 | (unumber~) main::toD0181_$7#0
Adding number conversion cast (unumber) 0 in (byte) memset::c#1 ← (number) 0
Adding number conversion cast (unumber) 2 in (word) main::i#0 ← (number) 2
Adding number conversion cast (unumber) 0 in (bool~) main::$36 ← (number) 0 != *((byte*) main::sieve_i#2)
Adding number conversion cast (unumber) $64 in (number~) main::$12 ← (dword) CLOCKS_PER_SEC#0 / (number) $64
Adding number conversion cast (unumber) main::$12 in (number~) main::$12 ← (dword) CLOCKS_PER_SEC#0 / (unumber)(number) $64
Adding number conversion cast (unumber) 2 in (word) main::i#1 ← (number) 2
Adding number conversion cast (unumber) 2 in (number~) main::$25 ← (word) main::i#6 * (number) 2
Adding number conversion cast (unumber) main::$25 in (number~) main::$25 ← (word) main::i#6 * (unumber)(number) 2
Adding number conversion cast (unumber) 1 in *((byte*) main::s#2) ← (number) 1
Adding number conversion cast (unumber) 0 in (bool~) main::$37 ← (number) 0 != *((byte*) sieve#0 + (word) main::i#8)
Adding number conversion cast (unumber) $514 in (bool~) main::$32 ← (word) main::i#3 < (number) $514
Adding number conversion cast (unumber) $3e7 in (byte*~) main::$35 ← (byte*) SCREEN#0 + (number) $3e7
Successful SSA optimization PassNAddNumberTypeConversions
Adding number conversion cast (word) to elements in (word[]) RADIX_BINARY_VALUES#0 ← { (word)(number) $8000, (word)(number) $4000, (word)(number) $2000, (word)(number) $1000, (word)(number) $800, (word)(number) $400, (word)(number) $200, (word)(number) $100, (word)(number) $80, (word)(number) $40, (word)(number) $20, (word)(number) $10, (word)(number) 8, (word)(number) 4, (word)(number) 2 }
Adding number conversion cast (word) to elements in (word[]) RADIX_OCTAL_VALUES#0 ← { (word)(number) $8000, (word)(number) $1000, (word)(number) $200, (word)(number) $40, (word)(number) 8 }
Adding number conversion cast (word) to elements in (word[]) RADIX_DECIMAL_VALUES#0 ← { (word)(number) $2710, (word)(number) $3e8, (word)(number) $64, (word)(number) $a }
Adding number conversion cast (word) to elements in (word[]) RADIX_HEXADECIMAL_VALUES#0 ← { (word)(number) $1000, (word)(number) $100, (word)(number) $10 }
Adding number conversion cast (dword) to elements in (dword[]) RADIX_BINARY_VALUES_LONG#0 ← { (dword)(number) $80000000, (dword)(number) $40000000, (dword)(number) $20000000, (dword)(number) $10000000, (dword)(number) $8000000, (dword)(number) $4000000, (dword)(number) $2000000, (dword)(number) $1000000, (dword)(number) $800000, (dword)(number) $400000, (dword)(number) $200000, (dword)(number) $100000, (dword)(number) $80000, (dword)(number) $40000, (dword)(number) $20000, (dword)(number) $10000, (dword)(number) $8000, (dword)(number) $4000, (dword)(number) $2000, (dword)(number) $1000, (dword)(number) $800, (dword)(number) $400, (dword)(number) $200, (dword)(number) $100, (dword)(number) $80, (dword)(number) $40, (dword)(number) $20, (dword)(number) $10, (dword)(number) 8, (dword)(number) 4, (dword)(number) 2 }
Adding number conversion cast (dword) to elements in (dword[]) RADIX_OCTAL_VALUES_LONG#0 ← { (dword)(number) $40000000, (dword)(number) $8000000, (dword)(number) $1000000, (dword)(number) $200000, (dword)(number) $40000, (dword)(number) $8000, (dword)(number) $1000, (dword)(number) $200, (dword)(number) $40, (dword)(number) 8 }
Adding number conversion cast (dword) to elements in (dword[]) RADIX_DECIMAL_VALUES_LONG#0 ← { (dword)(number) $3b9aca00, (dword)(number) $5f5e100, (dword)(number) $989680, (dword)(number) $f4240, (dword)(number) $186a0, (dword)(number) $2710, (dword)(number) $3e8, (dword)(number) $64, (dword)(number) $a }
Adding number conversion cast (dword) to elements in (dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0 ← { (dword)(number) $10000000, (dword)(number) $1000000, (dword)(number) $100000, (dword)(number) $10000, (dword)(number) $1000, (dword)(number) $100, (dword)(number) $10 }
Successful SSA optimization PassNAddArrayNumberTypeConversions
Inlining cast (byte*~) memset::$2 ← (byte*)(void*) memset::str#3
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#3
Inlining cast (byte*) D018#0 ← (byte*)(number) $d018
Inlining cast (dword*) CIA2_TIMER_AB#0 ← (dword*)(number) $dd04
Inlining cast (byte*) CIA2_TIMER_A_CONTROL#0 ← (byte*)(number) $dd0e
Inlining cast (byte*) CIA2_TIMER_B_CONTROL#0 ← (byte*)(number) $dd0f
Inlining cast (byte) CIA_TIMER_CONTROL_STOP#0 ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_START#0 ← (unumber)(number) 1
Inlining cast (byte) CIA_TIMER_CONTROL_CONTINUOUS#0 ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 ← (unumber)(number) 0
Inlining cast (byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 ← (unumber)(number) $40
Inlining cast (word) CLOCKS_PER_FRAME#0 ← (unumber)(number) $4cc8
Inlining cast (byte) FRAMES_PER_SEC#0 ← (unumber)(number) $3c
Inlining cast (dword) CLOCKS_PER_INIT#0 ← (unumber)(number) $12
Inlining cast *((dword*) CIA2_TIMER_AB#0) ← (unumber)(number) $ffffffff
Inlining cast (word) rem16u#0 ← (unumber)(number) 0
Inlining cast (word) divr16u::quotient#0 ← (unumber)(number) 0
Inlining cast (word) divr16u::rem#3 ← (unumber)(number) 0
Inlining cast (byte) utoa::max_digits#1 ← (unumber)(number) 5
Inlining cast (byte) utoa::max_digits#2 ← (unumber)(number) 4
Inlining cast (byte) utoa::max_digits#3 ← (unumber)(number) 6
Inlining cast (byte) utoa::max_digits#4 ← (unumber)(number) $10
Inlining cast *((byte*) utoa::buffer#2) ← (unumber)(number) 0
Inlining cast (byte) utoa::started#0 ← (unumber)(number) 0
Inlining cast (byte) utoa::digit#0 ← (unumber)(number) 0
Inlining cast (byte) utoa::started#1 ← (unumber)(number) 1
Inlining cast (byte~) utoa::$4 ← (byte)(word) utoa::value#4
Inlining cast *((byte*) utoa::buffer#4) ← (unumber)(number) 0
Inlining cast (byte) utoa_append::digit#0 ← (unumber)(number) 0
Inlining cast (byte) ultoa::max_digits#1 ← (unumber)(number) $a
Inlining cast (byte) ultoa::max_digits#2 ← (unumber)(number) 8
Inlining cast (byte) ultoa::max_digits#3 ← (unumber)(number) $b
Inlining cast (byte) ultoa::max_digits#4 ← (unumber)(number) $20
Inlining cast *((byte*) ultoa::buffer#2) ← (unumber)(number) 0
Inlining cast (byte) ultoa::started#0 ← (unumber)(number) 0
Inlining cast (byte) ultoa::digit#0 ← (unumber)(number) 0
Inlining cast (byte) ultoa::started#1 ← (unumber)(number) 1
Inlining cast (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4
Inlining cast *((byte*) ultoa::buffer#4) ← (unumber)(number) 0
Inlining cast (byte) ultoa_append::digit#0 ← (unumber)(number) 0
Inlining cast (byte*) print_screen#0 ← (byte*)(number) $400
Inlining cast (word) memset::num#0 ← (unumber)(number) $3e8
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $400
Inlining cast (word) COUNT#0 ← (unumber)(number) $4000
Inlining cast (byte) SQRT_COUNT#0 ← (unumber)(number) $80
Inlining cast (byte*) sieve#0 ← (byte*)(number) $1000
Inlining cast (word~) main::toD0181_$0#0 ← (word)(byte*) main::toD0181_screen#1
Inlining cast (word~) main::toD0181_$4#0 ← (word)(byte*) main::toD0181_gfx#1
Inlining cast (byte) memset::c#1 ← (unumber)(number) 0
Inlining cast (word) main::i#0 ← (unumber)(number) 2
Inlining cast (word~) main::$13 ← (word)(unumber~) main::$12
Inlining cast (word~) main::$15 ← (word)(dword~) main::$14
Inlining cast (word) main::i#1 ← (unumber)(number) 2
Inlining cast *((byte*) main::s#2) ← (unumber)(number) 1
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (dword*) 56580
Simplifying constant pointer cast (byte*) 56590
Simplifying constant pointer cast (byte*) 56591
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast $4cc8
Simplifying constant integer cast $3c
Simplifying constant integer cast $12
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast $ffffffff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast (word) div32u16u::quotient_hi#1
Simplifying constant integer cast (word) div32u16u::quotient_lo#0
Simplifying constant integer cast $8000
Simplifying constant integer cast $4000
Simplifying constant integer cast $2000
Simplifying constant integer cast $1000
Simplifying constant integer cast $800
Simplifying constant integer cast $400
Simplifying constant integer cast $200
Simplifying constant integer cast $100
Simplifying constant integer cast $80
Simplifying constant integer cast $40
Simplifying constant integer cast $20
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast $8000
Simplifying constant integer cast $1000
Simplifying constant integer cast $200
Simplifying constant integer cast $40
Simplifying constant integer cast 8
Simplifying constant integer cast $2710
Simplifying constant integer cast $3e8
Simplifying constant integer cast $64
Simplifying constant integer cast $a
Simplifying constant integer cast $1000
Simplifying constant integer cast $100
Simplifying constant integer cast $10
Simplifying constant integer cast 5
Simplifying constant integer cast 4
Simplifying constant integer cast 6
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $80000000
Simplifying constant integer cast $40000000
Simplifying constant integer cast $20000000
Simplifying constant integer cast $10000000
Simplifying constant integer cast $8000000
Simplifying constant integer cast $4000000
Simplifying constant integer cast $2000000
Simplifying constant integer cast $1000000
Simplifying constant integer cast $800000
Simplifying constant integer cast $400000
Simplifying constant integer cast $200000
Simplifying constant integer cast $100000
Simplifying constant integer cast $80000
Simplifying constant integer cast $40000
Simplifying constant integer cast $20000
Simplifying constant integer cast $10000
Simplifying constant integer cast $8000
Simplifying constant integer cast $4000
Simplifying constant integer cast $2000
Simplifying constant integer cast $1000
Simplifying constant integer cast $800
Simplifying constant integer cast $400
Simplifying constant integer cast $200
Simplifying constant integer cast $100
Simplifying constant integer cast $80
Simplifying constant integer cast $40
Simplifying constant integer cast $20
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant integer cast 4
Simplifying constant integer cast 2
Simplifying constant integer cast $40000000
Simplifying constant integer cast $8000000
Simplifying constant integer cast $1000000
Simplifying constant integer cast $200000
Simplifying constant integer cast $40000
Simplifying constant integer cast $8000
Simplifying constant integer cast $1000
Simplifying constant integer cast $200
Simplifying constant integer cast $40
Simplifying constant integer cast 8
Simplifying constant integer cast $3b9aca00
Simplifying constant integer cast $5f5e100
Simplifying constant integer cast $989680
Simplifying constant integer cast $f4240
Simplifying constant integer cast $186a0
Simplifying constant integer cast $2710
Simplifying constant integer cast $3e8
Simplifying constant integer cast $64
Simplifying constant integer cast $a
Simplifying constant integer cast $10000000
Simplifying constant integer cast $1000000
Simplifying constant integer cast $100000
Simplifying constant integer cast $10000
Simplifying constant integer cast $1000
Simplifying constant integer cast $100
Simplifying constant integer cast $10
Simplifying constant integer cast $a
Simplifying constant integer cast 8
Simplifying constant integer cast $b
Simplifying constant integer cast $20
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $28
Simplifying constant integer cast $3e8
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $4000
Simplifying constant integer cast $80
Simplifying constant pointer cast (byte*) 4096
Simplifying constant pointer cast (byte*) 6144
Simplifying constant integer cast $3fff
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast $64
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast $514
Simplifying constant integer cast $3e7
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $4cc8
Finalized unsigned number type (byte) $3c
Finalized unsigned number type (byte) $12
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (dword) $ffffffff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $b
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (word) $4000
Finalized unsigned number type (byte) $80
Finalized unsigned number type (word) $3fff
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $64
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $514
Finalized unsigned number type (word) $3e7
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to dword in (unumber~) clock::$0 ← (dword) $ffffffff - *((dword*) CIA2_TIMER_AB#0)
Inferred type updated to byte in (unumber~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80
Inferred type updated to word in (unumber~) divr16u::$5 ← (word) divr16u::rem#7 | (byte) 1
Inferred type updated to byte in (unumber~) utoa::$9 ← (byte) utoa::max_digits#5 - (byte) 1
Inferred type updated to byte in (unumber~) ultoa::$9 ← (byte) ultoa::max_digits#5 - (byte) 1
Inferred type updated to word in (unumber~) main::toD0181_$1#0 ← (word~) main::toD0181_$0#0 & (word) $3fff
Inferred type updated to word in (unumber~) main::toD0181_$2#0 ← (word~) main::toD0181_$1#0 * (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$3#0 ← > (word~) main::toD0181_$2#0
Inferred type updated to byte in (unumber~) main::toD0181_$6#0 ← (byte~) main::toD0181_$5#0 / (byte) 4
Inferred type updated to byte in (unumber~) main::toD0181_$7#0 ← (byte~) main::toD0181_$6#0 & (byte) $f
Inferred type updated to byte in (unumber~) main::toD0181_$8#0 ← (byte~) main::toD0181_$3#0 | (byte~) main::toD0181_$7#0
Inferred type updated to dword in (unumber~) main::$12 ← (dword) CLOCKS_PER_SEC#0 / (byte) $64
Inferred type updated to word in (unumber~) main::$25 ← (word) main::i#6 * (byte) 2
Inversing boolean not [2] (bool~) memset::$1 ← (word) memset::num#2 <= (byte) 0 from [1] (bool~) memset::$0 ← (word) memset::num#2 > (byte) 0
Inversing boolean not [62] (bool~) divr16u::$4 ← (byte~) divr16u::$2 == (byte) 0 from [61] (bool~) divr16u::$3 ← (byte~) divr16u::$2 != (byte) 0
Inversing boolean not [70] (bool~) divr16u::$9 ← (word) divr16u::rem#6 < (word) divr16u::divisor#2 from [69] (bool~) divr16u::$8 ← (word) divr16u::rem#6 >= (word) divr16u::divisor#2
Inversing boolean not [429] (bool~) main::$23 ← (byte) 0 == *((byte*) main::sieve_i#2) from [428] (bool~) main::$36 ← (byte) 0 != *((byte*) main::sieve_i#2)
Inversing boolean not [430] (bool~) main::$24 ← (byte) 0 != *((byte*) main::sieve_i#2) from [429] (bool~) main::$23 ← (byte) 0 == *((byte*) main::sieve_i#2)
Inversing boolean not [488] (bool~) main::$28 ← (byte) 0 == *((byte*) sieve#0 + (word) main::i#8) from [487] (bool~) main::$37 ← (byte) 0 != *((byte*) sieve#0 + (word) main::i#8)
Inversing boolean not [489] (bool~) main::$29 ← (byte) 0 != *((byte*) sieve#0 + (word) main::i#8) from [488] (bool~) main::$28 ← (byte) 0 == *((byte*) sieve#0 + (word) main::i#8)
Successful SSA optimization Pass2UnaryNotSimplification
Alias (void*) memset::return#0 = (void*) memset::str#2 (void*) memset::return#4 (void*) memset::return#1 
Alias (void*) memset::str#3 = (void*) memset::str#4 
Alias (word) memset::num#2 = (word) memset::num#3 
Alias (byte) memset::c#3 = (byte) memset::c#4 
Alias (byte*) memset::end#0 = (byte*~) memset::$3 
Alias (dword) CLOCKS_PER_SEC#0 = (word~) $0 
Alias (dword) clock::return#0 = (dword~) clock::$0 (dword) clock::return#3 (dword) clock::return#1 
Alias (word) divr16u::rem#0 = (word~) divr16u::$0 (word) divr16u::rem#7 
Alias (word) divr16u::dividend#0 = (word~) divr16u::$6 (word) divr16u::dividend#8 
Alias (word) divr16u::quotient#1 = (word~) divr16u::$7 (word) divr16u::quotient#4 
Alias (word) divr16u::dividend#3 = (word) divr16u::dividend#7 
Alias (word) divr16u::quotient#6 = (word) divr16u::quotient#7 
Alias (word) divr16u::divisor#4 = (word) divr16u::divisor#5 
Alias (byte) divr16u::i#5 = (byte) divr16u::i#6 
Alias (word) divr16u::rem#1 = (word~) divr16u::$5 
Alias (word) divr16u::rem#6 = (word) divr16u::rem#8 
Alias (word) divr16u::divisor#2 = (word) divr16u::divisor#3 
Alias (byte) divr16u::i#3 = (byte) divr16u::i#4 
Alias (word) divr16u::rem#2 = (word~) divr16u::$10 
Alias (word) divr16u::rem#11 = (word) divr16u::rem#9 
Alias (word) divr16u::return#0 = (word) divr16u::quotient#5 (word) divr16u::quotient#8 (word) divr16u::return#4 (word) divr16u::return#1 
Alias (word) rem16u#1 = (word) rem16u#9 (word) rem16u#2 
Alias (word) divr16u::dividend#1 = (word~) div32u16u::$0 
Alias (word) divr16u::return#2 = (word) divr16u::return#5 
Alias (dword) div32u16u::dividend#1 = (dword) div32u16u::dividend#2 
Alias (word) div32u16u::divisor#1 = (word) div32u16u::divisor#2 
Alias (word) rem16u#10 = (word) rem16u#3 
Alias (word) div32u16u::quotient_hi#0 = (word~) div32u16u::$1 (word) div32u16u::quotient_hi#1 
Alias (word) divr16u::dividend#2 = (word~) div32u16u::$2 
Alias (word) divr16u::return#3 = (word) divr16u::return#6 
Alias (word) rem16u#11 = (word) rem16u#4 (word) rem16u#12 (word) rem16u#5 
Alias (word) div32u16u::quotient_lo#0 = (word~) div32u16u::$3 
Alias (dword) div32u16u::return#0 = (dword) div32u16u::quotient#0 (dword~) div32u16u::$4 (dword) div32u16u::return#3 (dword) div32u16u::return#1 
Alias (word) rem16u#0 = (word) rem16u#43 (word) rem16u#37 (word) rem16u#31 (word) rem16u#27 (word) rem16u#24 (word) rem16u#23 (word) rem16u#19 
Alias (word) utoa::value#10 = (word) utoa::value#7 (word) utoa::value#11 (word) utoa::value#12 (word) utoa::value#8 (word) utoa::value#13 (word) utoa::value#9 (word) utoa::value#14 
Alias (byte*) utoa::buffer#10 = (byte*) utoa::buffer#16 (byte*) utoa::buffer#20 (byte*) utoa::buffer#15 (byte*) utoa::buffer#17 (byte*) utoa::buffer#13 (byte*) utoa::buffer#18 (byte*) utoa::buffer#19 (byte*) utoa::buffer#6 
Alias (byte) utoa::radix#1 = (byte) utoa::radix#2 (byte) utoa::radix#3 (byte) utoa::radix#4 
Alias (byte*) utoa::buffer#11 = (byte*) utoa::buffer#7 (byte*) utoa::buffer#8 
Alias (word) utoa::value#2 = (word) utoa::value#3 
Alias (word) utoa::digit_value#0 = (word) utoa::digit_value#1 
Alias (byte) utoa::digit#2 = (byte) utoa::digit#5 (byte) utoa::digit#4 
Alias (byte) utoa::max_digits#6 = (byte) utoa::max_digits#9 (byte) utoa::max_digits#7 
Alias (word*) utoa::digit_values#5 = (word*) utoa::digit_values#9 (word*) utoa::digit_values#8 
Alias (word) utoa_append::return#0 = (word) utoa_append::return#3 
Alias (word) utoa::value#0 = (word~) utoa::$8 
Alias (word) utoa::value#4 = (word) utoa::value#5 
Alias (byte*) utoa::buffer#12 = (byte*) utoa::buffer#9 
Alias (byte) utoa_append::digit#2 = (byte) utoa_append::digit#4 (byte) utoa_append::digit#3 
Alias (word) utoa_append::value#2 = (word) utoa_append::value#3 (word) utoa_append::value#4 (word) utoa_append::return#1 (word) utoa_append::return#4 (word) utoa_append::return#2 
Alias (word) utoa_append::sub#1 = (word) utoa_append::sub#2 
Alias (byte*) utoa_append::buffer#1 = (byte*) utoa_append::buffer#4 (byte*) utoa_append::buffer#2 
Alias (dword) ultoa::value#10 = (dword) ultoa::value#7 (dword) ultoa::value#11 (dword) ultoa::value#12 (dword) ultoa::value#8 (dword) ultoa::value#13 (dword) ultoa::value#9 (dword) ultoa::value#14 
Alias (byte*) ultoa::buffer#10 = (byte*) ultoa::buffer#16 (byte*) ultoa::buffer#20 (byte*) ultoa::buffer#15 (byte*) ultoa::buffer#17 (byte*) ultoa::buffer#13 (byte*) ultoa::buffer#18 (byte*) ultoa::buffer#19 (byte*) ultoa::buffer#6 
Alias (byte) ultoa::radix#1 = (byte) ultoa::radix#2 (byte) ultoa::radix#3 (byte) ultoa::radix#4 
Alias (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#7 (byte*) ultoa::buffer#8 
Alias (dword) ultoa::value#2 = (dword) ultoa::value#3 
Alias (dword) ultoa::digit_value#0 = (dword) ultoa::digit_value#1 
Alias (byte) ultoa::digit#2 = (byte) ultoa::digit#5 (byte) ultoa::digit#4 
Alias (byte) ultoa::max_digits#6 = (byte) ultoa::max_digits#9 (byte) ultoa::max_digits#7 
Alias (dword*) ultoa::digit_values#5 = (dword*) ultoa::digit_values#9 (dword*) ultoa::digit_values#8 
Alias (dword) ultoa_append::return#0 = (dword) ultoa_append::return#3 
Alias (dword) ultoa::value#0 = (dword~) ultoa::$8 
Alias (dword) ultoa::value#4 = (dword) ultoa::value#5 
Alias (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#9 
Alias (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#4 (byte) ultoa_append::digit#3 
Alias (dword) ultoa_append::value#2 = (dword) ultoa_append::value#3 (dword) ultoa_append::value#4 (dword) ultoa_append::return#1 (dword) ultoa_append::return#4 (dword) ultoa_append::return#2 
Alias (dword) ultoa_append::sub#1 = (dword) ultoa_append::sub#2 
Alias (byte*) ultoa_append::buffer#1 = (byte*) ultoa_append::buffer#4 (byte*) ultoa_append::buffer#2 
Alias (byte*) print_line_cursor#0 = (byte*) print_screen#0 (byte*) print_char_cursor#0 (byte*) print_line_cursor#38 (byte*) print_char_cursor#78 (byte*) print_screen#10 (byte*) print_line_cursor#34 (byte*) print_char_cursor#75 (byte*) print_screen#9 (byte*) print_line_cursor#33 (byte*) print_char_cursor#74 (byte*) print_screen#8 (byte*) print_line_cursor#27 (byte*) print_char_cursor#65 (byte*) print_screen#7 
Alias (byte*) print_str::str#8 = (byte*) print_str::str#9 
Alias (byte*) print_char_cursor#2 = (byte*) print_char_cursor#29 (byte*) print_char_cursor#56 (byte*) print_char_cursor#30 
Alias (byte*) print_line_cursor#1 = (byte*~) print_ln::$0 (byte*) print_line_cursor#12 (byte*) print_char_cursor#3 (byte*) print_line_cursor#13 (byte*) print_char_cursor#32 (byte*) print_line_cursor#2 (byte*) print_char_cursor#4 
Alias (byte*) print_char_cursor#58 = (byte*) print_char_cursor#67 
Alias (byte*) print_char_cursor#33 = (byte*) print_char_cursor#5 (byte*) print_char_cursor#34 (byte*) print_char_cursor#6 
Alias (byte*) print_char_cursor#59 = (byte*) print_char_cursor#68 
Alias (byte*) print_char_cursor#35 = (byte*) print_char_cursor#7 (byte*) print_char_cursor#36 (byte*) print_char_cursor#8 
Alias (byte*) print_char_cursor#10 = (byte*) print_char_cursor#38 (byte*) print_char_cursor#9 
Alias (byte*) print_line_cursor#14 = (byte*) print_screen#2 (byte*) print_screen#1 (byte*) print_line_cursor#3 (byte*) print_char_cursor#11 (byte*) print_char_cursor#39 (byte*) print_line_cursor#4 (byte*) print_char_cursor#12 
Alias (byte*) main::toD0181_screen#0 = (byte*) main::toD0181_screen#1 
Alias (byte*) main::toD0181_gfx#0 = (byte*) main::toD0181_gfx#1 
Alias (byte*) print_screen#3 = (byte*) print_screen#5 (byte*) print_screen#6 (byte*) print_screen#4 
Alias (byte*) print_line_cursor#22 = (byte*) print_line_cursor#35 (byte*) print_line_cursor#39 (byte*) print_line_cursor#28 
Alias (byte*) print_char_cursor#60 = (byte*) print_char_cursor#76 (byte*) print_char_cursor#79 (byte*) print_char_cursor#69 
Alias (word) rem16u#28 = (word) rem16u#56 (word) rem16u#57 (word) rem16u#55 (word) rem16u#54 (word) rem16u#53 (word) rem16u#51 (word) rem16u#49 (word) rem16u#47 (word) rem16u#44 (word) rem16u#38 (word) rem16u#32 
Alias (byte) main::toD0181_return#0 = (byte~) main::toD0181_$8#0 (byte) main::toD0181_return#2 (byte) main::toD0181_return#1 (byte) main::toD0181_return#3 (byte~) main::$0 
Alias (byte*) print_line_cursor#15 = (byte*) print_line_cursor#5 (byte*) print_line_cursor#23 
Alias (byte*) print_char_cursor#13 = (byte*) print_char_cursor#40 
Alias (byte*) print_char_cursor#14 = (byte*) print_char_cursor#41 
Alias (byte*) print_line_cursor#16 = (byte*) print_line_cursor#6 (byte*) print_line_cursor#29 (byte*) print_line_cursor#24 
Alias (byte*) print_char_cursor#15 = (byte*) print_char_cursor#42 
Alias (byte*) print_char_cursor#16 = (byte*) print_char_cursor#43 
Alias (byte*) print_char_cursor#17 = (byte*) print_char_cursor#44 
Alias (byte*) print_line_cursor#17 = (byte*) print_line_cursor#7 (byte*) print_line_cursor#52 (byte*) print_line_cursor#50 
Alias (byte*) print_char_cursor#18 = (byte*) print_char_cursor#45 (byte*) print_char_cursor#83 (byte*) print_char_cursor#81 
Alias (byte*) main::sieve_i#0 = (byte*~) main::$9 
Alias (byte*) main::sieve_i#2 = (byte*) main::sieve_i#4 (byte*) main::sieve_i#6 
Alias (word) main::i#11 = (word) main::i#4 (word) main::i#6 
Alias (word) rem16u#17 = (word) rem16u#33 (word) rem16u#25 (word) rem16u#20 (word) rem16u#39 
Alias (byte*) print_char_cursor#61 = (byte*) print_char_cursor#84 (byte*) print_char_cursor#80 (byte*) print_char_cursor#77 (byte*) print_char_cursor#70 (byte*) print_char_cursor#86 
Alias (byte*) print_line_cursor#25 = (byte*) print_line_cursor#53 (byte*) print_line_cursor#49 (byte*) print_line_cursor#47 (byte*) print_line_cursor#45 (byte*) print_line_cursor#42 (byte*) print_line_cursor#40 (byte*) print_line_cursor#36 (byte*) print_line_cursor#30 (byte*) print_line_cursor#55 
Alias (dword) clock::return#2 = (dword) clock::return#4 
Alias (dword) main::cyclecount#0 = (dword~) main::$11 (dword) main::cyclecount#4 (dword) main::cyclecount#3 (dword) main::cyclecount#2 (dword) main::cyclecount#1 
Alias (word) div32u16u::divisor#0 = (word~) main::$13 
Alias (dword) div32u16u::return#2 = (dword) div32u16u::return#4 
Alias (word) rem16u#13 = (word) rem16u#6 (word) rem16u#52 (word) rem16u#50 (word) rem16u#48 (word) rem16u#45 (word) rem16u#41 
Alias (word) main::sec100s#0 = (word~) main::$15 (word) main::sec100s#1 
Alias (byte*) print_char_cursor#19 = (byte*) print_char_cursor#46 
Alias (byte*) print_char_cursor#20 = (byte*) print_char_cursor#47 
Alias (byte*) print_char_cursor#21 = (byte*) print_char_cursor#48 
Alias (byte*) print_char_cursor#22 = (byte*) print_char_cursor#49 
Alias (byte*) print_line_cursor#18 = (byte*) print_line_cursor#8 
Alias (byte*) print_char_cursor#23 = (byte*) print_char_cursor#50 
Alias (word) main::j#0 = (word~) main::$25 
Alias (byte*) main::s#0 = (byte*~) main::$26 
Alias (byte*) main::s#2 = (byte*) main::s#3 
Alias (word) main::i#12 = (word) main::i#7 
Alias (word) main::j#2 = (word) main::j#3 
Alias (byte*) main::sieve_i#5 = (byte*) main::sieve_i#7 
Alias (word) rem16u#34 = (word) rem16u#40 
Alias (byte*) print_char_cursor#85 = (byte*) print_char_cursor#87 
Alias (byte*) print_line_cursor#54 = (byte*) print_line_cursor#56 
Alias (word) main::i#10 = (word) main::i#8 (word) main::i#14 (word) main::i#13 
Alias (byte*) print_char_cursor#62 = (byte*) print_char_cursor#71 
Alias (byte*) print_line_cursor#43 = (byte*) print_line_cursor#48 (byte*) print_line_cursor#46 (byte*) print_line_cursor#44 
Alias (word) rem16u#35 = (word) rem16u#46 (word) rem16u#42 (word) rem16u#36 
Alias (byte*) print_char_cursor#24 = (byte*) print_char_cursor#51 
Alias (byte*) print_char_cursor#25 = (byte*) print_char_cursor#52 
Alias (byte*) print_char_cursor#63 = (byte*) print_char_cursor#72 
Alias (byte*) print_line_cursor#32 = (byte*) print_line_cursor#37 (byte*) print_line_cursor#41 
Alias (word) rem16u#22 = (word) rem16u#26 (word) rem16u#30 
Alias (byte*) print_char_cursor#26 = (byte*) print_char_cursor#53 
Alias (byte*) print_line_cursor#19 = (byte*) print_line_cursor#31 (byte*) print_line_cursor#26 (byte*) print_line_cursor#9 
Alias (byte*) print_char_cursor#27 = (byte*) print_char_cursor#73 (byte*) print_char_cursor#64 (byte*) print_char_cursor#54 
Alias (word) rem16u#14 = (word) rem16u#21 (word) rem16u#18 (word) rem16u#7 
Alias (byte*) print_line_cursor#10 = (byte*) print_line_cursor#20 
Alias (byte*) print_char_cursor#28 = (byte*) print_char_cursor#55 
Alias (word) rem16u#15 = (word) rem16u#8 
Successful SSA optimization Pass2AliasElimination
Alias (word) divr16u::dividend#3 = (word) divr16u::dividend#4 
Alias (word) divr16u::quotient#3 = (word) divr16u::quotient#6 
Alias (word) divr16u::divisor#2 = (word) divr16u::divisor#4 (word) divr16u::divisor#7 
Alias (byte) divr16u::i#2 = (byte) divr16u::i#3 (byte) divr16u::i#5 
Alias (word) divr16u::dividend#0 = (word) divr16u::dividend#6 
Alias (word) utoa::value#10 = (word) utoa::value#6 
Alias (byte*) utoa::buffer#10 = (byte*) utoa::buffer#14 
Alias (byte) utoa::digit#2 = (byte) utoa::digit#3 
Alias (byte) utoa::max_digits#5 = (byte) utoa::max_digits#6 
Alias (word*) utoa::digit_values#5 = (word*) utoa::digit_values#6 
Alias (dword) ultoa::value#10 = (dword) ultoa::value#6 
Alias (byte*) ultoa::buffer#10 = (byte*) ultoa::buffer#14 
Alias (byte) ultoa::digit#2 = (byte) ultoa::digit#3 
Alias (byte) ultoa::max_digits#5 = (byte) ultoa::max_digits#6 
Alias (dword*) ultoa::digit_values#5 = (dword*) ultoa::digit_values#6 
Alias (word) main::i#10 = (word) main::i#9 
Alias (byte*) print_line_cursor#32 = (byte*) print_line_cursor#43 
Alias (word) rem16u#22 = (word) rem16u#35 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) memset::c#2 (byte) memset::c#3
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#5 (void*) memset::str#3
Identical Phi Values (word) divr16u::divisor#2 (word) divr16u::divisor#6
Identical Phi Values (dword) div32u16u::dividend#1 (dword) div32u16u::dividend#0
Identical Phi Values (word) div32u16u::divisor#1 (word) div32u16u::divisor#0
Identical Phi Values (word) rem16u#16 (word) rem16u#17
Identical Phi Values (word) rem16u#10 (word) rem16u#1
Identical Phi Values (word) rem16u#11 (word) rem16u#1
Identical Phi Values (byte) utoa::radix#1 (byte) utoa::radix#0
Identical Phi Values (word) utoa::value#10 (word) utoa::value#1
Identical Phi Values (byte*) utoa::buffer#10 (byte*) utoa::buffer#5
Identical Phi Values (word*) utoa::digit_values#5 (word*) utoa::digit_values#7
Identical Phi Values (byte) utoa::max_digits#5 (byte) utoa::max_digits#8
Identical Phi Values (word) utoa_append::value#5 (word) utoa_append::value#0
Identical Phi Values (word) utoa_append::sub#3 (word) utoa_append::sub#0
Identical Phi Values (byte*) utoa_append::buffer#3 (byte*) utoa_append::buffer#0
Identical Phi Values (word) utoa_append::sub#1 (word) utoa_append::sub#3
Identical Phi Values (byte*) utoa_append::buffer#1 (byte*) utoa_append::buffer#3
Identical Phi Values (byte) ultoa::radix#1 (byte) ultoa::radix#0
Identical Phi Values (dword) ultoa::value#10 (dword) ultoa::value#1
Identical Phi Values (byte*) ultoa::buffer#10 (byte*) ultoa::buffer#5
Identical Phi Values (dword*) ultoa::digit_values#5 (dword*) ultoa::digit_values#7
Identical Phi Values (byte) ultoa::max_digits#5 (byte) ultoa::max_digits#8
Identical Phi Values (dword) ultoa_append::value#5 (dword) ultoa_append::value#0
Identical Phi Values (dword) ultoa_append::sub#3 (dword) ultoa_append::sub#0
Identical Phi Values (byte*) ultoa_append::buffer#3 (byte*) ultoa_append::buffer#0
Identical Phi Values (dword) ultoa_append::sub#1 (dword) ultoa_append::sub#3
Identical Phi Values (byte*) ultoa_append::buffer#1 (byte*) ultoa_append::buffer#3
Identical Phi Values (byte*) print_char_cursor#31 (byte*) print_char_cursor#57
Identical Phi Values (byte*) print_char_cursor#33 (byte*) print_char_cursor#2
Identical Phi Values (dword) print_dword_decimal::w#1 (dword) print_dword_decimal::w#0
Identical Phi Values (byte*) print_char_cursor#59 (byte*) print_char_cursor#21
Identical Phi Values (byte*) print_char_cursor#35 (byte*) print_char_cursor#2
Identical Phi Values (byte) print_char::ch#1 (byte) print_char::ch#0
Identical Phi Values (byte*) print_char_cursor#37 (byte*) print_char_cursor#24
Identical Phi Values (byte*) print_line_cursor#14 (byte*) print_screen#3
Identical Phi Values (byte*) print_screen#3 (byte*) print_line_cursor#0
Identical Phi Values (byte*) print_line_cursor#22 (byte*) print_line_cursor#0
Identical Phi Values (byte*) print_char_cursor#60 (byte*) print_line_cursor#0
Identical Phi Values (word) rem16u#28 (word) rem16u#0
Identical Phi Values (byte*) print_line_cursor#15 (byte*) print_line_cursor#14
Identical Phi Values (byte*) print_char_cursor#13 (byte*) print_line_cursor#14
Identical Phi Values (byte*) print_char_cursor#14 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_line_cursor#16 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#15 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#16 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#17 (byte*) print_char_cursor#33
Identical Phi Values (byte*) print_line_cursor#17 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#18 (byte*) print_line_cursor#1
Identical Phi Values (word) rem16u#13 (word) rem16u#11
Identical Phi Values (byte*) print_char_cursor#19 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#20 (byte*) print_char_cursor#33
Identical Phi Values (byte*) print_char_cursor#21 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_char_cursor#22 (byte*) print_char_cursor#35
Identical Phi Values (byte*) print_line_cursor#18 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_char_cursor#23 (byte*) print_line_cursor#1
Identical Phi Values (word) main::i#12 (word) main::i#11
Identical Phi Values (byte*) main::sieve_i#5 (byte*) main::sieve_i#2
Identical Phi Values (word) rem16u#34 (word) rem16u#17
Identical Phi Values (byte*) print_char_cursor#85 (byte*) print_char_cursor#61
Identical Phi Values (byte*) print_line_cursor#54 (byte*) print_line_cursor#25
Identical Phi Values (byte*) print_line_cursor#32 (byte*) print_line_cursor#18
Identical Phi Values (word) rem16u#22 (word) rem16u#13
Identical Phi Values (byte*) print_char_cursor#24 (byte*) print_char_cursor#33
Identical Phi Values (byte*) print_char_cursor#25 (byte*) print_char_cursor#10
Identical Phi Values (byte*) print_char_cursor#26 (byte*) print_char_cursor#2
Identical Phi Values (byte*) print_line_cursor#19 (byte*) print_line_cursor#32
Identical Phi Values (byte*) print_char_cursor#27 (byte*) print_char_cursor#26
Identical Phi Values (word) rem16u#14 (word) rem16u#22
Identical Phi Values (byte*) print_line_cursor#10 (byte*) print_line_cursor#19
Identical Phi Values (byte*) print_char_cursor#28 (byte*) print_char_cursor#27
Identical Phi Values (word) rem16u#15 (word) rem16u#14
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#3
Identical Phi Values (byte*) print_char_cursor#57 (byte*) print_char_cursor#2
Identical Phi Values (word) main::i#5 (word) main::i#11
Identical Phi Values (byte*) main::sieve_i#3 (byte*) main::sieve_i#2
Identical Phi Values (word) rem16u#29 (word) rem16u#17
Identical Phi Values (byte*) print_char_cursor#82 (byte*) print_char_cursor#61
Identical Phi Values (byte*) print_line_cursor#51 (byte*) print_line_cursor#25
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (word) rem16u#17 (word) rem16u#0
Identical Phi Values (byte*) print_char_cursor#61 (byte*) print_line_cursor#1
Identical Phi Values (byte*) print_line_cursor#25 (byte*) print_line_cursor#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [41] (byte~) clock_start::$2 ← (byte) CIA_TIMER_CONTROL_STOP#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Identified duplicate assignment right side [48] (byte~) clock_start::$6 ← (byte) CIA_TIMER_CONTROL_START#0 | (byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) memset::$1 [3] if((word) memset::num#2<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$4 [15] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@4
Simple Condition (bool~) divr16u::$4 [63] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2
Simple Condition (bool~) divr16u::$9 [71] if((word) divr16u::rem#6<(word) divr16u::divisor#6) goto divr16u::@3
Simple Condition (bool~) divr16u::$11 [78] if((byte) divr16u::i#1!=rangelast(0,$f)) goto divr16u::@1
Simple Condition (bool~) utoa::$0 [128] if((byte) utoa::radix#0==(const byte) DECIMAL) goto utoa::@1
Simple Condition (bool~) utoa::$1 [134] if((byte) utoa::radix#0==(const byte) HEXADECIMAL) goto utoa::@2
Simple Condition (bool~) utoa::$2 [140] if((byte) utoa::radix#0==(const byte) OCTAL) goto utoa::@3
Simple Condition (bool~) utoa::$3 [146] if((byte) utoa::radix#0==(const byte) BINARY) goto utoa::@4
Simple Condition (bool~) utoa::$10 [173] if((byte) utoa::digit#1<(byte~) utoa::$9) goto utoa::@18
Simple Condition (bool~) utoa_append::$0 [194] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2
Simple Condition (bool~) ultoa::$0 [213] if((byte) ultoa::radix#0==(const byte) DECIMAL) goto ultoa::@1
Simple Condition (bool~) ultoa::$1 [219] if((byte) ultoa::radix#0==(const byte) HEXADECIMAL) goto ultoa::@2
Simple Condition (bool~) ultoa::$2 [225] if((byte) ultoa::radix#0==(const byte) OCTAL) goto ultoa::@3
Simple Condition (bool~) ultoa::$3 [231] if((byte) ultoa::radix#0==(const byte) BINARY) goto ultoa::@4
Simple Condition (bool~) ultoa::$10 [258] if((byte) ultoa::digit#1<(byte~) ultoa::$9) goto ultoa::@18
Simple Condition (bool~) ultoa_append::$0 [279] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2
Simple Condition (bool~) print_str::$0 [296] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2
Simple Condition (bool~) print_ln::$1 [309] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1
Simple Condition (bool~) main::$22 [426] if((word) main::i#11<(byte) SQRT_COUNT#0) goto main::@2
Simple Condition (bool~) main::$24 [431] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4
Simple Condition (bool~) main::$27 [481] if((word) main::j#2<(word) COUNT#0) goto main::@6
Simple Condition (bool~) main::$29 [490] if((byte) 0!=*((byte*) sieve#0 + (word) main::i#10)) goto main::@16
Simple Condition (bool~) main::$32 [494] if((word) main::i#3<(word) $514) goto main::@15
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting ! if()-condition to reversed if() [167] (bool~) utoa::$7 ← ! (bool~) utoa::$6
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting || if()-condition to two if()s [166] (bool~) utoa::$6 ← (byte) utoa::started#2 || (bool~) utoa::$5
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting ! if()-condition to reversed if() [252] (bool~) ultoa::$7 ← ! (bool~) ultoa::$6
Successful SSA optimization Pass2ConditionalAndOrRewriting
Rewriting || if()-condition to two if()s [251] (bool~) ultoa::$6 ← (byte) ultoa::started#2 || (bool~) ultoa::$5
Successful SSA optimization Pass2ConditionalAndOrRewriting
Warning! Adding boolean cast to non-boolean condition (byte) utoa::started#2
Warning! Adding boolean cast to non-boolean condition (byte) ultoa::started#2
Constant right-side identified [120] (word[]) RADIX_BINARY_VALUES#0 ← { (word) $8000, (word) $4000, (word) $2000, (word) $1000, (word) $800, (word) $400, (word) $200, (word) $100, (word) $80, (word) $40, (word) $20, (word) $10, (word) 8, (word) 4, (word) 2 }
Constant right-side identified [121] (word[]) RADIX_OCTAL_VALUES#0 ← { (word) $8000, (word) $1000, (word) $200, (word) $40, (word) 8 }
Constant right-side identified [122] (word[]) RADIX_DECIMAL_VALUES#0 ← { (word) $2710, (word) $3e8, (word) $64, (word) $a }
Constant right-side identified [123] (word[]) RADIX_HEXADECIMAL_VALUES#0 ← { (word) $1000, (word) $100, (word) $10 }
Constant right-side identified [205] (dword[]) RADIX_BINARY_VALUES_LONG#0 ← { (dword) $80000000, (dword) $40000000, (dword) $20000000, (dword) $10000000, (dword) $8000000, (dword) $4000000, (dword) $2000000, (dword) $1000000, (dword) $800000, (dword) $400000, (dword) $200000, (dword) $100000, (dword) $80000, (dword) $40000, (dword) $20000, (dword) $10000, (dword) $8000, (dword) $4000, (dword) $2000, (dword) $1000, (dword) $800, (dword) $400, (dword) $200, (dword) $100, (dword) $80, (dword) $40, (dword) $20, (dword) $10, (dword) 8, (dword) 4, (dword) 2 }
Constant right-side identified [206] (dword[]) RADIX_OCTAL_VALUES_LONG#0 ← { (dword) $40000000, (dword) $8000000, (dword) $1000000, (dword) $200000, (dword) $40000, (dword) $8000, (dword) $1000, (dword) $200, (dword) $40, (dword) 8 }
Constant right-side identified [207] (dword[]) RADIX_DECIMAL_VALUES_LONG#0 ← { (dword) $3b9aca00, (dword) $5f5e100, (dword) $989680, (dword) $f4240, (dword) $186a0, (dword) $2710, (dword) $3e8, (dword) $64, (dword) $a }
Constant right-side identified [208] (dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0 ← { (dword) $10000000, (dword) $1000000, (dword) $100000, (dword) $10000, (dword) $1000, (dword) $100, (dword) $10 }
Constant right-side identified [317] (byte[6]) decimal_digits#0 ← { fill( 6, 0) }
Constant right-side identified [332] (byte[$b]) decimal_digits_long#0 ← { fill( $b, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) D018#0 = (byte*) 53272
Constant (const dword*) CIA2_TIMER_AB#0 = (dword*) 56580
Constant (const byte*) CIA2_TIMER_A_CONTROL#0 = (byte*) 56590
Constant (const byte*) CIA2_TIMER_B_CONTROL#0 = (byte*) 56591
Constant (const byte) CIA_TIMER_CONTROL_STOP#0 = 0
Constant (const byte) CIA_TIMER_CONTROL_START#0 = 1
Constant (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 = 0
Constant (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0 = 0
Constant (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 = $40
Constant (const word) CLOCKS_PER_FRAME#0 = $4cc8
Constant (const byte) FRAMES_PER_SEC#0 = $3c
Constant (const dword) CLOCKS_PER_INIT#0 = $12
Constant (const word) rem16u#0 = 0
Constant (const word) divr16u::quotient#0 = 0
Constant (const byte) divr16u::i#0 = 0
Constant (const word) divr16u::rem#3 = 0
Constant (const byte[]) DIGITS#0 = $1
Constant (const word[]) RADIX_BINARY_VALUES#0 = { $8000, $4000, $2000, $1000, $800, $400, $200, $100, $80, $40, $20, $10, 8, 4, 2 }
Constant (const word[]) RADIX_OCTAL_VALUES#0 = { $8000, $1000, $200, $40, 8 }
Constant (const word[]) RADIX_DECIMAL_VALUES#0 = { $2710, $3e8, $64, $a }
Constant (const word[]) RADIX_HEXADECIMAL_VALUES#0 = { $1000, $100, $10 }
Constant (const byte) utoa::max_digits#0 = 0
Constant (const word*) utoa::digit_values#0 = (word*) 0
Constant (const byte) utoa::max_digits#1 = 5
Constant (const byte) utoa::max_digits#2 = 4
Constant (const byte) utoa::max_digits#3 = 6
Constant (const byte) utoa::max_digits#4 = $10
Constant (const byte) utoa::started#0 = 0
Constant (const byte) utoa::digit#0 = 0
Constant (const byte) utoa::started#1 = 1
Constant (const byte) utoa_append::digit#0 = 0
Constant (const dword[]) RADIX_BINARY_VALUES_LONG#0 = { $80000000, $40000000, $20000000, $10000000, $8000000, $4000000, $2000000, $1000000, $800000, $400000, $200000, $100000, $80000, $40000, $20000, $10000, $8000, $4000, $2000, $1000, $800, $400, $200, $100, $80, $40, $20, $10, 8, 4, 2 }
Constant (const dword[]) RADIX_OCTAL_VALUES_LONG#0 = { $40000000, $8000000, $1000000, $200000, $40000, $8000, $1000, $200, $40, 8 }
Constant (const dword[]) RADIX_DECIMAL_VALUES_LONG#0 = { $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a }
Constant (const dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0 = { $10000000, $1000000, $100000, $10000, $1000, $100, $10 }
Constant (const byte) ultoa::max_digits#0 = 0
Constant (const dword*) ultoa::digit_values#0 = (dword*) 0
Constant (const byte) ultoa::max_digits#1 = $a
Constant (const byte) ultoa::max_digits#2 = 8
Constant (const byte) ultoa::max_digits#3 = $b
Constant (const byte) ultoa::max_digits#4 = $20
Constant (const byte) ultoa::started#0 = 0
Constant (const byte) ultoa::digit#0 = 0
Constant (const byte) ultoa::started#1 = 1
Constant (const byte) ultoa_append::digit#0 = 0
Constant (const byte*) print_line_cursor#0 = (byte*) 1024
Constant (const byte[6]) decimal_digits#0 = { fill( 6, 0) }
Constant (const byte) utoa::radix#0 = DECIMAL
Constant (const byte[$b]) decimal_digits_long#0 = { fill( $b, 0) }
Constant (const byte) ultoa::radix#0 = DECIMAL
Constant (const byte) memset::c#0 = ' '
Constant (const word) memset::num#0 = $3e8
Constant (const byte*) SCREEN#0 = (byte*) 1024
Constant (const word) COUNT#0 = $4000
Constant (const byte) SQRT_COUNT#0 = $80
Constant (const byte*) sieve#0 = (byte*) 4096
Constant (const byte*) main::toD0181_gfx#0 = (byte*) 6144
Constant (const byte*) print_str::str#3 = main::str
Constant (const byte*) print_str::str#4 = main::str1
Constant (const byte) memset::c#1 = 0
Constant (const word) main::i#0 = 2
Constant (const byte*) print_str::str#5 = main::str2
Constant (const byte*) print_str::str#6 = main::str3
Constant (const word) main::i#1 = 2
Constant (const byte) print_char::ch#0 = ' '
Constant (const byte*) print_str::str#7 = main::str4
Successful SSA optimization Pass2ConstantIdentification
Constant (const word*) utoa::digit_values#1 = RADIX_DECIMAL_VALUES#0
Constant (const word*) utoa::digit_values#2 = RADIX_HEXADECIMAL_VALUES#0
Constant (const word*) utoa::digit_values#3 = RADIX_OCTAL_VALUES#0
Constant (const word*) utoa::digit_values#4 = RADIX_BINARY_VALUES#0
Constant (const dword*) ultoa::digit_values#1 = RADIX_DECIMAL_VALUES_LONG#0
Constant (const dword*) ultoa::digit_values#2 = RADIX_HEXADECIMAL_VALUES_LONG#0
Constant (const dword*) ultoa::digit_values#3 = RADIX_OCTAL_VALUES_LONG#0
Constant (const dword*) ultoa::digit_values#4 = RADIX_BINARY_VALUES_LONG#0
Constant (const byte*) utoa::buffer#5 = decimal_digits#0
Constant (const byte*) print_str::str#1 = decimal_digits#0
Constant (const byte*) ultoa::buffer#5 = decimal_digits_long#0
Constant (const byte*) print_str::str#2 = decimal_digits_long#0
Constant (const byte*) main::toD0181_screen#0 = SCREEN#0
Constant (const word) print_word_decimal::w#0 = COUNT#0
Constant (const word) memset::num#1 = COUNT#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (void*)print_line_cursor#0 in [353] (void*) memset::str#0 ← (void*)(const byte*) print_line_cursor#0
Constant value identified (word)main::toD0181_screen#0 in [374] (word~) main::toD0181_$0#0 ← (word)(const byte*) main::toD0181_screen#0
Constant value identified (word)main::toD0181_gfx#0 in [378] (word~) main::toD0181_$4#0 ← (word)(const byte*) main::toD0181_gfx#0
Constant value identified (void*)sieve#0 in [413] (void*) memset::str#1 ← (void*)(const byte*) sieve#0
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [128] if((const byte) utoa::radix#0==(const byte) DECIMAL) goto utoa::@1
if() condition always false - eliminating [134] if((const byte) utoa::radix#0==(const byte) HEXADECIMAL) goto utoa::@2
if() condition always false - eliminating [140] if((const byte) utoa::radix#0==(const byte) OCTAL) goto utoa::@3
if() condition always false - eliminating [146] if((const byte) utoa::radix#0==(const byte) BINARY) goto utoa::@4
if() condition always true - replacing block destination [213] if((const byte) ultoa::radix#0==(const byte) DECIMAL) goto ultoa::@1
if() condition always false - eliminating [219] if((const byte) ultoa::radix#0==(const byte) HEXADECIMAL) goto ultoa::@2
if() condition always false - eliminating [225] if((const byte) ultoa::radix#0==(const byte) OCTAL) goto ultoa::@3
if() condition always false - eliminating [231] if((const byte) ultoa::radix#0==(const byte) BINARY) goto ultoa::@4
if() condition always true - replacing block destination [510] if(true) goto main::@20
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [76] divr16u::i#1 ← ++ divr16u::i#2 to ++
Resolved ranged comparison value [78] if(divr16u::i#1!=rangelast(0,$f)) goto divr16u::@1 to (number) $10
De-inlining pointer[w] to *(pointer+w)   [490] if((byte) 0!=*((const byte*) sieve#0 + (word) main::i#10)) goto main::@16
Successful SSA optimization Pass2DeInlineWordDerefIdx
Simplifying expression containing zero CIA_TIMER_CONTROL_CONTINUOUS#0 in [38] (byte~) clock_start::$0 ← (const byte) CIA_TIMER_CONTROL_STOP#0 | (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Simplifying expression containing zero clock_start::$0 in [39] (byte~) clock_start::$1 ← (byte~) clock_start::$0 | (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
Simplifying expression containing zero CIA_TIMER_CONTROL_START#0 in [45] (byte~) clock_start::$4 ← (const byte) CIA_TIMER_CONTROL_START#0 | (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Simplifying expression containing zero clock_start::$6 in [49] (byte~) clock_start::$7 ← (byte~) clock_start::$6 | (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable (void*) memset::return#2 and assignment [156] (void*) memset::return#2 ← (void*) memset::str#3
Eliminating unused variable (void*) memset::return#3 and assignment [176] (void*) memset::return#3 ← (void*) memset::str#3
Eliminating unused constant (const byte) BINARY
Eliminating unused constant (const byte) OCTAL
Eliminating unused constant (const byte) HEXADECIMAL
Eliminating unused constant (const byte) utoa::max_digits#0
Eliminating unused constant (const word*) utoa::digit_values#0
Eliminating unused constant (const byte) utoa::radix#0
Eliminating unused constant (const byte) ultoa::max_digits#0
Eliminating unused constant (const dword*) ultoa::digit_values#0
Eliminating unused constant (const byte) ultoa::radix#0
Eliminating unused constant (const byte) CIA_TIMER_CONTROL_STOP#0
Eliminating unused constant (const byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES#0
Eliminating unused constant (const word) rem16u#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte) DECIMAL
Successful SSA optimization PassNEliminateUnusedVars
Eliminating variable (byte*) utoa::buffer#0 from unused block utoa::@12
Eliminating variable (byte*) utoa::buffer#1 from unused block utoa::@12
Eliminating variable (byte*) utoa::buffer#2 from unused block utoa::@12
Eliminating variable (byte*) ultoa::buffer#0 from unused block ultoa::@12
Eliminating variable (byte*) ultoa::buffer#1 from unused block ultoa::@12
Eliminating variable (byte*) ultoa::buffer#2 from unused block ultoa::@12
Removing unused block utoa::@9
Removing PHI-reference to removed block (utoa::@2) in block utoa::@8
Removing PHI-reference to removed block (utoa::@2) in block utoa::@8
Removing unused block utoa::@2
Removing unused block utoa::@10
Removing PHI-reference to removed block (utoa::@3) in block utoa::@8
Removing PHI-reference to removed block (utoa::@3) in block utoa::@8
Removing unused block utoa::@3
Removing unused block utoa::@11
Removing PHI-reference to removed block (utoa::@4) in block utoa::@8
Removing PHI-reference to removed block (utoa::@4) in block utoa::@8
Removing unused block utoa::@4
Removing unused block utoa::@12
Removing unused block ultoa::@9
Removing PHI-reference to removed block (ultoa::@2) in block ultoa::@8
Removing PHI-reference to removed block (ultoa::@2) in block ultoa::@8
Removing unused block ultoa::@2
Removing unused block ultoa::@10
Removing PHI-reference to removed block (ultoa::@3) in block ultoa::@8
Removing PHI-reference to removed block (ultoa::@3) in block ultoa::@8
Removing unused block ultoa::@3
Removing unused block ultoa::@11
Removing PHI-reference to removed block (ultoa::@4) in block ultoa::@8
Removing PHI-reference to removed block (ultoa::@4) in block ultoa::@8
Removing unused block ultoa::@4
Removing unused block ultoa::@12
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) $10 in if((byte) divr16u::i#1!=(number) $10) goto divr16u::@1
Adding number conversion cast (unumber) 0 in (bool~) utoa::$12 ← (number) 0 != (byte) utoa::started#2
Adding number conversion cast (unumber) 0 in (bool~) ultoa::$12 ← (number) 0 != (byte) ultoa::started#2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $10
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte~) clock_start::$1 = (byte~) clock_start::$0 (byte~) clock_start::$2 
Alias (byte~) clock_start::$6 = (byte~) clock_start::$4 (byte~) clock_start::$7 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word*) utoa::digit_values#7 (const word*) utoa::digit_values#1
Identical Phi Values (byte) utoa::max_digits#8 (const byte) utoa::max_digits#1
Identical Phi Values (dword*) ultoa::digit_values#7 (const dword*) ultoa::digit_values#1
Identical Phi Values (byte) ultoa::max_digits#8 (const byte) ultoa::max_digits#1
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) utoa::$12 [65] if((byte) 0!=(byte) utoa::started#2) goto utoa::@20
Simple Condition (bool~) ultoa::$12 [94] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@20
Simple Condition (bool~) utoa::$5 [206] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@20
Simple Condition (bool~) ultoa::$5 [207] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@20
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [10] (dword) CLOCKS_PER_SEC#0 ← (const word) CLOCKS_PER_FRAME#0 * (const byte) FRAMES_PER_SEC#0
Constant right-side identified [68] (byte~) utoa::$9 ← (const byte) utoa::max_digits#1 - (byte) 1
Constant right-side identified [97] (byte~) ultoa::$9 ← (const byte) ultoa::max_digits#1 - (byte) 1
Constant right-side identified [162] (byte*) main::sieve_i#0 ← (const byte*) sieve#0 + (const word) main::i#0
Constant right-side identified [203] (byte*~) main::$35 ← (const byte*) SCREEN#0 + (word) $3e7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const dword) CLOCKS_PER_SEC#0 = CLOCKS_PER_FRAME#0*FRAMES_PER_SEC#0
Constant (const byte) clock_start::$1 = CIA_TIMER_CONTROL_CONTINUOUS#0
Constant (const byte) clock_start::$6 = CIA_TIMER_CONTROL_START#0
Constant (const byte) utoa::$9 = utoa::max_digits#1-1
Constant (const byte) ultoa::$9 = ultoa::max_digits#1-1
Constant (const void*) memset::str#0 = (void*)print_line_cursor#0
Constant (const word) main::toD0181_$0#0 = (word)main::toD0181_screen#0
Constant (const word) main::toD0181_$4#0 = (word)main::toD0181_gfx#0
Constant (const void*) memset::str#1 = (void*)sieve#0
Constant (const byte*) main::sieve_i#0 = sieve#0+main::i#0
Constant (const byte*) main::$35 = SCREEN#0+$3e7
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 in [17] (byte~) clock_start::$3 ← (const byte) clock_start::$1 | (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) utoa::max_digits#2
Eliminating unused constant (const byte) utoa::max_digits#3
Eliminating unused constant (const byte) utoa::max_digits#4
Eliminating unused constant (const word*) utoa::digit_values#2
Eliminating unused constant (const word*) utoa::digit_values#3
Eliminating unused constant (const word*) utoa::digit_values#4
Eliminating unused constant (const byte) ultoa::max_digits#2
Eliminating unused constant (const byte) ultoa::max_digits#3
Eliminating unused constant (const byte) ultoa::max_digits#4
Eliminating unused constant (const dword*) ultoa::digit_values#2
Eliminating unused constant (const dword*) ultoa::digit_values#3
Eliminating unused constant (const dword*) ultoa::digit_values#4
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const word[]) RADIX_BINARY_VALUES#0
Eliminating unused constant (const word[]) RADIX_OCTAL_VALUES#0
Eliminating unused constant (const word[]) RADIX_HEXADECIMAL_VALUES#0
Eliminating unused constant (const dword[]) RADIX_BINARY_VALUES_LONG#0
Eliminating unused constant (const dword[]) RADIX_OCTAL_VALUES_LONG#0
Eliminating unused constant (const dword[]) RADIX_HEXADECIMAL_VALUES_LONG#0
Successful SSA optimization PassNEliminateUnusedVars
Constant right-side identified [16] (byte~) clock_start::$5 ← (const byte) clock_start::$6 | (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant right-side identified [127] (word~) main::toD0181_$1#0 ← (const word) main::toD0181_$0#0 & (word) $3fff
Constant right-side identified [130] (byte~) main::toD0181_$5#0 ← > (const word) main::toD0181_$4#0
Constant right-side identified [150] (dword~) main::$12 ← (const dword) CLOCKS_PER_SEC#0 / (byte) $64
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) clock_start::$3 = CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant (const byte) clock_start::$5 = clock_start::$6|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant (const word) main::toD0181_$1#0 = main::toD0181_$0#0&$3fff
Constant (const byte) main::toD0181_$5#0 = >main::toD0181_$4#0
Constant (const dword) main::$12 = CLOCKS_PER_SEC#0/$64
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)main::$12 in [151] (word) div32u16u::divisor#0 ← (word)(const dword) main::$12
Successful SSA optimization Pass2ConstantValues
Constant right-side identified [125] (word~) main::toD0181_$2#0 ← (const word) main::toD0181_$1#0 * (byte) 4
Constant right-side identified [127] (byte~) main::toD0181_$6#0 ← (const byte) main::toD0181_$5#0 / (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::toD0181_$2#0 = main::toD0181_$1#0*4
Constant (const byte) main::toD0181_$6#0 = main::toD0181_$5#0/4
Constant (const word) div32u16u::divisor#0 = (word)main::$12
Successful SSA optimization Pass2ConstantIdentification
Constant (const word) divr16u::divisor#0 = div32u16u::divisor#0
Constant (const word) divr16u::divisor#1 = div32u16u::divisor#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [123] (byte~) main::toD0181_$3#0 ← > (const word) main::toD0181_$2#0
Constant right-side identified [124] (byte~) main::toD0181_$7#0 ← (const byte) main::toD0181_$6#0 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::toD0181_$3#0 = >main::toD0181_$2#0
Constant (const byte) main::toD0181_$7#0 = main::toD0181_$6#0&$f
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [123] (byte) main::toD0181_return#0 ← (const byte) main::toD0181_$3#0 | (const byte) main::toD0181_$7#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::toD0181_return#0 = main::toD0181_$3#0|main::toD0181_$7#0
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [2] (byte*~) memset::$2 ← (byte*)(void*) memset::str#3 keeping memset::str#3
Inlining Noop Cast [4] (byte*) memset::dst#0 ← (byte*)(void*) memset::str#3 keeping memset::str#3
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift [49] (byte~) utoa::$11 ← (byte) utoa::digit#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [74] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 * (const byte) SIZEOF_DWORD
Rewriting multiplication to use shift [153] (word) main::j#0 ← (word) main::i#11 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) memset::c#0
Inlining constant with var siblings (const word) memset::num#0
Inlining constant with var siblings (const byte) memset::c#1
Inlining constant with var siblings (const word) memset::num#1
Inlining constant with var siblings (const void*) memset::str#0
Inlining constant with var siblings (const void*) memset::str#1
Inlining constant with var siblings (const word) divr16u::quotient#0
Inlining constant with var siblings (const byte) divr16u::i#0
Inlining constant with var siblings (const word) divr16u::rem#3
Inlining constant with var siblings (const word) divr16u::divisor#0
Inlining constant with var siblings (const word) divr16u::divisor#1
Inlining constant with var siblings (const byte) utoa::started#0
Inlining constant with var siblings (const byte) utoa::digit#0
Inlining constant with var siblings (const byte) utoa::started#1
Inlining constant with var siblings (const byte*) utoa::buffer#5
Inlining constant with var siblings (const byte) utoa_append::digit#0
Inlining constant with var siblings (const byte) ultoa::started#0
Inlining constant with var siblings (const byte) ultoa::digit#0
Inlining constant with var siblings (const byte) ultoa::started#1
Inlining constant with var siblings (const byte*) ultoa::buffer#5
Inlining constant with var siblings (const byte) ultoa_append::digit#0
Inlining constant with var siblings (const byte*) print_str::str#3
Inlining constant with var siblings (const byte*) print_str::str#4
Inlining constant with var siblings (const byte*) print_str::str#5
Inlining constant with var siblings (const byte*) print_str::str#6
Inlining constant with var siblings (const byte*) print_str::str#7
Inlining constant with var siblings (const byte*) print_str::str#1
Inlining constant with var siblings (const byte*) print_str::str#2
Inlining constant with var siblings (const word) print_word_decimal::w#0
Inlining constant with var siblings (const word) main::i#0
Inlining constant with var siblings (const word) main::i#1
Inlining constant with var siblings (const byte*) main::sieve_i#0
Inlining constant with var siblings (const byte*) print_line_cursor#0
Constant inlined utoa::digit_values#1 = (const word[]) RADIX_DECIMAL_VALUES#0
Constant inlined divr16u::rem#3 = (byte) 0
Constant inlined main::$12 = (const dword) CLOCKS_PER_SEC#0/(byte) $64
Constant inlined memset::num#1 = (const word) COUNT#0
Constant inlined memset::num#0 = (word) $3e8
Constant inlined clock_start::$5 = (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant inlined clock_start::$6 = (const byte) CIA_TIMER_CONTROL_START#0
Constant inlined $1 = (const byte[]) DIGITS#0
Constant inlined clock_start::$3 = (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
Constant inlined utoa::$9 = (const byte) utoa::max_digits#1-(byte) 1
Constant inlined print_line_cursor#0 = (byte*) 1024
Constant inlined main::toD0181_$1#0 = (word)(const byte*) SCREEN#0&(word) $3fff
Constant inlined ultoa::started#1 = (byte) 1
Constant inlined main::toD0181_$7#0 = >(word)(const byte*) main::toD0181_gfx#0/(byte) 4&(byte) $f
Constant inlined utoa::buffer#5 = (const byte[6]) decimal_digits#0
Constant inlined main::toD0181_$3#0 = >(word)(const byte*) SCREEN#0&(word) $3fff*(byte) 4
Constant inlined ultoa::digit#0 = (byte) 0
Constant inlined main::toD0181_$5#0 = >(word)(const byte*) main::toD0181_gfx#0
Constant inlined print_str::str#4 = (const string) main::str1
Constant inlined print_str::str#3 = (const string) main::str
Constant inlined print_str::str#2 = (const byte[$b]) decimal_digits_long#0
Constant inlined print_str::str#1 = (const byte[6]) decimal_digits#0
Constant inlined memset::c#0 = (byte) ' '
Constant inlined memset::c#1 = (byte) 0
Constant inlined print_str::str#7 = (const string) main::str4
Constant inlined print_str::str#6 = (const string) main::str3
Constant inlined print_str::str#5 = (const string) main::str2
Constant inlined utoa_append::digit#0 = (byte) 0
Constant inlined main::toD0181_screen#0 = (const byte*) SCREEN#0
Constant inlined divr16u::i#0 = (byte) 0
Constant inlined main::$35 = (const byte*) SCREEN#0+(word) $3e7
Constant inlined ultoa::$9 = (const byte) ultoa::max_digits#1-(byte) 1
Constant inlined divr16u::quotient#0 = (byte) 0
Constant inlined ultoa::buffer#5 = (const byte[$b]) decimal_digits_long#0
Constant inlined ultoa::started#0 = (byte) 0
Constant inlined utoa::digit#0 = (byte) 0
Constant inlined main::i#0 = (byte) 2
Constant inlined main::i#1 = (byte) 2
Constant inlined divr16u::divisor#1 = (const word) div32u16u::divisor#0
Constant inlined divr16u::divisor#0 = (const word) div32u16u::divisor#0
Constant inlined print_word_decimal::w#0 = (const word) COUNT#0
Constant inlined memset::str#1 = (void*)(const byte*) sieve#0
Constant inlined memset::str#0 = (void*)(byte*) 1024
Constant inlined utoa::started#1 = (byte) 1
Constant inlined main::toD0181_$0#0 = (word)(const byte*) SCREEN#0
Constant inlined utoa::started#0 = (byte) 0
Constant inlined clock_start::$1 = (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
Constant inlined main::toD0181_$6#0 = >(word)(const byte*) main::toD0181_gfx#0/(byte) 4
Constant inlined main::toD0181_$2#0 = (word)(const byte*) SCREEN#0&(word) $3fff*(byte) 4
Constant inlined main::toD0181_$4#0 = (word)(const byte*) main::toD0181_gfx#0
Constant inlined ultoa_append::digit#0 = (byte) 0
Constant inlined ultoa::digit_values#1 = (const dword[]) RADIX_DECIMAL_VALUES_LONG#0
Constant inlined main::sieve_i#0 = (const byte*) sieve#0+(byte) 2
Successful SSA optimization Pass2ConstantInlining
Identical Phi Values (word) divr16u::divisor#6 (const word) div32u16u::divisor#0
Successful SSA optimization Pass2IdenticalPhiElimination
Eliminating unused constant (const byte) SIZEOF_WORD
Eliminating unused constant (const byte) SIZEOF_DWORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting memset::@6(between memset::@4 and memset::@4)
Added new block during phi lifting divr16u::@8(between divr16u::@3 and divr16u::@1)
Added new block during phi lifting divr16u::@9(between divr16u::@1 and divr16u::@2)
Added new block during phi lifting divr16u::@10(between divr16u::@2 and divr16u::@3)
Added new block during phi lifting utoa::@24(between utoa::@19 and utoa::@18)
Added new block during phi lifting utoa::@25(between utoa::@23 and utoa::@19)
Added new block during phi lifting ultoa::@24(between ultoa::@19 and ultoa::@18)
Added new block during phi lifting ultoa::@25(between ultoa::@23 and ultoa::@19)
Added new block during phi lifting print_ln::@3(between print_ln::@1 and print_ln::@1)
Added new block during phi lifting main::@44(between main::@16 and main::@15)
Added new block during phi lifting main::@45(between main::@15 and main::@16)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @8
Adding NOP phi() at start of @12
Adding NOP phi() at start of @22
Adding NOP phi() at start of @24
Adding NOP phi() at start of @26
Adding NOP phi() at start of @36
Adding NOP phi() at start of @39
Adding NOP phi() at start of @49
Adding NOP phi() at start of @50
Adding NOP phi() at start of @51
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::toD0181_@return
Adding NOP phi() at start of main::@26
Adding NOP phi() at start of main::@27
Adding NOP phi() at start of main::@31
Adding NOP phi() at start of main::@32
Adding NOP phi() at start of main::@33
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@41
Adding NOP phi() at start of main::@43
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of print_word_decimal::@2
Adding NOP phi() at start of utoa
Adding NOP phi() at start of utoa::@1
Adding NOP phi() at start of print_ln::@2
Adding NOP phi() at start of print_dword_decimal::@2
Adding NOP phi() at start of ultoa
Adding NOP phi() at start of ultoa::@1
Adding NOP phi() at start of memset::@1
Adding NOP phi() at start of print_cls
Adding NOP phi() at start of print_cls::@1
CALL GRAPH
Calls in [] to main:11 
Calls in [main] to print_cls:18 print_str:20 print_ln:22 print_str:24 print_word_decimal:26 print_ln:28 memset:30 clock_start:32 clock:37 div32u16u:42 print_str:47 print_word_decimal:51 print_str:53 print_dword_decimal:55 print_ln:57 print_word_decimal:65 print_char:67 print_str:73 
Calls in [print_word_decimal] to utoa:112 print_str:114 
Calls in [utoa] to utoa_append:143 
Calls in [print_dword_decimal] to ultoa:167 print_str:169 
Calls in [ultoa] to ultoa_append:198 
Calls in [div32u16u] to divr16u:215 divr16u:222 
Calls in [print_cls] to memset:277 

Created 46 initial phi equivalence classes
Not coalescing [23] print_char_cursor#89 ← print_line_cursor#1
Coalesced [25] print_char_cursor#97 ← print_char_cursor#2
Coalesced [27] print_line_cursor#57 ← print_line_cursor#1
Not coalescing [46] print_char_cursor#90 ← print_line_cursor#1
Coalesced [49] print_word_decimal::w#5 ← print_word_decimal::w#1
Coalesced (already) [50] print_char_cursor#98 ← print_char_cursor#2
Coalesced [52] print_char_cursor#91 ← print_char_cursor#2
Coalesced (already) [56] print_line_cursor#58 ← print_line_cursor#1
Coalesced [58] print_char_cursor#100 ← print_line_cursor#1
Coalesced [63] print_word_decimal::w#4 ← print_word_decimal::w#2
Not coalescing [64] print_char_cursor#96 ← print_char_cursor#62
Coalesced [68] print_char_cursor#102 ← print_char_cursor#10
Coalesced [72] print_char_cursor#88 ← print_char_cursor#63
Coalesced [77] main::i#16 ← main::i#3
Not coalescing [78] print_char_cursor#99 ← print_char_cursor#63
Not coalescing [79] print_char_cursor#101 ← print_char_cursor#62
Coalesced [83] main::j#4 ← main::j#0
Coalesced [84] main::s#4 ← main::s#0
Coalesced [89] main::i#15 ← main::i#2
Coalesced [90] main::sieve_i#8 ← main::sieve_i#1
Coalesced [94] main::j#5 ← main::j#1
Coalesced [95] main::s#5 ← main::s#1
Coalesced [97] print_str::str#11 ← print_str::str#10
Coalesced (already) [98] print_char_cursor#94 ← print_char_cursor#66
Coalesced [105] print_str::str#12 ← print_str::str#0
Coalesced [106] print_char_cursor#95 ← print_char_cursor#1
Coalesced (already) [113] print_char_cursor#93 ← print_char_cursor#58
Coalesced [119] utoa::value#16 ← utoa::value#1
Coalesced [125] utoa::value#17 ← utoa::value#2
Coalesced [126] utoa::started#5 ← utoa::started#2
Coalesced [127] utoa::buffer#22 ← utoa::buffer#11
Coalesced [136] utoa::digit#6 ← utoa::digit#1
Coalesced (already) [137] utoa::value#15 ← utoa::value#4
Coalesced (already) [138] utoa::started#4 ← utoa::started#3
Coalesced (already) [139] utoa::buffer#21 ← utoa::buffer#12
Coalesced [147] utoa::value#18 ← utoa::value#0
Coalesced [148] utoa::buffer#23 ← utoa::buffer#3
Coalesced [149] utoa_append::value#6 ← utoa_append::value#0
Coalesced [156] utoa_append::value#7 ← utoa_append::value#1
Coalesced [157] utoa_append::digit#5 ← utoa_append::digit#1
Coalesced [159] print_line_cursor#59 ← print_line_cursor#21
Coalesced (already) [165] print_line_cursor#60 ← print_line_cursor#1
Coalesced (already) [168] print_char_cursor#92 ← print_char_cursor#2
Coalesced [174] ultoa::value#16 ← ultoa::value#1
Coalesced [180] ultoa::value#17 ← ultoa::value#2
Coalesced [181] ultoa::started#5 ← ultoa::started#2
Coalesced [182] ultoa::buffer#22 ← ultoa::buffer#11
Coalesced [191] ultoa::digit#6 ← ultoa::digit#1
Coalesced (already) [192] ultoa::value#15 ← ultoa::value#4
Coalesced (already) [193] ultoa::started#4 ← ultoa::started#3
Coalesced (already) [194] ultoa::buffer#21 ← ultoa::buffer#12
Coalesced [202] ultoa::value#18 ← ultoa::value#0
Coalesced [203] ultoa::buffer#23 ← ultoa::buffer#3
Coalesced [204] ultoa_append::value#6 ← ultoa_append::value#0
Coalesced [211] ultoa_append::value#7 ← ultoa_append::value#1
Coalesced [212] ultoa_append::digit#5 ← ultoa_append::digit#1
Coalesced [214] divr16u::dividend#9 ← divr16u::dividend#1
Coalesced [220] divr16u::rem#12 ← divr16u::rem#4
Coalesced [221] divr16u::dividend#10 ← divr16u::dividend#2
Coalesced [228] divr16u::rem#13 ← divr16u::rem#10
Coalesced [229] divr16u::dividend#11 ← divr16u::dividend#5
Coalesced [236] divr16u::rem#16 ← divr16u::rem#1
Coalesced [243] divr16u::rem#18 ← divr16u::rem#2
Coalesced [244] divr16u::return#8 ← divr16u::quotient#2
Coalesced [250] divr16u::rem#14 ← divr16u::rem#11
Coalesced [251] divr16u::dividend#12 ← divr16u::dividend#0
Coalesced [252] divr16u::quotient#9 ← divr16u::return#0
Coalesced [253] divr16u::i#7 ← divr16u::i#1
Coalesced [254] divr16u::rem#17 ← divr16u::rem#6
Coalesced [255] divr16u::return#7 ← divr16u::quotient#1
Coalesced [256] divr16u::rem#15 ← divr16u::rem#0
Coalesced [275] memset::dst#4 ← memset::dst#1
Coalesced down to 29 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @8
Culled Empty Block (label) @12
Culled Empty Block (label) @22
Culled Empty Block (label) @24
Culled Empty Block (label) @26
Culled Empty Block (label) @36
Culled Empty Block (label) @39
Culled Empty Block (label) @49
Culled Empty Block (label) @51
Culled Empty Block (label) main::toD0181_@return
Culled Empty Block (label) main::@33
Culled Empty Block (label) main::@40
Culled Empty Block (label) main::@42
Culled Empty Block (label) main::@43
Culled Empty Block (label) main::@19
Culled Empty Block (label) print_word_decimal::@2
Culled Empty Block (label) utoa::@1
Culled Empty Block (label) utoa::@8
Culled Empty Block (label) utoa::@25
Culled Empty Block (label) utoa::@24
Culled Empty Block (label) print_ln::@2
Culled Empty Block (label) print_ln::@3
Culled Empty Block (label) print_dword_decimal::@2
Culled Empty Block (label) ultoa::@1
Culled Empty Block (label) ultoa::@8
Culled Empty Block (label) ultoa::@25
Culled Empty Block (label) ultoa::@24
Culled Empty Block (label) divr16u::@8
Culled Empty Block (label) divr16u::@10
Culled Empty Block (label) divr16u::@9
Culled Empty Block (label) memset::@1
Culled Empty Block (label) memset::@6
Culled Empty Block (label) print_cls::@1
Renumbering block @50 to @1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@4 to memset::@2
Renumbering block div32u16u::@2 to div32u16u::@1
Renumbering block div32u16u::@3 to div32u16u::@2
Renumbering block utoa::@18 to utoa::@1
Renumbering block utoa::@19 to utoa::@2
Renumbering block utoa::@20 to utoa::@3
Renumbering block utoa::@21 to utoa::@4
Renumbering block utoa::@22 to utoa::@5
Renumbering block utoa::@23 to utoa::@6
Renumbering block ultoa::@18 to ultoa::@1
Renumbering block ultoa::@19 to ultoa::@2
Renumbering block ultoa::@20 to ultoa::@3
Renumbering block ultoa::@21 to ultoa::@4
Renumbering block ultoa::@22 to ultoa::@5
Renumbering block ultoa::@23 to ultoa::@6
Renumbering block main::@13 to main::@7
Renumbering block main::@15 to main::@8
Renumbering block main::@16 to main::@9
Renumbering block main::@17 to main::@10
Renumbering block main::@18 to main::@11
Renumbering block main::@20 to main::@12
Renumbering block main::@25 to main::@13
Renumbering block main::@26 to main::@14
Renumbering block main::@27 to main::@15
Renumbering block main::@28 to main::@16
Renumbering block main::@29 to main::@17
Renumbering block main::@30 to main::@18
Renumbering block main::@31 to main::@19
Renumbering block main::@32 to main::@20
Renumbering block main::@34 to main::@21
Renumbering block main::@35 to main::@22
Renumbering block main::@36 to main::@23
Renumbering block main::@37 to main::@24
Renumbering block main::@38 to main::@25
Renumbering block main::@39 to main::@26
Renumbering block main::@41 to main::@27
Renumbering block main::@44 to main::@28
Renumbering block main::@45 to main::@29
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::toD0181
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@17
Adding NOP phi() at start of main::@18
Adding NOP phi() at start of main::@19
Adding NOP phi() at start of main::@20
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@24
Adding NOP phi() at start of main::@26
Adding NOP phi() at start of main::@27
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of print_word_decimal::@1
Adding NOP phi() at start of utoa
Adding NOP phi() at start of utoa_append
Adding NOP phi() at start of print_dword_decimal::@1
Adding NOP phi() at start of ultoa
Adding NOP phi() at start of ultoa_append
Adding NOP phi() at start of print_cls

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  to:main::toD0181
main::toD0181: scope:[main]  from main
  [5] phi()
  to:main::@13
main::@13: scope:[main]  from main::toD0181
  [6] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0
  [7] call print_cls 
  to:main::@14
main::@14: scope:[main]  from main::@13
  [8] phi()
  [9] call print_str 
  to:main::@15
main::@15: scope:[main]  from main::@14
  [10] phi()
  [11] call print_ln 
  to:main::@16
main::@16: scope:[main]  from main::@15
  [12] (byte*~) print_char_cursor#89 ← (byte*) print_line_cursor#1
  [13] call print_str 
  to:main::@17
main::@17: scope:[main]  from main::@16
  [14] phi()
  [15] call print_word_decimal 
  to:main::@18
main::@18: scope:[main]  from main::@17
  [16] phi()
  [17] call print_ln 
  to:main::@19
main::@19: scope:[main]  from main::@18
  [18] phi()
  [19] call memset 
  to:main::@20
main::@20: scope:[main]  from main::@19
  [20] phi()
  [21] call clock_start 
  to:main::@1
main::@1: scope:[main]  from main::@20 main::@4
  [22] (byte*) main::sieve_i#2 ← phi( main::@20/(const byte*) sieve#0+(byte) 2 main::@4/(byte*) main::sieve_i#1 )
  [22] (word) main::i#11 ← phi( main::@20/(byte) 2 main::@4/(word) main::i#2 )
  [23] if((word) main::i#11<(const byte) SQRT_COUNT#0) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [24] phi()
  [25] call clock 
  [26] (dword) clock::return#2 ← (dword) clock::return#0
  to:main::@21
main::@21: scope:[main]  from main::@3
  [27] (dword~) main::$10 ← (dword) clock::return#2
  [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT#0
  [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
  [30] call div32u16u 
  [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0
  to:main::@22
main::@22: scope:[main]  from main::@21
  [32] (dword~) main::$14 ← (dword) div32u16u::return#2
  [33] (word) main::sec100s#0 ← (word)(dword~) main::$14
  [34] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1
  [35] call print_str 
  to:main::@23
main::@23: scope:[main]  from main::@22
  [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0
  [37] call print_word_decimal 
  to:main::@24
main::@24: scope:[main]  from main::@23
  [38] phi()
  [39] call print_str 
  to:main::@25
main::@25: scope:[main]  from main::@24
  [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0
  [41] call print_dword_decimal 
  to:main::@26
main::@26: scope:[main]  from main::@25
  [42] phi()
  [43] call print_ln 
  to:main::@8
main::@8: scope:[main]  from main::@26 main::@28
  [44] (byte*) print_char_cursor#62 ← phi( main::@28/(byte*~) print_char_cursor#99 main::@26/(byte*) print_line_cursor#1 )
  [44] (word) main::i#10 ← phi( main::@28/(word) main::i#3 main::@26/(byte) 2 )
  [45] (byte*~) main::$38 ← (const byte*) sieve#0 + (word) main::i#10
  [46] if((byte) 0!=*((byte*~) main::$38)) goto main::@29
  to:main::@10
main::@10: scope:[main]  from main::@8
  [47] (word) print_word_decimal::w#2 ← (word) main::i#10
  [48] (byte*~) print_char_cursor#96 ← (byte*) print_char_cursor#62
  [49] call print_word_decimal 
  to:main::@27
main::@27: scope:[main]  from main::@10
  [50] phi()
  [51] call print_char 
  to:main::@9
main::@9: scope:[main]  from main::@27 main::@29
  [52] (byte*) print_char_cursor#63 ← phi( main::@29/(byte*~) print_char_cursor#101 main::@27/(byte*) print_char_cursor#10 )
  [53] (word) main::i#3 ← ++ (word) main::i#10
  [54] if((word) main::i#3<(word) $514) goto main::@28
  to:main::@11
main::@11: scope:[main]  from main::@9
  [55] phi()
  [56] call print_str 
  to:main::@12
main::@12: scope:[main]  from main::@11 main::@12
  [57] *((const byte*) SCREEN#0+(word) $3e7) ← ++ *((const byte*) SCREEN#0+(word) $3e7)
  to:main::@12
main::@28: scope:[main]  from main::@9
  [58] (byte*~) print_char_cursor#99 ← (byte*) print_char_cursor#63
  to:main::@8
main::@29: scope:[main]  from main::@8
  [59] (byte*~) print_char_cursor#101 ← (byte*) print_char_cursor#62
  to:main::@9
main::@2: scope:[main]  from main::@1
  [60] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4
  to:main::@7
main::@7: scope:[main]  from main::@2
  [61] (word) main::j#0 ← (word) main::i#11 << (byte) 1
  [62] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0
  to:main::@5
main::@5: scope:[main]  from main::@6 main::@7
  [63] (byte*) main::s#2 ← phi( main::@7/(byte*) main::s#0 main::@6/(byte*) main::s#1 )
  [63] (word) main::j#2 ← phi( main::@7/(word) main::j#0 main::@6/(word) main::j#1 )
  [64] if((word) main::j#2<(const word) COUNT#0) goto main::@6
  to:main::@4
main::@4: scope:[main]  from main::@2 main::@5
  [65] (word) main::i#2 ← ++ (word) main::i#11
  [66] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2
  to:main::@1
main::@6: scope:[main]  from main::@5
  [67] *((byte*) main::s#2) ← (byte) 1
  [68] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#11
  [69] (word) main::j#1 ← (word) main::j#2 + (word) main::i#11
  to:main::@5
print_str: scope:[print_str]  from main::@11 main::@14 main::@16 main::@22 main::@24 print_dword_decimal::@1 print_word_decimal::@1
  [70] (byte*) print_char_cursor#66 ← phi( main::@11/(byte*) print_char_cursor#63 main::@14/(byte*) 1024 main::@16/(byte*~) print_char_cursor#89 main::@22/(byte*~) print_char_cursor#90 main::@24/(byte*) print_char_cursor#2 print_dword_decimal::@1/(byte*) print_char_cursor#2 print_word_decimal::@1/(byte*) print_char_cursor#58 )
  [70] (byte*) print_str::str#10 ← phi( main::@11/(const string) main::str4 main::@14/(const string) main::str main::@16/(const string) main::str1 main::@22/(const string) main::str2 main::@24/(const string) main::str3 print_dword_decimal::@1/(const byte[$b]) decimal_digits_long#0 print_word_decimal::@1/(const byte[6]) decimal_digits#0 )
  to:print_str::@1
print_str::@1: scope:[print_str]  from print_str print_str::@2
  [71] (byte*) print_char_cursor#2 ← phi( print_str/(byte*) print_char_cursor#66 print_str::@2/(byte*) print_char_cursor#1 )
  [71] (byte*) print_str::str#8 ← phi( print_str/(byte*) print_str::str#10 print_str::@2/(byte*) print_str::str#0 )
  [72] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2
  to:print_str::@return
print_str::@return: scope:[print_str]  from print_str::@1
  [73] return 
  to:@return
print_str::@2: scope:[print_str]  from print_str::@1
  [74] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8)
  [75] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2
  [76] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8
  to:print_str::@1
print_char: scope:[print_char]  from main::@27
  [77] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0
  [78] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [79] return 
  to:@return
print_word_decimal: scope:[print_word_decimal]  from main::@10 main::@17 main::@23
  [80] (byte*) print_char_cursor#58 ← phi( main::@10/(byte*~) print_char_cursor#96 main::@17/(byte*) print_char_cursor#2 main::@23/(byte*) print_char_cursor#2 )
  [80] (word) print_word_decimal::w#3 ← phi( main::@10/(word) print_word_decimal::w#2 main::@17/(const word) COUNT#0 main::@23/(word) print_word_decimal::w#1 )
  [81] (word) utoa::value#1 ← (word) print_word_decimal::w#3
  [82] call utoa 
  to:print_word_decimal::@1
print_word_decimal::@1: scope:[print_word_decimal]  from print_word_decimal
  [83] phi()
  [84] call print_str 
  to:print_word_decimal::@return
print_word_decimal::@return: scope:[print_word_decimal]  from print_word_decimal::@1
  [85] return 
  to:@return
utoa: scope:[utoa]  from print_word_decimal
  [86] phi()
  to:utoa::@1
utoa::@1: scope:[utoa]  from utoa utoa::@2
  [87] (byte*) utoa::buffer#11 ← phi( utoa::@2/(byte*) utoa::buffer#12 utoa/(const byte[6]) decimal_digits#0 )
  [87] (byte) utoa::started#2 ← phi( utoa::@2/(byte) utoa::started#3 utoa/(byte) 0 )
  [87] (word) utoa::value#2 ← phi( utoa::@2/(word) utoa::value#4 utoa/(word) utoa::value#1 )
  [87] (byte) utoa::digit#2 ← phi( utoa::@2/(byte) utoa::digit#1 utoa/(byte) 0 )
  [88] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1
  [89] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES#0 + (byte~) utoa::$11)
  [90] if((byte) 0!=(byte) utoa::started#2) goto utoa::@3
  to:utoa::@6
utoa::@6: scope:[utoa]  from utoa::@1
  [91] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@3
  to:utoa::@2
utoa::@2: scope:[utoa]  from utoa::@5 utoa::@6
  [92] (byte*) utoa::buffer#12 ← phi( utoa::@6/(byte*) utoa::buffer#11 utoa::@5/(byte*) utoa::buffer#3 )
  [92] (byte) utoa::started#3 ← phi( utoa::@6/(byte) utoa::started#2 utoa::@5/(byte) 1 )
  [92] (word) utoa::value#4 ← phi( utoa::@6/(word) utoa::value#2 utoa::@5/(word) utoa::value#0 )
  [93] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2
  [94] if((byte) utoa::digit#1<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@1
  to:utoa::@4
utoa::@4: scope:[utoa]  from utoa::@2
  [95] (byte~) utoa::$4 ← (byte)(word) utoa::value#4
  [96] *((byte*) utoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) utoa::$4)
  [97] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#12
  [98] *((byte*) utoa::buffer#4) ← (byte) 0
  to:utoa::@return
utoa::@return: scope:[utoa]  from utoa::@4
  [99] return 
  to:@return
utoa::@3: scope:[utoa]  from utoa::@1 utoa::@6
  [100] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
  [101] (word) utoa_append::value#0 ← (word) utoa::value#2
  [102] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
  [103] call utoa_append 
  [104] (word) utoa_append::return#0 ← (word) utoa_append::value#2
  to:utoa::@5
utoa::@5: scope:[utoa]  from utoa::@3
  [105] (word) utoa::value#0 ← (word) utoa_append::return#0
  [106] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11
  to:utoa::@2
utoa_append: scope:[utoa_append]  from utoa::@3
  [107] phi()
  to:utoa_append::@1
utoa_append::@1: scope:[utoa_append]  from utoa_append utoa_append::@2
  [108] (byte) utoa_append::digit#2 ← phi( utoa_append/(byte) 0 utoa_append::@2/(byte) utoa_append::digit#1 )
  [108] (word) utoa_append::value#2 ← phi( utoa_append/(word) utoa_append::value#0 utoa_append::@2/(word) utoa_append::value#1 )
  [109] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2
  to:utoa_append::@3
utoa_append::@3: scope:[utoa_append]  from utoa_append::@1
  [110] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) utoa_append::digit#2)
  to:utoa_append::@return
utoa_append::@return: scope:[utoa_append]  from utoa_append::@3
  [111] return 
  to:@return
utoa_append::@2: scope:[utoa_append]  from utoa_append::@1
  [112] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2
  [113] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0
  to:utoa_append::@1
print_ln: scope:[print_ln]  from main::@15 main::@18 main::@26
  [114] (byte*) print_line_cursor#21 ← phi( main::@15/(byte*) 1024 main::@18/(byte*) print_line_cursor#1 main::@26/(byte*) print_line_cursor#1 )
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  [115] (byte*) print_line_cursor#11 ← phi( print_ln/(byte*) print_line_cursor#21 print_ln::@1/(byte*) print_line_cursor#1 )
  [116] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28
  [117] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@1
  [118] return 
  to:@return
print_dword_decimal: scope:[print_dword_decimal]  from main::@25
  [119] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0
  [120] call ultoa 
  to:print_dword_decimal::@1
print_dword_decimal::@1: scope:[print_dword_decimal]  from print_dword_decimal
  [121] phi()
  [122] call print_str 
  to:print_dword_decimal::@return
print_dword_decimal::@return: scope:[print_dword_decimal]  from print_dword_decimal::@1
  [123] return 
  to:@return
ultoa: scope:[ultoa]  from print_dword_decimal
  [124] phi()
  to:ultoa::@1
ultoa::@1: scope:[ultoa]  from ultoa ultoa::@2
  [125] (byte*) ultoa::buffer#11 ← phi( ultoa::@2/(byte*) ultoa::buffer#12 ultoa/(const byte[$b]) decimal_digits_long#0 )
  [125] (byte) ultoa::started#2 ← phi( ultoa::@2/(byte) ultoa::started#3 ultoa/(byte) 0 )
  [125] (dword) ultoa::value#2 ← phi( ultoa::@2/(dword) ultoa::value#4 ultoa/(dword) ultoa::value#1 )
  [125] (byte) ultoa::digit#2 ← phi( ultoa::@2/(byte) ultoa::digit#1 ultoa/(byte) 0 )
  [126] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2
  [127] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG#0 + (byte~) ultoa::$11)
  [128] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@3
  to:ultoa::@6
ultoa::@6: scope:[ultoa]  from ultoa::@1
  [129] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@3
  to:ultoa::@2
ultoa::@2: scope:[ultoa]  from ultoa::@5 ultoa::@6
  [130] (byte*) ultoa::buffer#12 ← phi( ultoa::@6/(byte*) ultoa::buffer#11 ultoa::@5/(byte*) ultoa::buffer#3 )
  [130] (byte) ultoa::started#3 ← phi( ultoa::@6/(byte) ultoa::started#2 ultoa::@5/(byte) 1 )
  [130] (dword) ultoa::value#4 ← phi( ultoa::@6/(dword) ultoa::value#2 ultoa::@5/(dword) ultoa::value#0 )
  [131] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2
  [132] if((byte) ultoa::digit#1<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@1
  to:ultoa::@4
ultoa::@4: scope:[ultoa]  from ultoa::@2
  [133] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4
  [134] *((byte*) ultoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) ultoa::$4)
  [135] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#12
  [136] *((byte*) ultoa::buffer#4) ← (byte) 0
  to:ultoa::@return
ultoa::@return: scope:[ultoa]  from ultoa::@4
  [137] return 
  to:@return
ultoa::@3: scope:[ultoa]  from ultoa::@1 ultoa::@6
  [138] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11
  [139] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2
  [140] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0
  [141] call ultoa_append 
  [142] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2
  to:ultoa::@5
ultoa::@5: scope:[ultoa]  from ultoa::@3
  [143] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0
  [144] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11
  to:ultoa::@2
ultoa_append: scope:[ultoa_append]  from ultoa::@3
  [145] phi()
  to:ultoa_append::@1
ultoa_append::@1: scope:[ultoa_append]  from ultoa_append ultoa_append::@2
  [146] (byte) ultoa_append::digit#2 ← phi( ultoa_append/(byte) 0 ultoa_append::@2/(byte) ultoa_append::digit#1 )
  [146] (dword) ultoa_append::value#2 ← phi( ultoa_append/(dword) ultoa_append::value#0 ultoa_append::@2/(dword) ultoa_append::value#1 )
  [147] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2
  to:ultoa_append::@3
ultoa_append::@3: scope:[ultoa_append]  from ultoa_append::@1
  [148] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) ultoa_append::digit#2)
  to:ultoa_append::@return
ultoa_append::@return: scope:[ultoa_append]  from ultoa_append::@3
  [149] return 
  to:@return
ultoa_append::@2: scope:[ultoa_append]  from ultoa_append::@1
  [150] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2
  [151] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0
  to:ultoa_append::@1
div32u16u: scope:[div32u16u]  from main::@21
  [152] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0
  [153] call divr16u 
  [154] (word) divr16u::return#2 ← (word) divr16u::return#0
  to:div32u16u::@1
div32u16u::@1: scope:[div32u16u]  from div32u16u
  [155] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2
  [156] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0
  [157] (word) divr16u::rem#4 ← (word) rem16u#1
  [158] call divr16u 
  [159] (word) divr16u::return#3 ← (word) divr16u::return#0
  to:div32u16u::@2
div32u16u::@2: scope:[div32u16u]  from div32u16u::@1
  [160] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3
  [161] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0
  to:div32u16u::@return
div32u16u::@return: scope:[div32u16u]  from div32u16u::@2
  [162] return 
  to:@return
divr16u: scope:[divr16u]  from div32u16u div32u16u::@1
  [163] (word) divr16u::dividend#5 ← phi( div32u16u/(word) divr16u::dividend#1 div32u16u::@1/(word) divr16u::dividend#2 )
  [163] (word) divr16u::rem#10 ← phi( div32u16u/(byte) 0 div32u16u::@1/(word) divr16u::rem#4 )
  to:divr16u::@1
divr16u::@1: scope:[divr16u]  from divr16u divr16u::@3
  [164] (byte) divr16u::i#2 ← phi( divr16u/(byte) 0 divr16u::@3/(byte) divr16u::i#1 )
  [164] (word) divr16u::quotient#3 ← phi( divr16u/(byte) 0 divr16u::@3/(word) divr16u::return#0 )
  [164] (word) divr16u::dividend#3 ← phi( divr16u/(word) divr16u::dividend#5 divr16u::@3/(word) divr16u::dividend#0 )
  [164] (word) divr16u::rem#5 ← phi( divr16u/(word) divr16u::rem#10 divr16u::@3/(word) divr16u::rem#11 )
  [165] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1
  [166] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3
  [167] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80
  [168] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2
  to:divr16u::@4
divr16u::@4: scope:[divr16u]  from divr16u::@1
  [169] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1
  to:divr16u::@2
divr16u::@2: scope:[divr16u]  from divr16u::@1 divr16u::@4
  [170] (word) divr16u::rem#6 ← phi( divr16u::@1/(word) divr16u::rem#0 divr16u::@4/(word) divr16u::rem#1 )
  [171] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1
  [172] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1
  [173] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3
  to:divr16u::@5
divr16u::@5: scope:[divr16u]  from divr16u::@2
  [174] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1
  [175] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0
  to:divr16u::@3
divr16u::@3: scope:[divr16u]  from divr16u::@2 divr16u::@5
  [176] (word) divr16u::return#0 ← phi( divr16u::@2/(word) divr16u::quotient#1 divr16u::@5/(word) divr16u::quotient#2 )
  [176] (word) divr16u::rem#11 ← phi( divr16u::@2/(word) divr16u::rem#6 divr16u::@5/(word) divr16u::rem#2 )
  [177] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2
  [178] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1
  to:divr16u::@6
divr16u::@6: scope:[divr16u]  from divr16u::@3
  [179] (word) rem16u#1 ← (word) divr16u::rem#11
  to:divr16u::@return
divr16u::@return: scope:[divr16u]  from divr16u::@6
  [180] return 
  to:@return
clock: scope:[clock]  from main::@3
  [181] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0)
  to:clock::@return
clock::@return: scope:[clock]  from clock
  [182] return 
  to:@return
clock_start: scope:[clock_start]  from main::@20
  [183] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0
  [184] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  [185] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff
  [186] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0
  [187] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0
  to:clock_start::@return
clock_start::@return: scope:[clock_start]  from clock_start
  [188] return 
  to:@return
memset: scope:[memset]  from main::@19 print_cls
  [189] (byte) memset::c#3 ← phi( main::@19/(byte) 0 print_cls/(byte) ' ' )
  [189] (void*) memset::str#3 ← phi( main::@19/(void*)(const byte*) sieve#0 print_cls/(void*)(byte*) 1024 )
  [189] (word) memset::num#2 ← phi( main::@19/(const word) COUNT#0 print_cls/(word) $3e8 )
  [190] if((word) memset::num#2<=(byte) 0) goto memset::@return
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [191] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2
  [192] (byte*~) memset::dst#3 ← (byte*)(void*) memset::str#3
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@2
  [193] (byte*) memset::dst#2 ← phi( memset::@1/(byte*~) memset::dst#3 memset::@2/(byte*) memset::dst#1 )
  [194] *((byte*) memset::dst#2) ← (byte) memset::c#3
  [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  [196] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset memset::@2
  [197] return 
  to:@return
print_cls: scope:[print_cls]  from main::@13
  [198] phi()
  [199] call memset 
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls
  [200] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(dword*) CIA2_TIMER_AB
(byte*) CIA2_TIMER_A_CONTROL
(byte*) CIA2_TIMER_B_CONTROL
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(byte) CIA_TIMER_CONTROL_START
(byte) CIA_TIMER_CONTROL_STOP
(word) CLOCKS_PER_FRAME
(dword) CLOCKS_PER_INIT
(dword) CLOCKS_PER_SEC
(word) COUNT
(byte*) D018
(byte[]) DIGITS
(byte) FRAMES_PER_SEC
(word[]) RADIX_BINARY_VALUES
(dword[]) RADIX_BINARY_VALUES_LONG
(word[]) RADIX_DECIMAL_VALUES
(dword[]) RADIX_DECIMAL_VALUES_LONG
(word[]) RADIX_HEXADECIMAL_VALUES
(dword[]) RADIX_HEXADECIMAL_VALUES_LONG
(word[]) RADIX_OCTAL_VALUES
(dword[]) RADIX_OCTAL_VALUES_LONG
(byte*) SCREEN
(byte) SQRT_COUNT
(dword()) clock()
(dword) clock::return
(dword) clock::return#0 1.3333333333333333
(dword) clock::return#2 4.0
(void()) clock_start()
(byte[6]) decimal_digits
(byte[$b]) decimal_digits_long
(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
(dword) div32u16u::dividend
(dword) div32u16u::dividend#0 1.2000000000000002
(word) div32u16u::divisor
(dword) div32u16u::quotient
(word) div32u16u::quotient_hi
(word) div32u16u::quotient_hi#0 0.6666666666666666
(word) div32u16u::quotient_lo
(word) div32u16u::quotient_lo#0 4.0
(dword) div32u16u::return
(dword) div32u16u::return#0 1.3333333333333333
(dword) div32u16u::return#2 4.0
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(byte~) divr16u::$1 22.0
(byte~) divr16u::$2 22.0
(word) divr16u::dividend
(word) divr16u::dividend#0 2.75
(word) divr16u::dividend#1 4.0
(word) divr16u::dividend#2 2.0
(word) divr16u::dividend#3 5.0
(word) divr16u::dividend#5 6.0
(word) divr16u::divisor
(byte) divr16u::i
(byte) divr16u::i#1 16.5
(byte) divr16u::i#2 1.6923076923076923
(word) divr16u::quotient
(word) divr16u::quotient#1 16.5
(word) divr16u::quotient#2 11.0
(word) divr16u::quotient#3 2.75
(word) divr16u::rem
(word) divr16u::rem#0 8.25
(word) divr16u::rem#1 22.0
(word) divr16u::rem#10 4.0
(word) divr16u::rem#11 11.666666666666666
(word) divr16u::rem#2 22.0
(word) divr16u::rem#4 4.0
(word) divr16u::rem#5 24.0
(word) divr16u::rem#6 11.0
(word) divr16u::return
(word) divr16u::return#0 5.285714285714286
(word) divr16u::return#2 4.0
(word) divr16u::return#3 4.0
(void()) main()
(dword~) main::$10 4.0
(dword~) main::$14 2.0
(byte*~) main::$38 22.0
(dword) main::cyclecount
(dword) main::cyclecount#0 0.5
(word) main::i
(word) main::i#10 4.4
(word) main::i#11 24.6
(word) main::i#2 11.0
(word) main::i#3 11.0
(word) main::j
(word) main::j#0 16.5
(word) main::j#1 202.0
(word) main::j#2 78.5
(byte*) main::s
(byte*) main::s#0 22.0
(byte*) main::s#1 101.0
(byte*) main::s#2 104.66666666666666
(word) main::sec100s
(word) main::sec100s#0 1.3333333333333333
(byte*) main::sieve_i
(byte*) main::sieve_i#1 22.0
(byte*) main::sieve_i#2 3.0
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(number~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(number~) main::toD0181_$6
(number~) main::toD0181_$7
(number~) main::toD0181_$8
(byte*) main::toD0181_gfx
(byte) main::toD0181_return
(byte*) main::toD0181_screen
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte) memset::c#3 1.375
(byte*) memset::dst
(byte*) memset::dst#1 16.5
(byte*) memset::dst#2 17.5
(byte*~) memset::dst#3 4.0
(byte*) memset::end
(byte*) memset::end#0 2.1666666666666665
(word) memset::num
(word) memset::num#2 2.0
(void*) memset::return
(void*) memset::str
(void*) memset::str#3
(void()) print_char((byte) print_char::ch)
(byte) print_char::ch
(byte*) print_char_cursor
(byte*) print_char_cursor#1 101.0
(byte*) print_char_cursor#10 4.333333333333333
(byte*~) print_char_cursor#101 22.0
(byte*) print_char_cursor#2 10.25
(byte*) print_char_cursor#58 4.25
(byte*) print_char_cursor#62 8.75
(byte*) print_char_cursor#63 8.75
(byte*) print_char_cursor#66 14.0
(byte*~) print_char_cursor#89 4.0
(byte*~) print_char_cursor#90 4.0
(byte*~) print_char_cursor#96 22.0
(byte*~) print_char_cursor#99 22.0
(void()) print_cls()
(void()) print_dword_decimal((dword) print_dword_decimal::w)
(dword) print_dword_decimal::w
(dword) print_dword_decimal::w#0 4.0
(byte*) print_line_cursor
(byte*) print_line_cursor#1 0.9347826086956521
(byte*) print_line_cursor#11 24.0
(byte*) print_line_cursor#21 6.0
(void()) print_ln()
(byte*) print_screen
(void()) print_str((byte*) print_str::str)
(byte*) print_str::str
(byte*) print_str::str#0 202.0
(byte*) print_str::str#10 2.0
(byte*) print_str::str#8 101.5
(void()) print_word_decimal((word) print_word_decimal::w)
(word) print_word_decimal::w
(word) print_word_decimal::w#1 4.0
(word) print_word_decimal::w#2 11.0
(word) print_word_decimal::w#3 15.0
(word) rem16u
(word) rem16u#1 0.6666666666666666
(byte*) sieve
(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
(byte~) ultoa::$11 22.0
(byte~) ultoa::$4 4.0
(byte*) ultoa::buffer
(byte*) ultoa::buffer#11 4.0
(byte*) ultoa::buffer#12 7.400000000000001
(byte*) ultoa::buffer#3 22.0
(byte*) ultoa::buffer#4 4.0
(byte) ultoa::digit
(byte) ultoa::digit#1 16.5
(byte) ultoa::digit#2 2.5384615384615383
(dword) ultoa::digit_value
(dword) ultoa::digit_value#0 6.6000000000000005
(dword*) ultoa::digit_values
(byte) ultoa::max_digits
(byte) ultoa::radix
(byte) ultoa::started
(byte) ultoa::started#2 6.6000000000000005
(byte) ultoa::started#3 7.333333333333333
(dword) ultoa::value
(dword) ultoa::value#0 11.0
(dword) ultoa::value#1 2.0
(dword) ultoa::value#2 7.666666666666666
(dword) ultoa::value#4 11.0
(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
(byte*) ultoa_append::buffer
(byte*) ultoa_append::buffer#0 1.625
(byte) ultoa_append::digit
(byte) ultoa_append::digit#1 101.0
(byte) ultoa_append::digit#2 102.0
(dword) ultoa_append::return
(dword) ultoa_append::return#0 22.0
(dword) ultoa_append::sub
(dword) ultoa_append::sub#0 35.5
(dword) ultoa_append::value
(dword) ultoa_append::value#0 4.333333333333333
(dword) ultoa_append::value#1 202.0
(dword) ultoa_append::value#2 52.66666666666666
(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
(byte~) utoa::$11 202.0
(byte~) utoa::$4 4.0
(byte*) utoa::buffer
(byte*) utoa::buffer#11 36.72727272727273
(byte*) utoa::buffer#12 61.39999999999999
(byte*) utoa::buffer#3 202.0
(byte*) utoa::buffer#4 4.0
(byte) utoa::digit
(byte) utoa::digit#1 151.5
(byte) utoa::digit#2 23.307692307692307
(word) utoa::digit_value
(word) utoa::digit_value#0 60.599999999999994
(word*) utoa::digit_values
(byte) utoa::max_digits
(byte) utoa::radix
(byte) utoa::started
(byte) utoa::started#2 60.599999999999994
(byte) utoa::started#3 67.33333333333333
(word) utoa::value
(word) utoa::value#0 101.0
(word) utoa::value#1 2.0
(word) utoa::value#2 67.66666666666666
(word) utoa::value#4 101.0
(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
(byte*) utoa_append::buffer
(byte*) utoa_append::buffer#0 12.875
(byte) utoa_append::digit
(byte) utoa_append::digit#1 1001.0
(byte) utoa_append::digit#2 1002.0
(word) utoa_append::return
(word) utoa_append::return#0 202.0
(word) utoa_append::sub
(word) utoa_append::sub#0 350.5
(word) utoa_append::value
(word) utoa_append::value#0 34.33333333333333
(word) utoa_append::value#1 2002.0
(word) utoa_append::value#2 517.6666666666667

Initial phi equivalence classes
[ main::i#11 main::i#2 ]
[ main::sieve_i#2 main::sieve_i#1 ]
[ main::i#10 main::i#3 ]
[ main::j#2 main::j#0 main::j#1 ]
[ main::s#2 main::s#0 main::s#1 ]
[ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ]
[ print_str::str#8 print_str::str#10 print_str::str#0 ]
[ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ]
[ utoa::digit#2 utoa::digit#1 ]
[ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ]
[ utoa::started#2 utoa::started#3 ]
[ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ]
[ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ]
[ utoa_append::digit#2 utoa_append::digit#1 ]
[ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ]
[ ultoa::digit#2 ultoa::digit#1 ]
[ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ]
[ ultoa::started#2 ultoa::started#3 ]
[ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ]
[ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ]
[ ultoa_append::digit#2 ultoa_append::digit#1 ]
[ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
[ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
[ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
[ divr16u::i#2 divr16u::i#1 ]
[ memset::num#2 ]
[ memset::str#3 ]
[ memset::c#3 ]
[ memset::dst#2 memset::dst#3 memset::dst#1 ]
Added variable clock::return#2 to zero page equivalence class [ clock::return#2 ]
Added variable main::$10 to zero page equivalence class [ main::$10 ]
Added variable main::cyclecount#0 to zero page equivalence class [ main::cyclecount#0 ]
Added variable div32u16u::dividend#0 to zero page equivalence class [ div32u16u::dividend#0 ]
Added variable div32u16u::return#2 to zero page equivalence class [ div32u16u::return#2 ]
Added variable main::$14 to zero page equivalence class [ main::$14 ]
Added variable main::sec100s#0 to zero page equivalence class [ main::sec100s#0 ]
Added variable print_dword_decimal::w#0 to zero page equivalence class [ print_dword_decimal::w#0 ]
Added variable main::$38 to zero page equivalence class [ main::$38 ]
Added variable utoa::$11 to zero page equivalence class [ utoa::$11 ]
Added variable utoa::digit_value#0 to zero page equivalence class [ utoa::digit_value#0 ]
Added variable utoa::$4 to zero page equivalence class [ utoa::$4 ]
Added variable utoa::buffer#4 to zero page equivalence class [ utoa::buffer#4 ]
Added variable utoa_append::buffer#0 to zero page equivalence class [ utoa_append::buffer#0 ]
Added variable utoa_append::sub#0 to zero page equivalence class [ utoa_append::sub#0 ]
Added variable utoa_append::return#0 to zero page equivalence class [ utoa_append::return#0 ]
Added variable ultoa::$11 to zero page equivalence class [ ultoa::$11 ]
Added variable ultoa::digit_value#0 to zero page equivalence class [ ultoa::digit_value#0 ]
Added variable ultoa::$4 to zero page equivalence class [ ultoa::$4 ]
Added variable ultoa::buffer#4 to zero page equivalence class [ ultoa::buffer#4 ]
Added variable ultoa_append::buffer#0 to zero page equivalence class [ ultoa_append::buffer#0 ]
Added variable ultoa_append::sub#0 to zero page equivalence class [ ultoa_append::sub#0 ]
Added variable ultoa_append::return#0 to zero page equivalence class [ ultoa_append::return#0 ]
Added variable divr16u::return#2 to zero page equivalence class [ divr16u::return#2 ]
Added variable div32u16u::quotient_hi#0 to zero page equivalence class [ div32u16u::quotient_hi#0 ]
Added variable divr16u::return#3 to zero page equivalence class [ divr16u::return#3 ]
Added variable div32u16u::quotient_lo#0 to zero page equivalence class [ div32u16u::quotient_lo#0 ]
Added variable div32u16u::return#0 to zero page equivalence class [ div32u16u::return#0 ]
Added variable divr16u::$1 to zero page equivalence class [ divr16u::$1 ]
Added variable divr16u::$2 to zero page equivalence class [ divr16u::$2 ]
Added variable rem16u#1 to zero page equivalence class [ rem16u#1 ]
Added variable clock::return#0 to zero page equivalence class [ clock::return#0 ]
Added variable memset::end#0 to zero page equivalence class [ memset::end#0 ]
Complete equivalence classes
[ main::i#11 main::i#2 ]
[ main::sieve_i#2 main::sieve_i#1 ]
[ main::i#10 main::i#3 ]
[ main::j#2 main::j#0 main::j#1 ]
[ main::s#2 main::s#0 main::s#1 ]
[ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ]
[ print_str::str#8 print_str::str#10 print_str::str#0 ]
[ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ]
[ utoa::digit#2 utoa::digit#1 ]
[ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ]
[ utoa::started#2 utoa::started#3 ]
[ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ]
[ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ]
[ utoa_append::digit#2 utoa_append::digit#1 ]
[ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ]
[ ultoa::digit#2 ultoa::digit#1 ]
[ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ]
[ ultoa::started#2 ultoa::started#3 ]
[ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ]
[ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ]
[ ultoa_append::digit#2 ultoa_append::digit#1 ]
[ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
[ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
[ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
[ divr16u::i#2 divr16u::i#1 ]
[ memset::num#2 ]
[ memset::str#3 ]
[ memset::c#3 ]
[ memset::dst#2 memset::dst#3 memset::dst#1 ]
[ clock::return#2 ]
[ main::$10 ]
[ main::cyclecount#0 ]
[ div32u16u::dividend#0 ]
[ div32u16u::return#2 ]
[ main::$14 ]
[ main::sec100s#0 ]
[ print_dword_decimal::w#0 ]
[ main::$38 ]
[ utoa::$11 ]
[ utoa::digit_value#0 ]
[ utoa::$4 ]
[ utoa::buffer#4 ]
[ utoa_append::buffer#0 ]
[ utoa_append::sub#0 ]
[ utoa_append::return#0 ]
[ ultoa::$11 ]
[ ultoa::digit_value#0 ]
[ ultoa::$4 ]
[ ultoa::buffer#4 ]
[ ultoa_append::buffer#0 ]
[ ultoa_append::sub#0 ]
[ ultoa_append::return#0 ]
[ divr16u::return#2 ]
[ div32u16u::quotient_hi#0 ]
[ divr16u::return#3 ]
[ div32u16u::quotient_lo#0 ]
[ div32u16u::return#0 ]
[ divr16u::$1 ]
[ divr16u::$2 ]
[ rem16u#1 ]
[ clock::return#0 ]
[ memset::end#0 ]
Allocated zp ZP_WORD:2 [ main::i#11 main::i#2 ]
Allocated zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ]
Allocated zp ZP_WORD:6 [ main::i#10 main::i#3 ]
Allocated zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ]
Allocated zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ]
Allocated zp ZP_WORD:12 [ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ]
Allocated zp ZP_WORD:14 [ print_str::str#8 print_str::str#10 print_str::str#0 ]
Allocated zp ZP_WORD:16 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ]
Allocated zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Allocated zp ZP_WORD:19 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ]
Allocated zp ZP_BYTE:21 [ utoa::started#2 utoa::started#3 ]
Allocated zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ]
Allocated zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ]
Allocated zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ]
Allocated zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ]
Allocated zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Allocated zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ]
Allocated zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#3 ]
Allocated zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ]
Allocated zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ]
Allocated zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ]
Allocated zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ]
Allocated zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
Allocated zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ]
Allocated zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ]
Allocated zp ZP_WORD:49 [ memset::num#2 ]
Allocated zp ZP_WORD:51 [ memset::str#3 ]
Allocated zp ZP_BYTE:53 [ memset::c#3 ]
Allocated zp ZP_WORD:54 [ memset::dst#2 memset::dst#3 memset::dst#1 ]
Allocated zp ZP_DWORD:56 [ clock::return#2 ]
Allocated zp ZP_DWORD:60 [ main::$10 ]
Allocated zp ZP_DWORD:64 [ main::cyclecount#0 ]
Allocated zp ZP_DWORD:68 [ div32u16u::dividend#0 ]
Allocated zp ZP_DWORD:72 [ div32u16u::return#2 ]
Allocated zp ZP_DWORD:76 [ main::$14 ]
Allocated zp ZP_WORD:80 [ main::sec100s#0 ]
Allocated zp ZP_DWORD:82 [ print_dword_decimal::w#0 ]
Allocated zp ZP_WORD:86 [ main::$38 ]
Allocated zp ZP_BYTE:88 [ utoa::$11 ]
Allocated zp ZP_WORD:89 [ utoa::digit_value#0 ]
Allocated zp ZP_BYTE:91 [ utoa::$4 ]
Allocated zp ZP_WORD:92 [ utoa::buffer#4 ]
Allocated zp ZP_WORD:94 [ utoa_append::buffer#0 ]
Allocated zp ZP_WORD:96 [ utoa_append::sub#0 ]
Allocated zp ZP_WORD:98 [ utoa_append::return#0 ]
Allocated zp ZP_BYTE:100 [ ultoa::$11 ]
Allocated zp ZP_DWORD:101 [ ultoa::digit_value#0 ]
Allocated zp ZP_BYTE:105 [ ultoa::$4 ]
Allocated zp ZP_WORD:106 [ ultoa::buffer#4 ]
Allocated zp ZP_WORD:108 [ ultoa_append::buffer#0 ]
Allocated zp ZP_DWORD:110 [ ultoa_append::sub#0 ]
Allocated zp ZP_DWORD:114 [ ultoa_append::return#0 ]
Allocated zp ZP_WORD:118 [ divr16u::return#2 ]
Allocated zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ]
Allocated zp ZP_WORD:122 [ divr16u::return#3 ]
Allocated zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ]
Allocated zp ZP_DWORD:126 [ div32u16u::return#0 ]
Allocated zp ZP_BYTE:130 [ divr16u::$1 ]
Allocated zp ZP_BYTE:131 [ divr16u::$2 ]
Allocated zp ZP_WORD:132 [ rem16u#1 ]
Allocated zp ZP_DWORD:134 [ clock::return#0 ]
Allocated zp ZP_WORD:138 [ memset::end#0 ]

INITIAL ASM
  // File Comments
  // Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label D018 = $d018
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles per frame (on a C64 PAL)
  .const CLOCKS_PER_FRAME = $4cc8
  // Frames per second (on a C64 PAL)
  .const FRAMES_PER_SEC = $3c
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  .const COUNT = $4000
  /* Up to what number? */
  .const SQRT_COUNT = $80
  /* Sqrt of COUNT */
  .label sieve = $1000
  // Clock cycles per second (on a C64 PAL)
  .const CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
  .label rem16u = $84
  .label print_char_cursor = $c
  .label print_line_cursor = $1b
  .label print_char_cursor_62 = $1b
  .label print_char_cursor_99 = $1b
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label toD0181_gfx = $1800
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>toD0181_gfx)/4&$f
    .label _10 = $3c
    .label _14 = $4c
    .label cyclecount = $40
    .label sec100s = $50
    .label i = 2
    .label sieve_i = 4
    .label j = 8
    .label s = $a
    .label i_3 = 6
    .label i_10 = 6
    .label _38 = $56
    // [5] phi from main to main::toD0181 [phi:main->main::toD0181]
  toD0181_from_main:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b13
    // main::@13
  b13:
    // [6] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    //Show lower case font
    lda #toD0181_return
    sta D018
    // [7] call print_cls 
    // [198] phi from main::@13 to print_cls [phi:main::@13->print_cls]
  print_cls_from_b13:
    jsr print_cls
    // [8] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  b14_from_b13:
    jmp b14
    // main::@14
  b14:
    // [9] call print_str 
    // [70] phi from main::@14 to print_str [phi:main::@14->print_str]
  print_str_from_b14:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) 1024 [phi:main::@14->print_str#0] -- pbuz1=pbuc1 
    lda #<$400
    sta print_char_cursor
    lda #>$400
    sta print_char_cursor+1
    // [70] phi (byte*) print_str::str#10 = (const string) main::str [phi:main::@14->print_str#1] -- pbuz1=pbuc1 
    lda #<str
    sta print_str.str
    lda #>str
    sta print_str.str+1
    jsr print_str
    // [10] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  b15_from_b14:
    jmp b15
    // main::@15
  b15:
    // [11] call print_ln 
    // [114] phi from main::@15 to print_ln [phi:main::@15->print_ln]
  print_ln_from_b15:
    // [114] phi (byte*) print_line_cursor#21 = (byte*) 1024 [phi:main::@15->print_ln#0] -- pbuz1=pbuc1 
    lda #<$400
    sta print_line_cursor
    lda #>$400
    sta print_line_cursor+1
    jsr print_ln
    jmp b16
    // main::@16
  b16:
    // [12] (byte*~) print_char_cursor#89 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda print_line_cursor
    sta print_char_cursor
    lda print_line_cursor+1
    sta print_char_cursor+1
    // [13] call print_str 
    // [70] phi from main::@16 to print_str [phi:main::@16->print_str]
  print_str_from_b16:
    // [70] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#89 [phi:main::@16->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str1 [phi:main::@16->print_str#1] -- pbuz1=pbuc1 
    lda #<str1
    sta print_str.str
    lda #>str1
    sta print_str.str+1
    jsr print_str
    // [14] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  b17_from_b16:
    jmp b17
    // main::@17
  b17:
    // [15] call print_word_decimal 
    // [80] phi from main::@17 to print_word_decimal [phi:main::@17->print_word_decimal]
  print_word_decimal_from_b17:
    // [80] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@17->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (const word) COUNT#0 [phi:main::@17->print_word_decimal#1] -- vwuz1=vwuc1 
    lda #<COUNT
    sta print_word_decimal.w
    lda #>COUNT
    sta print_word_decimal.w+1
    jsr print_word_decimal
    // [16] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  b18_from_b17:
    jmp b18
    // main::@18
  b18:
    // [17] call print_ln 
    // [114] phi from main::@18 to print_ln [phi:main::@18->print_ln]
  print_ln_from_b18:
    // [114] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@18->print_ln#0] -- register_copy 
    jsr print_ln
    // [18] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  b19_from_b18:
    jmp b19
    // main::@19
  b19:
    // [19] call memset 
    // [189] phi from main::@19 to memset [phi:main::@19->memset]
  memset_from_b19:
    // [189] phi (byte) memset::c#3 = (byte) 0 [phi:main::@19->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta memset.c
    // [189] phi (void*) memset::str#3 = (void*)(const byte*) sieve#0 [phi:main::@19->memset#1] -- pvoz1=pvoc1 
    lda #<sieve
    sta memset.str
    lda #>sieve
    sta memset.str+1
    // [189] phi (word) memset::num#2 = (const word) COUNT#0 [phi:main::@19->memset#2] -- vwuz1=vwuc1 
    lda #<COUNT
    sta memset.num
    lda #>COUNT
    sta memset.num+1
    jsr memset
    // [20] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  b20_from_b19:
    jmp b20
    // main::@20
  b20:
    // [21] call clock_start 
    jsr clock_start
    // [22] phi from main::@20 to main::@1 [phi:main::@20->main::@1]
  b1_from_b20:
    // [22] phi (byte*) main::sieve_i#2 = (const byte*) sieve#0+(byte) 2 [phi:main::@20->main::@1#0] -- pbuz1=pbuc1 
    lda #<sieve+2
    sta sieve_i
    lda #>sieve+2
    sta sieve_i+1
    // [22] phi (word) main::i#11 = (byte) 2 [phi:main::@20->main::@1#1] -- vwuz1=vbuc1 
    lda #<2
    sta i
    lda #>2
    sta i+1
    jmp b1
    // main::@1
  b1:
    // [23] if((word) main::i#11<(const byte) SQRT_COUNT#0) goto main::@2 -- vwuz1_lt_vbuc1_then_la1 
    lda i+1
    cmp #>SQRT_COUNT
    bcc b2
    bne !+
    lda i
    cmp #<SQRT_COUNT
    bcc b2
  !:
    // [24] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  b3_from_b1:
    jmp b3
    // main::@3
  b3:
    // [25] call clock 
    jsr clock
    // [26] (dword) clock::return#2 ← (dword) clock::return#0 -- vduz1=vduz2 
    lda clock.return
    sta clock.return_2
    lda clock.return+1
    sta clock.return_2+1
    lda clock.return+2
    sta clock.return_2+2
    lda clock.return+3
    sta clock.return_2+3
    jmp b21
    // main::@21
  b21:
    // [27] (dword~) main::$10 ← (dword) clock::return#2 -- vduz1=vduz2 
    lda clock.return_2
    sta _10
    lda clock.return_2+1
    sta _10+1
    lda clock.return_2+2
    sta _10+2
    lda clock.return_2+3
    sta _10+3
    // [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT#0 -- vduz1=vduz2_minus_vduc1 
    lda _10
    sec
    sbc #<CLOCKS_PER_INIT
    sta cyclecount
    lda _10+1
    sbc #>CLOCKS_PER_INIT
    sta cyclecount+1
    lda _10+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta cyclecount+2
    lda _10+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta cyclecount+3
    // [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0 -- vduz1=vduz2 
    lda cyclecount
    sta div32u16u.dividend
    lda cyclecount+1
    sta div32u16u.dividend+1
    lda cyclecount+2
    sta div32u16u.dividend+2
    lda cyclecount+3
    sta div32u16u.dividend+3
    // [30] call div32u16u 
    jsr div32u16u
    // [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0 -- vduz1=vduz2 
    lda div32u16u.return
    sta div32u16u.return_2
    lda div32u16u.return+1
    sta div32u16u.return_2+1
    lda div32u16u.return+2
    sta div32u16u.return_2+2
    lda div32u16u.return+3
    sta div32u16u.return_2+3
    jmp b22
    // main::@22
  b22:
    // [32] (dword~) main::$14 ← (dword) div32u16u::return#2 -- vduz1=vduz2 
    lda div32u16u.return_2
    sta _14
    lda div32u16u.return_2+1
    sta _14+1
    lda div32u16u.return_2+2
    sta _14+2
    lda div32u16u.return_2+3
    sta _14+3
    // [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 -- vwuz1=_word_vduz2 
    lda _14
    sta sec100s
    lda _14+1
    sta sec100s+1
    // [34] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda print_line_cursor
    sta print_char_cursor
    lda print_line_cursor+1
    sta print_char_cursor+1
    // [35] call print_str 
    // [70] phi from main::@22 to print_str [phi:main::@22->print_str]
  print_str_from_b22:
    // [70] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#90 [phi:main::@22->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str2 [phi:main::@22->print_str#1] -- pbuz1=pbuc1 
    lda #<str2
    sta print_str.str
    lda #>str2
    sta print_str.str+1
    jsr print_str
    jmp b23
    // main::@23
  b23:
    // [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0 -- vwuz1=vwuz2 
    lda sec100s
    sta print_word_decimal.w
    lda sec100s+1
    sta print_word_decimal.w+1
    // [37] call print_word_decimal 
    // [80] phi from main::@23 to print_word_decimal [phi:main::@23->print_word_decimal]
  print_word_decimal_from_b23:
    // [80] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@23->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#1 [phi:main::@23->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [38] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  b24_from_b23:
    jmp b24
    // main::@24
  b24:
    // [39] call print_str 
    // [70] phi from main::@24 to print_str [phi:main::@24->print_str]
  print_str_from_b24:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:main::@24->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str3 [phi:main::@24->print_str#1] -- pbuz1=pbuc1 
    lda #<str3
    sta print_str.str
    lda #>str3
    sta print_str.str+1
    jsr print_str
    jmp b25
    // main::@25
  b25:
    // [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0 -- vduz1=vduz2 
    lda cyclecount
    sta print_dword_decimal.w
    lda cyclecount+1
    sta print_dword_decimal.w+1
    lda cyclecount+2
    sta print_dword_decimal.w+2
    lda cyclecount+3
    sta print_dword_decimal.w+3
    // [41] call print_dword_decimal 
    jsr print_dword_decimal
    // [42] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  b26_from_b25:
    jmp b26
    // main::@26
  b26:
    // [43] call print_ln 
    // [114] phi from main::@26 to print_ln [phi:main::@26->print_ln]
  print_ln_from_b26:
    // [114] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@26->print_ln#0] -- register_copy 
    jsr print_ln
    // [44] phi from main::@26 to main::@8 [phi:main::@26->main::@8]
  b8_from_b26:
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_line_cursor#1 [phi:main::@26->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (byte) 2 [phi:main::@26->main::@8#1] -- vwuz1=vbuc1 
    lda #<2
    sta i_10
    lda #>2
    sta i_10+1
    jmp b8
    // main::@8
  b8:
    // [45] (byte*~) main::$38 ← (const byte*) sieve#0 + (word) main::i#10 -- pbuz1=pbuc1_plus_vwuz2 
    lda i_10
    clc
    adc #<sieve
    sta _38
    lda i_10+1
    adc #>sieve
    sta _38+1
    // [46] if((byte) 0!=*((byte*~) main::$38)) goto main::@29 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (_38),y
    cmp #0
    bne b29
    jmp b10
    // main::@10
  b10:
    // [47] (word) print_word_decimal::w#2 ← (word) main::i#10 -- vwuz1=vwuz2 
    lda i_10
    sta print_word_decimal.w
    lda i_10+1
    sta print_word_decimal.w+1
    // [48] (byte*~) print_char_cursor#96 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda print_char_cursor_62
    sta print_char_cursor
    lda print_char_cursor_62+1
    sta print_char_cursor+1
    // [49] call print_word_decimal 
    // [80] phi from main::@10 to print_word_decimal [phi:main::@10->print_word_decimal]
  print_word_decimal_from_b10:
    // [80] phi (byte*) print_char_cursor#58 = (byte*~) print_char_cursor#96 [phi:main::@10->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#2 [phi:main::@10->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [50] phi from main::@10 to main::@27 [phi:main::@10->main::@27]
  b27_from_b10:
    jmp b27
    // main::@27
  b27:
    // [51] call print_char 
    jsr print_char
    // [52] phi from main::@27 main::@29 to main::@9 [phi:main::@27/main::@29->main::@9]
  b9_from_b27:
  b9_from_b29:
    // [52] phi (byte*) print_char_cursor#63 = (byte*) print_char_cursor#10 [phi:main::@27/main::@29->main::@9#0] -- register_copy 
    jmp b9
    // main::@9
  b9:
    // [53] (word) main::i#3 ← ++ (word) main::i#10 -- vwuz1=_inc_vwuz1 
    inc i_3
    bne !+
    inc i_3+1
  !:
    // [54] if((word) main::i#3<(word) $514) goto main::@28 -- vwuz1_lt_vwuc1_then_la1 
    lda i_3+1
    cmp #>$514
    bcc b28
    bne !+
    lda i_3
    cmp #<$514
    bcc b28
  !:
    // [55] phi from main::@9 to main::@11 [phi:main::@9->main::@11]
  b11_from_b9:
    jmp b11
    // main::@11
  b11:
    // [56] call print_str 
    // [70] phi from main::@11 to print_str [phi:main::@11->print_str]
  print_str_from_b11:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#63 [phi:main::@11->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str4 [phi:main::@11->print_str#1] -- pbuz1=pbuc1 
    lda #<str4
    sta print_str.str
    lda #>str4
    sta print_str.str+1
    jsr print_str
    jmp b12
    // main::@12
  b12:
    // [57] *((const byte*) SCREEN#0+(word) $3e7) ← ++ *((const byte*) SCREEN#0+(word) $3e7) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
    jmp b12
    // main::@28
  b28:
    // [58] (byte*~) print_char_cursor#99 ← (byte*) print_char_cursor#63 -- pbuz1=pbuz2 
    lda print_char_cursor
    sta print_char_cursor_99
    lda print_char_cursor+1
    sta print_char_cursor_99+1
    // [44] phi from main::@28 to main::@8 [phi:main::@28->main::@8]
  b8_from_b28:
    // [44] phi (byte*) print_char_cursor#62 = (byte*~) print_char_cursor#99 [phi:main::@28->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (word) main::i#3 [phi:main::@28->main::@8#1] -- register_copy 
    jmp b8
    // main::@29
  b29:
    // [59] (byte*~) print_char_cursor#101 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda print_char_cursor_62
    sta print_char_cursor
    lda print_char_cursor_62+1
    sta print_char_cursor+1
    jmp b9_from_b29
    // main::@2
  b2:
    // [60] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (sieve_i),y
    cmp #0
    bne b4
    jmp b7
    // main::@7
  b7:
    // [61] (word) main::j#0 ← (word) main::i#11 << (byte) 1 -- vwuz1=vwuz2_rol_1 
    lda i
    asl
    sta j
    lda i+1
    rol
    sta j+1
    // [62] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda j
    clc
    adc #<sieve
    sta s
    lda j+1
    adc #>sieve
    sta s+1
    // [63] phi from main::@6 main::@7 to main::@5 [phi:main::@6/main::@7->main::@5]
  b5_from_b6:
  b5_from_b7:
    // [63] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@6/main::@7->main::@5#0] -- register_copy 
    // [63] phi (word) main::j#2 = (word) main::j#1 [phi:main::@6/main::@7->main::@5#1] -- register_copy 
    jmp b5
    // main::@5
  b5:
    // [64] if((word) main::j#2<(const word) COUNT#0) goto main::@6 -- vwuz1_lt_vwuc1_then_la1 
    lda j+1
    cmp #>COUNT
    bcc b6
    bne !+
    lda j
    cmp #<COUNT
    bcc b6
  !:
    jmp b4
    // main::@4
  b4:
    // [65] (word) main::i#2 ← ++ (word) main::i#11 -- vwuz1=_inc_vwuz1 
    inc i
    bne !+
    inc i+1
  !:
    // [66] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2 -- pbuz1=_inc_pbuz1 
    inc sieve_i
    bne !+
    inc sieve_i+1
  !:
    // [22] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  b1_from_b4:
    // [22] phi (byte*) main::sieve_i#2 = (byte*) main::sieve_i#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [22] phi (word) main::i#11 = (word) main::i#2 [phi:main::@4->main::@1#1] -- register_copy 
    jmp b1
    // main::@6
  b6:
    // [67] *((byte*) main::s#2) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (s),y
    // [68] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#11 -- pbuz1=pbuz1_plus_vwuz2 
    lda s
    clc
    adc i
    sta s
    lda s+1
    adc i+1
    sta s+1
    // [69] (word) main::j#1 ← (word) main::j#2 + (word) main::i#11 -- vwuz1=vwuz1_plus_vwuz2 
    lda j
    clc
    adc i
    sta j
    lda j+1
    adc i+1
    sta j+1
    jmp b5_from_b6
    str: .text "Sieve benchmark - calculating primes@"
    str1: .text "between 2 and @"
    str2: .text "100ths seconds used: @"
    str3: .text " cycles: @"
    str4: .text "...@"
}
  // print_str
// Print a zero-terminated string
// print_str(byte* zeropage($e) str)
print_str: {
    .label str = $e
    // [71] phi from print_str print_str::@2 to print_str::@1 [phi:print_str/print_str::@2->print_str::@1]
  b1_from_print_str:
  b1_from_b2:
    // [71] phi (byte*) print_char_cursor#2 = (byte*) print_char_cursor#66 [phi:print_str/print_str::@2->print_str::@1#0] -- register_copy 
    // [71] phi (byte*) print_str::str#8 = (byte*) print_str::str#10 [phi:print_str/print_str::@2->print_str::@1#1] -- register_copy 
    jmp b1
    // print_str::@1
  b1:
    // [72] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2 -- _deref_pbuz1_neq_vbuc1_then_la1 
    ldy #0
    lda (str),y
    cmp #'@'
    bne b2
    jmp breturn
    // print_str::@return
  breturn:
    // [73] return 
    rts
    // print_str::@2
  b2:
    // [74] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (str),y
    ldy #0
    sta (print_char_cursor),y
    // [75] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc print_char_cursor
    bne !+
    inc print_char_cursor+1
  !:
    // [76] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8 -- pbuz1=_inc_pbuz1 
    inc str
    bne !+
    inc str+1
  !:
    jmp b1_from_b2
}
  // print_char
// Print a single char
print_char: {
    .const ch = ' '
    // [77] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (print_char_cursor),y
    // [78] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc print_char_cursor
    bne !+
    inc print_char_cursor+1
  !:
    jmp breturn
    // print_char::@return
  breturn:
    // [79] return 
    rts
}
  // print_word_decimal
// Print a word as DECIMAL
// print_word_decimal(word zeropage($10) w)
print_word_decimal: {
    .label w = $10
    // [81] (word) utoa::value#1 ← (word) print_word_decimal::w#3 -- vwuz1=vwuz2 
    lda w
    sta utoa.value
    lda w+1
    sta utoa.value+1
    // [82] call utoa 
    // [86] phi from print_word_decimal to utoa [phi:print_word_decimal->utoa]
  utoa_from_print_word_decimal:
    jsr utoa
    // [83] phi from print_word_decimal to print_word_decimal::@1 [phi:print_word_decimal->print_word_decimal::@1]
  b1_from_print_word_decimal:
    jmp b1
    // print_word_decimal::@1
  b1:
    // [84] call print_str 
    // [70] phi from print_word_decimal::@1 to print_str [phi:print_word_decimal::@1->print_str]
  print_str_from_b1:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#58 [phi:print_word_decimal::@1->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const byte[6]) decimal_digits#0 [phi:print_word_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta print_str.str
    lda #>decimal_digits
    sta print_str.str+1
    jsr print_str
    jmp breturn
    // print_word_decimal::@return
  breturn:
    // [85] return 
    rts
}
  // utoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// utoa(word zeropage($13) value, byte* zeropage($16) buffer)
utoa: {
    .const max_digits = 5
    .label _4 = $5b
    .label _11 = $58
    .label digit_value = $59
    .label digit = $12
    .label value = $13
    .label buffer = $16
    .label buffer_4 = $5c
    .label started = $15
    // [87] phi from utoa to utoa::@1 [phi:utoa->utoa::@1]
  b1_from_utoa:
    // [87] phi (byte*) utoa::buffer#11 = (const byte[6]) decimal_digits#0 [phi:utoa->utoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta buffer
    lda #>decimal_digits
    sta buffer+1
    // [87] phi (byte) utoa::started#2 = (byte) 0 [phi:utoa->utoa::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta started
    // [87] phi (word) utoa::value#2 = (word) utoa::value#1 [phi:utoa->utoa::@1#2] -- register_copy 
    // [87] phi (byte) utoa::digit#2 = (byte) 0 [phi:utoa->utoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta digit
    jmp b1
    // [87] phi from utoa::@2 to utoa::@1 [phi:utoa::@2->utoa::@1]
  b1_from_b2:
    // [87] phi (byte*) utoa::buffer#11 = (byte*) utoa::buffer#12 [phi:utoa::@2->utoa::@1#0] -- register_copy 
    // [87] phi (byte) utoa::started#2 = (byte) utoa::started#3 [phi:utoa::@2->utoa::@1#1] -- register_copy 
    // [87] phi (word) utoa::value#2 = (word) utoa::value#4 [phi:utoa::@2->utoa::@1#2] -- register_copy 
    // [87] phi (byte) utoa::digit#2 = (byte) utoa::digit#1 [phi:utoa::@2->utoa::@1#3] -- register_copy 
    jmp b1
    // utoa::@1
  b1:
    // [88] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda digit
    asl
    sta _11
    // [89] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES#0 + (byte~) utoa::$11) -- vwuz1=pwuc1_derefidx_vbuz2 
    ldy _11
    lda RADIX_DECIMAL_VALUES,y
    sta digit_value
    lda RADIX_DECIMAL_VALUES+1,y
    sta digit_value+1
    // [90] if((byte) 0!=(byte) utoa::started#2) goto utoa::@3 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp started
    bne b3
    jmp b6
    // utoa::@6
  b6:
    // [91] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@3 -- vwuz1_ge_vwuz2_then_la1 
    lda digit_value+1
    cmp value+1
    bne !+
    lda digit_value
    cmp value
    beq b3
  !:
    bcc b3
    // [92] phi from utoa::@6 to utoa::@2 [phi:utoa::@6->utoa::@2]
  b2_from_b6:
    // [92] phi (byte*) utoa::buffer#12 = (byte*) utoa::buffer#11 [phi:utoa::@6->utoa::@2#0] -- register_copy 
    // [92] phi (byte) utoa::started#3 = (byte) utoa::started#2 [phi:utoa::@6->utoa::@2#1] -- register_copy 
    // [92] phi (word) utoa::value#4 = (word) utoa::value#2 [phi:utoa::@6->utoa::@2#2] -- register_copy 
    jmp b2
    // utoa::@2
  b2:
    // [93] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [94] if((byte) utoa::digit#1<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda digit
    cmp #max_digits-1
    bcc b1_from_b2
    jmp b4
    // utoa::@4
  b4:
    // [95] (byte~) utoa::$4 ← (byte)(word) utoa::value#4 -- vbuz1=_byte_vwuz2 
    lda value
    sta _4
    // [96] *((byte*) utoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) utoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy _4
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // [97] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#12 -- pbuz1=_inc_pbuz2 
    lda buffer
    clc
    adc #1
    sta buffer_4
    lda buffer+1
    adc #0
    sta buffer_4+1
    // [98] *((byte*) utoa::buffer#4) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer_4),y
    jmp breturn
    // utoa::@return
  breturn:
    // [99] return 
    rts
    // utoa::@3
  b3:
    // [100] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11 -- pbuz1=pbuz2 
    lda buffer
    sta utoa_append.buffer
    lda buffer+1
    sta utoa_append.buffer+1
    // [101] (word) utoa_append::value#0 ← (word) utoa::value#2 -- vwuz1=vwuz2 
    lda value
    sta utoa_append.value
    lda value+1
    sta utoa_append.value+1
    // [102] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0 -- vwuz1=vwuz2 
    lda digit_value
    sta utoa_append.sub
    lda digit_value+1
    sta utoa_append.sub+1
    // [103] call utoa_append 
    // [107] phi from utoa::@3 to utoa_append [phi:utoa::@3->utoa_append]
  utoa_append_from_b3:
    jsr utoa_append
    // [104] (word) utoa_append::return#0 ← (word) utoa_append::value#2 -- vwuz1=vwuz2 
    lda utoa_append.value
    sta utoa_append.return
    lda utoa_append.value+1
    sta utoa_append.return+1
    jmp b5
    // utoa::@5
  b5:
    // [105] (word) utoa::value#0 ← (word) utoa_append::return#0 -- vwuz1=vwuz2 
    lda utoa_append.return
    sta value
    lda utoa_append.return+1
    sta value+1
    // [106] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [92] phi from utoa::@5 to utoa::@2 [phi:utoa::@5->utoa::@2]
  b2_from_b5:
    // [92] phi (byte*) utoa::buffer#12 = (byte*) utoa::buffer#3 [phi:utoa::@5->utoa::@2#0] -- register_copy 
    // [92] phi (byte) utoa::started#3 = (byte) 1 [phi:utoa::@5->utoa::@2#1] -- vbuz1=vbuc1 
    lda #1
    sta started
    // [92] phi (word) utoa::value#4 = (word) utoa::value#0 [phi:utoa::@5->utoa::@2#2] -- register_copy 
    jmp b2
}
  // utoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// utoa_append(byte* zeropage($5e) buffer, word zeropage($18) value, word zeropage($60) sub)
utoa_append: {
    .label buffer = $5e
    .label value = $18
    .label sub = $60
    .label return = $62
    .label digit = $1a
    // [108] phi from utoa_append to utoa_append::@1 [phi:utoa_append->utoa_append::@1]
  b1_from_utoa_append:
    // [108] phi (byte) utoa_append::digit#2 = (byte) 0 [phi:utoa_append->utoa_append::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta digit
    // [108] phi (word) utoa_append::value#2 = (word) utoa_append::value#0 [phi:utoa_append->utoa_append::@1#1] -- register_copy 
    jmp b1
    // utoa_append::@1
  b1:
    // [109] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 -- vwuz1_ge_vwuz2_then_la1 
    lda sub+1
    cmp value+1
    bne !+
    lda sub
    cmp value
    beq b2
  !:
    bcc b2
    jmp b3
    // utoa_append::@3
  b3:
    // [110] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) utoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy digit
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa_append::@return
  breturn:
    // [111] return 
    rts
    // utoa_append::@2
  b2:
    // [112] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [113] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda value
    sec
    sbc sub
    sta value
    lda value+1
    sbc sub+1
    sta value+1
    // [108] phi from utoa_append::@2 to utoa_append::@1 [phi:utoa_append::@2->utoa_append::@1]
  b1_from_b2:
    // [108] phi (byte) utoa_append::digit#2 = (byte) utoa_append::digit#1 [phi:utoa_append::@2->utoa_append::@1#0] -- register_copy 
    // [108] phi (word) utoa_append::value#2 = (word) utoa_append::value#1 [phi:utoa_append::@2->utoa_append::@1#1] -- register_copy 
    jmp b1
}
  // print_ln
// Print a newline
print_ln: {
    // [115] phi from print_ln print_ln::@1 to print_ln::@1 [phi:print_ln/print_ln::@1->print_ln::@1]
  b1_from_print_ln:
  b1_from_b1:
    // [115] phi (byte*) print_line_cursor#11 = (byte*) print_line_cursor#21 [phi:print_ln/print_ln::@1->print_ln::@1#0] -- register_copy 
    jmp b1
    // print_ln::@1
  b1:
    // [116] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc print_line_cursor
    sta print_line_cursor
    bcc !+
    inc print_line_cursor+1
  !:
    // [117] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 -- pbuz1_lt_pbuz2_then_la1 
    lda print_line_cursor+1
    cmp print_char_cursor+1
    bcc b1_from_b1
    bne !+
    lda print_line_cursor
    cmp print_char_cursor
    bcc b1_from_b1
  !:
    jmp breturn
    // print_ln::@return
  breturn:
    // [118] return 
    rts
}
  // print_dword_decimal
// Print a dword as DECIMAL
// print_dword_decimal(dword zeropage($52) w)
print_dword_decimal: {
    .label w = $52
    // [119] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0 -- vduz1=vduz2 
    lda w
    sta ultoa.value
    lda w+1
    sta ultoa.value+1
    lda w+2
    sta ultoa.value+2
    lda w+3
    sta ultoa.value+3
    // [120] call ultoa 
    // [124] phi from print_dword_decimal to ultoa [phi:print_dword_decimal->ultoa]
  ultoa_from_print_dword_decimal:
    jsr ultoa
    // [121] phi from print_dword_decimal to print_dword_decimal::@1 [phi:print_dword_decimal->print_dword_decimal::@1]
  b1_from_print_dword_decimal:
    jmp b1
    // print_dword_decimal::@1
  b1:
    // [122] call print_str 
    // [70] phi from print_dword_decimal::@1 to print_str [phi:print_dword_decimal::@1->print_str]
  print_str_from_b1:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:print_dword_decimal::@1->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const byte[$b]) decimal_digits_long#0 [phi:print_dword_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta print_str.str
    lda #>decimal_digits_long
    sta print_str.str+1
    jsr print_str
    jmp breturn
    // print_dword_decimal::@return
  breturn:
    // [123] return 
    rts
}
  // ultoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// ultoa(dword zeropage($1e) value, byte* zeropage($23) buffer)
ultoa: {
    .const max_digits = $a
    .label _4 = $69
    .label _11 = $64
    .label digit_value = $65
    .label digit = $1d
    .label value = $1e
    .label buffer = $23
    .label buffer_4 = $6a
    .label started = $22
    // [125] phi from ultoa to ultoa::@1 [phi:ultoa->ultoa::@1]
  b1_from_ultoa:
    // [125] phi (byte*) ultoa::buffer#11 = (const byte[$b]) decimal_digits_long#0 [phi:ultoa->ultoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta buffer
    lda #>decimal_digits_long
    sta buffer+1
    // [125] phi (byte) ultoa::started#2 = (byte) 0 [phi:ultoa->ultoa::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta started
    // [125] phi (dword) ultoa::value#2 = (dword) ultoa::value#1 [phi:ultoa->ultoa::@1#2] -- register_copy 
    // [125] phi (byte) ultoa::digit#2 = (byte) 0 [phi:ultoa->ultoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta digit
    jmp b1
    // [125] phi from ultoa::@2 to ultoa::@1 [phi:ultoa::@2->ultoa::@1]
  b1_from_b2:
    // [125] phi (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#12 [phi:ultoa::@2->ultoa::@1#0] -- register_copy 
    // [125] phi (byte) ultoa::started#2 = (byte) ultoa::started#3 [phi:ultoa::@2->ultoa::@1#1] -- register_copy 
    // [125] phi (dword) ultoa::value#2 = (dword) ultoa::value#4 [phi:ultoa::@2->ultoa::@1#2] -- register_copy 
    // [125] phi (byte) ultoa::digit#2 = (byte) ultoa::digit#1 [phi:ultoa::@2->ultoa::@1#3] -- register_copy 
    jmp b1
    // ultoa::@1
  b1:
    // [126] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 -- vbuz1=vbuz2_rol_2 
    lda digit
    asl
    asl
    sta _11
    // [127] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG#0 + (byte~) ultoa::$11) -- vduz1=pduc1_derefidx_vbuz2 
    ldy _11
    lda RADIX_DECIMAL_VALUES_LONG,y
    sta digit_value
    lda RADIX_DECIMAL_VALUES_LONG+1,y
    sta digit_value+1
    lda RADIX_DECIMAL_VALUES_LONG+2,y
    sta digit_value+2
    lda RADIX_DECIMAL_VALUES_LONG+3,y
    sta digit_value+3
    // [128] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@3 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp started
    bne b3
    jmp b6
    // ultoa::@6
  b6:
    // [129] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@3 -- vduz1_ge_vduz2_then_la1 
    lda value+3
    cmp digit_value+3
    bcc !+
    bne b3
    lda value+2
    cmp digit_value+2
    bcc !+
    bne b3
    lda value+1
    cmp digit_value+1
    bcc !+
    bne b3
    lda value
    cmp digit_value
    bcs b3
  !:
    // [130] phi from ultoa::@6 to ultoa::@2 [phi:ultoa::@6->ultoa::@2]
  b2_from_b6:
    // [130] phi (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#11 [phi:ultoa::@6->ultoa::@2#0] -- register_copy 
    // [130] phi (byte) ultoa::started#3 = (byte) ultoa::started#2 [phi:ultoa::@6->ultoa::@2#1] -- register_copy 
    // [130] phi (dword) ultoa::value#4 = (dword) ultoa::value#2 [phi:ultoa::@6->ultoa::@2#2] -- register_copy 
    jmp b2
    // ultoa::@2
  b2:
    // [131] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [132] if((byte) ultoa::digit#1<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda digit
    cmp #max_digits-1
    bcc b1_from_b2
    jmp b4
    // ultoa::@4
  b4:
    // [133] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4 -- vbuz1=_byte_vduz2 
    lda value
    sta _4
    // [134] *((byte*) ultoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) ultoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy _4
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // [135] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#12 -- pbuz1=_inc_pbuz2 
    lda buffer
    clc
    adc #1
    sta buffer_4
    lda buffer+1
    adc #0
    sta buffer_4+1
    // [136] *((byte*) ultoa::buffer#4) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer_4),y
    jmp breturn
    // ultoa::@return
  breturn:
    // [137] return 
    rts
    // ultoa::@3
  b3:
    // [138] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11 -- pbuz1=pbuz2 
    lda buffer
    sta ultoa_append.buffer
    lda buffer+1
    sta ultoa_append.buffer+1
    // [139] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2 -- vduz1=vduz2 
    lda value
    sta ultoa_append.value
    lda value+1
    sta ultoa_append.value+1
    lda value+2
    sta ultoa_append.value+2
    lda value+3
    sta ultoa_append.value+3
    // [140] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0 -- vduz1=vduz2 
    lda digit_value
    sta ultoa_append.sub
    lda digit_value+1
    sta ultoa_append.sub+1
    lda digit_value+2
    sta ultoa_append.sub+2
    lda digit_value+3
    sta ultoa_append.sub+3
    // [141] call ultoa_append 
    // [145] phi from ultoa::@3 to ultoa_append [phi:ultoa::@3->ultoa_append]
  ultoa_append_from_b3:
    jsr ultoa_append
    // [142] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2 -- vduz1=vduz2 
    lda ultoa_append.value
    sta ultoa_append.return
    lda ultoa_append.value+1
    sta ultoa_append.return+1
    lda ultoa_append.value+2
    sta ultoa_append.return+2
    lda ultoa_append.value+3
    sta ultoa_append.return+3
    jmp b5
    // ultoa::@5
  b5:
    // [143] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0 -- vduz1=vduz2 
    lda ultoa_append.return
    sta value
    lda ultoa_append.return+1
    sta value+1
    lda ultoa_append.return+2
    sta value+2
    lda ultoa_append.return+3
    sta value+3
    // [144] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [130] phi from ultoa::@5 to ultoa::@2 [phi:ultoa::@5->ultoa::@2]
  b2_from_b5:
    // [130] phi (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#3 [phi:ultoa::@5->ultoa::@2#0] -- register_copy 
    // [130] phi (byte) ultoa::started#3 = (byte) 1 [phi:ultoa::@5->ultoa::@2#1] -- vbuz1=vbuc1 
    lda #1
    sta started
    // [130] phi (dword) ultoa::value#4 = (dword) ultoa::value#0 [phi:ultoa::@5->ultoa::@2#2] -- register_copy 
    jmp b2
}
  // ultoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// ultoa_append(byte* zeropage($6c) buffer, dword zeropage($25) value, dword zeropage($6e) sub)
ultoa_append: {
    .label buffer = $6c
    .label value = $25
    .label sub = $6e
    .label return = $72
    .label digit = $29
    // [146] phi from ultoa_append to ultoa_append::@1 [phi:ultoa_append->ultoa_append::@1]
  b1_from_ultoa_append:
    // [146] phi (byte) ultoa_append::digit#2 = (byte) 0 [phi:ultoa_append->ultoa_append::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta digit
    // [146] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#0 [phi:ultoa_append->ultoa_append::@1#1] -- register_copy 
    jmp b1
    // ultoa_append::@1
  b1:
    // [147] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 -- vduz1_ge_vduz2_then_la1 
    lda value+3
    cmp sub+3
    bcc !+
    bne b2
    lda value+2
    cmp sub+2
    bcc !+
    bne b2
    lda value+1
    cmp sub+1
    bcc !+
    bne b2
    lda value
    cmp sub
    bcs b2
  !:
    jmp b3
    // ultoa_append::@3
  b3:
    // [148] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) ultoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy digit
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa_append::@return
  breturn:
    // [149] return 
    rts
    // ultoa_append::@2
  b2:
    // [150] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [151] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 -- vduz1=vduz1_minus_vduz2 
    lda value
    sec
    sbc sub
    sta value
    lda value+1
    sbc sub+1
    sta value+1
    lda value+2
    sbc sub+2
    sta value+2
    lda value+3
    sbc sub+3
    sta value+3
    // [146] phi from ultoa_append::@2 to ultoa_append::@1 [phi:ultoa_append::@2->ultoa_append::@1]
  b1_from_b2:
    // [146] phi (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#1 [phi:ultoa_append::@2->ultoa_append::@1#0] -- register_copy 
    // [146] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#1 [phi:ultoa_append::@2->ultoa_append::@1#1] -- register_copy 
    jmp b1
}
  // div32u16u
// Divide unsigned 32-bit dword dividend with a 16-bit word divisor
// The 16-bit word remainder can be found in rem16u after the division
// div32u16u(dword zeropage($44) dividend)
div32u16u: {
    .label divisor = CLOCKS_PER_SEC/$64
    .label quotient_hi = $78
    .label quotient_lo = $7c
    .label return = $7e
    .label dividend = $44
    .label return_2 = $48
    // [152] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 -- vwuz1=_hi_vduz2 
    lda dividend+2
    sta divr16u.dividend
    lda dividend+3
    sta divr16u.dividend+1
    // [153] call divr16u 
    // [163] phi from div32u16u to divr16u [phi:div32u16u->divr16u]
  divr16u_from_div32u16u:
    // [163] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#1 [phi:div32u16u->divr16u#0] -- register_copy 
    // [163] phi (word) divr16u::rem#10 = (byte) 0 [phi:div32u16u->divr16u#1] -- vwuz1=vbuc1 
    lda #<0
    sta divr16u.rem
    lda #>0
    sta divr16u.rem+1
    jsr divr16u
    // [154] (word) divr16u::return#2 ← (word) divr16u::return#0 -- vwuz1=vwuz2 
    lda divr16u.return
    sta divr16u.return_2
    lda divr16u.return+1
    sta divr16u.return_2+1
    jmp b1
    // div32u16u::@1
  b1:
    // [155] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda divr16u.return_2
    sta quotient_hi
    lda divr16u.return_2+1
    sta quotient_hi+1
    // [156] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 -- vwuz1=_lo_vduz2 
    lda dividend
    sta divr16u.dividend
    lda dividend+1
    sta divr16u.dividend+1
    // [157] (word) divr16u::rem#4 ← (word) rem16u#1 -- vwuz1=vwuz2 
    lda rem16u
    sta divr16u.rem
    lda rem16u+1
    sta divr16u.rem+1
    // [158] call divr16u 
    // [163] phi from div32u16u::@1 to divr16u [phi:div32u16u::@1->divr16u]
  divr16u_from_b1:
    // [163] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#2 [phi:div32u16u::@1->divr16u#0] -- register_copy 
    // [163] phi (word) divr16u::rem#10 = (word) divr16u::rem#4 [phi:div32u16u::@1->divr16u#1] -- register_copy 
    jsr divr16u
    // [159] (word) divr16u::return#3 ← (word) divr16u::return#0 -- vwuz1=vwuz2 
    lda divr16u.return
    sta divr16u.return_3
    lda divr16u.return+1
    sta divr16u.return_3+1
    jmp b2
    // div32u16u::@2
  b2:
    // [160] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3 -- vwuz1=vwuz2 
    lda divr16u.return_3
    sta quotient_lo
    lda divr16u.return_3+1
    sta quotient_lo+1
    // [161] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 -- vduz1=vwuz2_dword_vwuz3 
    lda quotient_hi
    sta return+2
    lda quotient_hi+1
    sta return+3
    lda quotient_lo
    sta return
    lda quotient_lo+1
    sta return+1
    jmp breturn
    // div32u16u::@return
  breturn:
    // [162] return 
    rts
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($2c) dividend, word zeropage($2a) rem)
divr16u: {
    .label _1 = $82
    .label _2 = $83
    .label rem = $2a
    .label dividend = $2c
    .label quotient = $2e
    .label i = $30
    .label return = $2e
    .label return_2 = $76
    .label return_3 = $7a
    // [164] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
  b1_from_divr16u:
    // [164] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    // [164] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta quotient
    lda #>0
    sta quotient+1
    // [164] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#5 [phi:divr16u->divr16u::@1#2] -- register_copy 
    // [164] phi (word) divr16u::rem#5 = (word) divr16u::rem#10 [phi:divr16u->divr16u::@1#3] -- register_copy 
    jmp b1
    // [164] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
  b1_from_b3:
    // [164] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [164] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [164] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [164] phi (word) divr16u::rem#5 = (word) divr16u::rem#11 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    jmp b1
    // divr16u::@1
  b1:
    // [165] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl rem
    rol rem+1
    // [166] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 -- vbuz1=_hi_vwuz2 
    lda dividend+1
    sta _1
    // [167] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and _1
    sta _2
    // [168] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuz1_eq_0_then_la1 
    lda _2
    cmp #0
    beq b2_from_b1
    jmp b4
    // divr16u::@4
  b4:
    // [169] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora rem
    sta rem
    // [170] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
  b2_from_b1:
  b2_from_b4:
    // [170] phi (word) divr16u::rem#6 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    jmp b2
    // divr16u::@2
  b2:
    // [171] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl dividend
    rol dividend+1
    // [172] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl quotient
    rol quotient+1
    // [173] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuc1_then_la1 
    lda rem+1
    cmp #>div32u16u.divisor
    bcc b3_from_b2
    bne !+
    lda rem
    cmp #<div32u16u.divisor
    bcc b3_from_b2
  !:
    jmp b5
    // divr16u::@5
  b5:
    // [174] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc quotient
    bne !+
    inc quotient+1
  !:
    // [175] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 -- vwuz1=vwuz1_minus_vwuc1 
    lda rem
    sec
    sbc #<div32u16u.divisor
    sta rem
    lda rem+1
    sbc #>div32u16u.divisor
    sta rem+1
    // [176] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
  b3_from_b2:
  b3_from_b5:
    // [176] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [176] phi (word) divr16u::rem#11 = (word) divr16u::rem#6 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    jmp b3
    // divr16u::@3
  b3:
    // [177] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [178] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$10
    cmp i
    bne b1_from_b3
    jmp b6
    // divr16u::@6
  b6:
    // [179] (word) rem16u#1 ← (word) divr16u::rem#11 -- vwuz1=vwuz2 
    lda rem
    sta rem16u
    lda rem+1
    sta rem16u+1
    jmp breturn
    // divr16u::@return
  breturn:
    // [180] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $86
    .label return_2 = $38
    // [181] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta return+3
    jmp breturn
    // clock::@return
  breturn:
    // [182] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [183] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // [184] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [185] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [186] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [187] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    jmp breturn
    // clock_start::@return
  breturn:
    // [188] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage($33) str, byte zeropage($35) c, word zeropage($31) num)
memset: {
    .label end = $8a
    .label dst = $36
    .label num = $31
    .label str = $33
    .label c = $35
    // [190] if((word) memset::num#2<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda num
    bne !+
    lda num+1
    beq breturn
  !:
    jmp b1
    // memset::@1
  b1:
    // [191] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 -- pbuz1=pbuz2_plus_vwuz3 
    lda str
    clc
    adc num
    sta end
    lda str+1
    adc num+1
    sta end+1
    // [192] (byte*~) memset::dst#3 ← (byte*)(void*) memset::str#3 -- pbuz1=pbuz2 
    lda str
    sta dst
    lda str+1
    sta dst+1
    // [193] phi from memset::@1 memset::@2 to memset::@2 [phi:memset::@1/memset::@2->memset::@2]
  b2_from_b1:
  b2_from_b2:
    // [193] phi (byte*) memset::dst#2 = (byte*~) memset::dst#3 [phi:memset::@1/memset::@2->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [194] *((byte*) memset::dst#2) ← (byte) memset::c#3 -- _deref_pbuz1=vbuz2 
    lda c
    ldy #0
    sta (dst),y
    // [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
    // [196] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuz2_then_la1 
    lda dst+1
    cmp end+1
    bne b2_from_b2
    lda dst
    cmp end
    bne b2_from_b2
    jmp breturn
    // memset::@return
  breturn:
    // [197] return 
    rts
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // [199] call memset 
    // [189] phi from print_cls to memset [phi:print_cls->memset]
  memset_from_print_cls:
    // [189] phi (byte) memset::c#3 = (byte) ' ' [phi:print_cls->memset#0] -- vbuz1=vbuc1 
    lda #' '
    sta memset.c
    // [189] phi (void*) memset::str#3 = (void*)(byte*) 1024 [phi:print_cls->memset#1] -- pvoz1=pvoc1 
    lda #<$400
    sta memset.str
    lda #>$400
    sta memset.str+1
    // [189] phi (word) memset::num#2 = (word) $3e8 [phi:print_cls->memset#2] -- vwuz1=vwuc1 
    lda #<$3e8
    sta memset.num
    lda #>$3e8
    sta memset.num+1
    jsr memset
    jmp breturn
    // print_cls::@return
  breturn:
    // [200] return 
    rts
}
  // File Data
  // The digits used for numbers
  DIGITS: .text "0123456789abcdef"
  // Values of decimal digits
  RADIX_DECIMAL_VALUES: .word $2710, $3e8, $64, $a
  // Values of decimal digits
  RADIX_DECIMAL_VALUES_LONG: .dword $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a
  // Digits used for storing the decimal word
  decimal_digits: .fill 6, 0
  // Digits used for storing the decimal word
  decimal_digits_long: .fill $b, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] (byte*~) print_char_cursor#89 ← (byte*) print_line_cursor#1 [ print_char_cursor#89 print_line_cursor#1 ] ( main:2 [ print_char_cursor#89 print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [23] if((word) main::i#11<(const byte) SQRT_COUNT#0) goto main::@2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ) always clobbers reg byte a 
Statement [26] (dword) clock::return#2 ← (dword) clock::return#0 [ print_line_cursor#1 clock::return#2 ] ( main:2 [ print_line_cursor#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [27] (dword~) main::$10 ← (dword) clock::return#2 [ print_line_cursor#1 main::$10 ] ( main:2 [ print_line_cursor#1 main::$10 ] ) always clobbers reg byte a 
Statement [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT#0 [ print_line_cursor#1 main::cyclecount#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 ] ) always clobbers reg byte a 
Statement [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ) always clobbers reg byte a 
Statement [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ) always clobbers reg byte a 
Statement [32] (dword~) main::$14 ← (dword) div32u16u::return#2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ) always clobbers reg byte a 
Statement [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ) always clobbers reg byte a 
Statement [34] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#90 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#90 ] ) always clobbers reg byte a 
Statement [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [45] (byte*~) main::$38 ← (const byte*) sieve#0 + (word) main::i#10 [ main::i#10 print_char_cursor#62 main::$38 ] ( main:2 [ main::i#10 print_char_cursor#62 main::$38 ] ) always clobbers reg byte a 
Statement [46] if((byte) 0!=*((byte*~) main::$38)) goto main::@29 [ main::i#10 print_char_cursor#62 ] ( main:2 [ main::i#10 print_char_cursor#62 ] ) always clobbers reg byte a reg byte y 
Statement [47] (word) print_word_decimal::w#2 ← (word) main::i#10 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ( main:2 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ) always clobbers reg byte a 
Statement [48] (byte*~) print_char_cursor#96 ← (byte*) print_char_cursor#62 [ main::i#10 print_word_decimal::w#2 print_char_cursor#96 ] ( main:2 [ main::i#10 print_word_decimal::w#2 print_char_cursor#96 ] ) always clobbers reg byte a 
Statement [54] if((word) main::i#3<(word) $514) goto main::@28 [ main::i#3 print_char_cursor#63 ] ( main:2 [ main::i#3 print_char_cursor#63 ] ) always clobbers reg byte a 
Statement [58] (byte*~) print_char_cursor#99 ← (byte*) print_char_cursor#63 [ main::i#3 print_char_cursor#99 ] ( main:2 [ main::i#3 print_char_cursor#99 ] ) always clobbers reg byte a 
Statement [59] (byte*~) print_char_cursor#101 ← (byte*) print_char_cursor#62 [ main::i#10 print_char_cursor#101 ] ( main:2 [ main::i#10 print_char_cursor#101 ] ) always clobbers reg byte a 
Statement [60] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ) always clobbers reg byte a reg byte y 
Statement [61] (word) main::j#0 ← (word) main::i#11 << (byte) 1 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 ] ) always clobbers reg byte a 
Statement [62] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 main::s#0 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 main::s#0 ] ) always clobbers reg byte a 
Statement [64] if((word) main::j#2<(const word) COUNT#0) goto main::@6 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a 
Statement [67] *((byte*) main::s#2) ← (byte) 1 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [68] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#11 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#1 ] ) always clobbers reg byte a 
Statement [69] (word) main::j#1 ← (word) main::j#2 + (word) main::i#11 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#1 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#1 main::s#1 ] ) always clobbers reg byte a 
Statement [72] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2 [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:56 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:84 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:84 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:49::print_str:84 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:122 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [74] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:56 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:84 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:84 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:49::print_str:84 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:122 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [77] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 [ print_char_cursor#2 ] ( main:2::print_char:51 [ main::i#10 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [81] (word) utoa::value#1 ← (word) print_word_decimal::w#3 [ print_char_cursor#58 utoa::value#1 ] ( main:2::print_word_decimal:15 [ print_line_cursor#1 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:37 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:49 [ main::i#10 print_char_cursor#58 utoa::value#1 ] ) always clobbers reg byte a 
Statement [88] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:21 [ utoa::started#2 utoa::started#3 ]
Statement [89] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES#0 + (byte~) utoa::$11) [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [91] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@3 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [95] (byte~) utoa::$4 ← (byte)(word) utoa::value#4 [ utoa::buffer#12 utoa::$4 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#12 utoa::$4 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#12 utoa::$4 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::buffer#12 utoa::$4 ] ) always clobbers reg byte a 
Statement [96] *((byte*) utoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) utoa::$4) [ utoa::buffer#12 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#12 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#12 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::buffer#12 ] ) always clobbers reg byte a reg byte y 
Statement [97] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#12 [ utoa::buffer#4 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#4 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#4 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::buffer#4 ] ) always clobbers reg byte a 
Statement [98] *((byte*) utoa::buffer#4) ← (byte) 0 [ ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 ] ) always clobbers reg byte a reg byte y 
Statement [100] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11 [ utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [101] (word) utoa_append::value#0 ← (word) utoa::value#2 [ utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ) always clobbers reg byte a 
Statement [102] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0 [ utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [104] (word) utoa_append::return#0 ← (word) utoa_append::value#2 [ utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ) always clobbers reg byte a 
Statement [105] (word) utoa::value#0 ← (word) utoa_append::return#0 [ utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ) always clobbers reg byte a 
Statement [109] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ( main:2::print_word_decimal:15::utoa:82::utoa_append:103 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:37::utoa:82::utoa_append:103 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:49::utoa:82::utoa_append:103 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ]
Statement [110] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) utoa_append::digit#2) [ utoa_append::value#2 ] ( main:2::print_word_decimal:15::utoa:82::utoa_append:103 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:37::utoa:82::utoa_append:103 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:49::utoa:82::utoa_append:103 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Statement [113] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ( main:2::print_word_decimal:15::utoa:82::utoa_append:103 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:37::utoa:82::utoa_append:103 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:49::utoa:82::utoa_append:103 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [116] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [117] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [119] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0 [ print_char_cursor#2 ultoa::value#1 ] ( main:2::print_dword_decimal:41 [ print_line_cursor#1 print_char_cursor#2 ultoa::value#1 ] ) always clobbers reg byte a 
Statement [126] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#3 ]
Statement [127] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG#0 + (byte~) ultoa::$11) [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [129] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@3 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [133] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4 [ ultoa::buffer#12 ultoa::$4 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#12 ultoa::$4 ] ) always clobbers reg byte a 
Statement [134] *((byte*) ultoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) ultoa::$4) [ ultoa::buffer#12 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#12 ] ) always clobbers reg byte a reg byte y 
Statement [135] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#12 [ ultoa::buffer#4 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#4 ] ) always clobbers reg byte a 
Statement [136] *((byte*) ultoa::buffer#4) ← (byte) 0 [ ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [138] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11 [ ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [139] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ) always clobbers reg byte a 
Statement [140] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [142] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ) always clobbers reg byte a 
Statement [143] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ) always clobbers reg byte a 
Statement [147] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ( main:2::print_dword_decimal:41::ultoa:120::ultoa_append:141 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ]
Statement [148] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) ultoa_append::digit#2) [ ultoa_append::value#2 ] ( main:2::print_dword_decimal:41::ultoa:120::ultoa_append:141 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Statement [151] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ( main:2::print_dword_decimal:41::ultoa:120::ultoa_append:141 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [152] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 [ div32u16u::dividend#0 divr16u::dividend#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#1 ] ) always clobbers reg byte a 
Statement [154] (word) divr16u::return#2 ← (word) divr16u::return#0 [ div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [155] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 [ div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [156] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 [ div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [157] (word) divr16u::rem#4 ← (word) rem16u#1 [ div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ) always clobbers reg byte a 
Statement [159] (word) divr16u::return#3 ← (word) divr16u::return#0 [ div32u16u::quotient_hi#0 divr16u::return#3 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#3 ] ) always clobbers reg byte a 
Statement [160] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3 [ div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ) always clobbers reg byte a 
Statement [161] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 [ div32u16u::return#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#0 ] ) always clobbers reg byte a 
Statement [166] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ]
Statement [169] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ) always clobbers reg byte a 
Statement [173] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 [ divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ) always clobbers reg byte a 
Statement [175] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 [ divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ) always clobbers reg byte a 
Statement [179] (word) rem16u#1 ← (word) divr16u::rem#11 [ divr16u::return#0 rem16u#1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#0 rem16u#1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [181] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) [ clock::return#0 ] ( main:2::clock:25 [ print_line_cursor#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [183] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [184] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [185] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [186] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [187] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [190] if((word) memset::num#2<=(byte) 0) goto memset::@return [ memset::num#2 memset::str#3 memset::c#3 ] ( main:2::memset:19 [ print_line_cursor#1 memset::num#2 memset::str#3 memset::c#3 ] main:2::print_cls:7::memset:199 [ memset::num#2 memset::str#3 memset::c#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:53 [ memset::c#3 ]
Statement [191] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 [ memset::str#3 memset::c#3 memset::end#0 ] ( main:2::memset:19 [ print_line_cursor#1 memset::str#3 memset::c#3 memset::end#0 ] main:2::print_cls:7::memset:199 [ memset::str#3 memset::c#3 memset::end#0 ] ) always clobbers reg byte a 
Statement [192] (byte*~) memset::dst#3 ← (byte*)(void*) memset::str#3 [ memset::c#3 memset::end#0 memset::dst#3 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#3 memset::end#0 memset::dst#3 ] main:2::print_cls:7::memset:199 [ memset::c#3 memset::end#0 memset::dst#3 ] ) always clobbers reg byte a 
Statement [194] *((byte*) memset::dst#2) ← (byte) memset::c#3 [ memset::c#3 memset::end#0 memset::dst#2 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#3 memset::end#0 memset::dst#2 ] main:2::print_cls:7::memset:199 [ memset::c#3 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:53 [ memset::c#3 ]
Statement [196] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@2 [ memset::c#3 memset::end#0 memset::dst#1 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#3 memset::end#0 memset::dst#1 ] main:2::print_cls:7::memset:199 [ memset::c#3 memset::end#0 memset::dst#1 ] ) always clobbers reg byte a 
Statement [6] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] (byte*~) print_char_cursor#89 ← (byte*) print_line_cursor#1 [ print_char_cursor#89 print_line_cursor#1 ] ( main:2 [ print_char_cursor#89 print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [23] if((word) main::i#11<(const byte) SQRT_COUNT#0) goto main::@2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ) always clobbers reg byte a 
Statement [26] (dword) clock::return#2 ← (dword) clock::return#0 [ print_line_cursor#1 clock::return#2 ] ( main:2 [ print_line_cursor#1 clock::return#2 ] ) always clobbers reg byte a 
Statement [27] (dword~) main::$10 ← (dword) clock::return#2 [ print_line_cursor#1 main::$10 ] ( main:2 [ print_line_cursor#1 main::$10 ] ) always clobbers reg byte a 
Statement [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT#0 [ print_line_cursor#1 main::cyclecount#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 ] ) always clobbers reg byte a 
Statement [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 ] ) always clobbers reg byte a 
Statement [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#2 ] ) always clobbers reg byte a 
Statement [32] (dword~) main::$14 ← (dword) div32u16u::return#2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::$14 ] ) always clobbers reg byte a 
Statement [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 ] ) always clobbers reg byte a 
Statement [34] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#90 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#90 ] ) always clobbers reg byte a 
Statement [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 main::cyclecount#0 print_word_decimal::w#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ( main:2 [ print_line_cursor#1 print_dword_decimal::w#0 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [45] (byte*~) main::$38 ← (const byte*) sieve#0 + (word) main::i#10 [ main::i#10 print_char_cursor#62 main::$38 ] ( main:2 [ main::i#10 print_char_cursor#62 main::$38 ] ) always clobbers reg byte a 
Statement [46] if((byte) 0!=*((byte*~) main::$38)) goto main::@29 [ main::i#10 print_char_cursor#62 ] ( main:2 [ main::i#10 print_char_cursor#62 ] ) always clobbers reg byte a reg byte y 
Statement [47] (word) print_word_decimal::w#2 ← (word) main::i#10 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ( main:2 [ main::i#10 print_char_cursor#62 print_word_decimal::w#2 ] ) always clobbers reg byte a 
Statement [48] (byte*~) print_char_cursor#96 ← (byte*) print_char_cursor#62 [ main::i#10 print_word_decimal::w#2 print_char_cursor#96 ] ( main:2 [ main::i#10 print_word_decimal::w#2 print_char_cursor#96 ] ) always clobbers reg byte a 
Statement [54] if((word) main::i#3<(word) $514) goto main::@28 [ main::i#3 print_char_cursor#63 ] ( main:2 [ main::i#3 print_char_cursor#63 ] ) always clobbers reg byte a 
Statement [58] (byte*~) print_char_cursor#99 ← (byte*) print_char_cursor#63 [ main::i#3 print_char_cursor#99 ] ( main:2 [ main::i#3 print_char_cursor#99 ] ) always clobbers reg byte a 
Statement [59] (byte*~) print_char_cursor#101 ← (byte*) print_char_cursor#62 [ main::i#10 print_char_cursor#101 ] ( main:2 [ main::i#10 print_char_cursor#101 ] ) always clobbers reg byte a 
Statement [60] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 ] ) always clobbers reg byte a reg byte y 
Statement [61] (word) main::j#0 ← (word) main::i#11 << (byte) 1 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 ] ) always clobbers reg byte a 
Statement [62] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 main::s#0 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#0 main::s#0 ] ) always clobbers reg byte a 
Statement [64] if((word) main::j#2<(const word) COUNT#0) goto main::@6 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a 
Statement [67] *((byte*) main::s#2) ← (byte) 1 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [68] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#11 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#2 main::s#1 ] ) always clobbers reg byte a 
Statement [69] (word) main::j#1 ← (word) main::j#2 + (word) main::i#11 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#1 main::s#1 ] ( main:2 [ print_line_cursor#1 main::i#11 main::sieve_i#2 main::j#1 main::s#1 ] ) always clobbers reg byte a 
Statement [72] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2 [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:56 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:84 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:84 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:49::print_str:84 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:122 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [74] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) [ print_char_cursor#2 print_str::str#8 ] ( main:2::print_str:9 [ print_char_cursor#2 print_str::str#8 ] main:2::print_str:13 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_str:35 [ print_line_cursor#1 main::cyclecount#0 main::sec100s#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:39 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_str:56 [ print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:15::print_str:84 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:37::print_str:84 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#2 print_str::str#8 ] main:2::print_word_decimal:49::print_str:84 [ main::i#10 print_char_cursor#2 print_str::str#8 ] main:2::print_dword_decimal:41::print_str:122 [ print_line_cursor#1 print_char_cursor#2 print_str::str#8 ] ) always clobbers reg byte a reg byte y 
Statement [77] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 [ print_char_cursor#2 ] ( main:2::print_char:51 [ main::i#10 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [81] (word) utoa::value#1 ← (word) print_word_decimal::w#3 [ print_char_cursor#58 utoa::value#1 ] ( main:2::print_word_decimal:15 [ print_line_cursor#1 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:37 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::value#1 ] main:2::print_word_decimal:49 [ main::i#10 print_char_cursor#58 utoa::value#1 ] ) always clobbers reg byte a 
Statement [88] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::$11 ] ) always clobbers reg byte a 
Statement [89] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES#0 + (byte~) utoa::$11) [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [91] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@3 [ utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::started#2 utoa::buffer#11 utoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [95] (byte~) utoa::$4 ← (byte)(word) utoa::value#4 [ utoa::buffer#12 utoa::$4 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#12 utoa::$4 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#12 utoa::$4 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::buffer#12 utoa::$4 ] ) always clobbers reg byte a 
Statement [96] *((byte*) utoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) utoa::$4) [ utoa::buffer#12 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#12 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#12 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::buffer#12 ] ) always clobbers reg byte a reg byte y 
Statement [97] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#12 [ utoa::buffer#4 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::buffer#4 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::buffer#4 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::buffer#4 ] ) always clobbers reg byte a 
Statement [98] *((byte*) utoa::buffer#4) ← (byte) 0 [ ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 ] ) always clobbers reg byte a reg byte y 
Statement [100] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11 [ utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::value#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [101] (word) utoa_append::value#0 ← (word) utoa::value#2 [ utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::digit_value#0 utoa_append::buffer#0 utoa_append::value#0 ] ) always clobbers reg byte a 
Statement [102] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0 [ utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::value#0 utoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [104] (word) utoa_append::return#0 ← (word) utoa_append::value#2 [ utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::return#0 ] ) always clobbers reg byte a 
Statement [105] (word) utoa::value#0 ← (word) utoa_append::return#0 [ utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ( main:2::print_word_decimal:15::utoa:82 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:37::utoa:82 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] main:2::print_word_decimal:49::utoa:82 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa::value#0 ] ) always clobbers reg byte a 
Statement [109] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ( main:2::print_word_decimal:15::utoa:82::utoa_append:103 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:37::utoa:82::utoa_append:103 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] main:2::print_word_decimal:49::utoa:82::utoa_append:103 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#2 utoa_append::digit#2 ] ) always clobbers reg byte a 
Statement [110] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) utoa_append::digit#2) [ utoa_append::value#2 ] ( main:2::print_word_decimal:15::utoa:82::utoa_append:103 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:37::utoa:82::utoa_append:103 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] main:2::print_word_decimal:49::utoa:82::utoa_append:103 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Statement [113] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 [ utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ( main:2::print_word_decimal:15::utoa:82::utoa_append:103 [ print_line_cursor#1 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:37::utoa:82::utoa_append:103 [ print_line_cursor#1 main::cyclecount#0 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] main:2::print_word_decimal:49::utoa:82::utoa_append:103 [ main::i#10 print_char_cursor#58 utoa::digit#2 utoa::buffer#11 utoa_append::buffer#0 utoa_append::sub#0 utoa_append::value#1 utoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [116] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [117] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 [ print_line_cursor#1 print_char_cursor#2 ] ( main:2::print_ln:11 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:17 [ print_line_cursor#1 print_char_cursor#2 ] main:2::print_ln:43 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a 
Statement [119] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0 [ print_char_cursor#2 ultoa::value#1 ] ( main:2::print_dword_decimal:41 [ print_line_cursor#1 print_char_cursor#2 ultoa::value#1 ] ) always clobbers reg byte a 
Statement [126] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::$11 ] ) always clobbers reg byte a 
Statement [127] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG#0 + (byte~) ultoa::$11) [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [129] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@3 [ ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::started#2 ultoa::buffer#11 ultoa::digit_value#0 ] ) always clobbers reg byte a 
Statement [133] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4 [ ultoa::buffer#12 ultoa::$4 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#12 ultoa::$4 ] ) always clobbers reg byte a 
Statement [134] *((byte*) ultoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) ultoa::$4) [ ultoa::buffer#12 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#12 ] ) always clobbers reg byte a reg byte y 
Statement [135] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#12 [ ultoa::buffer#4 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::buffer#4 ] ) always clobbers reg byte a 
Statement [136] *((byte*) ultoa::buffer#4) ← (byte) 0 [ ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [138] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11 [ ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::value#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ] ) always clobbers reg byte a 
Statement [139] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::digit_value#0 ultoa_append::buffer#0 ultoa_append::value#0 ] ) always clobbers reg byte a 
Statement [140] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::value#0 ultoa_append::sub#0 ] ) always clobbers reg byte a 
Statement [142] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2 [ ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::return#0 ] ) always clobbers reg byte a 
Statement [143] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0 [ ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ( main:2::print_dword_decimal:41::ultoa:120 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa::value#0 ] ) always clobbers reg byte a 
Statement [147] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ( main:2::print_dword_decimal:41::ultoa:120::ultoa_append:141 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#2 ultoa_append::digit#2 ] ) always clobbers reg byte a 
Statement [148] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) ultoa_append::digit#2) [ ultoa_append::value#2 ] ( main:2::print_dword_decimal:41::ultoa:120::ultoa_append:141 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::value#2 ] ) always clobbers reg byte a reg byte y 
Statement [151] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 [ ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ( main:2::print_dword_decimal:41::ultoa:120::ultoa_append:141 [ print_line_cursor#1 print_char_cursor#2 ultoa::digit#2 ultoa::buffer#11 ultoa_append::buffer#0 ultoa_append::sub#0 ultoa_append::value#1 ultoa_append::digit#1 ] ) always clobbers reg byte a 
Statement [152] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 [ div32u16u::dividend#0 divr16u::dividend#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#1 ] ) always clobbers reg byte a 
Statement [154] (word) divr16u::return#2 ← (word) divr16u::return#0 [ div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [155] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 [ div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 div32u16u::quotient_hi#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [156] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 [ div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 rem16u#1 ] ) always clobbers reg byte a 
Statement [157] (word) divr16u::rem#4 ← (word) rem16u#1 [ div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#2 divr16u::rem#4 ] ) always clobbers reg byte a 
Statement [159] (word) divr16u::return#3 ← (word) divr16u::return#0 [ div32u16u::quotient_hi#0 divr16u::return#3 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#3 ] ) always clobbers reg byte a 
Statement [160] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3 [ div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 div32u16u::quotient_lo#0 ] ) always clobbers reg byte a 
Statement [161] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 [ div32u16u::return#0 ] ( main:2::div32u16u:30 [ print_line_cursor#1 main::cyclecount#0 div32u16u::return#0 ] ) always clobbers reg byte a 
Statement [166] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#0 divr16u::$1 ] ) always clobbers reg byte a 
Statement [169] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 [ divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::dividend#3 divr16u::quotient#3 divr16u::i#2 divr16u::rem#1 ] ) always clobbers reg byte a 
Statement [173] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 [ divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::rem#6 divr16u::quotient#1 ] ) always clobbers reg byte a 
Statement [175] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 [ divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::i#2 divr16u::dividend#0 divr16u::quotient#2 divr16u::rem#2 ] ) always clobbers reg byte a 
Statement [179] (word) rem16u#1 ← (word) divr16u::rem#11 [ divr16u::return#0 rem16u#1 ] ( main:2::div32u16u:30::divr16u:153 [ print_line_cursor#1 main::cyclecount#0 div32u16u::dividend#0 divr16u::return#0 rem16u#1 ] main:2::div32u16u:30::divr16u:158 [ print_line_cursor#1 main::cyclecount#0 div32u16u::quotient_hi#0 divr16u::return#0 rem16u#1 ] ) always clobbers reg byte a 
Statement [181] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) [ clock::return#0 ] ( main:2::clock:25 [ print_line_cursor#1 clock::return#0 ] ) always clobbers reg byte a 
Statement [183] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [184] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [185] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [186] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [187] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 [ ] ( main:2::clock_start:21 [ print_line_cursor#1 ] ) always clobbers reg byte a 
Statement [190] if((word) memset::num#2<=(byte) 0) goto memset::@return [ memset::num#2 memset::str#3 memset::c#3 ] ( main:2::memset:19 [ print_line_cursor#1 memset::num#2 memset::str#3 memset::c#3 ] main:2::print_cls:7::memset:199 [ memset::num#2 memset::str#3 memset::c#3 ] ) always clobbers reg byte a 
Statement [191] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 [ memset::str#3 memset::c#3 memset::end#0 ] ( main:2::memset:19 [ print_line_cursor#1 memset::str#3 memset::c#3 memset::end#0 ] main:2::print_cls:7::memset:199 [ memset::str#3 memset::c#3 memset::end#0 ] ) always clobbers reg byte a 
Statement [192] (byte*~) memset::dst#3 ← (byte*)(void*) memset::str#3 [ memset::c#3 memset::end#0 memset::dst#3 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#3 memset::end#0 memset::dst#3 ] main:2::print_cls:7::memset:199 [ memset::c#3 memset::end#0 memset::dst#3 ] ) always clobbers reg byte a 
Statement [194] *((byte*) memset::dst#2) ← (byte) memset::c#3 [ memset::c#3 memset::end#0 memset::dst#2 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#3 memset::end#0 memset::dst#2 ] main:2::print_cls:7::memset:199 [ memset::c#3 memset::end#0 memset::dst#2 ] ) always clobbers reg byte a reg byte y 
Statement [196] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@2 [ memset::c#3 memset::end#0 memset::dst#1 ] ( main:2::memset:19 [ print_line_cursor#1 memset::c#3 memset::end#0 memset::dst#1 ] main:2::print_cls:7::memset:199 [ memset::c#3 memset::end#0 memset::dst#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_WORD:2 [ main::i#11 main::i#2 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] : zp ZP_WORD:4 , 
Potential registers zp ZP_WORD:6 [ main::i#10 main::i#3 ] : zp ZP_WORD:6 , 
Potential registers zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] : zp ZP_WORD:8 , 
Potential registers zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] : zp ZP_WORD:10 , 
Potential registers zp ZP_WORD:12 [ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ] : zp ZP_WORD:12 , 
Potential registers zp ZP_WORD:14 [ print_str::str#8 print_str::str#10 print_str::str#0 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_WORD:16 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] : zp ZP_WORD:16 , 
Potential registers zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] : zp ZP_BYTE:18 , reg byte x , 
Potential registers zp ZP_WORD:19 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ] : zp ZP_WORD:19 , 
Potential registers zp ZP_BYTE:21 [ utoa::started#2 utoa::started#3 ] : zp ZP_BYTE:21 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ] : zp ZP_WORD:22 , 
Potential registers zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] : zp ZP_WORD:24 , 
Potential registers zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ] : zp ZP_BYTE:26 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ] : zp ZP_WORD:27 , 
Potential registers zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] : zp ZP_BYTE:29 , reg byte x , 
Potential registers zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ] : zp ZP_DWORD:30 , 
Potential registers zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#3 ] : zp ZP_BYTE:34 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ] : zp ZP_WORD:35 , 
Potential registers zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] : zp ZP_DWORD:37 , 
Potential registers zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ] : zp ZP_BYTE:41 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] : zp ZP_WORD:42 , 
Potential registers zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] : zp ZP_WORD:44 , 
Potential registers zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] : zp ZP_WORD:46 , 
Potential registers zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ] : zp ZP_BYTE:48 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:49 [ memset::num#2 ] : zp ZP_WORD:49 , 
Potential registers zp ZP_WORD:51 [ memset::str#3 ] : zp ZP_WORD:51 , 
Potential registers zp ZP_BYTE:53 [ memset::c#3 ] : zp ZP_BYTE:53 , reg byte x , 
Potential registers zp ZP_WORD:54 [ memset::dst#2 memset::dst#3 memset::dst#1 ] : zp ZP_WORD:54 , 
Potential registers zp ZP_DWORD:56 [ clock::return#2 ] : zp ZP_DWORD:56 , 
Potential registers zp ZP_DWORD:60 [ main::$10 ] : zp ZP_DWORD:60 , 
Potential registers zp ZP_DWORD:64 [ main::cyclecount#0 ] : zp ZP_DWORD:64 , 
Potential registers zp ZP_DWORD:68 [ div32u16u::dividend#0 ] : zp ZP_DWORD:68 , 
Potential registers zp ZP_DWORD:72 [ div32u16u::return#2 ] : zp ZP_DWORD:72 , 
Potential registers zp ZP_DWORD:76 [ main::$14 ] : zp ZP_DWORD:76 , 
Potential registers zp ZP_WORD:80 [ main::sec100s#0 ] : zp ZP_WORD:80 , 
Potential registers zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] : zp ZP_DWORD:82 , 
Potential registers zp ZP_WORD:86 [ main::$38 ] : zp ZP_WORD:86 , 
Potential registers zp ZP_BYTE:88 [ utoa::$11 ] : zp ZP_BYTE:88 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:89 [ utoa::digit_value#0 ] : zp ZP_WORD:89 , 
Potential registers zp ZP_BYTE:91 [ utoa::$4 ] : zp ZP_BYTE:91 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:92 [ utoa::buffer#4 ] : zp ZP_WORD:92 , 
Potential registers zp ZP_WORD:94 [ utoa_append::buffer#0 ] : zp ZP_WORD:94 , 
Potential registers zp ZP_WORD:96 [ utoa_append::sub#0 ] : zp ZP_WORD:96 , 
Potential registers zp ZP_WORD:98 [ utoa_append::return#0 ] : zp ZP_WORD:98 , 
Potential registers zp ZP_BYTE:100 [ ultoa::$11 ] : zp ZP_BYTE:100 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_DWORD:101 [ ultoa::digit_value#0 ] : zp ZP_DWORD:101 , 
Potential registers zp ZP_BYTE:105 [ ultoa::$4 ] : zp ZP_BYTE:105 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:106 [ ultoa::buffer#4 ] : zp ZP_WORD:106 , 
Potential registers zp ZP_WORD:108 [ ultoa_append::buffer#0 ] : zp ZP_WORD:108 , 
Potential registers zp ZP_DWORD:110 [ ultoa_append::sub#0 ] : zp ZP_DWORD:110 , 
Potential registers zp ZP_DWORD:114 [ ultoa_append::return#0 ] : zp ZP_DWORD:114 , 
Potential registers zp ZP_WORD:118 [ divr16u::return#2 ] : zp ZP_WORD:118 , 
Potential registers zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] : zp ZP_WORD:120 , 
Potential registers zp ZP_WORD:122 [ divr16u::return#3 ] : zp ZP_WORD:122 , 
Potential registers zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] : zp ZP_WORD:124 , 
Potential registers zp ZP_DWORD:126 [ div32u16u::return#0 ] : zp ZP_DWORD:126 , 
Potential registers zp ZP_BYTE:130 [ divr16u::$1 ] : zp ZP_BYTE:130 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:131 [ divr16u::$2 ] : zp ZP_BYTE:131 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:132 [ rem16u#1 ] : zp ZP_WORD:132 , 
Potential registers zp ZP_DWORD:134 [ clock::return#0 ] : zp ZP_DWORD:134 , 
Potential registers zp ZP_WORD:138 [ memset::end#0 ] : zp ZP_WORD:138 , 

REGISTER UPLIFT SCOPES
Uplift Scope [utoa_append] 2,554: zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] 2,003: zp ZP_BYTE:26 [ utoa_append::digit#2 utoa_append::digit#1 ] 350.5: zp ZP_WORD:96 [ utoa_append::sub#0 ] 202: zp ZP_WORD:98 [ utoa_append::return#0 ] 12.88: zp ZP_WORD:94 [ utoa_append::buffer#0 ] 
Uplift Scope [utoa] 300.13: zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ] 271.67: zp ZP_WORD:19 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ] 202: zp ZP_BYTE:88 [ utoa::$11 ] 174.81: zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] 127.93: zp ZP_BYTE:21 [ utoa::started#2 utoa::started#3 ] 60.6: zp ZP_WORD:89 [ utoa::digit_value#0 ] 4: zp ZP_BYTE:91 [ utoa::$4 ] 4: zp ZP_WORD:92 [ utoa::buffer#4 ] 
Uplift Scope [main] 297: zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] 227.67: zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] 35.6: zp ZP_WORD:2 [ main::i#11 main::i#2 ] 25: zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] 22: zp ZP_WORD:86 [ main::$38 ] 15.4: zp ZP_WORD:6 [ main::i#10 main::i#3 ] 4: zp ZP_DWORD:60 [ main::$10 ] 2: zp ZP_DWORD:76 [ main::$14 ] 1.33: zp ZP_WORD:80 [ main::sec100s#0 ] 0.5: zp ZP_DWORD:64 [ main::cyclecount#0 ] 
Uplift Scope [ultoa_append] 259: zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] 203: zp ZP_BYTE:41 [ ultoa_append::digit#2 ultoa_append::digit#1 ] 35.5: zp ZP_DWORD:110 [ ultoa_append::sub#0 ] 22: zp ZP_DWORD:114 [ ultoa_append::return#0 ] 1.62: zp ZP_WORD:108 [ ultoa_append::buffer#0 ] 
Uplift Scope [print_str] 305.5: zp ZP_WORD:14 [ print_str::str#8 print_str::str#10 print_str::str#0 ] 
Uplift Scope [] 194.58: zp ZP_WORD:12 [ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ] 61.68: zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ] 0.67: zp ZP_WORD:132 [ rem16u#1 ] 
Uplift Scope [divr16u] 106.92: zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] 35.54: zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] 22: zp ZP_BYTE:130 [ divr16u::$1 ] 22: zp ZP_BYTE:131 [ divr16u::$2 ] 19.75: zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] 18.19: zp ZP_BYTE:48 [ divr16u::i#2 divr16u::i#1 ] 4: zp ZP_WORD:118 [ divr16u::return#2 ] 4: zp ZP_WORD:122 [ divr16u::return#3 ] 
Uplift Scope [ultoa] 33.4: zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ] 31.67: zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ] 22: zp ZP_BYTE:100 [ ultoa::$11 ] 19.04: zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] 13.93: zp ZP_BYTE:34 [ ultoa::started#2 ultoa::started#3 ] 6.6: zp ZP_DWORD:101 [ ultoa::digit_value#0 ] 4: zp ZP_BYTE:105 [ ultoa::$4 ] 4: zp ZP_WORD:106 [ ultoa::buffer#4 ] 
Uplift Scope [memset] 38: zp ZP_WORD:54 [ memset::dst#2 memset::dst#3 memset::dst#1 ] 2.17: zp ZP_WORD:138 [ memset::end#0 ] 2: zp ZP_WORD:49 [ memset::num#2 ] 1.38: zp ZP_BYTE:53 [ memset::c#3 ] 0: zp ZP_WORD:51 [ memset::str#3 ] 
Uplift Scope [print_word_decimal] 30: zp ZP_WORD:16 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] 
Uplift Scope [div32u16u] 4: zp ZP_DWORD:72 [ div32u16u::return#2 ] 4: zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] 1.33: zp ZP_DWORD:126 [ div32u16u::return#0 ] 1.2: zp ZP_DWORD:68 [ div32u16u::dividend#0 ] 0.67: zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] 
Uplift Scope [clock] 4: zp ZP_DWORD:56 [ clock::return#2 ] 1.33: zp ZP_DWORD:134 [ clock::return#0 ] 
Uplift Scope [print_dword_decimal] 4: zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] 
Uplift Scope [clock_start] 
Uplift Scope [RADIX] 
Uplift Scope [print_ln] 
Uplift Scope [print_char] 
Uplift Scope [print_cls] 

Uplifting [utoa_append] best 103614 combination zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] reg byte x [ utoa_append::digit#2 utoa_append::digit#1 ] zp ZP_WORD:96 [ utoa_append::sub#0 ] zp ZP_WORD:98 [ utoa_append::return#0 ] zp ZP_WORD:94 [ utoa_append::buffer#0 ] 
Uplifting [utoa] best 102310 combination zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ] zp ZP_WORD:19 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ] reg byte a [ utoa::$11 ] zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] reg byte x [ utoa::started#2 utoa::started#3 ] zp ZP_WORD:89 [ utoa::digit_value#0 ] reg byte a [ utoa::$4 ] zp ZP_WORD:92 [ utoa::buffer#4 ] 
Uplifting [main] best 102310 combination zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ] zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ] zp ZP_WORD:2 [ main::i#11 main::i#2 ] zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ] zp ZP_WORD:86 [ main::$38 ] zp ZP_WORD:6 [ main::i#10 main::i#3 ] zp ZP_DWORD:60 [ main::$10 ] zp ZP_DWORD:76 [ main::$14 ] zp ZP_WORD:80 [ main::sec100s#0 ] zp ZP_DWORD:64 [ main::cyclecount#0 ] 
Uplifting [ultoa_append] best 101707 combination zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] reg byte x [ ultoa_append::digit#2 ultoa_append::digit#1 ] zp ZP_DWORD:110 [ ultoa_append::sub#0 ] zp ZP_DWORD:114 [ ultoa_append::return#0 ] zp ZP_WORD:108 [ ultoa_append::buffer#0 ] 
Uplifting [print_str] best 101707 combination zp ZP_WORD:14 [ print_str::str#8 print_str::str#10 print_str::str#0 ] 
Uplifting [] best 101707 combination zp ZP_WORD:12 [ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ] zp ZP_WORD:27 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ] zp ZP_WORD:132 [ rem16u#1 ] 
Uplifting [divr16u] best 101497 combination zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] reg byte a [ divr16u::$1 ] reg byte a [ divr16u::$2 ] zp ZP_WORD:44 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ] reg byte x [ divr16u::i#2 divr16u::i#1 ] zp ZP_WORD:118 [ divr16u::return#2 ] zp ZP_WORD:122 [ divr16u::return#3 ] 
Uplifting [ultoa] best 101363 combination zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ] zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ] reg byte a [ ultoa::$11 ] zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] reg byte x [ ultoa::started#2 ultoa::started#3 ] zp ZP_DWORD:101 [ ultoa::digit_value#0 ] reg byte a [ ultoa::$4 ] zp ZP_WORD:106 [ ultoa::buffer#4 ] 
Uplifting [memset] best 101347 combination zp ZP_WORD:54 [ memset::dst#2 memset::dst#3 memset::dst#1 ] zp ZP_WORD:138 [ memset::end#0 ] zp ZP_WORD:49 [ memset::num#2 ] reg byte x [ memset::c#3 ] zp ZP_WORD:51 [ memset::str#3 ] 
Uplifting [print_word_decimal] best 101347 combination zp ZP_WORD:16 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] 
Uplifting [div32u16u] best 101347 combination zp ZP_DWORD:72 [ div32u16u::return#2 ] zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] zp ZP_DWORD:126 [ div32u16u::return#0 ] zp ZP_DWORD:68 [ div32u16u::dividend#0 ] zp ZP_WORD:120 [ div32u16u::quotient_hi#0 ] 
Uplifting [clock] best 101347 combination zp ZP_DWORD:56 [ clock::return#2 ] zp ZP_DWORD:134 [ clock::return#0 ] 
Uplifting [print_dword_decimal] best 101347 combination zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] 
Uplifting [clock_start] best 101347 combination 
Uplifting [RADIX] best 101347 combination 
Uplifting [print_ln] best 101347 combination 
Uplifting [print_char] best 101347 combination 
Uplifting [print_cls] best 101347 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ]
Uplifting [utoa] best 101347 combination zp ZP_BYTE:18 [ utoa::digit#2 utoa::digit#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ]
Uplifting [ultoa] best 101347 combination zp ZP_BYTE:29 [ ultoa::digit#2 ultoa::digit#1 ] 
Coalescing zero page register with common assignment [ zp ZP_WORD:42 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 ] ] with [ zp ZP_WORD:132 [ rem16u#1 ] ] - score: 2
Coalescing zero page register with common assignment [ zp ZP_WORD:6 [ main::i#10 main::i#3 ] ] with [ zp ZP_WORD:16 [ print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:19 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 ] ] with [ zp ZP_WORD:24 [ utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:19 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 ] ] with [ zp ZP_WORD:98 [ utoa_append::return#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 ] ] with [ zp ZP_WORD:92 [ utoa::buffer#4 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:22 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 utoa::buffer#4 ] ] with [ zp ZP_WORD:94 [ utoa_append::buffer#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ] ] with [ zp ZP_DWORD:37 [ ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 ] ] with [ zp ZP_DWORD:82 [ print_dword_decimal::w#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ] ] with [ zp ZP_DWORD:114 [ ultoa_append::return#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ] ] with [ zp ZP_WORD:106 [ ultoa::buffer#4 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:35 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ultoa::buffer#4 ] ] with [ zp ZP_WORD:108 [ ultoa_append::buffer#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 ] ] with [ zp ZP_WORD:118 [ divr16u::return#2 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 ] ] with [ zp ZP_WORD:122 [ divr16u::return#3 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:49 [ memset::num#2 ] ] with [ zp ZP_WORD:138 [ memset::end#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:51 [ memset::str#3 ] ] with [ zp ZP_WORD:54 [ memset::dst#2 memset::dst#3 memset::dst#1 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:56 [ clock::return#2 ] ] with [ zp ZP_DWORD:60 [ main::$10 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:56 [ clock::return#2 main::$10 ] ] with [ zp ZP_DWORD:134 [ clock::return#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:64 [ main::cyclecount#0 ] ] with [ zp ZP_DWORD:68 [ div32u16u::dividend#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:72 [ div32u16u::return#2 ] ] with [ zp ZP_DWORD:76 [ main::$14 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:72 [ div32u16u::return#2 main::$14 ] ] with [ zp ZP_DWORD:126 [ div32u16u::return#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:89 [ utoa::digit_value#0 ] ] with [ zp ZP_WORD:96 [ utoa_append::sub#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:101 [ ultoa::digit_value#0 ] ] with [ zp ZP_DWORD:110 [ ultoa_append::sub#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:6 [ main::i#10 main::i#3 print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 ] ] with [ zp ZP_WORD:80 [ main::sec100s#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 ] ] with [ zp ZP_DWORD:64 [ main::cyclecount#0 div32u16u::dividend#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_WORD:46 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 ] ] with [ zp ZP_WORD:124 [ div32u16u::quotient_lo#0 ] ] - score: 1
Coalescing zero page register with common assignment [ zp ZP_DWORD:30 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 main::cyclecount#0 div32u16u::dividend#0 ] ] with [ zp ZP_DWORD:56 [ clock::return#2 main::$10 clock::return#0 ] ] - score: 1
Allocated (was zp ZP_BYTE:18) zp ZP_BYTE:16 [ utoa::digit#2 utoa::digit#1 ]
Allocated (was zp ZP_WORD:19) zp ZP_WORD:17 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 utoa_append::return#0 ]
Allocated (was zp ZP_WORD:22) zp ZP_WORD:19 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 utoa::buffer#4 utoa_append::buffer#0 ]
Allocated (was zp ZP_WORD:27) zp ZP_WORD:21 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ]
Allocated (was zp ZP_BYTE:29) zp ZP_BYTE:23 [ ultoa::digit#2 ultoa::digit#1 ]
Allocated (was zp ZP_DWORD:30) zp ZP_DWORD:24 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 main::cyclecount#0 div32u16u::dividend#0 clock::return#2 main::$10 clock::return#0 ]
Allocated (was zp ZP_WORD:35) zp ZP_WORD:28 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ultoa::buffer#4 ultoa_append::buffer#0 ]
Allocated (was zp ZP_WORD:42) zp ZP_WORD:30 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 rem16u#1 ]
Allocated (was zp ZP_WORD:44) zp ZP_WORD:32 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
Allocated (was zp ZP_WORD:46) zp ZP_WORD:34 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 div32u16u::quotient_lo#0 ]
Allocated (was zp ZP_WORD:49) zp ZP_WORD:36 [ memset::num#2 memset::end#0 ]
Allocated (was zp ZP_WORD:51) zp ZP_WORD:38 [ memset::str#3 memset::dst#2 memset::dst#3 memset::dst#1 ]
Allocated (was zp ZP_DWORD:72) zp ZP_DWORD:40 [ div32u16u::return#2 main::$14 div32u16u::return#0 ]
Allocated (was zp ZP_WORD:86) zp ZP_WORD:44 [ main::$38 ]
Allocated (was zp ZP_WORD:89) zp ZP_WORD:46 [ utoa::digit_value#0 utoa_append::sub#0 ]
Allocated (was zp ZP_DWORD:101) zp ZP_DWORD:48 [ ultoa::digit_value#0 ultoa_append::sub#0 ]
Allocated (was zp ZP_WORD:120) zp ZP_WORD:52 [ div32u16u::quotient_hi#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label D018 = $d018
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles per frame (on a C64 PAL)
  .const CLOCKS_PER_FRAME = $4cc8
  // Frames per second (on a C64 PAL)
  .const FRAMES_PER_SEC = $3c
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  .const COUNT = $4000
  /* Up to what number? */
  .const SQRT_COUNT = $80
  /* Sqrt of COUNT */
  .label sieve = $1000
  // Clock cycles per second (on a C64 PAL)
  .const CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
  .label rem16u = $1e
  .label print_char_cursor = $c
  .label print_line_cursor = $15
  .label print_char_cursor_62 = $15
  .label print_char_cursor_99 = $15
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label toD0181_gfx = $1800
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>toD0181_gfx)/4&$f
    .label _10 = $18
    .label _14 = $28
    .label cyclecount = $18
    .label sec100s = 6
    .label i = 2
    .label sieve_i = 4
    .label j = 8
    .label s = $a
    .label i_3 = 6
    .label i_10 = 6
    .label _38 = $2c
    // [5] phi from main to main::toD0181 [phi:main->main::toD0181]
  toD0181_from_main:
    jmp toD0181
    // main::toD0181
  toD0181:
    jmp b13
    // main::@13
  b13:
    // [6] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    //Show lower case font
    lda #toD0181_return
    sta D018
    // [7] call print_cls 
    // [198] phi from main::@13 to print_cls [phi:main::@13->print_cls]
  print_cls_from_b13:
    jsr print_cls
    // [8] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
  b14_from_b13:
    jmp b14
    // main::@14
  b14:
    // [9] call print_str 
    // [70] phi from main::@14 to print_str [phi:main::@14->print_str]
  print_str_from_b14:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) 1024 [phi:main::@14->print_str#0] -- pbuz1=pbuc1 
    lda #<$400
    sta print_char_cursor
    lda #>$400
    sta print_char_cursor+1
    // [70] phi (byte*) print_str::str#10 = (const string) main::str [phi:main::@14->print_str#1] -- pbuz1=pbuc1 
    lda #<str
    sta print_str.str
    lda #>str
    sta print_str.str+1
    jsr print_str
    // [10] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
  b15_from_b14:
    jmp b15
    // main::@15
  b15:
    // [11] call print_ln 
    // [114] phi from main::@15 to print_ln [phi:main::@15->print_ln]
  print_ln_from_b15:
    // [114] phi (byte*) print_line_cursor#21 = (byte*) 1024 [phi:main::@15->print_ln#0] -- pbuz1=pbuc1 
    lda #<$400
    sta print_line_cursor
    lda #>$400
    sta print_line_cursor+1
    jsr print_ln
    jmp b16
    // main::@16
  b16:
    // [12] (byte*~) print_char_cursor#89 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda print_line_cursor
    sta print_char_cursor
    lda print_line_cursor+1
    sta print_char_cursor+1
    // [13] call print_str 
    // [70] phi from main::@16 to print_str [phi:main::@16->print_str]
  print_str_from_b16:
    // [70] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#89 [phi:main::@16->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str1 [phi:main::@16->print_str#1] -- pbuz1=pbuc1 
    lda #<str1
    sta print_str.str
    lda #>str1
    sta print_str.str+1
    jsr print_str
    // [14] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
  b17_from_b16:
    jmp b17
    // main::@17
  b17:
    // [15] call print_word_decimal 
    // [80] phi from main::@17 to print_word_decimal [phi:main::@17->print_word_decimal]
  print_word_decimal_from_b17:
    // [80] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@17->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (const word) COUNT#0 [phi:main::@17->print_word_decimal#1] -- vwuz1=vwuc1 
    lda #<COUNT
    sta print_word_decimal.w
    lda #>COUNT
    sta print_word_decimal.w+1
    jsr print_word_decimal
    // [16] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
  b18_from_b17:
    jmp b18
    // main::@18
  b18:
    // [17] call print_ln 
    // [114] phi from main::@18 to print_ln [phi:main::@18->print_ln]
  print_ln_from_b18:
    // [114] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@18->print_ln#0] -- register_copy 
    jsr print_ln
    // [18] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
  b19_from_b18:
    jmp b19
    // main::@19
  b19:
    // [19] call memset 
    // [189] phi from main::@19 to memset [phi:main::@19->memset]
  memset_from_b19:
    // [189] phi (byte) memset::c#3 = (byte) 0 [phi:main::@19->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [189] phi (void*) memset::str#3 = (void*)(const byte*) sieve#0 [phi:main::@19->memset#1] -- pvoz1=pvoc1 
    lda #<sieve
    sta memset.str
    lda #>sieve
    sta memset.str+1
    // [189] phi (word) memset::num#2 = (const word) COUNT#0 [phi:main::@19->memset#2] -- vwuz1=vwuc1 
    lda #<COUNT
    sta memset.num
    lda #>COUNT
    sta memset.num+1
    jsr memset
    // [20] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
  b20_from_b19:
    jmp b20
    // main::@20
  b20:
    // [21] call clock_start 
    jsr clock_start
    // [22] phi from main::@20 to main::@1 [phi:main::@20->main::@1]
  b1_from_b20:
    // [22] phi (byte*) main::sieve_i#2 = (const byte*) sieve#0+(byte) 2 [phi:main::@20->main::@1#0] -- pbuz1=pbuc1 
    lda #<sieve+2
    sta sieve_i
    lda #>sieve+2
    sta sieve_i+1
    // [22] phi (word) main::i#11 = (byte) 2 [phi:main::@20->main::@1#1] -- vwuz1=vbuc1 
    lda #<2
    sta i
    lda #>2
    sta i+1
    jmp b1
    // main::@1
  b1:
    // [23] if((word) main::i#11<(const byte) SQRT_COUNT#0) goto main::@2 -- vwuz1_lt_vbuc1_then_la1 
    lda i+1
    cmp #>SQRT_COUNT
    bcc b2
    bne !+
    lda i
    cmp #<SQRT_COUNT
    bcc b2
  !:
    // [24] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  b3_from_b1:
    jmp b3
    // main::@3
  b3:
    // [25] call clock 
    jsr clock
    // [26] (dword) clock::return#2 ← (dword) clock::return#0
    jmp b21
    // main::@21
  b21:
    // [27] (dword~) main::$10 ← (dword) clock::return#2
    // [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT#0 -- vduz1=vduz1_minus_vduc1 
    lda cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta cyclecount
    lda cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta cyclecount+1
    lda cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta cyclecount+2
    lda cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta cyclecount+3
    // [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
    // [30] call div32u16u 
    jsr div32u16u
    // [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0
    jmp b22
    // main::@22
  b22:
    // [32] (dword~) main::$14 ← (dword) div32u16u::return#2
    // [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 -- vwuz1=_word_vduz2 
    lda _14
    sta sec100s
    lda _14+1
    sta sec100s+1
    // [34] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda print_line_cursor
    sta print_char_cursor
    lda print_line_cursor+1
    sta print_char_cursor+1
    // [35] call print_str 
    // [70] phi from main::@22 to print_str [phi:main::@22->print_str]
  print_str_from_b22:
    // [70] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#90 [phi:main::@22->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str2 [phi:main::@22->print_str#1] -- pbuz1=pbuc1 
    lda #<str2
    sta print_str.str
    lda #>str2
    sta print_str.str+1
    jsr print_str
    jmp b23
    // main::@23
  b23:
    // [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0
    // [37] call print_word_decimal 
    // [80] phi from main::@23 to print_word_decimal [phi:main::@23->print_word_decimal]
  print_word_decimal_from_b23:
    // [80] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@23->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#1 [phi:main::@23->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [38] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
  b24_from_b23:
    jmp b24
    // main::@24
  b24:
    // [39] call print_str 
    // [70] phi from main::@24 to print_str [phi:main::@24->print_str]
  print_str_from_b24:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:main::@24->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str3 [phi:main::@24->print_str#1] -- pbuz1=pbuc1 
    lda #<str3
    sta print_str.str
    lda #>str3
    sta print_str.str+1
    jsr print_str
    jmp b25
    // main::@25
  b25:
    // [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0
    // [41] call print_dword_decimal 
    jsr print_dword_decimal
    // [42] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
  b26_from_b25:
    jmp b26
    // main::@26
  b26:
    // [43] call print_ln 
    // [114] phi from main::@26 to print_ln [phi:main::@26->print_ln]
  print_ln_from_b26:
    // [114] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@26->print_ln#0] -- register_copy 
    jsr print_ln
    // [44] phi from main::@26 to main::@8 [phi:main::@26->main::@8]
  b8_from_b26:
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_line_cursor#1 [phi:main::@26->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (byte) 2 [phi:main::@26->main::@8#1] -- vwuz1=vbuc1 
    lda #<2
    sta i_10
    lda #>2
    sta i_10+1
    jmp b8
    // main::@8
  b8:
    // [45] (byte*~) main::$38 ← (const byte*) sieve#0 + (word) main::i#10 -- pbuz1=pbuc1_plus_vwuz2 
    lda i_10
    clc
    adc #<sieve
    sta _38
    lda i_10+1
    adc #>sieve
    sta _38+1
    // [46] if((byte) 0!=*((byte*~) main::$38)) goto main::@29 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (_38),y
    cmp #0
    bne b29
    jmp b10
    // main::@10
  b10:
    // [47] (word) print_word_decimal::w#2 ← (word) main::i#10
    // [48] (byte*~) print_char_cursor#96 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda print_char_cursor_62
    sta print_char_cursor
    lda print_char_cursor_62+1
    sta print_char_cursor+1
    // [49] call print_word_decimal 
    // [80] phi from main::@10 to print_word_decimal [phi:main::@10->print_word_decimal]
  print_word_decimal_from_b10:
    // [80] phi (byte*) print_char_cursor#58 = (byte*~) print_char_cursor#96 [phi:main::@10->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#2 [phi:main::@10->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [50] phi from main::@10 to main::@27 [phi:main::@10->main::@27]
  b27_from_b10:
    jmp b27
    // main::@27
  b27:
    // [51] call print_char 
    jsr print_char
    // [52] phi from main::@27 main::@29 to main::@9 [phi:main::@27/main::@29->main::@9]
  b9_from_b27:
  b9_from_b29:
    // [52] phi (byte*) print_char_cursor#63 = (byte*) print_char_cursor#10 [phi:main::@27/main::@29->main::@9#0] -- register_copy 
    jmp b9
    // main::@9
  b9:
    // [53] (word) main::i#3 ← ++ (word) main::i#10 -- vwuz1=_inc_vwuz1 
    inc i_3
    bne !+
    inc i_3+1
  !:
    // [54] if((word) main::i#3<(word) $514) goto main::@28 -- vwuz1_lt_vwuc1_then_la1 
    lda i_3+1
    cmp #>$514
    bcc b28
    bne !+
    lda i_3
    cmp #<$514
    bcc b28
  !:
    // [55] phi from main::@9 to main::@11 [phi:main::@9->main::@11]
  b11_from_b9:
    jmp b11
    // main::@11
  b11:
    // [56] call print_str 
    // [70] phi from main::@11 to print_str [phi:main::@11->print_str]
  print_str_from_b11:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#63 [phi:main::@11->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str4 [phi:main::@11->print_str#1] -- pbuz1=pbuc1 
    lda #<str4
    sta print_str.str
    lda #>str4
    sta print_str.str+1
    jsr print_str
    jmp b12
    // main::@12
  b12:
    // [57] *((const byte*) SCREEN#0+(word) $3e7) ← ++ *((const byte*) SCREEN#0+(word) $3e7) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
    jmp b12
    // main::@28
  b28:
    // [58] (byte*~) print_char_cursor#99 ← (byte*) print_char_cursor#63 -- pbuz1=pbuz2 
    lda print_char_cursor
    sta print_char_cursor_99
    lda print_char_cursor+1
    sta print_char_cursor_99+1
    // [44] phi from main::@28 to main::@8 [phi:main::@28->main::@8]
  b8_from_b28:
    // [44] phi (byte*) print_char_cursor#62 = (byte*~) print_char_cursor#99 [phi:main::@28->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (word) main::i#3 [phi:main::@28->main::@8#1] -- register_copy 
    jmp b8
    // main::@29
  b29:
    // [59] (byte*~) print_char_cursor#101 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda print_char_cursor_62
    sta print_char_cursor
    lda print_char_cursor_62+1
    sta print_char_cursor+1
    jmp b9_from_b29
    // main::@2
  b2:
    // [60] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (sieve_i),y
    cmp #0
    bne b4
    jmp b7
    // main::@7
  b7:
    // [61] (word) main::j#0 ← (word) main::i#11 << (byte) 1 -- vwuz1=vwuz2_rol_1 
    lda i
    asl
    sta j
    lda i+1
    rol
    sta j+1
    // [62] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda j
    clc
    adc #<sieve
    sta s
    lda j+1
    adc #>sieve
    sta s+1
    // [63] phi from main::@6 main::@7 to main::@5 [phi:main::@6/main::@7->main::@5]
  b5_from_b6:
  b5_from_b7:
    // [63] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@6/main::@7->main::@5#0] -- register_copy 
    // [63] phi (word) main::j#2 = (word) main::j#1 [phi:main::@6/main::@7->main::@5#1] -- register_copy 
    jmp b5
    // main::@5
  b5:
    // [64] if((word) main::j#2<(const word) COUNT#0) goto main::@6 -- vwuz1_lt_vwuc1_then_la1 
    lda j+1
    cmp #>COUNT
    bcc b6
    bne !+
    lda j
    cmp #<COUNT
    bcc b6
  !:
    jmp b4
    // main::@4
  b4:
    // [65] (word) main::i#2 ← ++ (word) main::i#11 -- vwuz1=_inc_vwuz1 
    inc i
    bne !+
    inc i+1
  !:
    // [66] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2 -- pbuz1=_inc_pbuz1 
    inc sieve_i
    bne !+
    inc sieve_i+1
  !:
    // [22] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  b1_from_b4:
    // [22] phi (byte*) main::sieve_i#2 = (byte*) main::sieve_i#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [22] phi (word) main::i#11 = (word) main::i#2 [phi:main::@4->main::@1#1] -- register_copy 
    jmp b1
    // main::@6
  b6:
    // [67] *((byte*) main::s#2) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (s),y
    // [68] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#11 -- pbuz1=pbuz1_plus_vwuz2 
    lda s
    clc
    adc i
    sta s
    lda s+1
    adc i+1
    sta s+1
    // [69] (word) main::j#1 ← (word) main::j#2 + (word) main::i#11 -- vwuz1=vwuz1_plus_vwuz2 
    lda j
    clc
    adc i
    sta j
    lda j+1
    adc i+1
    sta j+1
    jmp b5_from_b6
    str: .text "Sieve benchmark - calculating primes@"
    str1: .text "between 2 and @"
    str2: .text "100ths seconds used: @"
    str3: .text " cycles: @"
    str4: .text "...@"
}
  // print_str
// Print a zero-terminated string
// print_str(byte* zeropage($e) str)
print_str: {
    .label str = $e
    // [71] phi from print_str print_str::@2 to print_str::@1 [phi:print_str/print_str::@2->print_str::@1]
  b1_from_print_str:
  b1_from_b2:
    // [71] phi (byte*) print_char_cursor#2 = (byte*) print_char_cursor#66 [phi:print_str/print_str::@2->print_str::@1#0] -- register_copy 
    // [71] phi (byte*) print_str::str#8 = (byte*) print_str::str#10 [phi:print_str/print_str::@2->print_str::@1#1] -- register_copy 
    jmp b1
    // print_str::@1
  b1:
    // [72] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2 -- _deref_pbuz1_neq_vbuc1_then_la1 
    ldy #0
    lda (str),y
    cmp #'@'
    bne b2
    jmp breturn
    // print_str::@return
  breturn:
    // [73] return 
    rts
    // print_str::@2
  b2:
    // [74] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (str),y
    ldy #0
    sta (print_char_cursor),y
    // [75] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc print_char_cursor
    bne !+
    inc print_char_cursor+1
  !:
    // [76] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8 -- pbuz1=_inc_pbuz1 
    inc str
    bne !+
    inc str+1
  !:
    jmp b1_from_b2
}
  // print_char
// Print a single char
print_char: {
    .const ch = ' '
    // [77] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (print_char_cursor),y
    // [78] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc print_char_cursor
    bne !+
    inc print_char_cursor+1
  !:
    jmp breturn
    // print_char::@return
  breturn:
    // [79] return 
    rts
}
  // print_word_decimal
// Print a word as DECIMAL
// print_word_decimal(word zeropage(6) w)
print_word_decimal: {
    .label w = 6
    // [81] (word) utoa::value#1 ← (word) print_word_decimal::w#3 -- vwuz1=vwuz2 
    lda w
    sta utoa.value
    lda w+1
    sta utoa.value+1
    // [82] call utoa 
    // [86] phi from print_word_decimal to utoa [phi:print_word_decimal->utoa]
  utoa_from_print_word_decimal:
    jsr utoa
    // [83] phi from print_word_decimal to print_word_decimal::@1 [phi:print_word_decimal->print_word_decimal::@1]
  b1_from_print_word_decimal:
    jmp b1
    // print_word_decimal::@1
  b1:
    // [84] call print_str 
    // [70] phi from print_word_decimal::@1 to print_str [phi:print_word_decimal::@1->print_str]
  print_str_from_b1:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#58 [phi:print_word_decimal::@1->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const byte[6]) decimal_digits#0 [phi:print_word_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta print_str.str
    lda #>decimal_digits
    sta print_str.str+1
    jsr print_str
    jmp breturn
    // print_word_decimal::@return
  breturn:
    // [85] return 
    rts
}
  // utoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// utoa(word zeropage($11) value, byte* zeropage($13) buffer)
utoa: {
    .const max_digits = 5
    .label digit_value = $2e
    .label digit = $10
    .label value = $11
    .label buffer = $13
    // [87] phi from utoa to utoa::@1 [phi:utoa->utoa::@1]
  b1_from_utoa:
    // [87] phi (byte*) utoa::buffer#11 = (const byte[6]) decimal_digits#0 [phi:utoa->utoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta buffer
    lda #>decimal_digits
    sta buffer+1
    // [87] phi (byte) utoa::started#2 = (byte) 0 [phi:utoa->utoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [87] phi (word) utoa::value#2 = (word) utoa::value#1 [phi:utoa->utoa::@1#2] -- register_copy 
    // [87] phi (byte) utoa::digit#2 = (byte) 0 [phi:utoa->utoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta digit
    jmp b1
    // [87] phi from utoa::@2 to utoa::@1 [phi:utoa::@2->utoa::@1]
  b1_from_b2:
    // [87] phi (byte*) utoa::buffer#11 = (byte*) utoa::buffer#12 [phi:utoa::@2->utoa::@1#0] -- register_copy 
    // [87] phi (byte) utoa::started#2 = (byte) utoa::started#3 [phi:utoa::@2->utoa::@1#1] -- register_copy 
    // [87] phi (word) utoa::value#2 = (word) utoa::value#4 [phi:utoa::@2->utoa::@1#2] -- register_copy 
    // [87] phi (byte) utoa::digit#2 = (byte) utoa::digit#1 [phi:utoa::@2->utoa::@1#3] -- register_copy 
    jmp b1
    // utoa::@1
  b1:
    // [88] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda digit
    asl
    // [89] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES#0 + (byte~) utoa::$11) -- vwuz1=pwuc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES,y
    sta digit_value
    lda RADIX_DECIMAL_VALUES+1,y
    sta digit_value+1
    // [90] if((byte) 0!=(byte) utoa::started#2) goto utoa::@3 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b3
    jmp b6
    // utoa::@6
  b6:
    // [91] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@3 -- vwuz1_ge_vwuz2_then_la1 
    lda digit_value+1
    cmp value+1
    bne !+
    lda digit_value
    cmp value
    beq b3
  !:
    bcc b3
    // [92] phi from utoa::@6 to utoa::@2 [phi:utoa::@6->utoa::@2]
  b2_from_b6:
    // [92] phi (byte*) utoa::buffer#12 = (byte*) utoa::buffer#11 [phi:utoa::@6->utoa::@2#0] -- register_copy 
    // [92] phi (byte) utoa::started#3 = (byte) utoa::started#2 [phi:utoa::@6->utoa::@2#1] -- register_copy 
    // [92] phi (word) utoa::value#4 = (word) utoa::value#2 [phi:utoa::@6->utoa::@2#2] -- register_copy 
    jmp b2
    // utoa::@2
  b2:
    // [93] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [94] if((byte) utoa::digit#1<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda digit
    cmp #max_digits-1
    bcc b1_from_b2
    jmp b4
    // utoa::@4
  b4:
    // [95] (byte~) utoa::$4 ← (byte)(word) utoa::value#4 -- vbuaa=_byte_vwuz1 
    lda value
    // [96] *((byte*) utoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) utoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // [97] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#12 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [98] *((byte*) utoa::buffer#4) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa::@return
  breturn:
    // [99] return 
    rts
    // utoa::@3
  b3:
    // [100] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
    // [101] (word) utoa_append::value#0 ← (word) utoa::value#2
    // [102] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
    // [103] call utoa_append 
    // [107] phi from utoa::@3 to utoa_append [phi:utoa::@3->utoa_append]
  utoa_append_from_b3:
    jsr utoa_append
    // [104] (word) utoa_append::return#0 ← (word) utoa_append::value#2
    jmp b5
    // utoa::@5
  b5:
    // [105] (word) utoa::value#0 ← (word) utoa_append::return#0
    // [106] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [92] phi from utoa::@5 to utoa::@2 [phi:utoa::@5->utoa::@2]
  b2_from_b5:
    // [92] phi (byte*) utoa::buffer#12 = (byte*) utoa::buffer#3 [phi:utoa::@5->utoa::@2#0] -- register_copy 
    // [92] phi (byte) utoa::started#3 = (byte) 1 [phi:utoa::@5->utoa::@2#1] -- vbuxx=vbuc1 
    ldx #1
    // [92] phi (word) utoa::value#4 = (word) utoa::value#0 [phi:utoa::@5->utoa::@2#2] -- register_copy 
    jmp b2
}
  // utoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// utoa_append(byte* zeropage($13) buffer, word zeropage($11) value, word zeropage($2e) sub)
utoa_append: {
    .label buffer = $13
    .label value = $11
    .label sub = $2e
    .label return = $11
    // [108] phi from utoa_append to utoa_append::@1 [phi:utoa_append->utoa_append::@1]
  b1_from_utoa_append:
    // [108] phi (byte) utoa_append::digit#2 = (byte) 0 [phi:utoa_append->utoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [108] phi (word) utoa_append::value#2 = (word) utoa_append::value#0 [phi:utoa_append->utoa_append::@1#1] -- register_copy 
    jmp b1
    // utoa_append::@1
  b1:
    // [109] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 -- vwuz1_ge_vwuz2_then_la1 
    lda sub+1
    cmp value+1
    bne !+
    lda sub
    cmp value
    beq b2
  !:
    bcc b2
    jmp b3
    // utoa_append::@3
  b3:
    // [110] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) utoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    jmp breturn
    // utoa_append::@return
  breturn:
    // [111] return 
    rts
    // utoa_append::@2
  b2:
    // [112] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // [113] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda value
    sec
    sbc sub
    sta value
    lda value+1
    sbc sub+1
    sta value+1
    // [108] phi from utoa_append::@2 to utoa_append::@1 [phi:utoa_append::@2->utoa_append::@1]
  b1_from_b2:
    // [108] phi (byte) utoa_append::digit#2 = (byte) utoa_append::digit#1 [phi:utoa_append::@2->utoa_append::@1#0] -- register_copy 
    // [108] phi (word) utoa_append::value#2 = (word) utoa_append::value#1 [phi:utoa_append::@2->utoa_append::@1#1] -- register_copy 
    jmp b1
}
  // print_ln
// Print a newline
print_ln: {
    // [115] phi from print_ln print_ln::@1 to print_ln::@1 [phi:print_ln/print_ln::@1->print_ln::@1]
  b1_from_print_ln:
  b1_from_b1:
    // [115] phi (byte*) print_line_cursor#11 = (byte*) print_line_cursor#21 [phi:print_ln/print_ln::@1->print_ln::@1#0] -- register_copy 
    jmp b1
    // print_ln::@1
  b1:
    // [116] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc print_line_cursor
    sta print_line_cursor
    bcc !+
    inc print_line_cursor+1
  !:
    // [117] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 -- pbuz1_lt_pbuz2_then_la1 
    lda print_line_cursor+1
    cmp print_char_cursor+1
    bcc b1_from_b1
    bne !+
    lda print_line_cursor
    cmp print_char_cursor
    bcc b1_from_b1
  !:
    jmp breturn
    // print_ln::@return
  breturn:
    // [118] return 
    rts
}
  // print_dword_decimal
// Print a dword as DECIMAL
// print_dword_decimal(dword zeropage($18) w)
print_dword_decimal: {
    .label w = $18
    // [119] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0
    // [120] call ultoa 
    // [124] phi from print_dword_decimal to ultoa [phi:print_dword_decimal->ultoa]
  ultoa_from_print_dword_decimal:
    jsr ultoa
    // [121] phi from print_dword_decimal to print_dword_decimal::@1 [phi:print_dword_decimal->print_dword_decimal::@1]
  b1_from_print_dword_decimal:
    jmp b1
    // print_dword_decimal::@1
  b1:
    // [122] call print_str 
    // [70] phi from print_dword_decimal::@1 to print_str [phi:print_dword_decimal::@1->print_str]
  print_str_from_b1:
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:print_dword_decimal::@1->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const byte[$b]) decimal_digits_long#0 [phi:print_dword_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta print_str.str
    lda #>decimal_digits_long
    sta print_str.str+1
    jsr print_str
    jmp breturn
    // print_dword_decimal::@return
  breturn:
    // [123] return 
    rts
}
  // ultoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// ultoa(dword zeropage($18) value, byte* zeropage($1c) buffer)
ultoa: {
    .const max_digits = $a
    .label digit_value = $30
    .label digit = $17
    .label value = $18
    .label buffer = $1c
    // [125] phi from ultoa to ultoa::@1 [phi:ultoa->ultoa::@1]
  b1_from_ultoa:
    // [125] phi (byte*) ultoa::buffer#11 = (const byte[$b]) decimal_digits_long#0 [phi:ultoa->ultoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta buffer
    lda #>decimal_digits_long
    sta buffer+1
    // [125] phi (byte) ultoa::started#2 = (byte) 0 [phi:ultoa->ultoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [125] phi (dword) ultoa::value#2 = (dword) ultoa::value#1 [phi:ultoa->ultoa::@1#2] -- register_copy 
    // [125] phi (byte) ultoa::digit#2 = (byte) 0 [phi:ultoa->ultoa::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta digit
    jmp b1
    // [125] phi from ultoa::@2 to ultoa::@1 [phi:ultoa::@2->ultoa::@1]
  b1_from_b2:
    // [125] phi (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#12 [phi:ultoa::@2->ultoa::@1#0] -- register_copy 
    // [125] phi (byte) ultoa::started#2 = (byte) ultoa::started#3 [phi:ultoa::@2->ultoa::@1#1] -- register_copy 
    // [125] phi (dword) ultoa::value#2 = (dword) ultoa::value#4 [phi:ultoa::@2->ultoa::@1#2] -- register_copy 
    // [125] phi (byte) ultoa::digit#2 = (byte) ultoa::digit#1 [phi:ultoa::@2->ultoa::@1#3] -- register_copy 
    jmp b1
    // ultoa::@1
  b1:
    // [126] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 -- vbuaa=vbuz1_rol_2 
    lda digit
    asl
    asl
    // [127] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG#0 + (byte~) ultoa::$11) -- vduz1=pduc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES_LONG,y
    sta digit_value
    lda RADIX_DECIMAL_VALUES_LONG+1,y
    sta digit_value+1
    lda RADIX_DECIMAL_VALUES_LONG+2,y
    sta digit_value+2
    lda RADIX_DECIMAL_VALUES_LONG+3,y
    sta digit_value+3
    // [128] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@3 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b3
    jmp b6
    // ultoa::@6
  b6:
    // [129] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@3 -- vduz1_ge_vduz2_then_la1 
    lda value+3
    cmp digit_value+3
    bcc !+
    bne b3
    lda value+2
    cmp digit_value+2
    bcc !+
    bne b3
    lda value+1
    cmp digit_value+1
    bcc !+
    bne b3
    lda value
    cmp digit_value
    bcs b3
  !:
    // [130] phi from ultoa::@6 to ultoa::@2 [phi:ultoa::@6->ultoa::@2]
  b2_from_b6:
    // [130] phi (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#11 [phi:ultoa::@6->ultoa::@2#0] -- register_copy 
    // [130] phi (byte) ultoa::started#3 = (byte) ultoa::started#2 [phi:ultoa::@6->ultoa::@2#1] -- register_copy 
    // [130] phi (dword) ultoa::value#4 = (dword) ultoa::value#2 [phi:ultoa::@6->ultoa::@2#2] -- register_copy 
    jmp b2
    // ultoa::@2
  b2:
    // [131] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [132] if((byte) ultoa::digit#1<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda digit
    cmp #max_digits-1
    bcc b1_from_b2
    jmp b4
    // ultoa::@4
  b4:
    // [133] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4 -- vbuaa=_byte_vduz1 
    lda value
    // [134] *((byte*) ultoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) ultoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // [135] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#12 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [136] *((byte*) ultoa::buffer#4) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa::@return
  breturn:
    // [137] return 
    rts
    // ultoa::@3
  b3:
    // [138] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11
    // [139] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2
    // [140] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0
    // [141] call ultoa_append 
    // [145] phi from ultoa::@3 to ultoa_append [phi:ultoa::@3->ultoa_append]
  ultoa_append_from_b3:
    jsr ultoa_append
    // [142] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2
    jmp b5
    // ultoa::@5
  b5:
    // [143] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0
    // [144] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [130] phi from ultoa::@5 to ultoa::@2 [phi:ultoa::@5->ultoa::@2]
  b2_from_b5:
    // [130] phi (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#3 [phi:ultoa::@5->ultoa::@2#0] -- register_copy 
    // [130] phi (byte) ultoa::started#3 = (byte) 1 [phi:ultoa::@5->ultoa::@2#1] -- vbuxx=vbuc1 
    ldx #1
    // [130] phi (dword) ultoa::value#4 = (dword) ultoa::value#0 [phi:ultoa::@5->ultoa::@2#2] -- register_copy 
    jmp b2
}
  // ultoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// ultoa_append(byte* zeropage($1c) buffer, dword zeropage($18) value, dword zeropage($30) sub)
ultoa_append: {
    .label buffer = $1c
    .label value = $18
    .label sub = $30
    .label return = $18
    // [146] phi from ultoa_append to ultoa_append::@1 [phi:ultoa_append->ultoa_append::@1]
  b1_from_ultoa_append:
    // [146] phi (byte) ultoa_append::digit#2 = (byte) 0 [phi:ultoa_append->ultoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [146] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#0 [phi:ultoa_append->ultoa_append::@1#1] -- register_copy 
    jmp b1
    // ultoa_append::@1
  b1:
    // [147] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 -- vduz1_ge_vduz2_then_la1 
    lda value+3
    cmp sub+3
    bcc !+
    bne b2
    lda value+2
    cmp sub+2
    bcc !+
    bne b2
    lda value+1
    cmp sub+1
    bcc !+
    bne b2
    lda value
    cmp sub
    bcs b2
  !:
    jmp b3
    // ultoa_append::@3
  b3:
    // [148] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) ultoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    jmp breturn
    // ultoa_append::@return
  breturn:
    // [149] return 
    rts
    // ultoa_append::@2
  b2:
    // [150] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // [151] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 -- vduz1=vduz1_minus_vduz2 
    lda value
    sec
    sbc sub
    sta value
    lda value+1
    sbc sub+1
    sta value+1
    lda value+2
    sbc sub+2
    sta value+2
    lda value+3
    sbc sub+3
    sta value+3
    // [146] phi from ultoa_append::@2 to ultoa_append::@1 [phi:ultoa_append::@2->ultoa_append::@1]
  b1_from_b2:
    // [146] phi (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#1 [phi:ultoa_append::@2->ultoa_append::@1#0] -- register_copy 
    // [146] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#1 [phi:ultoa_append::@2->ultoa_append::@1#1] -- register_copy 
    jmp b1
}
  // div32u16u
// Divide unsigned 32-bit dword dividend with a 16-bit word divisor
// The 16-bit word remainder can be found in rem16u after the division
// div32u16u(dword zeropage($18) dividend)
div32u16u: {
    .label divisor = CLOCKS_PER_SEC/$64
    .label quotient_hi = $34
    .label quotient_lo = $22
    .label return = $28
    .label dividend = $18
    // [152] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 -- vwuz1=_hi_vduz2 
    lda dividend+2
    sta divr16u.dividend
    lda dividend+3
    sta divr16u.dividend+1
    // [153] call divr16u 
    // [163] phi from div32u16u to divr16u [phi:div32u16u->divr16u]
  divr16u_from_div32u16u:
    // [163] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#1 [phi:div32u16u->divr16u#0] -- register_copy 
    // [163] phi (word) divr16u::rem#10 = (byte) 0 [phi:div32u16u->divr16u#1] -- vwuz1=vbuc1 
    lda #<0
    sta divr16u.rem
    lda #>0
    sta divr16u.rem+1
    jsr divr16u
    // [154] (word) divr16u::return#2 ← (word) divr16u::return#0
    jmp b1
    // div32u16u::@1
  b1:
    // [155] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda divr16u.return
    sta quotient_hi
    lda divr16u.return+1
    sta quotient_hi+1
    // [156] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 -- vwuz1=_lo_vduz2 
    lda dividend
    sta divr16u.dividend
    lda dividend+1
    sta divr16u.dividend+1
    // [157] (word) divr16u::rem#4 ← (word) rem16u#1
    // [158] call divr16u 
    // [163] phi from div32u16u::@1 to divr16u [phi:div32u16u::@1->divr16u]
  divr16u_from_b1:
    // [163] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#2 [phi:div32u16u::@1->divr16u#0] -- register_copy 
    // [163] phi (word) divr16u::rem#10 = (word) divr16u::rem#4 [phi:div32u16u::@1->divr16u#1] -- register_copy 
    jsr divr16u
    // [159] (word) divr16u::return#3 ← (word) divr16u::return#0
    jmp b2
    // div32u16u::@2
  b2:
    // [160] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3
    // [161] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 -- vduz1=vwuz2_dword_vwuz3 
    lda quotient_hi
    sta return+2
    lda quotient_hi+1
    sta return+3
    lda quotient_lo
    sta return
    lda quotient_lo+1
    sta return+1
    jmp breturn
    // div32u16u::@return
  breturn:
    // [162] return 
    rts
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($20) dividend, word zeropage($1e) rem)
divr16u: {
    .label rem = $1e
    .label dividend = $20
    .label quotient = $22
    .label return = $22
    // [164] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
  b1_from_divr16u:
    // [164] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [164] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    lda #<0
    sta quotient
    lda #>0
    sta quotient+1
    // [164] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#5 [phi:divr16u->divr16u::@1#2] -- register_copy 
    // [164] phi (word) divr16u::rem#5 = (word) divr16u::rem#10 [phi:divr16u->divr16u::@1#3] -- register_copy 
    jmp b1
    // [164] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
  b1_from_b3:
    // [164] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [164] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [164] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [164] phi (word) divr16u::rem#5 = (word) divr16u::rem#11 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    jmp b1
    // divr16u::@1
  b1:
    // [165] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl rem
    rol rem+1
    // [166] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 -- vbuaa=_hi_vwuz1 
    lda dividend+1
    // [167] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [168] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2_from_b1
    jmp b4
    // divr16u::@4
  b4:
    // [169] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora rem
    sta rem
    // [170] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
  b2_from_b1:
  b2_from_b4:
    // [170] phi (word) divr16u::rem#6 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    jmp b2
    // divr16u::@2
  b2:
    // [171] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl dividend
    rol dividend+1
    // [172] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl quotient
    rol quotient+1
    // [173] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuc1_then_la1 
    lda rem+1
    cmp #>div32u16u.divisor
    bcc b3_from_b2
    bne !+
    lda rem
    cmp #<div32u16u.divisor
    bcc b3_from_b2
  !:
    jmp b5
    // divr16u::@5
  b5:
    // [174] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc quotient
    bne !+
    inc quotient+1
  !:
    // [175] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 -- vwuz1=vwuz1_minus_vwuc1 
    lda rem
    sec
    sbc #<div32u16u.divisor
    sta rem
    lda rem+1
    sbc #>div32u16u.divisor
    sta rem+1
    // [176] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
  b3_from_b2:
  b3_from_b5:
    // [176] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [176] phi (word) divr16u::rem#11 = (word) divr16u::rem#6 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    jmp b3
    // divr16u::@3
  b3:
    // [177] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [178] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$10
    bne b1_from_b3
    jmp b6
    // divr16u::@6
  b6:
    // [179] (word) rem16u#1 ← (word) divr16u::rem#11
    jmp breturn
    // divr16u::@return
  breturn:
    // [180] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $18
    // [181] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta return+3
    jmp breturn
    // clock::@return
  breturn:
    // [182] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // [183] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // [184] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [185] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // [186] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // [187] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    jmp breturn
    // clock_start::@return
  breturn:
    // [188] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage($26) str, byte register(X) c, word zeropage($24) num)
memset: {
    .label end = $24
    .label dst = $26
    .label num = $24
    .label str = $26
    // [190] if((word) memset::num#2<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda num
    bne !+
    lda num+1
    beq breturn
  !:
    jmp b1
    // memset::@1
  b1:
    // [191] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 -- pbuz1=pbuz2_plus_vwuz1 
    lda end
    clc
    adc str
    sta end
    lda end+1
    adc str+1
    sta end+1
    // [192] (byte*~) memset::dst#3 ← (byte*)(void*) memset::str#3
    // [193] phi from memset::@1 memset::@2 to memset::@2 [phi:memset::@1/memset::@2->memset::@2]
  b2_from_b1:
  b2_from_b2:
    // [193] phi (byte*) memset::dst#2 = (byte*~) memset::dst#3 [phi:memset::@1/memset::@2->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [194] *((byte*) memset::dst#2) ← (byte) memset::c#3 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
    // [196] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuz2_then_la1 
    lda dst+1
    cmp end+1
    bne b2_from_b2
    lda dst
    cmp end
    bne b2_from_b2
    jmp breturn
    // memset::@return
  breturn:
    // [197] return 
    rts
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // [199] call memset 
    // [189] phi from print_cls to memset [phi:print_cls->memset]
  memset_from_print_cls:
    // [189] phi (byte) memset::c#3 = (byte) ' ' [phi:print_cls->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [189] phi (void*) memset::str#3 = (void*)(byte*) 1024 [phi:print_cls->memset#1] -- pvoz1=pvoc1 
    lda #<$400
    sta memset.str
    lda #>$400
    sta memset.str+1
    // [189] phi (word) memset::num#2 = (word) $3e8 [phi:print_cls->memset#2] -- vwuz1=vwuc1 
    lda #<$3e8
    sta memset.num
    lda #>$3e8
    sta memset.num+1
    jsr memset
    jmp breturn
    // print_cls::@return
  breturn:
    // [200] return 
    rts
}
  // File Data
  // The digits used for numbers
  DIGITS: .text "0123456789abcdef"
  // Values of decimal digits
  RADIX_DECIMAL_VALUES: .word $2710, $3e8, $64, $a
  // Values of decimal digits
  RADIX_DECIMAL_VALUES_LONG: .dword $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a
  // Digits used for storing the decimal word
  decimal_digits: .fill 6, 0
  // Digits used for storing the decimal word
  decimal_digits_long: .fill $b, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp toD0181
Removing instruction jmp b13
Removing instruction jmp b14
Removing instruction jmp b15
Removing instruction jmp b16
Removing instruction jmp b17
Removing instruction jmp b18
Removing instruction jmp b19
Removing instruction jmp b20
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b21
Removing instruction jmp b22
Removing instruction jmp b23
Removing instruction jmp b24
Removing instruction jmp b25
Removing instruction jmp b26
Removing instruction jmp b8
Removing instruction jmp b10
Removing instruction jmp b27
Removing instruction jmp b9
Removing instruction jmp b11
Removing instruction jmp b12
Removing instruction jmp b7
Removing instruction jmp b5
Removing instruction jmp b4
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b6
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b5
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b6
Removing instruction jmp b2
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b5
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b6
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Replacing instruction lda #0 with TXA
Replacing instruction ldy #0 with TAY
Replacing instruction lda #0 with TXA
Replacing instruction ldy #0 with TAY
Removing instruction lda #>0
Replacing instruction lda #<0 with TXA
Removing instruction lda #>0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b9_from_b29 with b9
Replacing label b5_from_b6 with b5
Replacing label b1_from_b2 with b1
Replacing label b1_from_b2 with b1
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Replacing label b1_from_b2 with b1
Replacing label b2_from_b1 with b2
Replacing label b3_from_b2 with b3
Replacing label b3_from_b2 with b3
Replacing label b1_from_b3 with b1
Replacing label b2_from_b2 with b2
Replacing label b2_from_b2 with b2
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction toD0181_from_main:
Removing instruction toD0181:
Removing instruction b14_from_b13:
Removing instruction print_str_from_b14:
Removing instruction b15_from_b14:
Removing instruction print_ln_from_b15:
Removing instruction b17_from_b16:
Removing instruction print_word_decimal_from_b17:
Removing instruction b18_from_b17:
Removing instruction print_ln_from_b18:
Removing instruction b19_from_b18:
Removing instruction memset_from_b19:
Removing instruction b20_from_b19:
Removing instruction b3_from_b1:
Removing instruction print_word_decimal_from_b23:
Removing instruction b24_from_b23:
Removing instruction print_str_from_b24:
Removing instruction b26_from_b25:
Removing instruction print_ln_from_b26:
Removing instruction b27_from_b10:
Removing instruction b9_from_b27:
Removing instruction b9_from_b29:
Removing instruction b11_from_b9:
Removing instruction print_str_from_b11:
Removing instruction b5_from_b6:
Removing instruction b5_from_b7:
Removing instruction b1_from_print_str:
Removing instruction b1_from_b2:
Removing instruction b1_from_print_word_decimal:
Removing instruction print_str_from_b1:
Removing instruction b1_from_b2:
Removing instruction b2_from_b6:
Removing instruction utoa_append_from_b3:
Removing instruction b1_from_print_ln:
Removing instruction b1_from_b1:
Removing instruction b1_from_print_dword_decimal:
Removing instruction print_str_from_b1:
Removing instruction b1_from_b2:
Removing instruction b2_from_b6:
Removing instruction ultoa_append_from_b3:
Removing instruction b1_from_b3:
Removing instruction b2_from_b1:
Removing instruction b2_from_b4:
Removing instruction b3_from_b2:
Removing instruction b3_from_b5:
Removing instruction breturn:
Removing instruction b2_from_b1:
Removing instruction b2_from_b2:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b13:
Removing instruction print_cls_from_b13:
Removing instruction b14:
Removing instruction b15:
Removing instruction b16:
Removing instruction print_str_from_b16:
Removing instruction b17:
Removing instruction b18:
Removing instruction b19:
Removing instruction b20:
Removing instruction b1_from_b20:
Removing instruction b3:
Removing instruction b21:
Removing instruction b22:
Removing instruction print_str_from_b22:
Removing instruction b23:
Removing instruction b24:
Removing instruction b25:
Removing instruction b26:
Removing instruction b8_from_b26:
Removing instruction b10:
Removing instruction print_word_decimal_from_b10:
Removing instruction b27:
Removing instruction b11:
Removing instruction b8_from_b28:
Removing instruction b7:
Removing instruction b1_from_b4:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction utoa_from_print_word_decimal:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_utoa:
Removing instruction b6:
Removing instruction b4:
Removing instruction breturn:
Removing instruction b5:
Removing instruction b2_from_b5:
Removing instruction b1_from_utoa_append:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction breturn:
Removing instruction ultoa_from_print_dword_decimal:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_ultoa:
Removing instruction b6:
Removing instruction b4:
Removing instruction breturn:
Removing instruction b5:
Removing instruction b2_from_b5:
Removing instruction b1_from_ultoa_append:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction divr16u_from_div32u16u:
Removing instruction b1:
Removing instruction divr16u_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction b1_from_divr16u:
Removing instruction b4:
Removing instruction b5:
Removing instruction b6:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction b1:
Removing instruction memset_from_print_cls:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Removing instruction jmp b1
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda digit_value+1
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination
Fixing long branch [105] bcc b2 to bcs
Fixing long branch [111] bcc b2 to bcs

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(dword*) CIA2_TIMER_AB
(const dword*) CIA2_TIMER_AB#0 CIA2_TIMER_AB = (dword*) 56580
(byte*) CIA2_TIMER_A_CONTROL
(const byte*) CIA2_TIMER_A_CONTROL#0 CIA2_TIMER_A_CONTROL = (byte*) 56590
(byte*) CIA2_TIMER_B_CONTROL
(const byte*) CIA2_TIMER_B_CONTROL#0 CIA2_TIMER_B_CONTROL = (byte*) 56591
(byte) CIA_TIMER_CONTROL_A_COUNT_CYCLES
(byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = (byte) $40
(byte) CIA_TIMER_CONTROL_CONTINUOUS
(const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 CIA_TIMER_CONTROL_CONTINUOUS = (byte) 0
(byte) CIA_TIMER_CONTROL_START
(const byte) CIA_TIMER_CONTROL_START#0 CIA_TIMER_CONTROL_START = (byte) 1
(byte) CIA_TIMER_CONTROL_STOP
(word) CLOCKS_PER_FRAME
(const word) CLOCKS_PER_FRAME#0 CLOCKS_PER_FRAME = (word) $4cc8
(dword) CLOCKS_PER_INIT
(const dword) CLOCKS_PER_INIT#0 CLOCKS_PER_INIT = (byte) $12
(dword) CLOCKS_PER_SEC
(const dword) CLOCKS_PER_SEC#0 CLOCKS_PER_SEC = (const word) CLOCKS_PER_FRAME#0*(const byte) FRAMES_PER_SEC#0
(word) COUNT
(const word) COUNT#0 COUNT = (word) $4000
(byte*) D018
(const byte*) D018#0 D018 = (byte*) 53272
(byte[]) DIGITS
(const byte[]) DIGITS#0 DIGITS = (string) "0123456789abcdef"
(byte) FRAMES_PER_SEC
(const byte) FRAMES_PER_SEC#0 FRAMES_PER_SEC = (byte) $3c
(const byte) RADIX::BINARY BINARY = (number) 2
(const byte) RADIX::DECIMAL DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL OCTAL = (number) 8
(word[]) RADIX_BINARY_VALUES
(dword[]) RADIX_BINARY_VALUES_LONG
(word[]) RADIX_DECIMAL_VALUES
(const word[]) RADIX_DECIMAL_VALUES#0 RADIX_DECIMAL_VALUES = { (word) $2710, (word) $3e8, (word) $64, (word) $a }
(dword[]) RADIX_DECIMAL_VALUES_LONG
(const dword[]) RADIX_DECIMAL_VALUES_LONG#0 RADIX_DECIMAL_VALUES_LONG = { (dword) $3b9aca00, (dword) $5f5e100, (dword) $989680, (dword) $f4240, (dword) $186a0, (dword) $2710, (dword) $3e8, (dword) $64, (dword) $a }
(word[]) RADIX_HEXADECIMAL_VALUES
(dword[]) RADIX_HEXADECIMAL_VALUES_LONG
(word[]) RADIX_OCTAL_VALUES
(dword[]) RADIX_OCTAL_VALUES_LONG
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = (byte*) 1024
(byte) SQRT_COUNT
(const byte) SQRT_COUNT#0 SQRT_COUNT = (byte) $80
(dword()) clock()
(label) clock::@return
(dword) clock::return
(dword) clock::return#0 return zp ZP_DWORD:24 1.3333333333333333
(dword) clock::return#2 return zp ZP_DWORD:24 4.0
(void()) clock_start()
(label) clock_start::@return
(byte[6]) decimal_digits
(const byte[6]) decimal_digits#0 decimal_digits = { fill( 6, 0) }
(byte[$b]) decimal_digits_long
(const byte[$b]) decimal_digits_long#0 decimal_digits_long = { fill( $b, 0) }
(dword()) div32u16u((dword) div32u16u::dividend , (word) div32u16u::divisor)
(label) div32u16u::@1
(label) div32u16u::@2
(label) div32u16u::@return
(dword) div32u16u::dividend
(dword) div32u16u::dividend#0 dividend zp ZP_DWORD:24 1.2000000000000002
(word) div32u16u::divisor
(const word) div32u16u::divisor#0 divisor = (word)(const dword) CLOCKS_PER_SEC#0/(byte) $64
(dword) div32u16u::quotient
(word) div32u16u::quotient_hi
(word) div32u16u::quotient_hi#0 quotient_hi zp ZP_WORD:52 0.6666666666666666
(word) div32u16u::quotient_lo
(word) div32u16u::quotient_lo#0 quotient_lo zp ZP_WORD:34 4.0
(dword) div32u16u::return
(dword) div32u16u::return#0 return zp ZP_DWORD:40 1.3333333333333333
(dword) div32u16u::return#2 return zp ZP_DWORD:40 4.0
(word()) divr16u((word) divr16u::dividend , (word) divr16u::divisor , (word) divr16u::rem)
(byte~) divr16u::$1 reg byte a 22.0
(byte~) divr16u::$2 reg byte a 22.0
(label) divr16u::@1
(label) divr16u::@2
(label) divr16u::@3
(label) divr16u::@4
(label) divr16u::@5
(label) divr16u::@6
(label) divr16u::@return
(word) divr16u::dividend
(word) divr16u::dividend#0 dividend zp ZP_WORD:32 2.75
(word) divr16u::dividend#1 dividend zp ZP_WORD:32 4.0
(word) divr16u::dividend#2 dividend zp ZP_WORD:32 2.0
(word) divr16u::dividend#3 dividend zp ZP_WORD:32 5.0
(word) divr16u::dividend#5 dividend zp ZP_WORD:32 6.0
(word) divr16u::divisor
(byte) divr16u::i
(byte) divr16u::i#1 reg byte x 16.5
(byte) divr16u::i#2 reg byte x 1.6923076923076923
(word) divr16u::quotient
(word) divr16u::quotient#1 quotient zp ZP_WORD:34 16.5
(word) divr16u::quotient#2 quotient zp ZP_WORD:34 11.0
(word) divr16u::quotient#3 quotient zp ZP_WORD:34 2.75
(word) divr16u::rem
(word) divr16u::rem#0 rem zp ZP_WORD:30 8.25
(word) divr16u::rem#1 rem zp ZP_WORD:30 22.0
(word) divr16u::rem#10 rem zp ZP_WORD:30 4.0
(word) divr16u::rem#11 rem zp ZP_WORD:30 11.666666666666666
(word) divr16u::rem#2 rem zp ZP_WORD:30 22.0
(word) divr16u::rem#4 rem zp ZP_WORD:30 4.0
(word) divr16u::rem#5 rem zp ZP_WORD:30 24.0
(word) divr16u::rem#6 rem zp ZP_WORD:30 11.0
(word) divr16u::return
(word) divr16u::return#0 return zp ZP_WORD:34 5.285714285714286
(word) divr16u::return#2 return zp ZP_WORD:34 4.0
(word) divr16u::return#3 return zp ZP_WORD:34 4.0
(void()) main()
(dword~) main::$10 $10 zp ZP_DWORD:24 4.0
(dword~) main::$14 $14 zp ZP_DWORD:40 2.0
(byte*~) main::$38 $38 zp ZP_WORD:44 22.0
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@18
(label) main::@19
(label) main::@2
(label) main::@20
(label) main::@21
(label) main::@22
(label) main::@23
(label) main::@24
(label) main::@25
(label) main::@26
(label) main::@27
(label) main::@28
(label) main::@29
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(dword) main::cyclecount
(dword) main::cyclecount#0 cyclecount zp ZP_DWORD:24 0.5
(word) main::i
(word) main::i#10 i#10 zp ZP_WORD:6 4.4
(word) main::i#11 i zp ZP_WORD:2 24.6
(word) main::i#2 i zp ZP_WORD:2 11.0
(word) main::i#3 i#3 zp ZP_WORD:6 11.0
(word) main::j
(word) main::j#0 j zp ZP_WORD:8 16.5
(word) main::j#1 j zp ZP_WORD:8 202.0
(word) main::j#2 j zp ZP_WORD:8 78.5
(byte*) main::s
(byte*) main::s#0 s zp ZP_WORD:10 22.0
(byte*) main::s#1 s zp ZP_WORD:10 101.0
(byte*) main::s#2 s zp ZP_WORD:10 104.66666666666666
(word) main::sec100s
(word) main::sec100s#0 sec100s zp ZP_WORD:6 1.3333333333333333
(byte*) main::sieve_i
(byte*) main::sieve_i#1 sieve_i zp ZP_WORD:4 22.0
(byte*) main::sieve_i#2 sieve_i zp ZP_WORD:4 3.0
(const string) main::str str = (string) "Sieve benchmark - calculating primes@"
(const string) main::str1 str1 = (string) "between 2 and @"
(const string) main::str2 str2 = (string) "100ths seconds used: @"
(const string) main::str3 str3 = (string) " cycles: @"
(const string) main::str4 str4 = (string) "...@"
(label) main::toD0181
(word~) main::toD0181_$0
(number~) main::toD0181_$1
(number~) main::toD0181_$2
(number~) main::toD0181_$3
(word~) main::toD0181_$4
(byte~) main::toD0181_$5
(number~) main::toD0181_$6
(number~) main::toD0181_$7
(number~) main::toD0181_$8
(byte*) main::toD0181_gfx
(const byte*) main::toD0181_gfx#0 toD0181_gfx = (byte*) 6144
(byte) main::toD0181_return
(const byte) main::toD0181_return#0 toD0181_return = >(word)(const byte*) SCREEN#0&(word) $3fff*(byte) 4|>(word)(const byte*) main::toD0181_gfx#0/(byte) 4&(byte) $f
(byte*) main::toD0181_screen
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@return
(byte) memset::c
(byte) memset::c#3 reg byte x 1.375
(byte*) memset::dst
(byte*) memset::dst#1 dst zp ZP_WORD:38 16.5
(byte*) memset::dst#2 dst zp ZP_WORD:38 17.5
(byte*~) memset::dst#3 dst zp ZP_WORD:38 4.0
(byte*) memset::end
(byte*) memset::end#0 end zp ZP_WORD:36 2.1666666666666665
(word) memset::num
(word) memset::num#2 num zp ZP_WORD:36 2.0
(void*) memset::return
(void*) memset::str
(void*) memset::str#3 str zp ZP_WORD:38
(void()) print_char((byte) print_char::ch)
(label) print_char::@return
(byte) print_char::ch
(const byte) print_char::ch#0 ch = (byte) ' '
(byte*) print_char_cursor
(byte*) print_char_cursor#1 print_char_cursor zp ZP_WORD:12 101.0
(byte*) print_char_cursor#10 print_char_cursor zp ZP_WORD:12 4.333333333333333
(byte*~) print_char_cursor#101 print_char_cursor zp ZP_WORD:12 22.0
(byte*) print_char_cursor#2 print_char_cursor zp ZP_WORD:12 10.25
(byte*) print_char_cursor#58 print_char_cursor zp ZP_WORD:12 4.25
(byte*) print_char_cursor#62 print_char_cursor#62 zp ZP_WORD:21 8.75
(byte*) print_char_cursor#63 print_char_cursor zp ZP_WORD:12 8.75
(byte*) print_char_cursor#66 print_char_cursor zp ZP_WORD:12 14.0
(byte*~) print_char_cursor#89 print_char_cursor zp ZP_WORD:12 4.0
(byte*~) print_char_cursor#90 print_char_cursor zp ZP_WORD:12 4.0
(byte*~) print_char_cursor#96 print_char_cursor zp ZP_WORD:12 22.0
(byte*~) print_char_cursor#99 print_char_cursor#99 zp ZP_WORD:21 22.0
(void()) print_cls()
(label) print_cls::@return
(void()) print_dword_decimal((dword) print_dword_decimal::w)
(label) print_dword_decimal::@1
(label) print_dword_decimal::@return
(dword) print_dword_decimal::w
(dword) print_dword_decimal::w#0 w zp ZP_DWORD:24 4.0
(byte*) print_line_cursor
(byte*) print_line_cursor#1 print_line_cursor zp ZP_WORD:21 0.9347826086956521
(byte*) print_line_cursor#11 print_line_cursor zp ZP_WORD:21 24.0
(byte*) print_line_cursor#21 print_line_cursor zp ZP_WORD:21 6.0
(void()) print_ln()
(label) print_ln::@1
(label) print_ln::@return
(byte*) print_screen
(void()) print_str((byte*) print_str::str)
(label) print_str::@1
(label) print_str::@2
(label) print_str::@return
(byte*) print_str::str
(byte*) print_str::str#0 str zp ZP_WORD:14 202.0
(byte*) print_str::str#10 str zp ZP_WORD:14 2.0
(byte*) print_str::str#8 str zp ZP_WORD:14 101.5
(void()) print_word_decimal((word) print_word_decimal::w)
(label) print_word_decimal::@1
(label) print_word_decimal::@return
(word) print_word_decimal::w
(word) print_word_decimal::w#1 w zp ZP_WORD:6 4.0
(word) print_word_decimal::w#2 w zp ZP_WORD:6 11.0
(word) print_word_decimal::w#3 w zp ZP_WORD:6 15.0
(word) rem16u
(word) rem16u#1 rem16u zp ZP_WORD:30 0.6666666666666666
(byte*) sieve
(const byte*) sieve#0 sieve = (byte*) 4096
(void()) ultoa((dword) ultoa::value , (byte*) ultoa::buffer , (byte) ultoa::radix)
(byte~) ultoa::$11 reg byte a 22.0
(byte~) ultoa::$4 reg byte a 4.0
(label) ultoa::@1
(label) ultoa::@2
(label) ultoa::@3
(label) ultoa::@4
(label) ultoa::@5
(label) ultoa::@6
(label) ultoa::@return
(byte*) ultoa::buffer
(byte*) ultoa::buffer#11 buffer zp ZP_WORD:28 4.0
(byte*) ultoa::buffer#12 buffer zp ZP_WORD:28 7.400000000000001
(byte*) ultoa::buffer#3 buffer zp ZP_WORD:28 22.0
(byte*) ultoa::buffer#4 buffer zp ZP_WORD:28 4.0
(byte) ultoa::digit
(byte) ultoa::digit#1 digit zp ZP_BYTE:23 16.5
(byte) ultoa::digit#2 digit zp ZP_BYTE:23 2.5384615384615383
(dword) ultoa::digit_value
(dword) ultoa::digit_value#0 digit_value zp ZP_DWORD:48 6.6000000000000005
(dword*) ultoa::digit_values
(byte) ultoa::max_digits
(const byte) ultoa::max_digits#1 max_digits = (byte) $a
(byte) ultoa::radix
(byte) ultoa::started
(byte) ultoa::started#2 reg byte x 6.6000000000000005
(byte) ultoa::started#3 reg byte x 7.333333333333333
(dword) ultoa::value
(dword) ultoa::value#0 value zp ZP_DWORD:24 11.0
(dword) ultoa::value#1 value zp ZP_DWORD:24 2.0
(dword) ultoa::value#2 value zp ZP_DWORD:24 7.666666666666666
(dword) ultoa::value#4 value zp ZP_DWORD:24 11.0
(dword()) ultoa_append((byte*) ultoa_append::buffer , (dword) ultoa_append::value , (dword) ultoa_append::sub)
(label) ultoa_append::@1
(label) ultoa_append::@2
(label) ultoa_append::@3
(label) ultoa_append::@return
(byte*) ultoa_append::buffer
(byte*) ultoa_append::buffer#0 buffer zp ZP_WORD:28 1.625
(byte) ultoa_append::digit
(byte) ultoa_append::digit#1 reg byte x 101.0
(byte) ultoa_append::digit#2 reg byte x 102.0
(dword) ultoa_append::return
(dword) ultoa_append::return#0 return zp ZP_DWORD:24 22.0
(dword) ultoa_append::sub
(dword) ultoa_append::sub#0 sub zp ZP_DWORD:48 35.5
(dword) ultoa_append::value
(dword) ultoa_append::value#0 value zp ZP_DWORD:24 4.333333333333333
(dword) ultoa_append::value#1 value zp ZP_DWORD:24 202.0
(dword) ultoa_append::value#2 value zp ZP_DWORD:24 52.66666666666666
(void()) utoa((word) utoa::value , (byte*) utoa::buffer , (byte) utoa::radix)
(byte~) utoa::$11 reg byte a 202.0
(byte~) utoa::$4 reg byte a 4.0
(label) utoa::@1
(label) utoa::@2
(label) utoa::@3
(label) utoa::@4
(label) utoa::@5
(label) utoa::@6
(label) utoa::@return
(byte*) utoa::buffer
(byte*) utoa::buffer#11 buffer zp ZP_WORD:19 36.72727272727273
(byte*) utoa::buffer#12 buffer zp ZP_WORD:19 61.39999999999999
(byte*) utoa::buffer#3 buffer zp ZP_WORD:19 202.0
(byte*) utoa::buffer#4 buffer zp ZP_WORD:19 4.0
(byte) utoa::digit
(byte) utoa::digit#1 digit zp ZP_BYTE:16 151.5
(byte) utoa::digit#2 digit zp ZP_BYTE:16 23.307692307692307
(word) utoa::digit_value
(word) utoa::digit_value#0 digit_value zp ZP_WORD:46 60.599999999999994
(word*) utoa::digit_values
(byte) utoa::max_digits
(const byte) utoa::max_digits#1 max_digits = (byte) 5
(byte) utoa::radix
(byte) utoa::started
(byte) utoa::started#2 reg byte x 60.599999999999994
(byte) utoa::started#3 reg byte x 67.33333333333333
(word) utoa::value
(word) utoa::value#0 value zp ZP_WORD:17 101.0
(word) utoa::value#1 value zp ZP_WORD:17 2.0
(word) utoa::value#2 value zp ZP_WORD:17 67.66666666666666
(word) utoa::value#4 value zp ZP_WORD:17 101.0
(word()) utoa_append((byte*) utoa_append::buffer , (word) utoa_append::value , (word) utoa_append::sub)
(label) utoa_append::@1
(label) utoa_append::@2
(label) utoa_append::@3
(label) utoa_append::@return
(byte*) utoa_append::buffer
(byte*) utoa_append::buffer#0 buffer zp ZP_WORD:19 12.875
(byte) utoa_append::digit
(byte) utoa_append::digit#1 reg byte x 1001.0
(byte) utoa_append::digit#2 reg byte x 1002.0
(word) utoa_append::return
(word) utoa_append::return#0 return zp ZP_WORD:17 202.0
(word) utoa_append::sub
(word) utoa_append::sub#0 sub zp ZP_WORD:46 350.5
(word) utoa_append::value
(word) utoa_append::value#0 value zp ZP_WORD:17 34.33333333333333
(word) utoa_append::value#1 value zp ZP_WORD:17 2002.0
(word) utoa_append::value#2 value zp ZP_WORD:17 517.6666666666667

zp ZP_WORD:2 [ main::i#11 main::i#2 ]
zp ZP_WORD:4 [ main::sieve_i#2 main::sieve_i#1 ]
zp ZP_WORD:6 [ main::i#10 main::i#3 print_word_decimal::w#3 print_word_decimal::w#2 print_word_decimal::w#1 main::sec100s#0 ]
zp ZP_WORD:8 [ main::j#2 main::j#0 main::j#1 ]
zp ZP_WORD:10 [ main::s#2 main::s#0 main::s#1 ]
zp ZP_WORD:12 [ print_char_cursor#66 print_char_cursor#63 print_char_cursor#101 print_char_cursor#10 print_char_cursor#89 print_char_cursor#90 print_char_cursor#2 print_char_cursor#58 print_char_cursor#1 print_char_cursor#96 ]
zp ZP_WORD:14 [ print_str::str#8 print_str::str#10 print_str::str#0 ]
zp ZP_BYTE:16 [ utoa::digit#2 utoa::digit#1 ]
zp ZP_WORD:17 [ utoa::value#2 utoa::value#4 utoa::value#1 utoa::value#0 utoa_append::value#2 utoa_append::value#0 utoa_append::value#1 utoa_append::return#0 ]
reg byte x [ utoa::started#2 utoa::started#3 ]
zp ZP_WORD:19 [ utoa::buffer#11 utoa::buffer#12 utoa::buffer#3 utoa::buffer#4 utoa_append::buffer#0 ]
reg byte x [ utoa_append::digit#2 utoa_append::digit#1 ]
zp ZP_WORD:21 [ print_line_cursor#11 print_line_cursor#21 print_char_cursor#62 print_char_cursor#99 print_line_cursor#1 ]
zp ZP_BYTE:23 [ ultoa::digit#2 ultoa::digit#1 ]
zp ZP_DWORD:24 [ ultoa::value#2 ultoa::value#4 ultoa::value#1 ultoa::value#0 ultoa_append::value#2 ultoa_append::value#0 ultoa_append::value#1 print_dword_decimal::w#0 ultoa_append::return#0 main::cyclecount#0 div32u16u::dividend#0 clock::return#2 main::$10 clock::return#0 ]
reg byte x [ ultoa::started#2 ultoa::started#3 ]
zp ZP_WORD:28 [ ultoa::buffer#11 ultoa::buffer#12 ultoa::buffer#3 ultoa::buffer#4 ultoa_append::buffer#0 ]
reg byte x [ ultoa_append::digit#2 ultoa_append::digit#1 ]
zp ZP_WORD:30 [ divr16u::rem#5 divr16u::rem#10 divr16u::rem#4 divr16u::rem#11 divr16u::rem#6 divr16u::rem#0 divr16u::rem#1 divr16u::rem#2 rem16u#1 ]
zp ZP_WORD:32 [ divr16u::dividend#3 divr16u::dividend#5 divr16u::dividend#1 divr16u::dividend#2 divr16u::dividend#0 ]
zp ZP_WORD:34 [ divr16u::quotient#3 divr16u::return#0 divr16u::quotient#1 divr16u::quotient#2 divr16u::return#2 divr16u::return#3 div32u16u::quotient_lo#0 ]
reg byte x [ divr16u::i#2 divr16u::i#1 ]
zp ZP_WORD:36 [ memset::num#2 memset::end#0 ]
zp ZP_WORD:38 [ memset::str#3 memset::dst#2 memset::dst#3 memset::dst#1 ]
reg byte x [ memset::c#3 ]
zp ZP_DWORD:40 [ div32u16u::return#2 main::$14 div32u16u::return#0 ]
zp ZP_WORD:44 [ main::$38 ]
reg byte a [ utoa::$11 ]
zp ZP_WORD:46 [ utoa::digit_value#0 utoa_append::sub#0 ]
reg byte a [ utoa::$4 ]
reg byte a [ ultoa::$11 ]
zp ZP_DWORD:48 [ ultoa::digit_value#0 ultoa_append::sub#0 ]
reg byte a [ ultoa::$4 ]
zp ZP_WORD:52 [ div32u16u::quotient_hi#0 ]
reg byte a [ divr16u::$1 ]
reg byte a [ divr16u::$2 ]


FINAL ASSEMBLER
Score: 82987

  // File Comments
  // Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label D018 = $d018
  // CIA #2 Timer A+B Value (32-bit)
  .label CIA2_TIMER_AB = $dd04
  // CIA #2 Timer A Control Register
  .label CIA2_TIMER_A_CONTROL = $dd0e
  // CIA #2 Timer B Control Register
  .label CIA2_TIMER_B_CONTROL = $dd0f
  // Timer Control - Start/stop timer (0:stop, 1: start)
  .const CIA_TIMER_CONTROL_START = 1
  // Timer Control - Time CONTINUOUS/ONE-SHOT (0:CONTINUOUS, 1: ONE-SHOT)
  .const CIA_TIMER_CONTROL_CONTINUOUS = 0
  // Timer B Control - Timer counts (00:system cycles, 01: CNT pulses, 10: timer A underflow, 11: time A underflow while CNT is high)
  .const CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A = $40
  // Clock cycles per frame (on a C64 PAL)
  .const CLOCKS_PER_FRAME = $4cc8
  // Frames per second (on a C64 PAL)
  .const FRAMES_PER_SEC = $3c
  // Clock cycles used to start & read the cycle clock by calling clock_start() and clock() once. Can be subtracted when calculating the number of cycles used by a routine.
  // To make precise cycle measurements interrupts and the display must be disabled so neither steals any cycles from the code.
  .const CLOCKS_PER_INIT = $12
  .label SCREEN = $400
  .const COUNT = $4000
  /* Up to what number? */
  .const SQRT_COUNT = $80
  /* Sqrt of COUNT */
  .label sieve = $1000
  // Clock cycles per second (on a C64 PAL)
  .const CLOCKS_PER_SEC = CLOCKS_PER_FRAME*FRAMES_PER_SEC
  .label rem16u = $1e
  .label print_char_cursor = $c
  .label print_line_cursor = $15
  .label print_char_cursor_62 = $15
  .label print_char_cursor_99 = $15
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label toD0181_gfx = $1800
    .const toD0181_return = (>(SCREEN&$3fff)*4)|(>toD0181_gfx)/4&$f
    .label _10 = $18
    .label _14 = $28
    .label cyclecount = $18
    .label sec100s = 6
    .label i = 2
    .label sieve_i = 4
    .label j = 8
    .label s = $a
    .label i_3 = 6
    .label i_10 = 6
    .label _38 = $2c
    // [5] phi from main to main::toD0181 [phi:main->main::toD0181]
    // main::toD0181
    // main::@13
    // *D018 = toD018(SCREEN, 0x1800)
    // [6] *((const byte*) D018#0) ← (const byte) main::toD0181_return#0 -- _deref_pbuc1=vbuc2 
    //Show lower case font
    lda #toD0181_return
    sta D018
    // print_cls()
    // [7] call print_cls 
    // [198] phi from main::@13 to print_cls [phi:main::@13->print_cls]
    jsr print_cls
    // [8] phi from main::@13 to main::@14 [phi:main::@13->main::@14]
    // main::@14
    // print_str("Sieve benchmark - calculating primes")
    // [9] call print_str 
    // [70] phi from main::@14 to print_str [phi:main::@14->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*) 1024 [phi:main::@14->print_str#0] -- pbuz1=pbuc1 
    lda #<$400
    sta print_char_cursor
    lda #>$400
    sta print_char_cursor+1
    // [70] phi (byte*) print_str::str#10 = (const string) main::str [phi:main::@14->print_str#1] -- pbuz1=pbuc1 
    lda #<str
    sta print_str.str
    lda #>str
    sta print_str.str+1
    jsr print_str
    // [10] phi from main::@14 to main::@15 [phi:main::@14->main::@15]
    // main::@15
    // print_ln()
    // [11] call print_ln 
    // [114] phi from main::@15 to print_ln [phi:main::@15->print_ln]
    // [114] phi (byte*) print_line_cursor#21 = (byte*) 1024 [phi:main::@15->print_ln#0] -- pbuz1=pbuc1 
    lda #<$400
    sta print_line_cursor
    lda #>$400
    sta print_line_cursor+1
    jsr print_ln
    // main::@16
    // [12] (byte*~) print_char_cursor#89 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda print_line_cursor
    sta print_char_cursor
    lda print_line_cursor+1
    sta print_char_cursor+1
    // print_str("between 2 and ")
    // [13] call print_str 
    // [70] phi from main::@16 to print_str [phi:main::@16->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#89 [phi:main::@16->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str1 [phi:main::@16->print_str#1] -- pbuz1=pbuc1 
    lda #<str1
    sta print_str.str
    lda #>str1
    sta print_str.str+1
    jsr print_str
    // [14] phi from main::@16 to main::@17 [phi:main::@16->main::@17]
    // main::@17
    // print_word_decimal(COUNT)
    // [15] call print_word_decimal 
    // [80] phi from main::@17 to print_word_decimal [phi:main::@17->print_word_decimal]
    // [80] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@17->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (const word) COUNT#0 [phi:main::@17->print_word_decimal#1] -- vwuz1=vwuc1 
    lda #<COUNT
    sta print_word_decimal.w
    lda #>COUNT
    sta print_word_decimal.w+1
    jsr print_word_decimal
    // [16] phi from main::@17 to main::@18 [phi:main::@17->main::@18]
    // main::@18
    // print_ln()
    // [17] call print_ln 
    // [114] phi from main::@18 to print_ln [phi:main::@18->print_ln]
    // [114] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@18->print_ln#0] -- register_copy 
    jsr print_ln
    // [18] phi from main::@18 to main::@19 [phi:main::@18->main::@19]
    // main::@19
    // memset(sieve, 0, COUNT)
    // [19] call memset 
    // [189] phi from main::@19 to memset [phi:main::@19->memset]
    // [189] phi (byte) memset::c#3 = (byte) 0 [phi:main::@19->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [189] phi (void*) memset::str#3 = (void*)(const byte*) sieve#0 [phi:main::@19->memset#1] -- pvoz1=pvoc1 
    lda #<sieve
    sta memset.str
    lda #>sieve
    sta memset.str+1
    // [189] phi (word) memset::num#2 = (const word) COUNT#0 [phi:main::@19->memset#2] -- vwuz1=vwuc1 
    lda #<COUNT
    sta memset.num
    lda #>COUNT
    sta memset.num+1
    jsr memset
    // [20] phi from main::@19 to main::@20 [phi:main::@19->main::@20]
    // main::@20
    // clock_start()
    // [21] call clock_start 
    jsr clock_start
    // [22] phi from main::@20 to main::@1 [phi:main::@20->main::@1]
    // [22] phi (byte*) main::sieve_i#2 = (const byte*) sieve#0+(byte) 2 [phi:main::@20->main::@1#0] -- pbuz1=pbuc1 
    lda #<sieve+2
    sta sieve_i
    lda #>sieve+2
    sta sieve_i+1
    // [22] phi (word) main::i#11 = (byte) 2 [phi:main::@20->main::@1#1] -- vwuz1=vbuc1 
    lda #<2
    sta i
    lda #>2
    sta i+1
    // main::@1
  b1:
    // while (i < SQRT_COUNT)
    // [23] if((word) main::i#11<(const byte) SQRT_COUNT#0) goto main::@2 -- vwuz1_lt_vbuc1_then_la1 
    lda i+1
    cmp #>SQRT_COUNT
    bcs !b2+
    jmp b2
  !b2:
    bne !+
    lda i
    cmp #<SQRT_COUNT
    bcs !b2+
    jmp b2
  !b2:
  !:
    // [24] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // main::@3
    // clock()
    // [25] call clock 
    jsr clock
    // [26] (dword) clock::return#2 ← (dword) clock::return#0
    // main::@21
    // [27] (dword~) main::$10 ← (dword) clock::return#2
    // cyclecount = clock()-CLOCKS_PER_INIT
    // [28] (dword) main::cyclecount#0 ← (dword~) main::$10 - (const dword) CLOCKS_PER_INIT#0 -- vduz1=vduz1_minus_vduc1 
    lda cyclecount
    sec
    sbc #<CLOCKS_PER_INIT
    sta cyclecount
    lda cyclecount+1
    sbc #>CLOCKS_PER_INIT
    sta cyclecount+1
    lda cyclecount+2
    sbc #<CLOCKS_PER_INIT>>$10
    sta cyclecount+2
    lda cyclecount+3
    sbc #>CLOCKS_PER_INIT>>$10
    sta cyclecount+3
    // div32u16u(cyclecount, (unsigned int)(CLOCKS_PER_SEC/100))
    // [29] (dword) div32u16u::dividend#0 ← (dword) main::cyclecount#0
    // [30] call div32u16u 
    jsr div32u16u
    // [31] (dword) div32u16u::return#2 ← (dword) div32u16u::return#0
    // main::@22
    // [32] (dword~) main::$14 ← (dword) div32u16u::return#2
    // sec100s = (unsigned int)div32u16u(cyclecount, (unsigned int)(CLOCKS_PER_SEC/100))
    // [33] (word) main::sec100s#0 ← (word)(dword~) main::$14 -- vwuz1=_word_vduz2 
    lda _14
    sta sec100s
    lda _14+1
    sta sec100s+1
    // [34] (byte*~) print_char_cursor#90 ← (byte*) print_line_cursor#1 -- pbuz1=pbuz2 
    lda print_line_cursor
    sta print_char_cursor
    lda print_line_cursor+1
    sta print_char_cursor+1
    // print_str("100ths seconds used: ")
    // [35] call print_str 
    // [70] phi from main::@22 to print_str [phi:main::@22->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*~) print_char_cursor#90 [phi:main::@22->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str2 [phi:main::@22->print_str#1] -- pbuz1=pbuc1 
    lda #<str2
    sta print_str.str
    lda #>str2
    sta print_str.str+1
    jsr print_str
    // main::@23
    // print_word_decimal(sec100s)
    // [36] (word) print_word_decimal::w#1 ← (word) main::sec100s#0
    // [37] call print_word_decimal 
    // [80] phi from main::@23 to print_word_decimal [phi:main::@23->print_word_decimal]
    // [80] phi (byte*) print_char_cursor#58 = (byte*) print_char_cursor#2 [phi:main::@23->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#1 [phi:main::@23->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [38] phi from main::@23 to main::@24 [phi:main::@23->main::@24]
    // main::@24
    // print_str(" cycles: ")
    // [39] call print_str 
    // [70] phi from main::@24 to print_str [phi:main::@24->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:main::@24->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str3 [phi:main::@24->print_str#1] -- pbuz1=pbuc1 
    lda #<str3
    sta print_str.str
    lda #>str3
    sta print_str.str+1
    jsr print_str
    // main::@25
    // print_dword_decimal(cyclecount)
    // [40] (dword) print_dword_decimal::w#0 ← (dword) main::cyclecount#0
    // [41] call print_dword_decimal 
    jsr print_dword_decimal
    // [42] phi from main::@25 to main::@26 [phi:main::@25->main::@26]
    // main::@26
    // print_ln()
    // [43] call print_ln 
    // [114] phi from main::@26 to print_ln [phi:main::@26->print_ln]
    // [114] phi (byte*) print_line_cursor#21 = (byte*) print_line_cursor#1 [phi:main::@26->print_ln#0] -- register_copy 
    jsr print_ln
    // [44] phi from main::@26 to main::@8 [phi:main::@26->main::@8]
    // [44] phi (byte*) print_char_cursor#62 = (byte*) print_line_cursor#1 [phi:main::@26->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (byte) 2 [phi:main::@26->main::@8#1] -- vwuz1=vbuc1 
    lda #<2
    sta i_10
    lda #>2
    sta i_10+1
    // main::@8
  b8:
    // if (!sieve[i])
    // [45] (byte*~) main::$38 ← (const byte*) sieve#0 + (word) main::i#10 -- pbuz1=pbuc1_plus_vwuz2 
    lda i_10
    clc
    adc #<sieve
    sta _38
    lda i_10+1
    adc #>sieve
    sta _38+1
    // [46] if((byte) 0!=*((byte*~) main::$38)) goto main::@29 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (_38),y
    cmp #0
    bne b29
    // main::@10
    // print_word_decimal(i)
    // [47] (word) print_word_decimal::w#2 ← (word) main::i#10
    // [48] (byte*~) print_char_cursor#96 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda print_char_cursor_62
    sta print_char_cursor
    lda print_char_cursor_62+1
    sta print_char_cursor+1
    // print_word_decimal(i)
    // [49] call print_word_decimal 
    // [80] phi from main::@10 to print_word_decimal [phi:main::@10->print_word_decimal]
    // [80] phi (byte*) print_char_cursor#58 = (byte*~) print_char_cursor#96 [phi:main::@10->print_word_decimal#0] -- register_copy 
    // [80] phi (word) print_word_decimal::w#3 = (word) print_word_decimal::w#2 [phi:main::@10->print_word_decimal#1] -- register_copy 
    jsr print_word_decimal
    // [50] phi from main::@10 to main::@27 [phi:main::@10->main::@27]
    // main::@27
    // print_char(' ')
    // [51] call print_char 
    jsr print_char
    // [52] phi from main::@27 main::@29 to main::@9 [phi:main::@27/main::@29->main::@9]
    // [52] phi (byte*) print_char_cursor#63 = (byte*) print_char_cursor#10 [phi:main::@27/main::@29->main::@9#0] -- register_copy 
    // main::@9
  b9:
    // for (i = 2; i < 1300; ++i)
    // [53] (word) main::i#3 ← ++ (word) main::i#10 -- vwuz1=_inc_vwuz1 
    inc i_3
    bne !+
    inc i_3+1
  !:
    // [54] if((word) main::i#3<(word) $514) goto main::@28 -- vwuz1_lt_vwuc1_then_la1 
    lda i_3+1
    cmp #>$514
    bcc b28
    bne !+
    lda i_3
    cmp #<$514
    bcc b28
  !:
    // [55] phi from main::@9 to main::@11 [phi:main::@9->main::@11]
    // main::@11
    // print_str("...")
    // [56] call print_str 
    // [70] phi from main::@11 to print_str [phi:main::@11->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#63 [phi:main::@11->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const string) main::str4 [phi:main::@11->print_str#1] -- pbuz1=pbuc1 
    lda #<str4
    sta print_str.str
    lda #>str4
    sta print_str.str+1
    jsr print_str
    // main::@12
  b12:
    // (*(SCREEN+999))++;
    // [57] *((const byte*) SCREEN#0+(word) $3e7) ← ++ *((const byte*) SCREEN#0+(word) $3e7) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc SCREEN+$3e7
    jmp b12
    // main::@28
  b28:
    // [58] (byte*~) print_char_cursor#99 ← (byte*) print_char_cursor#63 -- pbuz1=pbuz2 
    lda print_char_cursor
    sta print_char_cursor_99
    lda print_char_cursor+1
    sta print_char_cursor_99+1
    // [44] phi from main::@28 to main::@8 [phi:main::@28->main::@8]
    // [44] phi (byte*) print_char_cursor#62 = (byte*~) print_char_cursor#99 [phi:main::@28->main::@8#0] -- register_copy 
    // [44] phi (word) main::i#10 = (word) main::i#3 [phi:main::@28->main::@8#1] -- register_copy 
    jmp b8
    // main::@29
  b29:
    // [59] (byte*~) print_char_cursor#101 ← (byte*) print_char_cursor#62 -- pbuz1=pbuz2 
    lda print_char_cursor_62
    sta print_char_cursor
    lda print_char_cursor_62+1
    sta print_char_cursor+1
    jmp b9
    // main::@2
  b2:
    // if (!*sieve_i)
    // [60] if((byte) 0!=*((byte*) main::sieve_i#2)) goto main::@4 -- vbuc1_neq__deref_pbuz1_then_la1 
    ldy #0
    lda (sieve_i),y
    cmp #0
    bne b4
    // main::@7
    // j = i*2
    // [61] (word) main::j#0 ← (word) main::i#11 << (byte) 1 -- vwuz1=vwuz2_rol_1 
    lda i
    asl
    sta j
    lda i+1
    rol
    sta j+1
    // s = sieve+j
    // [62] (byte*) main::s#0 ← (const byte*) sieve#0 + (word) main::j#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda j
    clc
    adc #<sieve
    sta s
    lda j+1
    adc #>sieve
    sta s+1
    // [63] phi from main::@6 main::@7 to main::@5 [phi:main::@6/main::@7->main::@5]
    // [63] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@6/main::@7->main::@5#0] -- register_copy 
    // [63] phi (word) main::j#2 = (word) main::j#1 [phi:main::@6/main::@7->main::@5#1] -- register_copy 
    // main::@5
  b5:
    // while (j < COUNT)
    // [64] if((word) main::j#2<(const word) COUNT#0) goto main::@6 -- vwuz1_lt_vwuc1_then_la1 
    lda j+1
    cmp #>COUNT
    bcc b6
    bne !+
    lda j
    cmp #<COUNT
    bcc b6
  !:
    // main::@4
  b4:
    // i++;
    // [65] (word) main::i#2 ← ++ (word) main::i#11 -- vwuz1=_inc_vwuz1 
    inc i
    bne !+
    inc i+1
  !:
    // sieve_i++;
    // [66] (byte*) main::sieve_i#1 ← ++ (byte*) main::sieve_i#2 -- pbuz1=_inc_pbuz1 
    inc sieve_i
    bne !+
    inc sieve_i+1
  !:
    // [22] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [22] phi (byte*) main::sieve_i#2 = (byte*) main::sieve_i#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [22] phi (word) main::i#11 = (word) main::i#2 [phi:main::@4->main::@1#1] -- register_copy 
    jmp b1
    // main::@6
  b6:
    // *s = 1
    // [67] *((byte*) main::s#2) ← (byte) 1 -- _deref_pbuz1=vbuc1 
    lda #1
    ldy #0
    sta (s),y
    // s += i
    // [68] (byte*) main::s#1 ← (byte*) main::s#2 + (word) main::i#11 -- pbuz1=pbuz1_plus_vwuz2 
    lda s
    clc
    adc i
    sta s
    lda s+1
    adc i+1
    sta s+1
    // j += i
    // [69] (word) main::j#1 ← (word) main::j#2 + (word) main::i#11 -- vwuz1=vwuz1_plus_vwuz2 
    lda j
    clc
    adc i
    sta j
    lda j+1
    adc i+1
    sta j+1
    jmp b5
    str: .text "Sieve benchmark - calculating primes@"
    str1: .text "between 2 and @"
    str2: .text "100ths seconds used: @"
    str3: .text " cycles: @"
    str4: .text "...@"
}
  // print_str
// Print a zero-terminated string
// print_str(byte* zeropage($e) str)
print_str: {
    .label str = $e
    // [71] phi from print_str print_str::@2 to print_str::@1 [phi:print_str/print_str::@2->print_str::@1]
    // [71] phi (byte*) print_char_cursor#2 = (byte*) print_char_cursor#66 [phi:print_str/print_str::@2->print_str::@1#0] -- register_copy 
    // [71] phi (byte*) print_str::str#8 = (byte*) print_str::str#10 [phi:print_str/print_str::@2->print_str::@1#1] -- register_copy 
    // print_str::@1
  b1:
    // while(*str!='@')
    // [72] if(*((byte*) print_str::str#8)!=(byte) '@') goto print_str::@2 -- _deref_pbuz1_neq_vbuc1_then_la1 
    ldy #0
    lda (str),y
    cmp #'@'
    bne b2
    // print_str::@return
    // }
    // [73] return 
    rts
    // print_str::@2
  b2:
    // *(print_char_cursor++) = *(str++)
    // [74] *((byte*) print_char_cursor#2) ← *((byte*) print_str::str#8) -- _deref_pbuz1=_deref_pbuz2 
    ldy #0
    lda (str),y
    sta (print_char_cursor),y
    // *(print_char_cursor++) = *(str++);
    // [75] (byte*) print_char_cursor#1 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc print_char_cursor
    bne !+
    inc print_char_cursor+1
  !:
    // [76] (byte*) print_str::str#0 ← ++ (byte*) print_str::str#8 -- pbuz1=_inc_pbuz1 
    inc str
    bne !+
    inc str+1
  !:
    jmp b1
}
  // print_char
// Print a single char
print_char: {
    .const ch = ' '
    // *(print_char_cursor++) = ch
    // [77] *((byte*) print_char_cursor#2) ← (const byte) print_char::ch#0 -- _deref_pbuz1=vbuc1 
    lda #ch
    ldy #0
    sta (print_char_cursor),y
    // *(print_char_cursor++) = ch;
    // [78] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#2 -- pbuz1=_inc_pbuz1 
    inc print_char_cursor
    bne !+
    inc print_char_cursor+1
  !:
    // print_char::@return
    // }
    // [79] return 
    rts
}
  // print_word_decimal
// Print a word as DECIMAL
// print_word_decimal(word zeropage(6) w)
print_word_decimal: {
    .label w = 6
    // utoa(w, decimal_digits, DECIMAL)
    // [81] (word) utoa::value#1 ← (word) print_word_decimal::w#3 -- vwuz1=vwuz2 
    lda w
    sta utoa.value
    lda w+1
    sta utoa.value+1
    // [82] call utoa 
    // [86] phi from print_word_decimal to utoa [phi:print_word_decimal->utoa]
    jsr utoa
    // [83] phi from print_word_decimal to print_word_decimal::@1 [phi:print_word_decimal->print_word_decimal::@1]
    // print_word_decimal::@1
    // print_str(decimal_digits)
    // [84] call print_str 
    // [70] phi from print_word_decimal::@1 to print_str [phi:print_word_decimal::@1->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#58 [phi:print_word_decimal::@1->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const byte[6]) decimal_digits#0 [phi:print_word_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta print_str.str
    lda #>decimal_digits
    sta print_str.str+1
    jsr print_str
    // print_word_decimal::@return
    // }
    // [85] return 
    rts
}
  // utoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// utoa(word zeropage($11) value, byte* zeropage($13) buffer)
utoa: {
    .const max_digits = 5
    .label digit_value = $2e
    .label digit = $10
    .label value = $11
    .label buffer = $13
    // [87] phi from utoa to utoa::@1 [phi:utoa->utoa::@1]
    // [87] phi (byte*) utoa::buffer#11 = (const byte[6]) decimal_digits#0 [phi:utoa->utoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits
    sta buffer
    lda #>decimal_digits
    sta buffer+1
    // [87] phi (byte) utoa::started#2 = (byte) 0 [phi:utoa->utoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [87] phi (word) utoa::value#2 = (word) utoa::value#1 [phi:utoa->utoa::@1#2] -- register_copy 
    // [87] phi (byte) utoa::digit#2 = (byte) 0 [phi:utoa->utoa::@1#3] -- vbuz1=vbuc1 
    txa
    sta digit
    // [87] phi from utoa::@2 to utoa::@1 [phi:utoa::@2->utoa::@1]
    // [87] phi (byte*) utoa::buffer#11 = (byte*) utoa::buffer#12 [phi:utoa::@2->utoa::@1#0] -- register_copy 
    // [87] phi (byte) utoa::started#2 = (byte) utoa::started#3 [phi:utoa::@2->utoa::@1#1] -- register_copy 
    // [87] phi (word) utoa::value#2 = (word) utoa::value#4 [phi:utoa::@2->utoa::@1#2] -- register_copy 
    // [87] phi (byte) utoa::digit#2 = (byte) utoa::digit#1 [phi:utoa::@2->utoa::@1#3] -- register_copy 
    // utoa::@1
  b1:
    // digit_value = digit_values[digit]
    // [88] (byte~) utoa::$11 ← (byte) utoa::digit#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda digit
    asl
    // [89] (word) utoa::digit_value#0 ← *((const word[]) RADIX_DECIMAL_VALUES#0 + (byte~) utoa::$11) -- vwuz1=pwuc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES,y
    sta digit_value
    lda RADIX_DECIMAL_VALUES+1,y
    sta digit_value+1
    // if (started || value >= digit_value)
    // [90] if((byte) 0!=(byte) utoa::started#2) goto utoa::@3 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b3
    // utoa::@6
    // [91] if((word) utoa::value#2>=(word) utoa::digit_value#0) goto utoa::@3 -- vwuz1_ge_vwuz2_then_la1 
    cmp value+1
    bne !+
    lda digit_value
    cmp value
    beq b3
  !:
    bcc b3
    // [92] phi from utoa::@6 to utoa::@2 [phi:utoa::@6->utoa::@2]
    // [92] phi (byte*) utoa::buffer#12 = (byte*) utoa::buffer#11 [phi:utoa::@6->utoa::@2#0] -- register_copy 
    // [92] phi (byte) utoa::started#3 = (byte) utoa::started#2 [phi:utoa::@6->utoa::@2#1] -- register_copy 
    // [92] phi (word) utoa::value#4 = (word) utoa::value#2 [phi:utoa::@6->utoa::@2#2] -- register_copy 
    // utoa::@2
  b2:
    // for( char digit=0; digit<max_digits-1; digit++ )
    // [93] (byte) utoa::digit#1 ← ++ (byte) utoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [94] if((byte) utoa::digit#1<(const byte) utoa::max_digits#1-(byte) 1) goto utoa::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda digit
    cmp #max_digits-1
    bcc b1
    // utoa::@4
    // (char)value
    // [95] (byte~) utoa::$4 ← (byte)(word) utoa::value#4 -- vbuaa=_byte_vwuz1 
    lda value
    // *buffer++ = DIGITS[(char)value]
    // [96] *((byte*) utoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) utoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // *buffer++ = DIGITS[(char)value];
    // [97] (byte*) utoa::buffer#4 ← ++ (byte*) utoa::buffer#12 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // *buffer = 0
    // [98] *((byte*) utoa::buffer#4) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (buffer),y
    // utoa::@return
    // }
    // [99] return 
    rts
    // utoa::@3
  b3:
    // utoa_append(buffer++, value, digit_value)
    // [100] (byte*) utoa_append::buffer#0 ← (byte*) utoa::buffer#11
    // [101] (word) utoa_append::value#0 ← (word) utoa::value#2
    // [102] (word) utoa_append::sub#0 ← (word) utoa::digit_value#0
    // [103] call utoa_append 
    // [107] phi from utoa::@3 to utoa_append [phi:utoa::@3->utoa_append]
    jsr utoa_append
    // utoa_append(buffer++, value, digit_value)
    // [104] (word) utoa_append::return#0 ← (word) utoa_append::value#2
    // utoa::@5
    // value = utoa_append(buffer++, value, digit_value)
    // [105] (word) utoa::value#0 ← (word) utoa_append::return#0
    // value = utoa_append(buffer++, value, digit_value);
    // [106] (byte*) utoa::buffer#3 ← ++ (byte*) utoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [92] phi from utoa::@5 to utoa::@2 [phi:utoa::@5->utoa::@2]
    // [92] phi (byte*) utoa::buffer#12 = (byte*) utoa::buffer#3 [phi:utoa::@5->utoa::@2#0] -- register_copy 
    // [92] phi (byte) utoa::started#3 = (byte) 1 [phi:utoa::@5->utoa::@2#1] -- vbuxx=vbuc1 
    ldx #1
    // [92] phi (word) utoa::value#4 = (word) utoa::value#0 [phi:utoa::@5->utoa::@2#2] -- register_copy 
    jmp b2
}
  // utoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// utoa_append(byte* zeropage($13) buffer, word zeropage($11) value, word zeropage($2e) sub)
utoa_append: {
    .label buffer = $13
    .label value = $11
    .label sub = $2e
    .label return = $11
    // [108] phi from utoa_append to utoa_append::@1 [phi:utoa_append->utoa_append::@1]
    // [108] phi (byte) utoa_append::digit#2 = (byte) 0 [phi:utoa_append->utoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [108] phi (word) utoa_append::value#2 = (word) utoa_append::value#0 [phi:utoa_append->utoa_append::@1#1] -- register_copy 
    // utoa_append::@1
  b1:
    // while (value >= sub)
    // [109] if((word) utoa_append::value#2>=(word) utoa_append::sub#0) goto utoa_append::@2 -- vwuz1_ge_vwuz2_then_la1 
    lda sub+1
    cmp value+1
    bne !+
    lda sub
    cmp value
    beq b2
  !:
    bcc b2
    // utoa_append::@3
    // *buffer = DIGITS[digit]
    // [110] *((byte*) utoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) utoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    // utoa_append::@return
    // }
    // [111] return 
    rts
    // utoa_append::@2
  b2:
    // digit++;
    // [112] (byte) utoa_append::digit#1 ← ++ (byte) utoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // value -= sub
    // [113] (word) utoa_append::value#1 ← (word) utoa_append::value#2 - (word) utoa_append::sub#0 -- vwuz1=vwuz1_minus_vwuz2 
    lda value
    sec
    sbc sub
    sta value
    lda value+1
    sbc sub+1
    sta value+1
    // [108] phi from utoa_append::@2 to utoa_append::@1 [phi:utoa_append::@2->utoa_append::@1]
    // [108] phi (byte) utoa_append::digit#2 = (byte) utoa_append::digit#1 [phi:utoa_append::@2->utoa_append::@1#0] -- register_copy 
    // [108] phi (word) utoa_append::value#2 = (word) utoa_append::value#1 [phi:utoa_append::@2->utoa_append::@1#1] -- register_copy 
    jmp b1
}
  // print_ln
// Print a newline
print_ln: {
    // [115] phi from print_ln print_ln::@1 to print_ln::@1 [phi:print_ln/print_ln::@1->print_ln::@1]
    // [115] phi (byte*) print_line_cursor#11 = (byte*) print_line_cursor#21 [phi:print_ln/print_ln::@1->print_ln::@1#0] -- register_copy 
    // print_ln::@1
  b1:
    // print_line_cursor + $28
    // [116] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#11 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc print_line_cursor
    sta print_line_cursor
    bcc !+
    inc print_line_cursor+1
  !:
    // while (print_line_cursor<print_char_cursor)
    // [117] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#2) goto print_ln::@1 -- pbuz1_lt_pbuz2_then_la1 
    lda print_line_cursor+1
    cmp print_char_cursor+1
    bcc b1
    bne !+
    lda print_line_cursor
    cmp print_char_cursor
    bcc b1
  !:
    // print_ln::@return
    // }
    // [118] return 
    rts
}
  // print_dword_decimal
// Print a dword as DECIMAL
// print_dword_decimal(dword zeropage($18) w)
print_dword_decimal: {
    .label w = $18
    // ultoa(w, decimal_digits_long, DECIMAL)
    // [119] (dword) ultoa::value#1 ← (dword) print_dword_decimal::w#0
    // [120] call ultoa 
    // [124] phi from print_dword_decimal to ultoa [phi:print_dword_decimal->ultoa]
    jsr ultoa
    // [121] phi from print_dword_decimal to print_dword_decimal::@1 [phi:print_dword_decimal->print_dword_decimal::@1]
    // print_dword_decimal::@1
    // print_str(decimal_digits_long)
    // [122] call print_str 
    // [70] phi from print_dword_decimal::@1 to print_str [phi:print_dword_decimal::@1->print_str]
    // [70] phi (byte*) print_char_cursor#66 = (byte*) print_char_cursor#2 [phi:print_dword_decimal::@1->print_str#0] -- register_copy 
    // [70] phi (byte*) print_str::str#10 = (const byte[$b]) decimal_digits_long#0 [phi:print_dword_decimal::@1->print_str#1] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta print_str.str
    lda #>decimal_digits_long
    sta print_str.str+1
    jsr print_str
    // print_dword_decimal::@return
    // }
    // [123] return 
    rts
}
  // ultoa
// Converts unsigned number value to a string representing it in RADIX format.
// If the leading digits are zero they are not included in the string.
// - value : The number to be converted to RADIX
// - buffer : receives the string representing the number and zero-termination.
// - radix : The radix to convert the number to (from the enum RADIX)
// ultoa(dword zeropage($18) value, byte* zeropage($1c) buffer)
ultoa: {
    .const max_digits = $a
    .label digit_value = $30
    .label digit = $17
    .label value = $18
    .label buffer = $1c
    // [125] phi from ultoa to ultoa::@1 [phi:ultoa->ultoa::@1]
    // [125] phi (byte*) ultoa::buffer#11 = (const byte[$b]) decimal_digits_long#0 [phi:ultoa->ultoa::@1#0] -- pbuz1=pbuc1 
    lda #<decimal_digits_long
    sta buffer
    lda #>decimal_digits_long
    sta buffer+1
    // [125] phi (byte) ultoa::started#2 = (byte) 0 [phi:ultoa->ultoa::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [125] phi (dword) ultoa::value#2 = (dword) ultoa::value#1 [phi:ultoa->ultoa::@1#2] -- register_copy 
    // [125] phi (byte) ultoa::digit#2 = (byte) 0 [phi:ultoa->ultoa::@1#3] -- vbuz1=vbuc1 
    txa
    sta digit
    // [125] phi from ultoa::@2 to ultoa::@1 [phi:ultoa::@2->ultoa::@1]
    // [125] phi (byte*) ultoa::buffer#11 = (byte*) ultoa::buffer#12 [phi:ultoa::@2->ultoa::@1#0] -- register_copy 
    // [125] phi (byte) ultoa::started#2 = (byte) ultoa::started#3 [phi:ultoa::@2->ultoa::@1#1] -- register_copy 
    // [125] phi (dword) ultoa::value#2 = (dword) ultoa::value#4 [phi:ultoa::@2->ultoa::@1#2] -- register_copy 
    // [125] phi (byte) ultoa::digit#2 = (byte) ultoa::digit#1 [phi:ultoa::@2->ultoa::@1#3] -- register_copy 
    // ultoa::@1
  b1:
    // digit_value = digit_values[digit]
    // [126] (byte~) ultoa::$11 ← (byte) ultoa::digit#2 << (byte) 2 -- vbuaa=vbuz1_rol_2 
    lda digit
    asl
    asl
    // [127] (dword) ultoa::digit_value#0 ← *((const dword[]) RADIX_DECIMAL_VALUES_LONG#0 + (byte~) ultoa::$11) -- vduz1=pduc1_derefidx_vbuaa 
    tay
    lda RADIX_DECIMAL_VALUES_LONG,y
    sta digit_value
    lda RADIX_DECIMAL_VALUES_LONG+1,y
    sta digit_value+1
    lda RADIX_DECIMAL_VALUES_LONG+2,y
    sta digit_value+2
    lda RADIX_DECIMAL_VALUES_LONG+3,y
    sta digit_value+3
    // if (started || value >= digit_value)
    // [128] if((byte) 0!=(byte) ultoa::started#2) goto ultoa::@3 -- vbuc1_neq_vbuxx_then_la1 
    cpx #0
    bne b3
    // ultoa::@6
    // [129] if((dword) ultoa::value#2>=(dword) ultoa::digit_value#0) goto ultoa::@3 -- vduz1_ge_vduz2_then_la1 
    lda value+3
    cmp digit_value+3
    bcc !+
    bne b3
    lda value+2
    cmp digit_value+2
    bcc !+
    bne b3
    lda value+1
    cmp digit_value+1
    bcc !+
    bne b3
    lda value
    cmp digit_value
    bcs b3
  !:
    // [130] phi from ultoa::@6 to ultoa::@2 [phi:ultoa::@6->ultoa::@2]
    // [130] phi (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#11 [phi:ultoa::@6->ultoa::@2#0] -- register_copy 
    // [130] phi (byte) ultoa::started#3 = (byte) ultoa::started#2 [phi:ultoa::@6->ultoa::@2#1] -- register_copy 
    // [130] phi (dword) ultoa::value#4 = (dword) ultoa::value#2 [phi:ultoa::@6->ultoa::@2#2] -- register_copy 
    // ultoa::@2
  b2:
    // for( char digit=0; digit<max_digits-1; digit++ )
    // [131] (byte) ultoa::digit#1 ← ++ (byte) ultoa::digit#2 -- vbuz1=_inc_vbuz1 
    inc digit
    // [132] if((byte) ultoa::digit#1<(const byte) ultoa::max_digits#1-(byte) 1) goto ultoa::@1 -- vbuz1_lt_vbuc1_then_la1 
    lda digit
    cmp #max_digits-1
    bcc b1
    // ultoa::@4
    // (char)value
    // [133] (byte~) ultoa::$4 ← (byte)(dword) ultoa::value#4 -- vbuaa=_byte_vduz1 
    lda value
    // *buffer++ = DIGITS[(char)value]
    // [134] *((byte*) ultoa::buffer#12) ← *((const byte[]) DIGITS#0 + (byte~) ultoa::$4) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda DIGITS,y
    ldy #0
    sta (buffer),y
    // *buffer++ = DIGITS[(char)value];
    // [135] (byte*) ultoa::buffer#4 ← ++ (byte*) ultoa::buffer#12 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // *buffer = 0
    // [136] *((byte*) ultoa::buffer#4) ← (byte) 0 -- _deref_pbuz1=vbuc1 
    lda #0
    tay
    sta (buffer),y
    // ultoa::@return
    // }
    // [137] return 
    rts
    // ultoa::@3
  b3:
    // ultoa_append(buffer++, value, digit_value)
    // [138] (byte*) ultoa_append::buffer#0 ← (byte*) ultoa::buffer#11
    // [139] (dword) ultoa_append::value#0 ← (dword) ultoa::value#2
    // [140] (dword) ultoa_append::sub#0 ← (dword) ultoa::digit_value#0
    // [141] call ultoa_append 
    // [145] phi from ultoa::@3 to ultoa_append [phi:ultoa::@3->ultoa_append]
    jsr ultoa_append
    // ultoa_append(buffer++, value, digit_value)
    // [142] (dword) ultoa_append::return#0 ← (dword) ultoa_append::value#2
    // ultoa::@5
    // value = ultoa_append(buffer++, value, digit_value)
    // [143] (dword) ultoa::value#0 ← (dword) ultoa_append::return#0
    // value = ultoa_append(buffer++, value, digit_value);
    // [144] (byte*) ultoa::buffer#3 ← ++ (byte*) ultoa::buffer#11 -- pbuz1=_inc_pbuz1 
    inc buffer
    bne !+
    inc buffer+1
  !:
    // [130] phi from ultoa::@5 to ultoa::@2 [phi:ultoa::@5->ultoa::@2]
    // [130] phi (byte*) ultoa::buffer#12 = (byte*) ultoa::buffer#3 [phi:ultoa::@5->ultoa::@2#0] -- register_copy 
    // [130] phi (byte) ultoa::started#3 = (byte) 1 [phi:ultoa::@5->ultoa::@2#1] -- vbuxx=vbuc1 
    ldx #1
    // [130] phi (dword) ultoa::value#4 = (dword) ultoa::value#0 [phi:ultoa::@5->ultoa::@2#2] -- register_copy 
    jmp b2
}
  // ultoa_append
// Used to convert a single digit of an unsigned number value to a string representation
// Counts a single digit up from '0' as long as the value is larger than sub.
// Each time the digit is increased sub is subtracted from value.
// - buffer : pointer to the char that receives the digit
// - value : The value where the digit will be derived from
// - sub : the value of a '1' in the digit. Subtracted continually while the digit is increased.
//        (For decimal the subs used are 10000, 1000, 100, 10, 1)
// returns : the value reduced by sub * digit so that it is less than sub.
// ultoa_append(byte* zeropage($1c) buffer, dword zeropage($18) value, dword zeropage($30) sub)
ultoa_append: {
    .label buffer = $1c
    .label value = $18
    .label sub = $30
    .label return = $18
    // [146] phi from ultoa_append to ultoa_append::@1 [phi:ultoa_append->ultoa_append::@1]
    // [146] phi (byte) ultoa_append::digit#2 = (byte) 0 [phi:ultoa_append->ultoa_append::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [146] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#0 [phi:ultoa_append->ultoa_append::@1#1] -- register_copy 
    // ultoa_append::@1
  b1:
    // while (value >= sub)
    // [147] if((dword) ultoa_append::value#2>=(dword) ultoa_append::sub#0) goto ultoa_append::@2 -- vduz1_ge_vduz2_then_la1 
    lda value+3
    cmp sub+3
    bcc !+
    bne b2
    lda value+2
    cmp sub+2
    bcc !+
    bne b2
    lda value+1
    cmp sub+1
    bcc !+
    bne b2
    lda value
    cmp sub
    bcs b2
  !:
    // ultoa_append::@3
    // *buffer = DIGITS[digit]
    // [148] *((byte*) ultoa_append::buffer#0) ← *((const byte[]) DIGITS#0 + (byte) ultoa_append::digit#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda DIGITS,x
    ldy #0
    sta (buffer),y
    // ultoa_append::@return
    // }
    // [149] return 
    rts
    // ultoa_append::@2
  b2:
    // digit++;
    // [150] (byte) ultoa_append::digit#1 ← ++ (byte) ultoa_append::digit#2 -- vbuxx=_inc_vbuxx 
    inx
    // value -= sub
    // [151] (dword) ultoa_append::value#1 ← (dword) ultoa_append::value#2 - (dword) ultoa_append::sub#0 -- vduz1=vduz1_minus_vduz2 
    lda value
    sec
    sbc sub
    sta value
    lda value+1
    sbc sub+1
    sta value+1
    lda value+2
    sbc sub+2
    sta value+2
    lda value+3
    sbc sub+3
    sta value+3
    // [146] phi from ultoa_append::@2 to ultoa_append::@1 [phi:ultoa_append::@2->ultoa_append::@1]
    // [146] phi (byte) ultoa_append::digit#2 = (byte) ultoa_append::digit#1 [phi:ultoa_append::@2->ultoa_append::@1#0] -- register_copy 
    // [146] phi (dword) ultoa_append::value#2 = (dword) ultoa_append::value#1 [phi:ultoa_append::@2->ultoa_append::@1#1] -- register_copy 
    jmp b1
}
  // div32u16u
// Divide unsigned 32-bit dword dividend with a 16-bit word divisor
// The 16-bit word remainder can be found in rem16u after the division
// div32u16u(dword zeropage($18) dividend)
div32u16u: {
    .label divisor = CLOCKS_PER_SEC/$64
    .label quotient_hi = $34
    .label quotient_lo = $22
    .label return = $28
    .label dividend = $18
    // divr16u(>dividend, divisor, 0)
    // [152] (word) divr16u::dividend#1 ← > (dword) div32u16u::dividend#0 -- vwuz1=_hi_vduz2 
    lda dividend+2
    sta divr16u.dividend
    lda dividend+3
    sta divr16u.dividend+1
    // [153] call divr16u 
    // [163] phi from div32u16u to divr16u [phi:div32u16u->divr16u]
    // [163] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#1 [phi:div32u16u->divr16u#0] -- register_copy 
    // [163] phi (word) divr16u::rem#10 = (byte) 0 [phi:div32u16u->divr16u#1] -- vwuz1=vbuc1 
    lda #<0
    sta divr16u.rem
    sta divr16u.rem+1
    jsr divr16u
    // divr16u(>dividend, divisor, 0)
    // [154] (word) divr16u::return#2 ← (word) divr16u::return#0
    // div32u16u::@1
    // quotient_hi = divr16u(>dividend, divisor, 0)
    // [155] (word) div32u16u::quotient_hi#0 ← (word) divr16u::return#2 -- vwuz1=vwuz2 
    lda divr16u.return
    sta quotient_hi
    lda divr16u.return+1
    sta quotient_hi+1
    // divr16u(<dividend, divisor, rem16u)
    // [156] (word) divr16u::dividend#2 ← < (dword) div32u16u::dividend#0 -- vwuz1=_lo_vduz2 
    lda dividend
    sta divr16u.dividend
    lda dividend+1
    sta divr16u.dividend+1
    // [157] (word) divr16u::rem#4 ← (word) rem16u#1
    // [158] call divr16u 
    // [163] phi from div32u16u::@1 to divr16u [phi:div32u16u::@1->divr16u]
    // [163] phi (word) divr16u::dividend#5 = (word) divr16u::dividend#2 [phi:div32u16u::@1->divr16u#0] -- register_copy 
    // [163] phi (word) divr16u::rem#10 = (word) divr16u::rem#4 [phi:div32u16u::@1->divr16u#1] -- register_copy 
    jsr divr16u
    // divr16u(<dividend, divisor, rem16u)
    // [159] (word) divr16u::return#3 ← (word) divr16u::return#0
    // div32u16u::@2
    // quotient_lo = divr16u(<dividend, divisor, rem16u)
    // [160] (word) div32u16u::quotient_lo#0 ← (word) divr16u::return#3
    // quotient = { quotient_hi, quotient_lo}
    // [161] (dword) div32u16u::return#0 ← (word) div32u16u::quotient_hi#0 dw= (word) div32u16u::quotient_lo#0 -- vduz1=vwuz2_dword_vwuz3 
    lda quotient_hi
    sta return+2
    lda quotient_hi+1
    sta return+3
    lda quotient_lo
    sta return
    lda quotient_lo+1
    sta return+1
    // div32u16u::@return
    // }
    // [162] return 
    rts
}
  // divr16u
// Performs division on two 16 bit unsigned words and an initial remainder
// Returns the quotient dividend/divisor.
// The final remainder will be set into the global variable rem16u
// Implemented using simple binary division
// divr16u(word zeropage($20) dividend, word zeropage($1e) rem)
divr16u: {
    .label rem = $1e
    .label dividend = $20
    .label quotient = $22
    .label return = $22
    // [164] phi from divr16u to divr16u::@1 [phi:divr16u->divr16u::@1]
    // [164] phi (byte) divr16u::i#2 = (byte) 0 [phi:divr16u->divr16u::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [164] phi (word) divr16u::quotient#3 = (byte) 0 [phi:divr16u->divr16u::@1#1] -- vwuz1=vbuc1 
    txa
    sta quotient
    sta quotient+1
    // [164] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#5 [phi:divr16u->divr16u::@1#2] -- register_copy 
    // [164] phi (word) divr16u::rem#5 = (word) divr16u::rem#10 [phi:divr16u->divr16u::@1#3] -- register_copy 
    // [164] phi from divr16u::@3 to divr16u::@1 [phi:divr16u::@3->divr16u::@1]
    // [164] phi (byte) divr16u::i#2 = (byte) divr16u::i#1 [phi:divr16u::@3->divr16u::@1#0] -- register_copy 
    // [164] phi (word) divr16u::quotient#3 = (word) divr16u::return#0 [phi:divr16u::@3->divr16u::@1#1] -- register_copy 
    // [164] phi (word) divr16u::dividend#3 = (word) divr16u::dividend#0 [phi:divr16u::@3->divr16u::@1#2] -- register_copy 
    // [164] phi (word) divr16u::rem#5 = (word) divr16u::rem#11 [phi:divr16u::@3->divr16u::@1#3] -- register_copy 
    // divr16u::@1
  b1:
    // rem = rem << 1
    // [165] (word) divr16u::rem#0 ← (word) divr16u::rem#5 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl rem
    rol rem+1
    // >dividend
    // [166] (byte~) divr16u::$1 ← > (word) divr16u::dividend#3 -- vbuaa=_hi_vwuz1 
    lda dividend+1
    // >dividend & $80
    // [167] (byte~) divr16u::$2 ← (byte~) divr16u::$1 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if( (>dividend & $80) != 0 )
    // [168] if((byte~) divr16u::$2==(byte) 0) goto divr16u::@2 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b2
    // divr16u::@4
    // rem = rem | 1
    // [169] (word) divr16u::rem#1 ← (word) divr16u::rem#0 | (byte) 1 -- vwuz1=vwuz1_bor_vbuc1 
    lda #1
    ora rem
    sta rem
    // [170] phi from divr16u::@1 divr16u::@4 to divr16u::@2 [phi:divr16u::@1/divr16u::@4->divr16u::@2]
    // [170] phi (word) divr16u::rem#6 = (word) divr16u::rem#0 [phi:divr16u::@1/divr16u::@4->divr16u::@2#0] -- register_copy 
    // divr16u::@2
  b2:
    // dividend = dividend << 1
    // [171] (word) divr16u::dividend#0 ← (word) divr16u::dividend#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl dividend
    rol dividend+1
    // quotient = quotient << 1
    // [172] (word) divr16u::quotient#1 ← (word) divr16u::quotient#3 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl quotient
    rol quotient+1
    // if(rem>=divisor)
    // [173] if((word) divr16u::rem#6<(const word) div32u16u::divisor#0) goto divr16u::@3 -- vwuz1_lt_vwuc1_then_la1 
    lda rem+1
    cmp #>div32u16u.divisor
    bcc b3
    bne !+
    lda rem
    cmp #<div32u16u.divisor
    bcc b3
  !:
    // divr16u::@5
    // quotient++;
    // [174] (word) divr16u::quotient#2 ← ++ (word) divr16u::quotient#1 -- vwuz1=_inc_vwuz1 
    inc quotient
    bne !+
    inc quotient+1
  !:
    // rem = rem - divisor
    // [175] (word) divr16u::rem#2 ← (word) divr16u::rem#6 - (const word) div32u16u::divisor#0 -- vwuz1=vwuz1_minus_vwuc1 
    lda rem
    sec
    sbc #<div32u16u.divisor
    sta rem
    lda rem+1
    sbc #>div32u16u.divisor
    sta rem+1
    // [176] phi from divr16u::@2 divr16u::@5 to divr16u::@3 [phi:divr16u::@2/divr16u::@5->divr16u::@3]
    // [176] phi (word) divr16u::return#0 = (word) divr16u::quotient#1 [phi:divr16u::@2/divr16u::@5->divr16u::@3#0] -- register_copy 
    // [176] phi (word) divr16u::rem#11 = (word) divr16u::rem#6 [phi:divr16u::@2/divr16u::@5->divr16u::@3#1] -- register_copy 
    // divr16u::@3
  b3:
    // for( byte i : 0..15)
    // [177] (byte) divr16u::i#1 ← ++ (byte) divr16u::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [178] if((byte) divr16u::i#1!=(byte) $10) goto divr16u::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$10
    bne b1
    // divr16u::@6
    // rem16u = rem
    // [179] (word) rem16u#1 ← (word) divr16u::rem#11
    // divr16u::@return
    // }
    // [180] return 
    rts
}
  // clock
// Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
// This uses CIA #2 Timer A+B on the C64, and must be initialized using clock_start()
clock: {
    .label return = $18
    // 0xffffffff - *CIA2_TIMER_AB
    // [181] (dword) clock::return#0 ← (dword) $ffffffff - *((const dword*) CIA2_TIMER_AB#0) -- vduz1=vduc1_minus__deref_pduc2 
    lda #<$ffffffff
    sec
    sbc CIA2_TIMER_AB
    sta return
    lda #>$ffffffff
    sbc CIA2_TIMER_AB+1
    sta return+1
    lda #<$ffffffff>>$10
    sbc CIA2_TIMER_AB+2
    sta return+2
    lda #>$ffffffff>>$10
    sbc CIA2_TIMER_AB+3
    sta return+3
    // clock::@return
    // }
    // [182] return 
    rts
}
  // clock_start
// Reset & start the processor clock time. The value can be read using clock().
// This uses CIA #2 Timer A+B on the C64
clock_start: {
    // *CIA2_TIMER_A_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [183] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_CONTINUOUS#0 -- _deref_pbuc1=vbuc2 
    // Setup CIA#2 timer A to count (down) CPU cycles
    lda #CIA_TIMER_CONTROL_CONTINUOUS
    sta CIA2_TIMER_A_CONTROL
    // *CIA2_TIMER_B_CONTROL = CIA_TIMER_CONTROL_STOP | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [184] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // *CIA2_TIMER_AB = 0xffffffff
    // [185] *((const dword*) CIA2_TIMER_AB#0) ← (dword) $ffffffff -- _deref_pduc1=vduc2 
    lda #<$ffffffff
    sta CIA2_TIMER_AB
    lda #>$ffffffff
    sta CIA2_TIMER_AB+1
    lda #<$ffffffff>>$10
    sta CIA2_TIMER_AB+2
    lda #>$ffffffff>>$10
    sta CIA2_TIMER_AB+3
    // *CIA2_TIMER_B_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    // [186] *((const byte*) CIA2_TIMER_B_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0|(const byte) CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START|CIA_TIMER_CONTROL_B_COUNT_UNDERFLOW_A
    sta CIA2_TIMER_B_CONTROL
    // *CIA2_TIMER_A_CONTROL = CIA_TIMER_CONTROL_START | CIA_TIMER_CONTROL_CONTINUOUS | CIA_TIMER_CONTROL_A_COUNT_CYCLES
    // [187] *((const byte*) CIA2_TIMER_A_CONTROL#0) ← (const byte) CIA_TIMER_CONTROL_START#0 -- _deref_pbuc1=vbuc2 
    lda #CIA_TIMER_CONTROL_START
    sta CIA2_TIMER_A_CONTROL
    // clock_start::@return
    // }
    // [188] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zeropage($26) str, byte register(X) c, word zeropage($24) num)
memset: {
    .label end = $24
    .label dst = $26
    .label num = $24
    .label str = $26
    // if(num>0)
    // [190] if((word) memset::num#2<=(byte) 0) goto memset::@return -- vwuz1_le_0_then_la1 
    lda num
    bne !+
    lda num+1
    beq breturn
  !:
    // memset::@1
    // end = (char*)str + num
    // [191] (byte*) memset::end#0 ← (byte*)(void*) memset::str#3 + (word) memset::num#2 -- pbuz1=pbuz2_plus_vwuz1 
    lda end
    clc
    adc str
    sta end
    lda end+1
    adc str+1
    sta end+1
    // [192] (byte*~) memset::dst#3 ← (byte*)(void*) memset::str#3
    // [193] phi from memset::@1 memset::@2 to memset::@2 [phi:memset::@1/memset::@2->memset::@2]
    // [193] phi (byte*) memset::dst#2 = (byte*~) memset::dst#3 [phi:memset::@1/memset::@2->memset::@2#0] -- register_copy 
    // memset::@2
  b2:
    // *dst = c
    // [194] *((byte*) memset::dst#2) ← (byte) memset::c#3 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [195] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
    // [196] if((byte*) memset::dst#1!=(byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuz2_then_la1 
    lda dst+1
    cmp end+1
    bne b2
    lda dst
    cmp end
    bne b2
    // memset::@return
  breturn:
    // }
    // [197] return 
    rts
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // memset(print_screen, ' ', 1000)
    // [199] call memset 
    // [189] phi from print_cls to memset [phi:print_cls->memset]
    // [189] phi (byte) memset::c#3 = (byte) ' ' [phi:print_cls->memset#0] -- vbuxx=vbuc1 
    ldx #' '
    // [189] phi (void*) memset::str#3 = (void*)(byte*) 1024 [phi:print_cls->memset#1] -- pvoz1=pvoc1 
    lda #<$400
    sta memset.str
    lda #>$400
    sta memset.str+1
    // [189] phi (word) memset::num#2 = (word) $3e8 [phi:print_cls->memset#2] -- vwuz1=vwuc1 
    lda #<$3e8
    sta memset.num
    lda #>$3e8
    sta memset.num+1
    jsr memset
    // print_cls::@return
    // }
    // [200] return 
    rts
}
  // File Data
  // The digits used for numbers
  DIGITS: .text "0123456789abcdef"
  // Values of decimal digits
  RADIX_DECIMAL_VALUES: .word $2710, $3e8, $64, $a
  // Values of decimal digits
  RADIX_DECIMAL_VALUES_LONG: .dword $3b9aca00, $5f5e100, $989680, $f4240, $186a0, $2710, $3e8, $64, $a
  // Digits used for storing the decimal word
  decimal_digits: .fill 6, 0
  // Digits used for storing the decimal word
  decimal_digits_long: .fill $b, 0

