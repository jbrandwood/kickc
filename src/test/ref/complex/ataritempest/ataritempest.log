Loading link script "ataritempest.ld"
Culled Empty Block (label) @1
Culled Empty Block (label) @2

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) BGCOL#0 ← ((byte*)) (number) $c01a
  to:@3
main: scope:[main]  from @3
  *((byte*) BGCOL#0) ← ++ *((byte*) BGCOL#0)
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
entryPoint: scope:[entryPoint]  from
  *((byte*) BGCOL#0) ← ++ *((byte*) BGCOL#0)
  to:entryPoint::@return
entryPoint::@return: scope:[entryPoint]  from entryPoint
  return 
  to:@return
nmiHandler: scope:[nmiHandler]  from
  *((byte*) BGCOL#0) ← ++ *((byte*) BGCOL#0)
  to:nmiHandler::@return
nmiHandler::@return: scope:[nmiHandler]  from nmiHandler
  return 
  to:@return
@3: scope:[]  from @begin
  (void()*~) $0 ← & interrupt(HARDWARE_ALL)(void()) nmiHandler()
  (void()*~) $1 ← & (void()) entryPoint()
  (void()*[]) VECTORS#0 ← { (void()*~) $0, (void()*~) $1 }
  call main 
  to:@4
@4: scope:[]  from @3
  to:@end
@end: scope:[]  from @4

SYMBOL TABLE SSA
(void()*~) $0
(void()*~) $1
(label) @3
(label) @4
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) BGCOL#0
(void()*[]) VECTORS
(void()*[]) VECTORS#0
(void()) entryPoint()
(label) entryPoint::@return
(void()) main()
(label) main::@return
interrupt(HARDWARE_ALL)(void()) nmiHandler()
(label) nmiHandler::@return

Inlining cast (byte*) BGCOL#0 ← (byte*)(number) $c01a
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 49178
Successful SSA optimization PassNCastSimplification
Constant right-side identified [7] (void()*~) $0 ← & interrupt(HARDWARE_ALL)(void()) nmiHandler()
Constant right-side identified [8] (void()*~) $1 ← & (void()) entryPoint()
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) BGCOL#0 = (byte*) 49178
Constant (const void()*) $0 = &nmiHandler
Constant (const void()*) $1 = &entryPoint
Successful SSA optimization Pass2ConstantIdentification
Identified constant from value list (void()*[]) { (const void()*) $0, (const void()*) $1 }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const void()*[]) VECTORS#0 = { $0, $1 }
Successful SSA optimization Pass2ConstantIdentification
Constant inlined $0 = &interrupt(HARDWARE_ALL)(void()) nmiHandler()
Constant inlined $1 = &(void()) entryPoint()
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @4
Adding NOP phi() at start of @end
CALL GRAPH
Calls in [] to main:2 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @4
Renumbering block @3 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0)
  to:main::@return
main::@return: scope:[main]  from main
  [5] return 
  to:@return
nmiHandler: scope:[nmiHandler]  from
  [6] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0)
  to:nmiHandler::@return
nmiHandler::@return: scope:[nmiHandler]  from nmiHandler
  [7] return 
  to:@return
entryPoint: scope:[entryPoint]  from
  [8] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0)
  to:entryPoint::@return
entryPoint::@return: scope:[entryPoint]  from entryPoint
  [9] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) BGCOL
(void()*[]) VECTORS
(void()) entryPoint()
(void()) main()
interrupt(HARDWARE_ALL)(void()) nmiHandler()

Initial phi equivalence classes
Complete equivalence classes

INITIAL ASM
Target platform is custom
  // File Comments
// Atari Tempest ROM Development Template
// Each function of the kernal is a no-args function
// The functions are placed in the SYSCALLS table surrounded by JMP and NOP
  // Upstart
  .file [name="ataritempest.bin", type="bin", segments="AtariTempest"]
.segmentdef AtariTempest [segments="Code, Data, Vectors"]
.segmentdef Code [start=$4000, min=$4000, max=$bff9]
.segmentdef Data [startAfter="Code"]
.segmentdef Vectors [start=$bffa, min=$bffa, max=$bfff]
  // Global Constants & labels
  .label BGCOL = $c01a
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
.segment Code
  // main
main: {
    // [4] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    jmp breturn
    // main::@return
  breturn:
    // [5] return 
    rts
}
  // nmiHandler
nmiHandler: {
    // entry interrupt(HARDWARE_ALL)
    sta rega+1
    stx regx+1
    sty regy+1
    // [6] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    jmp breturn
    // nmiHandler::@return
  breturn:
    // [7] return  - exit interrupt(HARDWARE_ALL)
  rega:
    lda #00
  regx:
    ldx #00
  regy:
    ldy #00
    rti
}
  // entryPoint
entryPoint: {
    // [8] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    jmp breturn
    // entryPoint::@return
  breturn:
    // [9] return 
    rts
}
  // File Data
.segment Vectors
  VECTORS: .word nmiHandler, entryPoint

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] return  [ ] (  [ ] ) always clobbers reg byte a reg byte x reg byte y 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 
Uplift Scope [entryPoint] 
Uplift Scope [nmiHandler] 
Uplift Scope [] 

Uplifting [main] best 183 combination 
Uplifting [entryPoint] best 183 combination 
Uplifting [nmiHandler] best 183 combination 
Uplifting [] best 183 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Atari Tempest ROM Development Template
// Each function of the kernal is a no-args function
// The functions are placed in the SYSCALLS table surrounded by JMP and NOP
  // Upstart
  .file [name="ataritempest.bin", type="bin", segments="AtariTempest"]
.segmentdef AtariTempest [segments="Code, Data, Vectors"]
.segmentdef Code [start=$4000, min=$4000, max=$bff9]
.segmentdef Data [startAfter="Code"]
.segmentdef Vectors [start=$bffa, min=$bffa, max=$bfff]
  // Global Constants & labels
  .label BGCOL = $c01a
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
.segment Code
  // main
main: {
    // [4] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    jmp breturn
    // main::@return
  breturn:
    // [5] return 
    rts
}
  // nmiHandler
nmiHandler: {
    // entry interrupt(HARDWARE_ALL)
    sta rega+1
    stx regx+1
    sty regy+1
    // [6] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    jmp breturn
    // nmiHandler::@return
  breturn:
    // [7] return  - exit interrupt(HARDWARE_ALL)
  rega:
    lda #00
  regx:
    ldx #00
  regy:
    ldy #00
    rti
}
  // entryPoint
entryPoint: {
    // [8] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    jmp breturn
    // entryPoint::@return
  breturn:
    // [9] return 
    rts
}
  // File Data
.segment Vectors
  VECTORS: .word nmiHandler, entryPoint

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction breturn:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bbegin:
Removing instruction bend:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) BGCOL
(const byte*) BGCOL#0 BGCOL = (byte*) 49178
(void()*[]) VECTORS
(const void()*[]) VECTORS#0 VECTORS = { &interrupt(HARDWARE_ALL)(void()) nmiHandler(), &(void()) entryPoint() }
(void()) entryPoint()
(label) entryPoint::@return
(void()) main()
(label) main::@return
interrupt(HARDWARE_ALL)(void()) nmiHandler()
(label) nmiHandler::@return



FINAL ASSEMBLER
Score: 162

  // File Comments
// Atari Tempest ROM Development Template
// Each function of the kernal is a no-args function
// The functions are placed in the SYSCALLS table surrounded by JMP and NOP
  // Upstart
  .file [name="ataritempest.bin", type="bin", segments="AtariTempest"]
.segmentdef AtariTempest [segments="Code, Data, Vectors"]
.segmentdef Code [start=$4000, min=$4000, max=$bff9]
.segmentdef Data [startAfter="Code"]
.segmentdef Vectors [start=$bffa, min=$bffa, max=$bfff]
  // Global Constants & labels
  .label BGCOL = $c01a
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
.segment Code
  // main
main: {
    // (*BGCOL)++;
    // [4] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // main::@return
    // }
    // [5] return 
    rts
}
  // nmiHandler
nmiHandler: {
    // entry interrupt(HARDWARE_ALL)
    sta rega+1
    stx regx+1
    sty regy+1
    // (*BGCOL)++;
    // [6] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // nmiHandler::@return
    // }
    // [7] return  - exit interrupt(HARDWARE_ALL)
  rega:
    lda #00
  regx:
    ldx #00
  regy:
    ldy #00
    rti
}
  // entryPoint
entryPoint: {
    // (*BGCOL)++;
    // [8] *((const byte*) BGCOL#0) ← ++ *((const byte*) BGCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // entryPoint::@return
    // }
    // [9] return 
    rts
}
  // File Data
.segment Vectors
  VECTORS: .word nmiHandler, entryPoint

