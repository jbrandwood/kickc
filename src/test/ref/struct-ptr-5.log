Fixing struct type size struct Entry to 3
Fixing pointer addition (struct Entry*~) main::$0 ← (struct Entry*) ENTRIES + (number) 1
Fixing pointer addition (struct Entry*~) main::$1 ← (struct Entry*) ENTRIES + (number) 2
Rewriting struct pointer member access *((struct Entry*) main::entry0).next
Rewriting struct pointer member access *((struct Entry*) main::entry0).value
Rewriting struct pointer member access *((struct Entry*) main::entry2).next
Rewriting struct pointer member access *((struct Entry*) main::entry2).value
Rewriting struct pointer member access *((struct Entry*) main::entry1).next
Rewriting struct pointer member access *((struct Entry*) main::entry1).value
Rewriting struct pointer member access *((struct Entry*) main::entry).value
Rewriting struct pointer member access *((struct Entry*) main::entry).next
Rewriting struct pointer member access *((struct Entry*) main::entry).next
Rewriting struct pointer member access *((struct Entry*) main::entry).next
Warning! Adding boolean cast to non-boolean condition (struct Entry*) main::entry
Identified constant variable (struct Entry*) ENTRIES
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (struct Entry*) ENTRIES#0 ← ((struct Entry*)) (number) $1000
  to:@1
main: scope:[main]  from @1
  (struct Entry*) main::entry0#0 ← (struct Entry*) ENTRIES#0
  (number~) main::$5 ← (number) 1 * (const byte) SIZEOF_STRUCT_ENTRY
  (struct Entry*~) main::$0 ← (struct Entry*) ENTRIES#0 + (number~) main::$5
  (struct Entry*) main::entry1#0 ← (struct Entry*~) main::$0
  (number~) main::$6 ← (number) 2 * (const byte) SIZEOF_STRUCT_ENTRY
  (struct Entry*~) main::$1 ← (struct Entry*) ENTRIES#0 + (number~) main::$6
  (struct Entry*) main::entry2#0 ← (struct Entry*~) main::$1
  (struct Entry**) main::$7 ← (struct Entry**)(struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
  *((struct Entry**) main::$7) ← (struct Entry*) main::entry2#0
  (byte*) main::$8 ← (byte*)(struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
  *((byte*) main::$8) ← (number) 1
  (struct Entry**) main::$9 ← (struct Entry**)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
  *((struct Entry**) main::$9) ← (struct Entry*) main::entry1#0
  (byte*) main::$10 ← (byte*)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
  *((byte*) main::$10) ← (number) 2
  (struct Entry**) main::$11 ← (struct Entry**)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
  *((struct Entry**) main::$11) ← ((struct Entry*)) (number) 0
  (byte*) main::$12 ← (byte*)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
  *((byte*) main::$12) ← (number) 3
  (byte*) main::SCREEN#0 ← ((byte*)) (number) $400
  (byte) main::idx#0 ← (number) 0
  (struct Entry*) main::entry#0 ← (struct Entry*) ENTRIES#0
  to:main::@1
main::@1: scope:[main]  from main main::@2
  (byte) main::idx#6 ← phi( main/(byte) main::idx#0 main::@2/(byte) main::idx#4 )
  (struct Entry*) main::entry#2 ← phi( main/(struct Entry*) main::entry#0 main::@2/(struct Entry*) main::entry#1 )
  (bool~) main::$17 ← (struct Entry*)(word) 0 != (struct Entry*) main::entry#2
  if((bool~) main::$17) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (byte) main::idx#5 ← phi( main::@1/(byte) main::idx#6 )
  (struct Entry*) main::entry#3 ← phi( main::@1/(struct Entry*) main::entry#2 )
  (byte*) main::$13 ← (byte*)(struct Entry*) main::entry#3 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
  (byte~) main::$2 ← (byte) '0' + *((byte*) main::$13)
  *((byte*) main::SCREEN#0 + (byte) main::idx#5) ← (byte~) main::$2
  (byte) main::idx#1 ← ++ (byte) main::idx#5
  (struct Entry**) main::$14 ← (struct Entry**)(struct Entry*) main::entry#3 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
  (byte~) main::$3 ← < *((struct Entry**) main::$14)
  *((byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3
  (byte) main::idx#2 ← ++ (byte) main::idx#1
  (struct Entry**) main::$15 ← (struct Entry**)(struct Entry*) main::entry#3 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
  (byte~) main::$4 ← > *((struct Entry**) main::$15)
  *((byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4
  (byte) main::idx#3 ← ++ (byte) main::idx#2
  *((byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' '
  (byte) main::idx#4 ← ++ (byte) main::idx#3
  (struct Entry**) main::$16 ← (struct Entry**)(struct Entry*) main::entry#3 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
  (struct Entry*) main::entry#1 ← *((struct Entry**) main::$16)
  to:main::@1
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@1: scope:[]  from @begin
  call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(struct Entry*) ENTRIES
(struct Entry*) ENTRIES#0
(struct Entry*) Entry::next
(byte) Entry::value
(const byte) OFFSET_STRUCT_ENTRY_NEXT = (byte) 1
(const byte) OFFSET_STRUCT_ENTRY_VALUE = (byte) 0
(const byte) SIZEOF_STRUCT_ENTRY = (byte) 3
(void()) main()
(struct Entry*~) main::$0
(struct Entry*~) main::$1
(byte*) main::$10
(struct Entry**) main::$11
(byte*) main::$12
(byte*) main::$13
(struct Entry**) main::$14
(struct Entry**) main::$15
(struct Entry**) main::$16
(bool~) main::$17
(byte~) main::$2
(byte~) main::$3
(byte~) main::$4
(number~) main::$5
(number~) main::$6
(struct Entry**) main::$7
(byte*) main::$8
(struct Entry**) main::$9
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::SCREEN
(byte*) main::SCREEN#0
(struct Entry*) main::entry
(struct Entry*) main::entry#0
(struct Entry*) main::entry#1
(struct Entry*) main::entry#2
(struct Entry*) main::entry#3
(struct Entry*) main::entry0
(struct Entry*) main::entry0#0
(struct Entry*) main::entry1
(struct Entry*) main::entry1#0
(struct Entry*) main::entry2
(struct Entry*) main::entry2#0
(byte) main::idx
(byte) main::idx#0
(byte) main::idx#1
(byte) main::idx#2
(byte) main::idx#3
(byte) main::idx#4
(byte) main::idx#5
(byte) main::idx#6

Adding number conversion cast (unumber) 1 in (number~) main::$5 ← (number) 1 * (const byte) SIZEOF_STRUCT_ENTRY
Adding number conversion cast (unumber) main::$5 in (number~) main::$5 ← (unumber)(number) 1 * (const byte) SIZEOF_STRUCT_ENTRY
Adding number conversion cast (unumber) 2 in (number~) main::$6 ← (number) 2 * (const byte) SIZEOF_STRUCT_ENTRY
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (unumber)(number) 2 * (const byte) SIZEOF_STRUCT_ENTRY
Adding number conversion cast (unumber) 1 in *((byte*) main::$8) ← (number) 1
Adding number conversion cast (unumber) 2 in *((byte*) main::$10) ← (number) 2
Adding number conversion cast (unumber) 3 in *((byte*) main::$12) ← (number) 3
Adding number conversion cast (unumber) 0 in (byte) main::idx#0 ← (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (struct Entry*) ENTRIES#0 ← (struct Entry*)(number) $1000
Inlining cast *((byte*) main::$8) ← (unumber)(number) 1
Inlining cast *((byte*) main::$10) ← (unumber)(number) 2
Inlining cast *((struct Entry**) main::$11) ← (struct Entry*)(number) 0
Inlining cast *((byte*) main::$12) ← (unumber)(number) 3
Inlining cast (byte*) main::SCREEN#0 ← (byte*)(number) $400
Inlining cast (byte) main::idx#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct Entry*) 4096
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant pointer cast (struct Entry*) 0
Simplifying constant integer cast 3
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$5 ← (byte) 1 * (const byte) SIZEOF_STRUCT_ENTRY
Inferred type updated to byte in (unumber~) main::$6 ← (byte) 2 * (const byte) SIZEOF_STRUCT_ENTRY
Alias (struct Entry*) main::entry1#0 = (struct Entry*~) main::$0 
Alias (struct Entry*) main::entry2#0 = (struct Entry*~) main::$1 
Alias (struct Entry*) main::entry#2 = (struct Entry*) main::entry#3 
Alias (byte) main::idx#5 = (byte) main::idx#6 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) main::$17 [25] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#2) goto main::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [2] (byte~) main::$5 ← (byte) 1 * (const byte) SIZEOF_STRUCT_ENTRY
Constant right-side identified [5] (byte~) main::$6 ← (byte) 2 * (const byte) SIZEOF_STRUCT_ENTRY
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const struct Entry*) ENTRIES#0 = (struct Entry*) 4096
Constant (const byte) main::$5 = 1*SIZEOF_STRUCT_ENTRY
Constant (const byte) main::$6 = 2*SIZEOF_STRUCT_ENTRY
Constant (const byte*) main::SCREEN#0 = (byte*) 1024
Constant (const byte) main::idx#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const struct Entry*) main::entry0#0 = ENTRIES#0
Constant (const struct Entry*) main::entry#0 = ENTRIES#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (struct Entry**)main::entry0#0 in [8] (struct Entry**) main::$7 ← (struct Entry**)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Constant value identified (byte*)main::entry0#0 in [10] (byte*) main::$8 ← (byte*)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
Successful SSA optimization Pass2ConstantValues
Converting *(pointer+n) to pointer[n] [9] *((struct Entry**) main::$7) ← (struct Entry*) main::entry2#0  -- *((struct Entry**)main::entry0#0 + OFFSET_STRUCT_ENTRY_NEXT)
Converting *(pointer+n) to pointer[n] [11] *((byte*) main::$8) ← (byte) 1  -- *((byte*)main::entry0#0 + OFFSET_STRUCT_ENTRY_VALUE)
Converting *(pointer+n) to pointer[n] [13] *((struct Entry**) main::$9) ← (struct Entry*) main::entry1#0  -- *((struct Entry**)main::entry2#0 + OFFSET_STRUCT_ENTRY_NEXT)
Converting *(pointer+n) to pointer[n] [15] *((byte*) main::$10) ← (byte) 2  -- *((byte*)main::entry2#0 + OFFSET_STRUCT_ENTRY_VALUE)
Converting *(pointer+n) to pointer[n] [17] *((struct Entry**) main::$11) ← (struct Entry*) 0  -- *((struct Entry**)main::entry1#0 + OFFSET_STRUCT_ENTRY_NEXT)
Converting *(pointer+n) to pointer[n] [19] *((byte*) main::$12) ← (byte) 3  -- *((byte*)main::entry1#0 + OFFSET_STRUCT_ENTRY_VALUE)
Converting *(pointer+n) to pointer[n] [28] (byte~) main::$2 ← (byte) '0' + *((byte*) main::$13)  -- *((byte*)main::entry#2 + OFFSET_STRUCT_ENTRY_VALUE)
Converting *(pointer+n) to pointer[n] [32] (byte~) main::$3 ← < *((struct Entry**) main::$14)  -- *((struct Entry**)main::entry#2 + OFFSET_STRUCT_ENTRY_NEXT)
Converting *(pointer+n) to pointer[n] [36] (byte~) main::$4 ← > *((struct Entry**) main::$15)  -- *((struct Entry**)main::entry#2 + OFFSET_STRUCT_ENTRY_NEXT)
Converting *(pointer+n) to pointer[n] [42] (struct Entry*) main::entry#1 ← *((struct Entry**) main::$16)  -- *((struct Entry**)main::entry#2 + OFFSET_STRUCT_ENTRY_NEXT)
Successful SSA optimization Pass2InlineDerefIdx
Simplifying expression containing zero (byte*)main::entry0#0 in [10] (byte*) main::$8 ← (byte*)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
Simplifying expression containing zero (byte*)main::entry0#0 in [11] *((byte*)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE) ← (byte) 1
Simplifying expression containing zero (byte*)main::entry2#0 in [14] (byte*) main::$10 ← (byte*)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
Simplifying expression containing zero (byte*)main::entry2#0 in [15] *((byte*)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE) ← (byte) 2
Simplifying expression containing zero (byte*)main::entry1#0 in [18] (byte*) main::$12 ← (byte*)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
Simplifying expression containing zero (byte*)main::entry1#0 in [19] *((byte*)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_VALUE) ← (byte) 3
Simplifying expression containing zero (byte*)main::entry#2 in [27] (byte*) main::$13 ← (byte*)(struct Entry*) main::entry#2 + (const byte) OFFSET_STRUCT_ENTRY_VALUE
Simplifying expression containing zero (byte*)main::entry#2 in [28] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#2 + (const byte) OFFSET_STRUCT_ENTRY_VALUE)
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable (struct Entry**) main::$7 and assignment [2] (struct Entry**) main::$7 ← (struct Entry**)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Eliminating unused variable (byte*) main::$8 and assignment [4] (byte*) main::$8 ← (byte*)(const struct Entry*) main::entry0#0
Eliminating unused variable (struct Entry**) main::$9 and assignment [6] (struct Entry**) main::$9 ← (struct Entry**)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Eliminating unused variable (byte*) main::$10 and assignment [8] (byte*) main::$10 ← (byte*)(struct Entry*) main::entry2#0
Eliminating unused variable (struct Entry**) main::$11 and assignment [10] (struct Entry**) main::$11 ← (struct Entry**)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Eliminating unused variable (byte*) main::$12 and assignment [12] (byte*) main::$12 ← (byte*)(struct Entry*) main::entry1#0
Eliminating unused variable (byte*) main::$13 and assignment [16] (byte*) main::$13 ← (byte*)(struct Entry*) main::entry#2
Eliminating unused variable (struct Entry**) main::$14 and assignment [20] (struct Entry**) main::$14 ← (struct Entry**)(struct Entry*) main::entry#2 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Eliminating unused variable (struct Entry**) main::$15 and assignment [24] (struct Entry**) main::$15 ← (struct Entry**)(struct Entry*) main::entry#2 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Eliminating unused variable (struct Entry**) main::$16 and assignment [30] (struct Entry**) main::$16 ← (struct Entry**)(struct Entry*) main::entry#2 + (const byte) OFFSET_STRUCT_ENTRY_NEXT
Eliminating unused constant (const byte) OFFSET_STRUCT_ENTRY_VALUE
Successful SSA optimization PassNEliminateUnusedVars
GRAPH (NEW VERSIONS for main::entry#2)
@begin: scope:[]  from
  to:@1
main: scope:[main]  from @1
  [0] (struct Entry*) main::entry1#0 ← (const struct Entry*) ENTRIES#0 + (const byte) main::$5
  [1] (struct Entry*) main::entry2#0 ← (const struct Entry*) ENTRIES#0 + (const byte) main::$6
  [2] *((struct Entry**)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) main::entry2#0
  [3] *((byte*)(const struct Entry*) main::entry0#0) ← (byte) 1
  [4] *((struct Entry**)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) main::entry1#0
  [5] *((byte*)(struct Entry*) main::entry2#0) ← (byte) 2
  [6] *((struct Entry**)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0
  [7] *((byte*)(struct Entry*) main::entry1#0) ← (byte) 3
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [8] (byte) main::idx#5 ← phi( main/(const byte) main::idx#0 main::@2/(byte) main::idx#4 )
  [8] (struct Entry*) main::entry#2 ← phi( main/(const struct Entry*) main::entry#0 main::@2/(struct Entry*) main::entry#1 )
  [9] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#2) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (struct Entry*) main::entry#4 ← phi( )
  [10] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4)
  [11] *((const byte*) main::SCREEN#0 + (byte) main::idx#5) ← (byte~) main::$2
  [12] (byte) main::idx#1 ← ++ (byte) main::idx#5
  [13] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  [14] *((const byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3
  [15] (byte) main::idx#2 ← ++ (byte) main::idx#1
  [16] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  [17] *((const byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4
  [18] (byte) main::idx#3 ← ++ (byte) main::idx#2
  [19] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' '
  [20] (byte) main::idx#4 ← ++ (byte) main::idx#3
  [21] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  to:main::@1
main::@return: scope:[main]  from main::@1
  [22] return 
  to:@return
@1: scope:[]  from @begin
  [23] call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

GRAPH (NEW VERSIONS for main::idx#5)
@begin: scope:[]  from
  to:@1
main: scope:[main]  from @1
  [0] (struct Entry*) main::entry1#0 ← (const struct Entry*) ENTRIES#0 + (const byte) main::$5
  [1] (struct Entry*) main::entry2#0 ← (const struct Entry*) ENTRIES#0 + (const byte) main::$6
  [2] *((struct Entry**)(const struct Entry*) main::entry0#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) main::entry2#0
  [3] *((byte*)(const struct Entry*) main::entry0#0) ← (byte) 1
  [4] *((struct Entry**)(struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) main::entry1#0
  [5] *((byte*)(struct Entry*) main::entry2#0) ← (byte) 2
  [6] *((struct Entry**)(struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0
  [7] *((byte*)(struct Entry*) main::entry1#0) ← (byte) 3
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [8] (byte) main::idx#5 ← phi( main/(const byte) main::idx#0 main::@2/(byte) main::idx#4 )
  [8] (struct Entry*) main::entry#2 ← phi( main/(const struct Entry*) main::entry#0 main::@2/(struct Entry*) main::entry#1 )
  [9] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#2) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (byte) main::idx#7 ← phi( )
  (struct Entry*) main::entry#4 ← phi( main::@1/(struct Entry*) main::entry#2 )
  [10] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4)
  [11] *((const byte*) main::SCREEN#0 + (byte) main::idx#7) ← (byte~) main::$2
  [12] (byte) main::idx#1 ← ++ (byte) main::idx#7
  [13] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  [14] *((const byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3
  [15] (byte) main::idx#2 ← ++ (byte) main::idx#1
  [16] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  [17] *((const byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4
  [18] (byte) main::idx#3 ← ++ (byte) main::idx#2
  [19] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' '
  [20] (byte) main::idx#4 ← ++ (byte) main::idx#3
  [21] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  to:main::@1
main::@return: scope:[main]  from main::@1
  [22] return 
  to:@return
@1: scope:[]  from @begin
  [23] call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

Successful SSA optimization Pass2LoopHeadConstantIdentification
Alias (struct Entry*) main::entry#1 = (struct Entry*) main::entry#2 
Alias (byte) main::idx#4 = (byte) main::idx#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (struct Entry*) main::entry#5 (const struct Entry*) main::entry#0
Identical Phi Values (byte) main::idx#8 (const byte) main::idx#0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [0] (struct Entry*) main::entry1#0 ← (const struct Entry*) ENTRIES#0 + (const byte) main::$5
Constant right-side identified [1] (struct Entry*) main::entry2#0 ← (const struct Entry*) ENTRIES#0 + (const byte) main::$6
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const struct Entry*) main::entry1#0 = ENTRIES#0+main::$5
Constant (const struct Entry*) main::entry2#0 = ENTRIES#0+main::$6
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (struct Entry**)main::entry2#0 in [4] *((struct Entry**)(const struct Entry*) main::entry2#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0
Constant value identified (byte*)main::entry2#0 in [5] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2
Constant value identified (struct Entry**)main::entry1#0 in [6] *((struct Entry**)(const struct Entry*) main::entry1#0 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0
Constant value identified (byte*)main::entry1#0 in [7] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [27] if((struct Entry*)(word) 0!=(const struct Entry*) main::entry#0) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Inlining constant with var siblings (const byte) main::idx#0
Inlining constant with var siblings (const struct Entry*) main::entry#0
Constant inlined main::$5 = (byte) 1*(const byte) SIZEOF_STRUCT_ENTRY
Constant inlined main::$6 = (byte) 2*(const byte) SIZEOF_STRUCT_ENTRY
Constant inlined main::idx#0 = (byte) 0
Constant inlined main::entry0#0 = (const struct Entry*) ENTRIES#0
Constant inlined main::entry#0 = (const struct Entry*) ENTRIES#0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *((struct Entry**)ENTRIES#0+OFFSET_STRUCT_ENTRY_NEXT)
Consolidated array index constant in *((struct Entry**)main::entry2#0+OFFSET_STRUCT_ENTRY_NEXT)
Consolidated array index constant in *((struct Entry**)main::entry1#0+OFFSET_STRUCT_ENTRY_NEXT)
Successful SSA optimization Pass2ConstantAdditionElimination
Added new block during phi lifting main::@7(between main::@1 and main::@2)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1_1
CALL GRAPH
Calls in [] to main:2 

Created 2 initial phi equivalence classes
Coalesced [27] main::entry#6 ← main::entry#1
Coalesced [28] main::idx#9 ← main::idx#4
Coalesced down to 2 phi equivalence classes
Culled Empty Block (label) @2
Culled Empty Block (label) main::@1_1
Culled Empty Block (label) main::@7
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] *((struct Entry**)(const struct Entry*) ENTRIES#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry2#0
  [5] *((byte*)(const struct Entry*) ENTRIES#0) ← (byte) 1
  [6] *((struct Entry**)(const struct Entry*) main::entry2#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0
  [7] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2
  [8] *((struct Entry**)(const struct Entry*) main::entry1#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0
  [9] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3
  to:main::@2
main::@2: scope:[main]  from main main::@1
  [10] (byte) main::idx#7 ← phi( main::@1/(byte) main::idx#4 main/(byte) 0 )
  [10] (struct Entry*) main::entry#4 ← phi( main::@1/(struct Entry*) main::entry#1 main/(const struct Entry*) ENTRIES#0 )
  [11] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4)
  [12] *((const byte*) main::SCREEN#0 + (byte) main::idx#7) ← (byte~) main::$2
  [13] (byte) main::idx#1 ← ++ (byte) main::idx#7
  [14] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  [15] *((const byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3
  [16] (byte) main::idx#2 ← ++ (byte) main::idx#1
  [17] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  [18] *((const byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4
  [19] (byte) main::idx#3 ← ++ (byte) main::idx#2
  [20] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' '
  [21] (byte) main::idx#4 ← ++ (byte) main::idx#3
  [22] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT)
  to:main::@1
main::@1: scope:[main]  from main::@2
  [23] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#1) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@1
  [24] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(struct Entry*) ENTRIES
(struct Entry*) Entry::next
(byte) Entry::value
(void()) main()
(byte~) main::$2 22.0
(byte~) main::$3 22.0
(byte~) main::$4 22.0
(byte*) main::SCREEN
(struct Entry*) main::entry
(struct Entry*) main::entry#1 16.5
(struct Entry*) main::entry#4 0.9166666666666666
(struct Entry*) main::entry0
(struct Entry*) main::entry1
(struct Entry*) main::entry2
(byte) main::idx
(byte) main::idx#1 11.0
(byte) main::idx#2 11.0
(byte) main::idx#3 16.5
(byte) main::idx#4 7.333333333333333
(byte) main::idx#7 11.0

Initial phi equivalence classes
[ main::entry#4 main::entry#1 ]
[ main::idx#7 main::idx#4 ]
Added variable main::$2 to zero page equivalence class [ main::$2 ]
Added variable main::idx#1 to zero page equivalence class [ main::idx#1 ]
Added variable main::$3 to zero page equivalence class [ main::$3 ]
Added variable main::idx#2 to zero page equivalence class [ main::idx#2 ]
Added variable main::$4 to zero page equivalence class [ main::$4 ]
Added variable main::idx#3 to zero page equivalence class [ main::idx#3 ]
Complete equivalence classes
[ main::entry#4 main::entry#1 ]
[ main::idx#7 main::idx#4 ]
[ main::$2 ]
[ main::idx#1 ]
[ main::$3 ]
[ main::idx#2 ]
[ main::$4 ]
[ main::idx#3 ]
Allocated zp ZP_WORD:2 [ main::entry#4 main::entry#1 ]
Allocated zp ZP_BYTE:4 [ main::idx#7 main::idx#4 ]
Allocated zp ZP_BYTE:5 [ main::$2 ]
Allocated zp ZP_BYTE:6 [ main::idx#1 ]
Allocated zp ZP_BYTE:7 [ main::$3 ]
Allocated zp ZP_BYTE:8 [ main::idx#2 ]
Allocated zp ZP_BYTE:9 [ main::$4 ]
Allocated zp ZP_BYTE:10 [ main::idx#3 ]

INITIAL ASM
Target platform is c64basic
  // File Comments
// Minimal struct - simple linked list implemented using pointers
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .const SIZEOF_STRUCT_ENTRY = 3
  .const OFFSET_STRUCT_ENTRY_NEXT = 1
  .label ENTRIES = $1000
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    // Run through the linked list
    .label SCREEN = $400
    .label entry1 = ENTRIES+1*SIZEOF_STRUCT_ENTRY
    .label entry2 = ENTRIES+2*SIZEOF_STRUCT_ENTRY
    .label _2 = 5
    .label _3 = 7
    .label _4 = 9
    .label idx = 6
    .label idx_2 = 8
    .label idx_3 = $a
    .label idx_4 = 4
    .label entry = 2
    .label idx_7 = 4
    // [4] *((struct Entry**)(const struct Entry*) ENTRIES#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry2#0 -- _deref_pptc1=pssc2 
    lda #<entry2
    sta ENTRIES+OFFSET_STRUCT_ENTRY_NEXT
    lda #>entry2
    sta ENTRIES+OFFSET_STRUCT_ENTRY_NEXT+1
    // [5] *((byte*)(const struct Entry*) ENTRIES#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta ENTRIES
    // [6] *((struct Entry**)(const struct Entry*) main::entry2#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0 -- _deref_pptc1=pssc2 
    lda #<entry1
    sta entry2+OFFSET_STRUCT_ENTRY_NEXT
    lda #>entry1
    sta entry2+OFFSET_STRUCT_ENTRY_NEXT+1
    // [7] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta entry2
    // [8] *((struct Entry**)(const struct Entry*) main::entry1#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0 -- _deref_pptc1=pssc2 
    lda #<0
    sta entry1+OFFSET_STRUCT_ENTRY_NEXT
    lda #>0
    sta entry1+OFFSET_STRUCT_ENTRY_NEXT+1
    // [9] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta entry1
    // [10] phi from main to main::@2 [phi:main->main::@2]
  b2_from_main:
    // [10] phi (byte) main::idx#7 = (byte) 0 [phi:main->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta idx_7
    // [10] phi (struct Entry*) main::entry#4 = (const struct Entry*) ENTRIES#0 [phi:main->main::@2#1] -- pssz1=pssc1 
    lda #<ENTRIES
    sta entry
    lda #>ENTRIES
    sta entry+1
    jmp b2
    // [10] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    // [10] phi (byte) main::idx#7 = (byte) main::idx#4 [phi:main::@1->main::@2#0] -- register_copy 
    // [10] phi (struct Entry*) main::entry#4 = (struct Entry*) main::entry#1 [phi:main::@1->main::@2#1] -- register_copy 
    jmp b2
    // main::@2
  b2:
    // [11] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4) -- vbuz1=vbuc1_plus__deref_pbuz2 
    lda #'0'
    clc
    ldy #0
    adc (entry),y
    sta _2
    // [12] *((const byte*) main::SCREEN#0 + (byte) main::idx#7) ← (byte~) main::$2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _2
    ldy idx_7
    sta SCREEN,y
    // [13] (byte) main::idx#1 ← ++ (byte) main::idx#7 -- vbuz1=_inc_vbuz2 
    ldy idx_7
    iny
    sty idx
    // [14] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- vbuz1=_lo_pptz2_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT
    lda (entry),y
    sta _3
    // [15] *((const byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _3
    ldy idx
    sta SCREEN,y
    // [16] (byte) main::idx#2 ← ++ (byte) main::idx#1 -- vbuz1=_inc_vbuz2 
    ldy idx
    iny
    sty idx_2
    // [17] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- vbuz1=_hi_pptz2_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT+1
    lda (entry),y
    sta _4
    // [18] *((const byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda _4
    ldy idx_2
    sta SCREEN,y
    // [19] (byte) main::idx#3 ← ++ (byte) main::idx#2 -- vbuz1=_inc_vbuz2 
    ldy idx_2
    iny
    sty idx_3
    // [20] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' ' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #' '
    ldy idx_3
    sta SCREEN,y
    // [21] (byte) main::idx#4 ← ++ (byte) main::idx#3 -- vbuz1=_inc_vbuz2 
    ldy idx_3
    iny
    sty idx_4
    // [22] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- pssz1=pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT
    lda (entry),y
    pha
    iny
    lda (entry),y
    sta entry+1
    pla
    sta entry
    jmp b1
    // main::@1
  b1:
    // [23] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#1) goto main::@2 -- pssc1_neq_pssz1_then_la1 
    lda entry+1
    cmp #>0
    bne b2_from_b1
    lda entry
    cmp #<0
    bne b2_from_b1
    jmp breturn
    // main::@return
  breturn:
    // [24] return 
    rts
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] *((struct Entry**)(const struct Entry*) ENTRIES#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry2#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [5] *((byte*)(const struct Entry*) ENTRIES#0) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((struct Entry**)(const struct Entry*) main::entry2#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((struct Entry**)(const struct Entry*) main::entry1#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [11] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4) [ main::entry#4 main::idx#7 main::$2 ] ( main:2 [ main::entry#4 main::idx#7 main::$2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ main::idx#7 main::idx#4 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:4 [ main::idx#7 main::idx#4 ]
Statement [14] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) [ main::entry#4 main::idx#1 main::$3 ] ( main:2 [ main::entry#4 main::idx#1 main::$3 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ main::idx#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:6 [ main::idx#1 ]
Statement [17] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) [ main::entry#4 main::idx#2 main::$4 ] ( main:2 [ main::entry#4 main::idx#2 main::$4 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ main::idx#2 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:8 [ main::idx#2 ]
Statement [20] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' ' [ main::entry#4 main::idx#3 ] ( main:2 [ main::entry#4 main::idx#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ main::idx#3 ]
Statement [22] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) [ main::entry#1 main::idx#4 ] ( main:2 [ main::entry#1 main::idx#4 ] ) always clobbers reg byte a reg byte y 
Statement [23] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#1) goto main::@2 [ main::entry#1 main::idx#4 ] ( main:2 [ main::entry#1 main::idx#4 ] ) always clobbers reg byte a 
Statement [4] *((struct Entry**)(const struct Entry*) ENTRIES#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry2#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [5] *((byte*)(const struct Entry*) ENTRIES#0) ← (byte) 1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] *((struct Entry**)(const struct Entry*) main::entry2#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [8] *((struct Entry**)(const struct Entry*) main::entry1#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [11] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4) [ main::entry#4 main::idx#7 main::$2 ] ( main:2 [ main::entry#4 main::idx#7 main::$2 ] ) always clobbers reg byte a reg byte y 
Statement [14] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) [ main::entry#4 main::idx#1 main::$3 ] ( main:2 [ main::entry#4 main::idx#1 main::$3 ] ) always clobbers reg byte a reg byte y 
Statement [17] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) [ main::entry#4 main::idx#2 main::$4 ] ( main:2 [ main::entry#4 main::idx#2 main::$4 ] ) always clobbers reg byte a reg byte y 
Statement [20] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' ' [ main::entry#4 main::idx#3 ] ( main:2 [ main::entry#4 main::idx#3 ] ) always clobbers reg byte a 
Statement [22] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) [ main::entry#1 main::idx#4 ] ( main:2 [ main::entry#1 main::idx#4 ] ) always clobbers reg byte a reg byte y 
Statement [23] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#1) goto main::@2 [ main::entry#1 main::idx#4 ] ( main:2 [ main::entry#1 main::idx#4 ] ) always clobbers reg byte a 
Potential registers zp ZP_WORD:2 [ main::entry#4 main::entry#1 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_BYTE:4 [ main::idx#7 main::idx#4 ] : zp ZP_BYTE:4 , reg byte x , 
Potential registers zp ZP_BYTE:5 [ main::$2 ] : zp ZP_BYTE:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ main::idx#1 ] : zp ZP_BYTE:6 , reg byte x , 
Potential registers zp ZP_BYTE:7 [ main::$3 ] : zp ZP_BYTE:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ main::idx#2 ] : zp ZP_BYTE:8 , reg byte x , 
Potential registers zp ZP_BYTE:9 [ main::$4 ] : zp ZP_BYTE:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ main::idx#3 ] : zp ZP_BYTE:10 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 22: zp ZP_BYTE:5 [ main::$2 ] 22: zp ZP_BYTE:7 [ main::$3 ] 22: zp ZP_BYTE:9 [ main::$4 ] 18.33: zp ZP_BYTE:4 [ main::idx#7 main::idx#4 ] 17.42: zp ZP_WORD:2 [ main::entry#4 main::entry#1 ] 16.5: zp ZP_BYTE:10 [ main::idx#3 ] 11: zp ZP_BYTE:6 [ main::idx#1 ] 11: zp ZP_BYTE:8 [ main::idx#2 ] 
Uplift Scope [Entry] 
Uplift Scope [] 

Uplifting [main] best 1577 combination reg byte a [ main::$2 ] reg byte a [ main::$3 ] reg byte a [ main::$4 ] reg byte x [ main::idx#7 main::idx#4 ] zp ZP_WORD:2 [ main::entry#4 main::entry#1 ] zp ZP_BYTE:10 [ main::idx#3 ] zp ZP_BYTE:6 [ main::idx#1 ] zp ZP_BYTE:8 [ main::idx#2 ] 
Limited combination testing to 100 combinations of 1536 possible.
Uplifting [Entry] best 1577 combination 
Uplifting [] best 1577 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ main::idx#3 ]
Uplifting [main] best 1487 combination reg byte x [ main::idx#3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ main::idx#1 ]
Uplifting [main] best 1397 combination reg byte x [ main::idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:8 [ main::idx#2 ]
Uplifting [main] best 1307 combination reg byte x [ main::idx#2 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Minimal struct - simple linked list implemented using pointers
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .const SIZEOF_STRUCT_ENTRY = 3
  .const OFFSET_STRUCT_ENTRY_NEXT = 1
  .label ENTRIES = $1000
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    // Run through the linked list
    .label SCREEN = $400
    .label entry1 = ENTRIES+1*SIZEOF_STRUCT_ENTRY
    .label entry2 = ENTRIES+2*SIZEOF_STRUCT_ENTRY
    .label entry = 2
    // [4] *((struct Entry**)(const struct Entry*) ENTRIES#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry2#0 -- _deref_pptc1=pssc2 
    lda #<entry2
    sta ENTRIES+OFFSET_STRUCT_ENTRY_NEXT
    lda #>entry2
    sta ENTRIES+OFFSET_STRUCT_ENTRY_NEXT+1
    // [5] *((byte*)(const struct Entry*) ENTRIES#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta ENTRIES
    // [6] *((struct Entry**)(const struct Entry*) main::entry2#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0 -- _deref_pptc1=pssc2 
    lda #<entry1
    sta entry2+OFFSET_STRUCT_ENTRY_NEXT
    lda #>entry1
    sta entry2+OFFSET_STRUCT_ENTRY_NEXT+1
    // [7] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta entry2
    // [8] *((struct Entry**)(const struct Entry*) main::entry1#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0 -- _deref_pptc1=pssc2 
    lda #<0
    sta entry1+OFFSET_STRUCT_ENTRY_NEXT
    lda #>0
    sta entry1+OFFSET_STRUCT_ENTRY_NEXT+1
    // [9] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta entry1
    // [10] phi from main to main::@2 [phi:main->main::@2]
  b2_from_main:
    // [10] phi (byte) main::idx#7 = (byte) 0 [phi:main->main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [10] phi (struct Entry*) main::entry#4 = (const struct Entry*) ENTRIES#0 [phi:main->main::@2#1] -- pssz1=pssc1 
    lda #<ENTRIES
    sta entry
    lda #>ENTRIES
    sta entry+1
    jmp b2
    // [10] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    // [10] phi (byte) main::idx#7 = (byte) main::idx#4 [phi:main::@1->main::@2#0] -- register_copy 
    // [10] phi (struct Entry*) main::entry#4 = (struct Entry*) main::entry#1 [phi:main::@1->main::@2#1] -- register_copy 
    jmp b2
    // main::@2
  b2:
    // [11] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4) -- vbuaa=vbuc1_plus__deref_pbuz1 
    lda #'0'
    clc
    ldy #0
    adc (entry),y
    // [12] *((const byte*) main::SCREEN#0 + (byte) main::idx#7) ← (byte~) main::$2 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // [13] (byte) main::idx#1 ← ++ (byte) main::idx#7 -- vbuxx=_inc_vbuxx 
    inx
    // [14] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- vbuaa=_lo_pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT
    lda (entry),y
    // [15] *((const byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // [16] (byte) main::idx#2 ← ++ (byte) main::idx#1 -- vbuxx=_inc_vbuxx 
    inx
    // [17] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- vbuaa=_hi_pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT+1
    lda (entry),y
    // [18] *((const byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // [19] (byte) main::idx#3 ← ++ (byte) main::idx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [20] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta SCREEN,x
    // [21] (byte) main::idx#4 ← ++ (byte) main::idx#3 -- vbuxx=_inc_vbuxx 
    inx
    // [22] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- pssz1=pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT
    lda (entry),y
    pha
    iny
    lda (entry),y
    sta entry+1
    pla
    sta entry
    jmp b1
    // main::@1
  b1:
    // [23] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#1) goto main::@2 -- pssc1_neq_pssz1_then_la1 
    lda entry+1
    cmp #>0
    bne b2_from_b1
    lda entry
    cmp #<0
    bne b2_from_b1
    jmp breturn
    // main::@return
  breturn:
    // [24] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b2
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b2_from_b1 with b2
Replacing label b2_from_b1 with b2
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Removing instruction b2_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b2_from_main:
Removing instruction b1:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(struct Entry*) ENTRIES
(const struct Entry*) ENTRIES#0 ENTRIES = (struct Entry*) 4096
(struct Entry*) Entry::next
(byte) Entry::value
(const byte) OFFSET_STRUCT_ENTRY_NEXT OFFSET_STRUCT_ENTRY_NEXT = (byte) 1
(const byte) SIZEOF_STRUCT_ENTRY SIZEOF_STRUCT_ENTRY = (byte) 3
(void()) main()
(byte~) main::$2 reg byte a 22.0
(byte~) main::$3 reg byte a 22.0
(byte~) main::$4 reg byte a 22.0
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::SCREEN
(const byte*) main::SCREEN#0 SCREEN = (byte*) 1024
(struct Entry*) main::entry
(struct Entry*) main::entry#1 entry zp ZP_WORD:2 16.5
(struct Entry*) main::entry#4 entry zp ZP_WORD:2 0.9166666666666666
(struct Entry*) main::entry0
(struct Entry*) main::entry1
(const struct Entry*) main::entry1#0 entry1 = (const struct Entry*) ENTRIES#0+(byte) 1*(const byte) SIZEOF_STRUCT_ENTRY
(struct Entry*) main::entry2
(const struct Entry*) main::entry2#0 entry2 = (const struct Entry*) ENTRIES#0+(byte) 2*(const byte) SIZEOF_STRUCT_ENTRY
(byte) main::idx
(byte) main::idx#1 reg byte x 11.0
(byte) main::idx#2 reg byte x 11.0
(byte) main::idx#3 reg byte x 16.5
(byte) main::idx#4 reg byte x 7.333333333333333
(byte) main::idx#7 reg byte x 11.0

zp ZP_WORD:2 [ main::entry#4 main::entry#1 ]
reg byte x [ main::idx#7 main::idx#4 ]
reg byte a [ main::$2 ]
reg byte x [ main::idx#1 ]
reg byte a [ main::$3 ]
reg byte x [ main::idx#2 ]
reg byte a [ main::$4 ]
reg byte x [ main::idx#3 ]


FINAL ASSEMBLER
Score: 1173

  // File Comments
// Minimal struct - simple linked list implemented using pointers
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const SIZEOF_STRUCT_ENTRY = 3
  .const OFFSET_STRUCT_ENTRY_NEXT = 1
  .label ENTRIES = $1000
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // Run through the linked list
    .label SCREEN = $400
    .label entry1 = ENTRIES+1*SIZEOF_STRUCT_ENTRY
    .label entry2 = ENTRIES+2*SIZEOF_STRUCT_ENTRY
    .label entry = 2
    // entry0->next = entry2
    // [4] *((struct Entry**)(const struct Entry*) ENTRIES#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry2#0 -- _deref_pptc1=pssc2 
    lda #<entry2
    sta ENTRIES+OFFSET_STRUCT_ENTRY_NEXT
    lda #>entry2
    sta ENTRIES+OFFSET_STRUCT_ENTRY_NEXT+1
    // entry0->value = 1
    // [5] *((byte*)(const struct Entry*) ENTRIES#0) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    lda #1
    sta ENTRIES
    // entry2->next = entry1
    // [6] *((struct Entry**)(const struct Entry*) main::entry2#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (const struct Entry*) main::entry1#0 -- _deref_pptc1=pssc2 
    lda #<entry1
    sta entry2+OFFSET_STRUCT_ENTRY_NEXT
    lda #>entry1
    sta entry2+OFFSET_STRUCT_ENTRY_NEXT+1
    // entry2->value = 2
    // [7] *((byte*)(const struct Entry*) main::entry2#0) ← (byte) 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta entry2
    // entry1->next = 0
    // [8] *((struct Entry**)(const struct Entry*) main::entry1#0+(const byte) OFFSET_STRUCT_ENTRY_NEXT) ← (struct Entry*) 0 -- _deref_pptc1=pssc2 
    lda #<0
    sta entry1+OFFSET_STRUCT_ENTRY_NEXT
    sta entry1+OFFSET_STRUCT_ENTRY_NEXT+1
    // entry1->value = 3
    // [9] *((byte*)(const struct Entry*) main::entry1#0) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta entry1
    // [10] phi from main to main::@2 [phi:main->main::@2]
    // [10] phi (byte) main::idx#7 = (byte) 0 [phi:main->main::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [10] phi (struct Entry*) main::entry#4 = (const struct Entry*) ENTRIES#0 [phi:main->main::@2#1] -- pssz1=pssc1 
    lda #<ENTRIES
    sta entry
    lda #>ENTRIES
    sta entry+1
    // [10] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // [10] phi (byte) main::idx#7 = (byte) main::idx#4 [phi:main::@1->main::@2#0] -- register_copy 
    // [10] phi (struct Entry*) main::entry#4 = (struct Entry*) main::entry#1 [phi:main::@1->main::@2#1] -- register_copy 
    // main::@2
  b2:
    // '0'+entry->value
    // [11] (byte~) main::$2 ← (byte) '0' + *((byte*)(struct Entry*) main::entry#4) -- vbuaa=vbuc1_plus__deref_pbuz1 
    lda #'0'
    clc
    ldy #0
    adc (entry),y
    // SCREEN[idx++] = '0'+entry->value
    // [12] *((const byte*) main::SCREEN#0 + (byte) main::idx#7) ← (byte~) main::$2 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // SCREEN[idx++] = '0'+entry->value;
    // [13] (byte) main::idx#1 ← ++ (byte) main::idx#7 -- vbuxx=_inc_vbuxx 
    inx
    // <entry->next
    // [14] (byte~) main::$3 ← < *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- vbuaa=_lo_pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT
    lda (entry),y
    // SCREEN[idx++] = <entry->next
    // [15] *((const byte*) main::SCREEN#0 + (byte) main::idx#1) ← (byte~) main::$3 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // SCREEN[idx++] = <entry->next;
    // [16] (byte) main::idx#2 ← ++ (byte) main::idx#1 -- vbuxx=_inc_vbuxx 
    inx
    // >entry->next
    // [17] (byte~) main::$4 ← > *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- vbuaa=_hi_pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT+1
    lda (entry),y
    // SCREEN[idx++] = >entry->next
    // [18] *((const byte*) main::SCREEN#0 + (byte) main::idx#2) ← (byte~) main::$4 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta SCREEN,x
    // SCREEN[idx++] = >entry->next;
    // [19] (byte) main::idx#3 ← ++ (byte) main::idx#2 -- vbuxx=_inc_vbuxx 
    inx
    // SCREEN[idx++] = ' '
    // [20] *((const byte*) main::SCREEN#0 + (byte) main::idx#3) ← (byte) ' ' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #' '
    sta SCREEN,x
    // SCREEN[idx++] = ' ';
    // [21] (byte) main::idx#4 ← ++ (byte) main::idx#3 -- vbuxx=_inc_vbuxx 
    inx
    // entry = entry->next
    // [22] (struct Entry*) main::entry#1 ← *((struct Entry**)(struct Entry*) main::entry#4 + (const byte) OFFSET_STRUCT_ENTRY_NEXT) -- pssz1=pptz1_derefidx_vbuc1 
    ldy #OFFSET_STRUCT_ENTRY_NEXT
    lda (entry),y
    pha
    iny
    lda (entry),y
    sta entry+1
    pla
    sta entry
    // main::@1
    // while(entry)
    // [23] if((struct Entry*)(word) 0!=(struct Entry*) main::entry#1) goto main::@2 -- pssc1_neq_pssz1_then_la1 
    lda entry+1
    cmp #>0
    bne b2
    lda entry
    cmp #<0
    bne b2
    // main::@return
    // }
    // [24] return 
    rts
}
  // File Data

