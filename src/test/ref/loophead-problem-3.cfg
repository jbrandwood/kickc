@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call mul16u 
  [6] (dword) mul16u::return#2 ← (dword) mul16u::res#2
  to:main::@1
main::@1: scope:[main]  from main
  [7] (dword) main::result#0 ← (dword) mul16u::return#2
  [8] (word) main::kaputt#0 ← < (dword) main::result#0
  [9] (byte~) main::$2 ← < (word) main::kaputt#0
  [10] *((const byte*) BORDERCOL) ← (byte~) main::$2
  [11] (byte~) main::$3 ← > (word) main::kaputt#0
  [12] *((const byte*) BGCOL) ← (byte~) main::$3
  to:main::@return
main::@return: scope:[main]  from main::@1
  [13] return 
  to:@return

(dword()) mul16u((word) mul16u::a , (word) mul16u::b)
mul16u: scope:[mul16u]  from main
  [14] phi()
  to:mul16u::@1
mul16u::@1: scope:[mul16u]  from mul16u mul16u::@3
  [15] (dword) mul16u::mb#2 ← phi( mul16u/(dword)(const word) mul16u::b#0 mul16u::@3/(dword) mul16u::mb#1 )
  [15] (dword) mul16u::res#2 ← phi( mul16u/(dword) 0 mul16u::@3/(dword) mul16u::res#6 )
  [15] (word) mul16u::a#2 ← phi( mul16u/(byte) 4 mul16u::@3/(word) mul16u::a#0 )
  [16] if((word) mul16u::a#2!=(byte) 0) goto mul16u::@2
  to:mul16u::@return
mul16u::@return: scope:[mul16u]  from mul16u::@1
  [17] return 
  to:@return
mul16u::@2: scope:[mul16u]  from mul16u::@1
  [18] (byte~) mul16u::$1 ← (word) mul16u::a#2 & (byte) 1
  [19] if((byte~) mul16u::$1==(byte) 0) goto mul16u::@3
  to:mul16u::@4
mul16u::@4: scope:[mul16u]  from mul16u::@2
  [20] (dword) mul16u::res#1 ← (dword) mul16u::res#2 + (dword) mul16u::mb#2
  to:mul16u::@3
mul16u::@3: scope:[mul16u]  from mul16u::@2 mul16u::@4
  [21] (dword) mul16u::res#6 ← phi( mul16u::@2/(dword) mul16u::res#2 mul16u::@4/(dword) mul16u::res#1 )
  [22] (word) mul16u::a#0 ← (word) mul16u::a#2 >> (byte) 1
  [23] (dword) mul16u::mb#1 ← (dword) mul16u::mb#2 << (byte) 1
  to:mul16u::@1
