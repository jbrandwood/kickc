Identified constant variable (byte*) PROCPORT
Identified constant variable (byte*) CHARGEN
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) RASTER
Identified constant variable (byte*) BGCOL
Identified constant variable (byte*) SCROLL
Identified constant variable (byte*) TEXT
Culled Empty Block (label) main::@1
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@6
Culled Empty Block (label) next_char::@3
Culled Empty Block (label) @4
Culled Empty Block (label) scroll_hard::@4
Culled Empty Block (label) scroll_hard::@3
Culled Empty Block (label) scroll_hard::@5
Culled Empty Block (label) scroll_hard::@6
Culled Empty Block (label) @5
Culled Empty Block (label) fillscreen::@4
Culled Empty Block (label) fillscreen::@3
Culled Empty Block (label) fillscreen::@5
Culled Empty Block (label) fillscreen::@6

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) PROCPORT ← ((byte*)) (number) 1
  (byte*) CHARGEN ← ((byte*)) (number) $d000
  (byte*) SCREEN ← ((byte*)) (number) $400
  (byte*) RASTER ← ((byte*)) (number) $d012
  (byte*) BGCOL ← ((byte*)) (number) $d020
  (byte*) SCROLL ← ((byte*)) (number) $d016
  (byte*) TEXT ← (const string) $0
  to:@1

(void()) main()
main: scope:[main]  from @6
  (byte*) current_chargen#30 ← phi( @6/(byte*) current_chargen#21 )
  (byte*) nxt#36 ← phi( @6/(byte*) nxt#26 )
  (byte) current_bit#31 ← phi( @6/(byte) current_bit#23 )
  (byte) scroll#21 ← phi( @6/(byte) scroll#15 )
  (byte*) fillscreen::screen#0 ← (byte*) SCREEN
  (byte) fillscreen::fill#0 ← (number) $20
  call fillscreen 
  to:main::@7
main::@7: scope:[main]  from main
  (byte*) current_chargen#29 ← phi( main/(byte*) current_chargen#30 )
  (byte*) nxt#34 ← phi( main/(byte*) nxt#36 )
  (byte) current_bit#30 ← phi( main/(byte) current_bit#31 )
  (byte) scroll#20 ← phi( main/(byte) scroll#21 )
  to:main::@2
main::@2: scope:[main]  from main::@2 main::@7 main::@8
  (byte*) current_chargen#27 ← phi( main::@2/(byte*) current_chargen#27 main::@7/(byte*) current_chargen#29 main::@8/(byte*) current_chargen#0 )
  (byte*) nxt#31 ← phi( main::@2/(byte*) nxt#31 main::@7/(byte*) nxt#34 main::@8/(byte*) nxt#0 )
  (byte) current_bit#29 ← phi( main::@2/(byte) current_bit#29 main::@7/(byte) current_bit#30 main::@8/(byte) current_bit#0 )
  (byte) scroll#18 ← phi( main::@2/(byte) scroll#18 main::@7/(byte) scroll#20 main::@8/(byte) scroll#0 )
  (bool~) main::$1 ← *((byte*) RASTER) != (number) $fe
  if((bool~) main::$1) goto main::@2
  to:main::@4
main::@4: scope:[main]  from main::@2 main::@4
  (byte*) current_chargen#22 ← phi( main::@2/(byte*) current_chargen#27 main::@4/(byte*) current_chargen#22 )
  (byte*) nxt#27 ← phi( main::@2/(byte*) nxt#31 main::@4/(byte*) nxt#27 )
  (byte) current_bit#24 ← phi( main::@2/(byte) current_bit#29 main::@4/(byte) current_bit#24 )
  (byte) scroll#16 ← phi( main::@2/(byte) scroll#18 main::@4/(byte) scroll#16 )
  (bool~) main::$2 ← *((byte*) RASTER) != (number) $ff
  if((bool~) main::$2) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@4
  (byte*) current_chargen#15 ← phi( main::@4/(byte*) current_chargen#22 )
  (byte*) nxt#21 ← phi( main::@4/(byte*) nxt#27 )
  (byte) current_bit#17 ← phi( main::@4/(byte) current_bit#24 )
  (byte) scroll#13 ← phi( main::@4/(byte) scroll#16 )
  *((byte*) BGCOL) ← ++ *((byte*) BGCOL)
  call scroll_soft 
  to:main::@8
main::@8: scope:[main]  from main::@5
  (byte*) current_chargen#8 ← phi( main::@5/(byte*) current_chargen#3 )
  (byte*) nxt#11 ← phi( main::@5/(byte*) nxt#3 )
  (byte) current_bit#9 ← phi( main::@5/(byte) current_bit#3 )
  (byte) scroll#7 ← phi( main::@5/(byte) scroll#5 )
  (byte) scroll#0 ← (byte) scroll#7
  (byte) current_bit#0 ← (byte) current_bit#9
  (byte*) nxt#0 ← (byte*) nxt#11
  (byte*) current_chargen#0 ← (byte*) current_chargen#8
  *((byte*) BGCOL) ← -- *((byte*) BGCOL)
  if(true) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@8
  (byte*) current_chargen#9 ← phi( main::@8/(byte*) current_chargen#0 )
  (byte*) nxt#12 ← phi( main::@8/(byte*) nxt#0 )
  (byte) current_bit#10 ← phi( main::@8/(byte) current_bit#0 )
  (byte) scroll#8 ← phi( main::@8/(byte) scroll#0 )
  (byte) scroll#1 ← (byte) scroll#8
  (byte) current_bit#1 ← (byte) current_bit#10
  (byte*) nxt#1 ← (byte*) nxt#12
  (byte*) current_chargen#1 ← (byte*) current_chargen#9
  return 
  to:@return
@1: scope:[]  from @begin
  (byte) scroll#2 ← (number) 7
  to:@2

(void()) scroll_soft()
scroll_soft: scope:[scroll_soft]  from main::@5
  (byte*) current_chargen#23 ← phi( main::@5/(byte*) current_chargen#15 )
  (byte*) nxt#28 ← phi( main::@5/(byte*) nxt#21 )
  (byte) current_bit#25 ← phi( main::@5/(byte) current_bit#17 )
  (byte) scroll#9 ← phi( main::@5/(byte) scroll#13 )
  (byte) scroll#3 ← -- (byte) scroll#9
  (bool~) scroll_soft::$0 ← (byte) scroll#3 == (number) $ff
  (bool~) scroll_soft::$1 ← ! (bool~) scroll_soft::$0
  if((bool~) scroll_soft::$1) goto scroll_soft::@1
  to:scroll_soft::@2
scroll_soft::@1: scope:[scroll_soft]  from scroll_soft scroll_soft::@3
  (byte*) current_chargen#17 ← phi( scroll_soft/(byte*) current_chargen#23 scroll_soft::@3/(byte*) current_chargen#2 )
  (byte*) nxt#23 ← phi( scroll_soft/(byte*) nxt#28 scroll_soft::@3/(byte*) nxt#2 )
  (byte) current_bit#19 ← phi( scroll_soft/(byte) current_bit#25 scroll_soft::@3/(byte) current_bit#2 )
  (byte) scroll#10 ← phi( scroll_soft/(byte) scroll#3 scroll_soft::@3/(byte) scroll#14 )
  *((byte*) SCROLL) ← (byte) scroll#10
  to:scroll_soft::@return
scroll_soft::@2: scope:[scroll_soft]  from scroll_soft
  (byte*) current_chargen#16 ← phi( scroll_soft/(byte*) current_chargen#23 )
  (byte*) nxt#22 ← phi( scroll_soft/(byte*) nxt#28 )
  (byte) current_bit#18 ← phi( scroll_soft/(byte) current_bit#25 )
  (byte) scroll#4 ← (number) 7
  call scroll_bit 
  to:scroll_soft::@3
scroll_soft::@3: scope:[scroll_soft]  from scroll_soft::@2
  (byte) scroll#14 ← phi( scroll_soft::@2/(byte) scroll#4 )
  (byte*) current_chargen#10 ← phi( scroll_soft::@2/(byte*) current_chargen#6 )
  (byte*) nxt#13 ← phi( scroll_soft::@2/(byte*) nxt#5 )
  (byte) current_bit#11 ← phi( scroll_soft::@2/(byte) current_bit#7 )
  (byte) current_bit#2 ← (byte) current_bit#11
  (byte*) nxt#2 ← (byte*) nxt#13
  (byte*) current_chargen#2 ← (byte*) current_chargen#10
  to:scroll_soft::@1
scroll_soft::@return: scope:[scroll_soft]  from scroll_soft::@1
  (byte*) current_chargen#11 ← phi( scroll_soft::@1/(byte*) current_chargen#17 )
  (byte*) nxt#14 ← phi( scroll_soft::@1/(byte*) nxt#23 )
  (byte) current_bit#12 ← phi( scroll_soft::@1/(byte) current_bit#19 )
  (byte) scroll#11 ← phi( scroll_soft::@1/(byte) scroll#10 )
  (byte) scroll#5 ← (byte) scroll#11
  (byte) current_bit#3 ← (byte) current_bit#12
  (byte*) nxt#3 ← (byte*) nxt#14
  (byte*) current_chargen#3 ← (byte*) current_chargen#11
  return 
  to:@return
@2: scope:[]  from @1
  (byte) scroll#19 ← phi( @1/(byte) scroll#2 )
  (byte*) current_chargen#4 ← (byte*) CHARGEN
  (byte) current_bit#4 ← (number) 1
  to:@3

(void()) scroll_bit()
scroll_bit: scope:[scroll_bit]  from scroll_soft::@2
  (byte*) current_chargen#28 ← phi( scroll_soft::@2/(byte*) current_chargen#16 )
  (byte*) nxt#29 ← phi( scroll_soft::@2/(byte*) nxt#22 )
  (byte) current_bit#13 ← phi( scroll_soft::@2/(byte) current_bit#18 )
  (number~) scroll_bit::$0 ← (byte) current_bit#13 / (number) 2
  (byte) current_bit#5 ← (number~) scroll_bit::$0
  (bool~) scroll_bit::$1 ← (byte) current_bit#5 == (number) 0
  (bool~) scroll_bit::$2 ← ! (bool~) scroll_bit::$1
  if((bool~) scroll_bit::$2) goto scroll_bit::@1
  to:scroll_bit::@2
scroll_bit::@1: scope:[scroll_bit]  from scroll_bit scroll_bit::@8
  (byte*) nxt#37 ← phi( scroll_bit/(byte*) nxt#29 scroll_bit::@8/(byte*) nxt#4 )
  (byte) current_bit#26 ← phi( scroll_bit/(byte) current_bit#5 scroll_bit::@8/(byte) current_bit#6 )
  (byte*) current_chargen#24 ← phi( scroll_bit/(byte*) current_chargen#28 scroll_bit::@8/(byte*) current_chargen#5 )
  call scroll_hard 
  to:scroll_bit::@7
scroll_bit::@7: scope:[scroll_bit]  from scroll_bit::@1
  (byte*) nxt#35 ← phi( scroll_bit::@1/(byte*) nxt#37 )
  (byte) current_bit#21 ← phi( scroll_bit::@1/(byte) current_bit#26 )
  (byte*) current_chargen#19 ← phi( scroll_bit::@1/(byte*) current_chargen#24 )
  asm { sei  }
  *((byte*) PROCPORT) ← (number) $32
  (byte*~) scroll_bit::$4 ← (byte*) SCREEN + (number) $28
  (byte*~) scroll_bit::$5 ← (byte*~) scroll_bit::$4 + (number) $27
  (byte*) scroll_bit::sc#0 ← (byte*~) scroll_bit::$5
  (byte) scroll_bit::r#0 ← (byte) 0
  to:scroll_bit::@3
scroll_bit::@2: scope:[scroll_bit]  from scroll_bit
  (byte*) nxt#24 ← phi( scroll_bit/(byte*) nxt#29 )
  call next_char 
  (byte) next_char::return#0 ← (byte) next_char::return#2
  to:scroll_bit::@8
scroll_bit::@8: scope:[scroll_bit]  from scroll_bit::@2
  (byte*) nxt#15 ← phi( scroll_bit::@2/(byte*) nxt#9 )
  (byte) next_char::return#3 ← phi( scroll_bit::@2/(byte) next_char::return#0 )
  (byte~) scroll_bit::$6 ← (byte) next_char::return#3
  (byte*) nxt#4 ← (byte*) nxt#15
  (word) scroll_bit::c#0 ← (byte~) scroll_bit::$6
  (number~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (number) 8
  (byte*~) scroll_bit::$8 ← (byte*) CHARGEN + (number~) scroll_bit::$7
  (byte*) current_chargen#5 ← (byte*~) scroll_bit::$8
  (byte) current_bit#6 ← (number) $80
  to:scroll_bit::@1
scroll_bit::@3: scope:[scroll_bit]  from scroll_bit::@4 scroll_bit::@7
  (byte*) nxt#32 ← phi( scroll_bit::@4/(byte*) nxt#30 scroll_bit::@7/(byte*) nxt#35 )
  (byte*) scroll_bit::sc#3 ← phi( scroll_bit::@4/(byte*) scroll_bit::sc#1 scroll_bit::@7/(byte*) scroll_bit::sc#0 )
  (byte) current_bit#14 ← phi( scroll_bit::@4/(byte) current_bit#20 scroll_bit::@7/(byte) current_bit#21 )
  (byte) scroll_bit::r#2 ← phi( scroll_bit::@4/(byte) scroll_bit::r#1 scroll_bit::@7/(byte) scroll_bit::r#0 )
  (byte*) current_chargen#12 ← phi( scroll_bit::@4/(byte*) current_chargen#18 scroll_bit::@7/(byte*) current_chargen#19 )
  (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#12 + (byte) scroll_bit::r#2)
  (byte) scroll_bit::b#0 ← (byte) ' '
  (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#14
  (bool~) scroll_bit::$10 ← (byte~) scroll_bit::$9 != (number) 0
  (bool~) scroll_bit::$11 ← ! (bool~) scroll_bit::$10
  if((bool~) scroll_bit::$11) goto scroll_bit::@4
  to:scroll_bit::@5
scroll_bit::@4: scope:[scroll_bit]  from scroll_bit::@3 scroll_bit::@5
  (byte*) nxt#30 ← phi( scroll_bit::@3/(byte*) nxt#32 scroll_bit::@5/(byte*) nxt#33 )
  (byte) current_bit#20 ← phi( scroll_bit::@3/(byte) current_bit#14 scroll_bit::@5/(byte) current_bit#27 )
  (byte*) current_chargen#18 ← phi( scroll_bit::@3/(byte*) current_chargen#12 scroll_bit::@5/(byte*) current_chargen#25 )
  (byte) scroll_bit::r#3 ← phi( scroll_bit::@3/(byte) scroll_bit::r#2 scroll_bit::@5/(byte) scroll_bit::r#4 )
  (byte*) scroll_bit::sc#2 ← phi( scroll_bit::@3/(byte*) scroll_bit::sc#3 scroll_bit::@5/(byte*) scroll_bit::sc#4 )
  (byte) scroll_bit::b#2 ← phi( scroll_bit::@3/(byte) scroll_bit::b#0 scroll_bit::@5/(byte) scroll_bit::b#1 )
  *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2
  (byte*~) scroll_bit::$12 ← (byte*) scroll_bit::sc#2 + (number) $28
  (byte*) scroll_bit::sc#1 ← (byte*~) scroll_bit::$12
  (byte) scroll_bit::r#1 ← (byte) scroll_bit::r#3 + rangenext(0,7)
  (bool~) scroll_bit::$13 ← (byte) scroll_bit::r#1 != rangelast(0,7)
  if((bool~) scroll_bit::$13) goto scroll_bit::@3
  to:scroll_bit::@6
scroll_bit::@5: scope:[scroll_bit]  from scroll_bit::@3
  (byte*) nxt#33 ← phi( scroll_bit::@3/(byte*) nxt#32 )
  (byte) current_bit#27 ← phi( scroll_bit::@3/(byte) current_bit#14 )
  (byte*) current_chargen#25 ← phi( scroll_bit::@3/(byte*) current_chargen#12 )
  (byte) scroll_bit::r#4 ← phi( scroll_bit::@3/(byte) scroll_bit::r#2 )
  (byte*) scroll_bit::sc#4 ← phi( scroll_bit::@3/(byte*) scroll_bit::sc#3 )
  (byte) scroll_bit::b#1 ← (number) $80+(byte) ' '
  to:scroll_bit::@4
scroll_bit::@6: scope:[scroll_bit]  from scroll_bit::@4
  (byte*) current_chargen#20 ← phi( scroll_bit::@4/(byte*) current_chargen#18 )
  (byte*) nxt#25 ← phi( scroll_bit::@4/(byte*) nxt#30 )
  (byte) current_bit#22 ← phi( scroll_bit::@4/(byte) current_bit#20 )
  *((byte*) PROCPORT) ← (number) $37
  asm { cli  }
  to:scroll_bit::@return
scroll_bit::@return: scope:[scroll_bit]  from scroll_bit::@6
  (byte*) current_chargen#13 ← phi( scroll_bit::@6/(byte*) current_chargen#20 )
  (byte*) nxt#16 ← phi( scroll_bit::@6/(byte*) nxt#25 )
  (byte) current_bit#15 ← phi( scroll_bit::@6/(byte) current_bit#22 )
  (byte) current_bit#7 ← (byte) current_bit#15
  (byte*) nxt#5 ← (byte*) nxt#16
  (byte*) current_chargen#6 ← (byte*) current_chargen#13
  return 
  to:@return
@3: scope:[]  from @2
  (byte*) current_chargen#26 ← phi( @2/(byte*) current_chargen#4 )
  (byte) current_bit#28 ← phi( @2/(byte) current_bit#4 )
  (byte) scroll#17 ← phi( @2/(byte) scroll#19 )
  (byte*) nxt#6 ← (byte*) TEXT
  to:@6

(byte()) next_char()
next_char: scope:[next_char]  from scroll_bit::@2
  (byte*) nxt#17 ← phi( scroll_bit::@2/(byte*) nxt#24 )
  (byte) next_char::c#0 ← *((byte*) nxt#17)
  (bool~) next_char::$0 ← (byte) next_char::c#0 == (number) 0
  (bool~) next_char::$1 ← ! (bool~) next_char::$0
  if((bool~) next_char::$1) goto next_char::@1
  to:next_char::@2
next_char::@1: scope:[next_char]  from next_char next_char::@2
  (byte) next_char::c#2 ← phi( next_char/(byte) next_char::c#0 next_char::@2/(byte) next_char::c#1 )
  (byte*) nxt#18 ← phi( next_char/(byte*) nxt#17 next_char::@2/(byte*) nxt#8 )
  (byte*) nxt#7 ← ++ (byte*) nxt#18
  (byte) next_char::return#1 ← (byte) next_char::c#2
  to:next_char::@return
next_char::@2: scope:[next_char]  from next_char
  (byte*) nxt#8 ← (byte*) TEXT
  (byte) next_char::c#1 ← *((byte*) nxt#8)
  to:next_char::@1
next_char::@return: scope:[next_char]  from next_char::@1
  (byte*) nxt#19 ← phi( next_char::@1/(byte*) nxt#7 )
  (byte) next_char::return#4 ← phi( next_char::@1/(byte) next_char::return#1 )
  (byte) next_char::return#2 ← (byte) next_char::return#4
  (byte*) nxt#9 ← (byte*) nxt#19
  return 
  to:@return

(void()) scroll_hard()
scroll_hard: scope:[scroll_hard]  from scroll_bit::@1
  (byte) scroll_hard::i#0 ← (number) 0
  to:scroll_hard::@1
scroll_hard::@1: scope:[scroll_hard]  from scroll_hard scroll_hard::@2
  (byte) scroll_hard::i#2 ← phi( scroll_hard/(byte) scroll_hard::i#0 scroll_hard::@2/(byte) scroll_hard::i#1 )
  (bool~) scroll_hard::$0 ← (byte) scroll_hard::i#2 != (number) $27
  if((bool~) scroll_hard::$0) goto scroll_hard::@2
  to:scroll_hard::@return
scroll_hard::@2: scope:[scroll_hard]  from scroll_hard::@1
  (byte) scroll_hard::i#3 ← phi( scroll_hard::@1/(byte) scroll_hard::i#2 )
  (byte*~) scroll_hard::$1 ← (byte*) SCREEN + (number) $28*(number) 0
  (byte*~) scroll_hard::$2 ← (byte*) SCREEN + (number) $28*(number) 0
  (number~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$1 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$2 + (number~) scroll_hard::$3)
  (byte*~) scroll_hard::$4 ← (byte*) SCREEN + (number) $28*(number) 1
  (byte*~) scroll_hard::$5 ← (byte*) SCREEN + (number) $28*(number) 1
  (number~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$4 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$5 + (number~) scroll_hard::$6)
  (byte*~) scroll_hard::$7 ← (byte*) SCREEN + (number) $28*(number) 2
  (byte*~) scroll_hard::$8 ← (byte*) SCREEN + (number) $28*(number) 2
  (number~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$7 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$8 + (number~) scroll_hard::$9)
  (byte*~) scroll_hard::$10 ← (byte*) SCREEN + (number) $28*(number) 3
  (byte*~) scroll_hard::$11 ← (byte*) SCREEN + (number) $28*(number) 3
  (number~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$10 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$11 + (number~) scroll_hard::$12)
  (byte*~) scroll_hard::$13 ← (byte*) SCREEN + (number) $28*(number) 4
  (byte*~) scroll_hard::$14 ← (byte*) SCREEN + (number) $28*(number) 4
  (number~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$13 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$14 + (number~) scroll_hard::$15)
  (byte*~) scroll_hard::$16 ← (byte*) SCREEN + (number) $28*(number) 5
  (byte*~) scroll_hard::$17 ← (byte*) SCREEN + (number) $28*(number) 5
  (number~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$16 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$17 + (number~) scroll_hard::$18)
  (byte*~) scroll_hard::$19 ← (byte*) SCREEN + (number) $28*(number) 6
  (byte*~) scroll_hard::$20 ← (byte*) SCREEN + (number) $28*(number) 6
  (number~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$19 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$20 + (number~) scroll_hard::$21)
  (byte*~) scroll_hard::$22 ← (byte*) SCREEN + (number) $28*(number) 7
  (byte*~) scroll_hard::$23 ← (byte*) SCREEN + (number) $28*(number) 7
  (number~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$22 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$23 + (number~) scroll_hard::$24)
  (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#3
  to:scroll_hard::@1
scroll_hard::@return: scope:[scroll_hard]  from scroll_hard::@1
  return 
  to:@return

(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
fillscreen: scope:[fillscreen]  from main
  (byte) fillscreen::fill#3 ← phi( main/(byte) fillscreen::fill#0 )
  (byte*) fillscreen::screen#1 ← phi( main/(byte*) fillscreen::screen#0 )
  (byte*) fillscreen::cursor#0 ← (byte*) fillscreen::screen#1
  to:fillscreen::@1
fillscreen::@1: scope:[fillscreen]  from fillscreen fillscreen::@2
  (byte) fillscreen::fill#2 ← phi( fillscreen/(byte) fillscreen::fill#3 fillscreen::@2/(byte) fillscreen::fill#1 )
  (byte*) fillscreen::cursor#2 ← phi( fillscreen/(byte*) fillscreen::cursor#0 fillscreen::@2/(byte*) fillscreen::cursor#1 )
  (byte*) fillscreen::screen#2 ← phi( fillscreen/(byte*) fillscreen::screen#1 fillscreen::@2/(byte*) fillscreen::screen#3 )
  (byte*~) fillscreen::$0 ← (byte*) fillscreen::screen#2 + (number) $3e8
  (bool~) fillscreen::$1 ← (byte*) fillscreen::cursor#2 < (byte*~) fillscreen::$0
  if((bool~) fillscreen::$1) goto fillscreen::@2
  to:fillscreen::@return
fillscreen::@2: scope:[fillscreen]  from fillscreen::@1
  (byte*) fillscreen::screen#3 ← phi( fillscreen::@1/(byte*) fillscreen::screen#2 )
  (byte*) fillscreen::cursor#3 ← phi( fillscreen::@1/(byte*) fillscreen::cursor#2 )
  (byte) fillscreen::fill#1 ← phi( fillscreen::@1/(byte) fillscreen::fill#2 )
  *((byte*) fillscreen::cursor#3) ← (byte) fillscreen::fill#1
  (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#3
  to:fillscreen::@1
fillscreen::@return: scope:[fillscreen]  from fillscreen::@1
  return 
  to:@return
@6: scope:[]  from @3
  (byte*) current_chargen#21 ← phi( @3/(byte*) current_chargen#26 )
  (byte*) nxt#26 ← phi( @3/(byte*) nxt#6 )
  (byte) current_bit#23 ← phi( @3/(byte) current_bit#28 )
  (byte) scroll#15 ← phi( @3/(byte) scroll#17 )
  call main 
  to:@7
@7: scope:[]  from @6
  (byte*) current_chargen#14 ← phi( @6/(byte*) current_chargen#1 )
  (byte*) nxt#20 ← phi( @6/(byte*) nxt#1 )
  (byte) current_bit#16 ← phi( @6/(byte) current_bit#1 )
  (byte) scroll#12 ← phi( @6/(byte) scroll#1 )
  (byte) scroll#6 ← (byte) scroll#12
  (byte) current_bit#8 ← (byte) current_bit#16
  (byte*) nxt#10 ← (byte*) nxt#20
  (byte*) current_chargen#7 ← (byte*) current_chargen#14
  to:@end
@end: scope:[]  from @7

SYMBOL TABLE SSA
(const string) $0 = (string) "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
(label) @1
(label) @2
(label) @3
(label) @6
(label) @7
(label) @begin
(label) @end
(byte*) BGCOL
(byte*) CHARGEN
(byte*) PROCPORT
(byte*) RASTER
(byte*) SCREEN
(byte*) SCROLL
(byte*) TEXT
(byte) current_bit
(byte) current_bit#0
(byte) current_bit#1
(byte) current_bit#10
(byte) current_bit#11
(byte) current_bit#12
(byte) current_bit#13
(byte) current_bit#14
(byte) current_bit#15
(byte) current_bit#16
(byte) current_bit#17
(byte) current_bit#18
(byte) current_bit#19
(byte) current_bit#2
(byte) current_bit#20
(byte) current_bit#21
(byte) current_bit#22
(byte) current_bit#23
(byte) current_bit#24
(byte) current_bit#25
(byte) current_bit#26
(byte) current_bit#27
(byte) current_bit#28
(byte) current_bit#29
(byte) current_bit#3
(byte) current_bit#30
(byte) current_bit#31
(byte) current_bit#4
(byte) current_bit#5
(byte) current_bit#6
(byte) current_bit#7
(byte) current_bit#8
(byte) current_bit#9
(byte*) current_chargen
(byte*) current_chargen#0
(byte*) current_chargen#1
(byte*) current_chargen#10
(byte*) current_chargen#11
(byte*) current_chargen#12
(byte*) current_chargen#13
(byte*) current_chargen#14
(byte*) current_chargen#15
(byte*) current_chargen#16
(byte*) current_chargen#17
(byte*) current_chargen#18
(byte*) current_chargen#19
(byte*) current_chargen#2
(byte*) current_chargen#20
(byte*) current_chargen#21
(byte*) current_chargen#22
(byte*) current_chargen#23
(byte*) current_chargen#24
(byte*) current_chargen#25
(byte*) current_chargen#26
(byte*) current_chargen#27
(byte*) current_chargen#28
(byte*) current_chargen#29
(byte*) current_chargen#3
(byte*) current_chargen#30
(byte*) current_chargen#4
(byte*) current_chargen#5
(byte*) current_chargen#6
(byte*) current_chargen#7
(byte*) current_chargen#8
(byte*) current_chargen#9
(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
(byte*~) fillscreen::$0
(bool~) fillscreen::$1
(label) fillscreen::@1
(label) fillscreen::@2
(label) fillscreen::@return
(byte*) fillscreen::cursor
(byte*) fillscreen::cursor#0
(byte*) fillscreen::cursor#1
(byte*) fillscreen::cursor#2
(byte*) fillscreen::cursor#3
(byte) fillscreen::fill
(byte) fillscreen::fill#0
(byte) fillscreen::fill#1
(byte) fillscreen::fill#2
(byte) fillscreen::fill#3
(byte*) fillscreen::screen
(byte*) fillscreen::screen#0
(byte*) fillscreen::screen#1
(byte*) fillscreen::screen#2
(byte*) fillscreen::screen#3
(void()) main()
(bool~) main::$1
(bool~) main::$2
(label) main::@2
(label) main::@4
(label) main::@5
(label) main::@7
(label) main::@8
(label) main::@return
(byte()) next_char()
(bool~) next_char::$0
(bool~) next_char::$1
(label) next_char::@1
(label) next_char::@2
(label) next_char::@return
(byte) next_char::c
(byte) next_char::c#0
(byte) next_char::c#1
(byte) next_char::c#2
(byte) next_char::return
(byte) next_char::return#0
(byte) next_char::return#1
(byte) next_char::return#2
(byte) next_char::return#3
(byte) next_char::return#4
(byte*) nxt
(byte*) nxt#0
(byte*) nxt#1
(byte*) nxt#10
(byte*) nxt#11
(byte*) nxt#12
(byte*) nxt#13
(byte*) nxt#14
(byte*) nxt#15
(byte*) nxt#16
(byte*) nxt#17
(byte*) nxt#18
(byte*) nxt#19
(byte*) nxt#2
(byte*) nxt#20
(byte*) nxt#21
(byte*) nxt#22
(byte*) nxt#23
(byte*) nxt#24
(byte*) nxt#25
(byte*) nxt#26
(byte*) nxt#27
(byte*) nxt#28
(byte*) nxt#29
(byte*) nxt#3
(byte*) nxt#30
(byte*) nxt#31
(byte*) nxt#32
(byte*) nxt#33
(byte*) nxt#34
(byte*) nxt#35
(byte*) nxt#36
(byte*) nxt#37
(byte*) nxt#4
(byte*) nxt#5
(byte*) nxt#6
(byte*) nxt#7
(byte*) nxt#8
(byte*) nxt#9
(byte) scroll
(byte) scroll#0
(byte) scroll#1
(byte) scroll#10
(byte) scroll#11
(byte) scroll#12
(byte) scroll#13
(byte) scroll#14
(byte) scroll#15
(byte) scroll#16
(byte) scroll#17
(byte) scroll#18
(byte) scroll#19
(byte) scroll#2
(byte) scroll#20
(byte) scroll#21
(byte) scroll#3
(byte) scroll#4
(byte) scroll#5
(byte) scroll#6
(byte) scroll#7
(byte) scroll#8
(byte) scroll#9
(void()) scroll_bit()
(number~) scroll_bit::$0
(bool~) scroll_bit::$1
(bool~) scroll_bit::$10
(bool~) scroll_bit::$11
(byte*~) scroll_bit::$12
(bool~) scroll_bit::$13
(bool~) scroll_bit::$2
(byte*~) scroll_bit::$4
(byte*~) scroll_bit::$5
(byte~) scroll_bit::$6
(number~) scroll_bit::$7
(byte*~) scroll_bit::$8
(byte~) scroll_bit::$9
(label) scroll_bit::@1
(label) scroll_bit::@2
(label) scroll_bit::@3
(label) scroll_bit::@4
(label) scroll_bit::@5
(label) scroll_bit::@6
(label) scroll_bit::@7
(label) scroll_bit::@8
(label) scroll_bit::@return
(byte) scroll_bit::b
(byte) scroll_bit::b#0
(byte) scroll_bit::b#1
(byte) scroll_bit::b#2
(byte) scroll_bit::bits
(byte) scroll_bit::bits#0
(word) scroll_bit::c
(word) scroll_bit::c#0
(byte) scroll_bit::r
(byte) scroll_bit::r#0
(byte) scroll_bit::r#1
(byte) scroll_bit::r#2
(byte) scroll_bit::r#3
(byte) scroll_bit::r#4
(byte*) scroll_bit::sc
(byte*) scroll_bit::sc#0
(byte*) scroll_bit::sc#1
(byte*) scroll_bit::sc#2
(byte*) scroll_bit::sc#3
(byte*) scroll_bit::sc#4
(void()) scroll_hard()
(bool~) scroll_hard::$0
(byte*~) scroll_hard::$1
(byte*~) scroll_hard::$10
(byte*~) scroll_hard::$11
(number~) scroll_hard::$12
(byte*~) scroll_hard::$13
(byte*~) scroll_hard::$14
(number~) scroll_hard::$15
(byte*~) scroll_hard::$16
(byte*~) scroll_hard::$17
(number~) scroll_hard::$18
(byte*~) scroll_hard::$19
(byte*~) scroll_hard::$2
(byte*~) scroll_hard::$20
(number~) scroll_hard::$21
(byte*~) scroll_hard::$22
(byte*~) scroll_hard::$23
(number~) scroll_hard::$24
(number~) scroll_hard::$3
(byte*~) scroll_hard::$4
(byte*~) scroll_hard::$5
(number~) scroll_hard::$6
(byte*~) scroll_hard::$7
(byte*~) scroll_hard::$8
(number~) scroll_hard::$9
(label) scroll_hard::@1
(label) scroll_hard::@2
(label) scroll_hard::@return
(byte) scroll_hard::i
(byte) scroll_hard::i#0
(byte) scroll_hard::i#1
(byte) scroll_hard::i#2
(byte) scroll_hard::i#3
(void()) scroll_soft()
(bool~) scroll_soft::$0
(bool~) scroll_soft::$1
(label) scroll_soft::@1
(label) scroll_soft::@2
(label) scroll_soft::@3
(label) scroll_soft::@return

Adding number conversion cast (unumber) $20 in (byte) fillscreen::fill#0 ← (number) $20
Adding number conversion cast (unumber) $fe in (bool~) main::$1 ← *((byte*) RASTER) != (number) $fe
Adding number conversion cast (unumber) $ff in (bool~) main::$2 ← *((byte*) RASTER) != (number) $ff
Adding number conversion cast (unumber) 7 in (byte) scroll#2 ← (number) 7
Adding number conversion cast (unumber) $ff in (bool~) scroll_soft::$0 ← (byte) scroll#3 == (number) $ff
Adding number conversion cast (unumber) 7 in (byte) scroll#4 ← (number) 7
Adding number conversion cast (unumber) 1 in (byte) current_bit#4 ← (number) 1
Adding number conversion cast (unumber) 2 in (number~) scroll_bit::$0 ← (byte) current_bit#13 / (number) 2
Adding number conversion cast (unumber) scroll_bit::$0 in (number~) scroll_bit::$0 ← (byte) current_bit#13 / (unumber)(number) 2
Adding number conversion cast (unumber) 0 in (bool~) scroll_bit::$1 ← (byte) current_bit#5 == (number) 0
Adding number conversion cast (unumber) $32 in *((byte*) PROCPORT) ← (number) $32
Adding number conversion cast (unumber) $28 in (byte*~) scroll_bit::$4 ← (byte*) SCREEN + (number) $28
Adding number conversion cast (unumber) $27 in (byte*~) scroll_bit::$5 ← (byte*~) scroll_bit::$4 + (number) $27
Adding number conversion cast (unumber) 8 in (number~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (number) 8
Adding number conversion cast (unumber) scroll_bit::$7 in (number~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (unumber)(number) 8
Adding number conversion cast (unumber) $80 in (byte) current_bit#6 ← (number) $80
Adding number conversion cast (unumber) 0 in (bool~) scroll_bit::$10 ← (byte~) scroll_bit::$9 != (number) 0
Adding number conversion cast (unumber) $28 in (byte*~) scroll_bit::$12 ← (byte*) scroll_bit::sc#2 + (number) $28
Adding number conversion cast (unumber) $80+' ' in (byte) scroll_bit::b#1 ← (number) $80+(byte) ' '
Adding number conversion cast (unumber) $80 in (byte) scroll_bit::b#1 ← ((unumber)) (number) $80+(byte) ' '
Adding number conversion cast (unumber) $37 in *((byte*) PROCPORT) ← (number) $37
Adding number conversion cast (unumber) 0 in (bool~) next_char::$0 ← (byte) next_char::c#0 == (number) 0
Adding number conversion cast (unumber) 0 in (byte) scroll_hard::i#0 ← (number) 0
Adding number conversion cast (unumber) $27 in (bool~) scroll_hard::$0 ← (byte) scroll_hard::i#2 != (number) $27
Adding number conversion cast (unumber) $28*0 in (byte*~) scroll_hard::$1 ← (byte*) SCREEN + (number) $28*(number) 0
Adding number conversion cast (unumber) $28*0 in (byte*~) scroll_hard::$2 ← (byte*) SCREEN + (number) $28*(number) 0
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$3 in (number~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*1 in (byte*~) scroll_hard::$4 ← (byte*) SCREEN + (number) $28*(number) 1
Adding number conversion cast (unumber) $28*1 in (byte*~) scroll_hard::$5 ← (byte*) SCREEN + (number) $28*(number) 1
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$6 in (number~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*2 in (byte*~) scroll_hard::$7 ← (byte*) SCREEN + (number) $28*(number) 2
Adding number conversion cast (unumber) $28*2 in (byte*~) scroll_hard::$8 ← (byte*) SCREEN + (number) $28*(number) 2
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$9 in (number~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*3 in (byte*~) scroll_hard::$10 ← (byte*) SCREEN + (number) $28*(number) 3
Adding number conversion cast (unumber) $28*3 in (byte*~) scroll_hard::$11 ← (byte*) SCREEN + (number) $28*(number) 3
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$12 in (number~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*4 in (byte*~) scroll_hard::$13 ← (byte*) SCREEN + (number) $28*(number) 4
Adding number conversion cast (unumber) $28*4 in (byte*~) scroll_hard::$14 ← (byte*) SCREEN + (number) $28*(number) 4
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$15 in (number~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*5 in (byte*~) scroll_hard::$16 ← (byte*) SCREEN + (number) $28*(number) 5
Adding number conversion cast (unumber) $28*5 in (byte*~) scroll_hard::$17 ← (byte*) SCREEN + (number) $28*(number) 5
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$18 in (number~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*6 in (byte*~) scroll_hard::$19 ← (byte*) SCREEN + (number) $28*(number) 6
Adding number conversion cast (unumber) $28*6 in (byte*~) scroll_hard::$20 ← (byte*) SCREEN + (number) $28*(number) 6
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$21 in (number~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*7 in (byte*~) scroll_hard::$22 ← (byte*) SCREEN + (number) $28*(number) 7
Adding number conversion cast (unumber) $28*7 in (byte*~) scroll_hard::$23 ← (byte*) SCREEN + (number) $28*(number) 7
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$24 in (number~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $3e8 in (byte*~) fillscreen::$0 ← (byte*) fillscreen::screen#2 + (number) $3e8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) PROCPORT ← (byte*)(number) 1
Inlining cast (byte*) CHARGEN ← (byte*)(number) $d000
Inlining cast (byte*) SCREEN ← (byte*)(number) $400
Inlining cast (byte*) RASTER ← (byte*)(number) $d012
Inlining cast (byte*) BGCOL ← (byte*)(number) $d020
Inlining cast (byte*) SCROLL ← (byte*)(number) $d016
Inlining cast (byte) fillscreen::fill#0 ← (unumber)(number) $20
Inlining cast (byte) scroll#2 ← (unumber)(number) 7
Inlining cast (byte) scroll#4 ← (unumber)(number) 7
Inlining cast (byte) current_bit#4 ← (unumber)(number) 1
Inlining cast *((byte*) PROCPORT) ← (unumber)(number) $32
Inlining cast (byte) current_bit#6 ← (unumber)(number) $80
Inlining cast (byte) scroll_bit::b#1 ← (unumber)(unumber)(number) $80+(byte) ' '
Inlining cast *((byte*) PROCPORT) ← (unumber)(number) $37
Inlining cast (byte) scroll_hard::i#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53270
Simplifying constant integer cast $20
Simplifying constant integer cast $fe
Simplifying constant integer cast $ff
Simplifying constant integer cast 7
Simplifying constant integer cast $ff
Simplifying constant integer cast 7
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast $32
Simplifying constant integer cast $28
Simplifying constant integer cast $27
Simplifying constant integer cast 8
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast (unumber)(number) $80+(byte) ' '
Simplifying constant integer cast $80
Simplifying constant integer cast $37
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $27
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $3e8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) $fe
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) $37
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3e8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) scroll_bit::$0 ← (byte) current_bit#13 / (byte) 2
Inferred type updated to word in (unumber~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (byte) 8
Inferred type updated to byte in (unumber~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (byte) 1
Inversing boolean not [38] (bool~) scroll_soft::$1 ← (byte) scroll#3 != (byte) $ff from [37] (bool~) scroll_soft::$0 ← (byte) scroll#3 == (byte) $ff
Inversing boolean not [62] (bool~) scroll_bit::$2 ← (byte) current_bit#5 != (byte) 0 from [61] (bool~) scroll_bit::$1 ← (byte) current_bit#5 == (byte) 0
Inversing boolean not [89] (bool~) scroll_bit::$11 ← (byte~) scroll_bit::$9 == (byte) 0 from [88] (bool~) scroll_bit::$10 ← (byte~) scroll_bit::$9 != (byte) 0
Inversing boolean not [113] (bool~) next_char::$1 ← (byte) next_char::c#0 != (byte) 0 from [112] (bool~) next_char::$0 ← (byte) next_char::c#0 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte) scroll#20 = (byte) scroll#21 
Alias (byte) current_bit#30 = (byte) current_bit#31 
Alias (byte*) nxt#34 = (byte*) nxt#36 
Alias (byte*) current_chargen#29 = (byte*) current_chargen#30 
Alias (byte) scroll#13 = (byte) scroll#16 
Alias (byte) current_bit#17 = (byte) current_bit#24 
Alias (byte*) nxt#21 = (byte*) nxt#27 
Alias (byte*) current_chargen#15 = (byte*) current_chargen#22 
Alias (byte) scroll#0 = (byte) scroll#7 (byte) scroll#8 (byte) scroll#1 
Alias (byte) current_bit#0 = (byte) current_bit#9 (byte) current_bit#10 (byte) current_bit#1 
Alias (byte*) nxt#0 = (byte*) nxt#11 (byte*) nxt#12 (byte*) nxt#1 
Alias (byte*) current_chargen#0 = (byte*) current_chargen#8 (byte*) current_chargen#9 (byte*) current_chargen#1 
Alias (byte) current_bit#18 = (byte) current_bit#25 
Alias (byte*) nxt#22 = (byte*) nxt#28 
Alias (byte*) current_chargen#16 = (byte*) current_chargen#23 
Alias (byte) scroll#14 = (byte) scroll#4 
Alias (byte) current_bit#11 = (byte) current_bit#2 
Alias (byte*) nxt#13 = (byte*) nxt#2 
Alias (byte*) current_chargen#10 = (byte*) current_chargen#2 
Alias (byte) scroll#10 = (byte) scroll#11 (byte) scroll#5 
Alias (byte) current_bit#12 = (byte) current_bit#19 (byte) current_bit#3 
Alias (byte*) nxt#14 = (byte*) nxt#23 (byte*) nxt#3 
Alias (byte*) current_chargen#11 = (byte*) current_chargen#17 (byte*) current_chargen#3 
Alias (byte) scroll#15 = (byte) scroll#19 (byte) scroll#2 (byte) scroll#17 
Alias (byte*) CHARGEN = (byte*) current_chargen#4 (byte*) current_chargen#26 (byte*) current_chargen#21 
Alias (byte) current_bit#5 = (byte~) scroll_bit::$0 
Alias (byte*) current_chargen#19 = (byte*) current_chargen#24 
Alias (byte) current_bit#21 = (byte) current_bit#26 
Alias (byte*) nxt#35 = (byte*) nxt#37 
Alias (byte*) scroll_bit::sc#0 = (byte*~) scroll_bit::$5 
Alias (byte*) nxt#24 = (byte*) nxt#29 
Alias (byte) next_char::return#0 = (byte) next_char::return#3 
Alias (byte*) nxt#15 = (byte*) nxt#4 
Alias (word) scroll_bit::c#0 = (byte~) scroll_bit::$6 
Alias (byte*) current_chargen#5 = (byte*~) scroll_bit::$8 
Alias (byte*) scroll_bit::sc#1 = (byte*~) scroll_bit::$12 
Alias (byte*) scroll_bit::sc#3 = (byte*) scroll_bit::sc#4 
Alias (byte) scroll_bit::r#2 = (byte) scroll_bit::r#4 
Alias (byte*) current_chargen#12 = (byte*) current_chargen#25 
Alias (byte) current_bit#14 = (byte) current_bit#27 
Alias (byte*) nxt#32 = (byte*) nxt#33 
Alias (byte) current_bit#15 = (byte) current_bit#22 (byte) current_bit#20 (byte) current_bit#7 
Alias (byte*) nxt#16 = (byte*) nxt#25 (byte*) nxt#30 (byte*) nxt#5 
Alias (byte*) current_chargen#13 = (byte*) current_chargen#20 (byte*) current_chargen#18 (byte*) current_chargen#6 
Alias (byte) current_bit#23 = (byte) current_bit#28 (byte) current_bit#4 
Alias (byte*) TEXT = (byte*) nxt#6 (byte*) nxt#26 
Alias (byte) next_char::return#1 = (byte) next_char::c#2 (byte) next_char::return#4 (byte) next_char::return#2 
Alias (byte*) nxt#19 = (byte*) nxt#7 (byte*) nxt#9 
Alias (byte) scroll_hard::i#2 = (byte) scroll_hard::i#3 
Alias (byte*) fillscreen::cursor#0 = (byte*) fillscreen::screen#1 
Alias (byte) fillscreen::fill#1 = (byte) fillscreen::fill#2 
Alias (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#3 
Alias (byte*) fillscreen::screen#2 = (byte*) fillscreen::screen#3 
Alias (byte) scroll#12 = (byte) scroll#6 
Alias (byte) current_bit#16 = (byte) current_bit#8 
Alias (byte*) nxt#10 = (byte*) nxt#20 
Alias (byte*) current_chargen#14 = (byte*) current_chargen#7 
Successful SSA optimization Pass2AliasElimination
Alias (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#3 
Alias (byte) scroll_bit::r#2 = (byte) scroll_bit::r#3 
Alias (byte*) current_chargen#12 = (byte*) current_chargen#13 
Alias (byte) current_bit#14 = (byte) current_bit#15 
Alias (byte*) nxt#16 = (byte*) nxt#32 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) scroll#20 (byte) scroll#15
Identical Phi Values (byte) current_bit#30 (byte) current_bit#23
Identical Phi Values (byte*) nxt#34 (byte*) TEXT
Identical Phi Values (byte*) current_chargen#29 (byte*) CHARGEN
Identical Phi Values (byte) scroll#13 (byte) scroll#18
Identical Phi Values (byte) current_bit#17 (byte) current_bit#29
Identical Phi Values (byte*) nxt#21 (byte*) nxt#31
Identical Phi Values (byte*) current_chargen#15 (byte*) current_chargen#27
Identical Phi Values (byte) scroll#0 (byte) scroll#10
Identical Phi Values (byte) current_bit#0 (byte) current_bit#12
Identical Phi Values (byte*) nxt#0 (byte*) nxt#14
Identical Phi Values (byte*) current_chargen#0 (byte*) current_chargen#11
Identical Phi Values (byte) scroll#9 (byte) scroll#13
Identical Phi Values (byte) current_bit#18 (byte) current_bit#17
Identical Phi Values (byte*) nxt#22 (byte*) nxt#21
Identical Phi Values (byte*) current_chargen#16 (byte*) current_chargen#15
Identical Phi Values (byte) current_bit#11 (byte) current_bit#14
Identical Phi Values (byte*) nxt#13 (byte*) nxt#16
Identical Phi Values (byte*) current_chargen#10 (byte*) current_chargen#12
Identical Phi Values (byte) current_bit#13 (byte) current_bit#18
Identical Phi Values (byte*) nxt#24 (byte*) nxt#22
Identical Phi Values (byte*) current_chargen#28 (byte*) current_chargen#16
Identical Phi Values (byte*) nxt#15 (byte*) nxt#19
Identical Phi Values (byte*) current_chargen#12 (byte*) current_chargen#19
Identical Phi Values (byte) current_bit#14 (byte) current_bit#21
Identical Phi Values (byte*) nxt#16 (byte*) nxt#35
Identical Phi Values (byte*) nxt#17 (byte*) nxt#24
Identical Phi Values (byte*) fillscreen::cursor#0 (byte*) fillscreen::screen#0
Identical Phi Values (byte) fillscreen::fill#3 (byte) fillscreen::fill#0
Identical Phi Values (byte*) fillscreen::screen#2 (byte*) fillscreen::cursor#0
Identical Phi Values (byte) fillscreen::fill#1 (byte) fillscreen::fill#3
Identical Phi Values (byte) scroll#12 (byte) scroll#0
Identical Phi Values (byte) current_bit#16 (byte) current_bit#0
Identical Phi Values (byte*) nxt#10 (byte*) nxt#0
Identical Phi Values (byte*) current_chargen#14 (byte*) current_chargen#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [14] if(*((byte*) RASTER)!=(byte) $fe) goto main::@2
Simple Condition (bool~) main::$2 [17] if(*((byte*) RASTER)!=(byte) $ff) goto main::@4
Simple Condition (bool~) scroll_soft::$1 [39] if((byte) scroll#3!=(byte) $ff) goto scroll_soft::@1
Simple Condition (bool~) scroll_bit::$2 [63] if((byte) current_bit#5!=(byte) 0) goto scroll_bit::@1
Simple Condition (bool~) scroll_bit::$11 [90] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4
Simple Condition (bool~) scroll_bit::$13 [97] if((byte) scroll_bit::r#1!=rangelast(0,7)) goto scroll_bit::@3
Simple Condition (bool~) next_char::$1 [114] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1
Simple Condition (bool~) scroll_hard::$0 [127] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2
Simple Condition (bool~) fillscreen::$1 [168] if((byte*) fillscreen::cursor#2<(byte*~) fillscreen::$0) goto fillscreen::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) PROCPORT = (byte*) 1
Constant (const byte*) CHARGEN = (byte*) 53248
Constant (const byte*) SCREEN = (byte*) 1024
Constant (const byte*) RASTER = (byte*) 53266
Constant (const byte*) BGCOL = (byte*) 53280
Constant (const byte*) SCROLL = (byte*) 53270
Constant (const byte*) TEXT = $0
Constant (const byte) fillscreen::fill#0 = $20
Constant (const byte) scroll#15 = 7
Constant (const byte) scroll#14 = 7
Constant (const byte) current_bit#23 = 1
Constant (const byte) scroll_bit::r#0 = 0
Constant (const byte) current_bit#6 = $80
Constant (const byte) scroll_bit::b#0 = ' '
Constant (const byte) scroll_bit::b#1 = $80+' '
Constant (const byte) scroll_hard::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) fillscreen::screen#0 = SCREEN
Constant (const byte*) nxt#8 = TEXT
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [27] if(true) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [95] scroll_bit::r#1 ← ++ scroll_bit::r#2 to ++
Resolved ranged comparison value [97] if(scroll_bit::r#1!=rangelast(0,7)) goto scroll_bit::@3 to (number) 8
Simplifying constant evaluating to zero (byte)(number) $28*(number) 0 in [129] (byte*~) scroll_hard::$1 ← (const byte*) SCREEN + (byte)(number) $28*(number) 0
Simplifying constant evaluating to zero (byte)(number) $28*(number) 0 in [130] (byte*~) scroll_hard::$2 ← (const byte*) SCREEN + (byte)(number) $28*(number) 0
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero SCREEN in [129] (byte*~) scroll_hard::$1 ← (const byte*) SCREEN + (byte) 0
Simplifying expression containing zero SCREEN in [130] (byte*~) scroll_hard::$2 ← (const byte*) SCREEN + (byte) 0
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) scroll_bit::r#1!=(number) 8) goto scroll_bit::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [19] (byte*~) scroll_bit::$4 ← (const byte*) SCREEN + (byte) $28
Constant right-side identified [50] (byte*~) scroll_hard::$4 ← (const byte*) SCREEN + (byte)(number) $28*(number) 1
Constant right-side identified [51] (byte*~) scroll_hard::$5 ← (const byte*) SCREEN + (byte)(number) $28*(number) 1
Constant right-side identified [54] (byte*~) scroll_hard::$7 ← (const byte*) SCREEN + (byte)(number) $28*(number) 2
Constant right-side identified [55] (byte*~) scroll_hard::$8 ← (const byte*) SCREEN + (byte)(number) $28*(number) 2
Constant right-side identified [58] (byte*~) scroll_hard::$10 ← (const byte*) SCREEN + (byte)(number) $28*(number) 3
Constant right-side identified [59] (byte*~) scroll_hard::$11 ← (const byte*) SCREEN + (byte)(number) $28*(number) 3
Constant right-side identified [62] (byte*~) scroll_hard::$13 ← (const byte*) SCREEN + (byte)(number) $28*(number) 4
Constant right-side identified [63] (byte*~) scroll_hard::$14 ← (const byte*) SCREEN + (byte)(number) $28*(number) 4
Constant right-side identified [66] (byte*~) scroll_hard::$16 ← (const byte*) SCREEN + (byte)(number) $28*(number) 5
Constant right-side identified [67] (byte*~) scroll_hard::$17 ← (const byte*) SCREEN + (byte)(number) $28*(number) 5
Constant right-side identified [70] (byte*~) scroll_hard::$19 ← (const byte*) SCREEN + (byte)(number) $28*(number) 6
Constant right-side identified [71] (byte*~) scroll_hard::$20 ← (const byte*) SCREEN + (byte)(number) $28*(number) 6
Constant right-side identified [74] (byte*~) scroll_hard::$22 ← (const byte*) SCREEN + (word)(number) $28*(number) 7
Constant right-side identified [75] (byte*~) scroll_hard::$23 ← (const byte*) SCREEN + (word)(number) $28*(number) 7
Constant right-side identified [81] (byte*~) fillscreen::$0 ← (const byte*) fillscreen::screen#0 + (word) $3e8
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) scroll_bit::$4 = SCREEN+$28
Constant (const byte*) scroll_hard::$1 = SCREEN
Constant (const byte*) scroll_hard::$2 = SCREEN
Constant (const byte*) scroll_hard::$4 = SCREEN+(byte)$28*1
Constant (const byte*) scroll_hard::$5 = SCREEN+(byte)$28*1
Constant (const byte*) scroll_hard::$7 = SCREEN+(byte)$28*2
Constant (const byte*) scroll_hard::$8 = SCREEN+(byte)$28*2
Constant (const byte*) scroll_hard::$10 = SCREEN+(byte)$28*3
Constant (const byte*) scroll_hard::$11 = SCREEN+(byte)$28*3
Constant (const byte*) scroll_hard::$13 = SCREEN+(byte)$28*4
Constant (const byte*) scroll_hard::$14 = SCREEN+(byte)$28*4
Constant (const byte*) scroll_hard::$16 = SCREEN+(byte)$28*5
Constant (const byte*) scroll_hard::$17 = SCREEN+(byte)$28*5
Constant (const byte*) scroll_hard::$19 = SCREEN+(byte)$28*6
Constant (const byte*) scroll_hard::$20 = SCREEN+(byte)$28*6
Constant (const byte*) scroll_hard::$22 = SCREEN+(word)$28*7
Constant (const byte*) scroll_hard::$23 = SCREEN+(word)$28*7
Constant (const byte*) fillscreen::$0 = fillscreen::screen#0+$3e8
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [19] (byte*) scroll_bit::sc#0 ← (const byte*) scroll_bit::$4 + (byte) $27
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) scroll_bit::sc#0 = scroll_bit::$4+$27
Successful SSA optimization Pass2ConstantIdentification
Rewriting division to use shift [13] (byte) current_bit#5 ← (byte) current_bit#29 / (byte) 2
Rewriting multiplication to use shift [22] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (byte) 8
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) scroll_bit::r#0
Inlining constant with var siblings (const byte) scroll_bit::b#0
Inlining constant with var siblings (const byte) scroll_bit::b#1
Inlining constant with var siblings (const byte*) scroll_bit::sc#0
Inlining constant with var siblings (const byte) scroll_hard::i#0
Inlining constant with var siblings (const byte) scroll#15
Inlining constant with var siblings (const byte) scroll#14
Inlining constant with var siblings (const byte) current_bit#23
Inlining constant with var siblings (const byte) current_bit#6
Inlining constant with var siblings (const byte*) nxt#8
Constant inlined scroll_hard::$4 = (const byte*) SCREEN+(byte)(number) $28*(number) 1
Constant inlined scroll_hard::$5 = (const byte*) SCREEN+(byte)(number) $28*(number) 1
Constant inlined scroll_hard::$2 = (const byte*) SCREEN
Constant inlined scroll_hard::$1 = (const byte*) SCREEN
Constant inlined $0 = (const byte*) TEXT
Constant inlined scroll_hard::$23 = (const byte*) SCREEN+(word)(number) $28*(number) 7
Constant inlined current_bit#6 = (byte) $80
Constant inlined scroll_bit::r#0 = (byte) 0
Constant inlined current_bit#23 = (byte) 1
Constant inlined fillscreen::screen#0 = (const byte*) SCREEN
Constant inlined nxt#8 = (const byte*) TEXT
Constant inlined scroll_hard::$8 = (const byte*) SCREEN+(byte)(number) $28*(number) 2
Constant inlined scroll_hard::$7 = (const byte*) SCREEN+(byte)(number) $28*(number) 2
Constant inlined scroll_hard::$20 = (const byte*) SCREEN+(byte)(number) $28*(number) 6
Constant inlined scroll_hard::$22 = (const byte*) SCREEN+(word)(number) $28*(number) 7
Constant inlined scroll_hard::i#0 = (byte) 0
Constant inlined scroll_bit::$4 = (const byte*) SCREEN+(byte) $28
Constant inlined scroll_bit::b#0 = (byte) ' '
Constant inlined fillscreen::$0 = (const byte*) SCREEN+(word) $3e8
Constant inlined scroll_bit::b#1 = (byte) $80+(byte) ' '
Constant inlined scroll_hard::$13 = (const byte*) SCREEN+(byte)(number) $28*(number) 4
Constant inlined scroll_hard::$14 = (const byte*) SCREEN+(byte)(number) $28*(number) 4
Constant inlined scroll_hard::$16 = (const byte*) SCREEN+(byte)(number) $28*(number) 5
Constant inlined scroll_hard::$17 = (const byte*) SCREEN+(byte)(number) $28*(number) 5
Constant inlined scroll_hard::$19 = (const byte*) SCREEN+(byte)(number) $28*(number) 6
Constant inlined scroll_bit::sc#0 = (const byte*) SCREEN+(byte) $28+(byte) $27
Constant inlined scroll#15 = (byte) 7
Constant inlined scroll_hard::$10 = (const byte*) SCREEN+(byte)(number) $28*(number) 3
Constant inlined scroll_hard::$11 = (const byte*) SCREEN+(byte)(number) $28*(number) 3
Constant inlined scroll#14 = (byte) 7
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(SCREEN+1 + scroll_hard::$3)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*1+1 + scroll_hard::$6)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*2+1 + scroll_hard::$9)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*3+1 + scroll_hard::$12)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*4+1 + scroll_hard::$15)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*5+1 + scroll_hard::$18)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*6+1 + scroll_hard::$21)
Consolidated array index constant in assignment *(SCREEN+(word)$28*7+1 + scroll_hard::$24)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (byte) scroll_hard::i#2 = (byte~) scroll_hard::$3 (byte~) scroll_hard::$6 (byte~) scroll_hard::$9 (byte~) scroll_hard::$12 (byte~) scroll_hard::$15 (byte~) scroll_hard::$18 (byte~) scroll_hard::$21 (byte~) scroll_hard::$24 
Successful SSA optimization Pass2AliasElimination
Added new block during phi lifting main::@9(between main::@2 and main::@2)
Added new block during phi lifting scroll_soft::@4(between scroll_soft and scroll_soft::@1)
Added new block during phi lifting scroll_bit::@9(between scroll_bit and scroll_bit::@1)
Added new block during phi lifting scroll_bit::@10(between scroll_bit::@4 and scroll_bit::@3)
Added new block during phi lifting next_char::@4(between next_char and next_char::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @6
Adding NOP phi() at start of @7
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of scroll_soft::@2
Adding NOP phi() at start of scroll_bit::@2
Adding NOP phi() at start of scroll_bit::@5
Adding NOP phi() at start of scroll_hard
Adding NOP phi() at start of fillscreen
CALL GRAPH
Calls in [] to main:5 
Calls in [main] to fillscreen:9 scroll_soft:15 
Calls in [scroll_soft] to scroll_bit:28 
Calls in [scroll_bit] to next_char:42 scroll_hard:50 

Created 18 initial phi equivalence classes
Coalesced [17] scroll#23 ← scroll#10
Coalesced [18] current_bit#33 ← current_bit#12
Coalesced [19] nxt#39 ← nxt#14
Coalesced [20] current_chargen#32 ← current_chargen#11
Coalesced (already) [21] scroll#22 ← scroll#18
Coalesced (already) [22] current_bit#32 ← current_bit#29
Coalesced (already) [23] nxt#38 ← nxt#31
Coalesced (already) [24] current_chargen#31 ← current_chargen#27
Coalesced [29] current_bit#35 ← current_bit#21
Coalesced [30] nxt#41 ← nxt#35
Coalesced [31] current_chargen#34 ← current_chargen#19
Coalesced [35] scroll#24 ← scroll#3
Coalesced (already) [36] current_bit#34 ← current_bit#29
Coalesced (already) [37] nxt#40 ← nxt#31
Coalesced (already) [38] current_chargen#33 ← current_chargen#27
Coalesced [47] current_chargen#36 ← current_chargen#5
Coalesced [48] nxt#43 ← nxt#19
Coalesced [66] scroll_bit::r#5 ← scroll_bit::r#1
Coalesced [67] scroll_bit::sc#5 ← scroll_bit::sc#1
Coalesced (already) [68] current_chargen#35 ← current_chargen#27
Coalesced [69] current_bit#36 ← current_bit#5
Coalesced (already) [70] nxt#42 ← nxt#31
Coalesced [84] scroll_hard::i#4 ← scroll_hard::i#1
Coalesced [88] next_char::return#6 ← next_char::c#1
Coalesced [92] nxt#44 ← nxt#31
Coalesced [93] next_char::return#5 ← next_char::c#0
Coalesced [100] fillscreen::cursor#4 ← fillscreen::cursor#1
Coalesced down to 10 phi equivalence classes
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) @7
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@9
Culled Empty Block (label) scroll_soft::@3
Culled Empty Block (label) scroll_soft::@4
Culled Empty Block (label) scroll_bit::@10
Culled Empty Block (label) scroll_bit::@9
Culled Empty Block (label) next_char::@4
Renumbering block @6 to @1
Renumbering block main::@2 to main::@1
Renumbering block main::@4 to main::@2
Renumbering block main::@5 to main::@3
Renumbering block main::@8 to main::@4
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of scroll_soft::@2
Adding NOP phi() at start of scroll_bit::@2
Adding NOP phi() at start of scroll_bit::@5
Adding NOP phi() at start of scroll_hard
Adding NOP phi() at start of fillscreen

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call fillscreen 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@4
  [6] (byte*) current_chargen#27 ← phi( main::@1/(byte*) current_chargen#27 main/(const byte*) CHARGEN main::@4/(byte*) current_chargen#11 )
  [6] (byte*) nxt#31 ← phi( main::@1/(byte*) nxt#31 main/(const byte*) TEXT main::@4/(byte*) nxt#14 )
  [6] (byte) current_bit#29 ← phi( main::@1/(byte) current_bit#29 main/(byte) 1 main::@4/(byte) current_bit#12 )
  [6] (byte) scroll#18 ← phi( main::@1/(byte) scroll#18 main/(byte) 7 main::@4/(byte) scroll#10 )
  [7] if(*((const byte*) RASTER)!=(byte) $fe) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@2
  [8] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  [9] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL)
  [10] call scroll_soft 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [11] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL)
  to:main::@1

(void()) scroll_soft()
scroll_soft: scope:[scroll_soft]  from main::@3
  [12] (byte) scroll#3 ← -- (byte) scroll#18
  [13] if((byte) scroll#3!=(byte) $ff) goto scroll_soft::@1
  to:scroll_soft::@2
scroll_soft::@2: scope:[scroll_soft]  from scroll_soft
  [14] phi()
  [15] call scroll_bit 
  to:scroll_soft::@1
scroll_soft::@1: scope:[scroll_soft]  from scroll_soft scroll_soft::@2
  [16] (byte*) current_chargen#11 ← phi( scroll_soft/(byte*) current_chargen#27 scroll_soft::@2/(byte*) current_chargen#19 )
  [16] (byte*) nxt#14 ← phi( scroll_soft/(byte*) nxt#31 scroll_soft::@2/(byte*) nxt#35 )
  [16] (byte) current_bit#12 ← phi( scroll_soft/(byte) current_bit#29 scroll_soft::@2/(byte) current_bit#21 )
  [16] (byte) scroll#10 ← phi( scroll_soft/(byte) scroll#3 scroll_soft::@2/(byte) 7 )
  [17] *((const byte*) SCROLL) ← (byte) scroll#10
  to:scroll_soft::@return
scroll_soft::@return: scope:[scroll_soft]  from scroll_soft::@1
  [18] return 
  to:@return

(void()) scroll_bit()
scroll_bit: scope:[scroll_bit]  from scroll_soft::@2
  [19] (byte) current_bit#5 ← (byte) current_bit#29 >> (byte) 1
  [20] if((byte) current_bit#5!=(byte) 0) goto scroll_bit::@1
  to:scroll_bit::@2
scroll_bit::@2: scope:[scroll_bit]  from scroll_bit
  [21] phi()
  [22] call next_char 
  [23] (byte) next_char::return#0 ← (byte) next_char::return#1
  to:scroll_bit::@8
scroll_bit::@8: scope:[scroll_bit]  from scroll_bit::@2
  [24] (word) scroll_bit::c#0 ← (byte) next_char::return#0
  [25] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3
  [26] (byte*) current_chargen#5 ← (const byte*) CHARGEN + (word~) scroll_bit::$7
  to:scroll_bit::@1
scroll_bit::@1: scope:[scroll_bit]  from scroll_bit scroll_bit::@8
  [27] (byte*) nxt#35 ← phi( scroll_bit/(byte*) nxt#31 scroll_bit::@8/(byte*) nxt#19 )
  [27] (byte) current_bit#21 ← phi( scroll_bit/(byte) current_bit#5 scroll_bit::@8/(byte) $80 )
  [27] (byte*) current_chargen#19 ← phi( scroll_bit/(byte*) current_chargen#27 scroll_bit::@8/(byte*) current_chargen#5 )
  [28] call scroll_hard 
  to:scroll_bit::@7
scroll_bit::@7: scope:[scroll_bit]  from scroll_bit::@1
  asm { sei  }
  [30] *((const byte*) PROCPORT) ← (byte) $32
  to:scroll_bit::@3
scroll_bit::@3: scope:[scroll_bit]  from scroll_bit::@4 scroll_bit::@7
  [31] (byte*) scroll_bit::sc#2 ← phi( scroll_bit::@4/(byte*) scroll_bit::sc#1 scroll_bit::@7/(const byte*) SCREEN+(byte) $28+(byte) $27 )
  [31] (byte) scroll_bit::r#2 ← phi( scroll_bit::@4/(byte) scroll_bit::r#1 scroll_bit::@7/(byte) 0 )
  [32] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#19 + (byte) scroll_bit::r#2)
  [33] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#21
  [34] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4
  to:scroll_bit::@5
scroll_bit::@5: scope:[scroll_bit]  from scroll_bit::@3
  [35] phi()
  to:scroll_bit::@4
scroll_bit::@4: scope:[scroll_bit]  from scroll_bit::@3 scroll_bit::@5
  [36] (byte) scroll_bit::b#2 ← phi( scroll_bit::@3/(byte) ' ' scroll_bit::@5/(byte) $80+(byte) ' ' )
  [37] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2
  [38] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28
  [39] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2
  [40] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3
  to:scroll_bit::@6
scroll_bit::@6: scope:[scroll_bit]  from scroll_bit::@4
  [41] *((const byte*) PROCPORT) ← (byte) $37
  asm { cli  }
  to:scroll_bit::@return
scroll_bit::@return: scope:[scroll_bit]  from scroll_bit::@6
  [43] return 
  to:@return

(void()) scroll_hard()
scroll_hard: scope:[scroll_hard]  from scroll_bit::@1
  [44] phi()
  to:scroll_hard::@1
scroll_hard::@1: scope:[scroll_hard]  from scroll_hard scroll_hard::@2
  [45] (byte) scroll_hard::i#2 ← phi( scroll_hard/(byte) 0 scroll_hard::@2/(byte) scroll_hard::i#1 )
  [46] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2
  to:scroll_hard::@return
scroll_hard::@return: scope:[scroll_hard]  from scroll_hard::@1
  [47] return 
  to:@return
scroll_hard::@2: scope:[scroll_hard]  from scroll_hard::@1
  [48] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2)
  [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2)
  [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2)
  [51] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2)
  [52] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2)
  [53] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2)
  [54] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2)
  [55] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2)
  [56] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2
  to:scroll_hard::@1

(byte()) next_char()
next_char: scope:[next_char]  from scroll_bit::@2
  [57] (byte) next_char::c#0 ← *((byte*) nxt#31)
  [58] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1
  to:next_char::@2
next_char::@2: scope:[next_char]  from next_char
  [59] (byte) next_char::c#1 ← *((const byte*) TEXT)
  to:next_char::@1
next_char::@1: scope:[next_char]  from next_char next_char::@2
  [60] (byte) next_char::return#1 ← phi( next_char/(byte) next_char::c#0 next_char::@2/(byte) next_char::c#1 )
  [60] (byte*) nxt#18 ← phi( next_char/(byte*) nxt#31 next_char::@2/(const byte*) TEXT )
  [61] (byte*) nxt#19 ← ++ (byte*) nxt#18
  to:next_char::@return
next_char::@return: scope:[next_char]  from next_char::@1
  [62] return 
  to:@return

(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
fillscreen: scope:[fillscreen]  from main
  [63] phi()
  to:fillscreen::@1
fillscreen::@1: scope:[fillscreen]  from fillscreen fillscreen::@2
  [64] (byte*) fillscreen::cursor#2 ← phi( fillscreen/(const byte*) SCREEN fillscreen::@2/(byte*) fillscreen::cursor#1 )
  [65] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2
  to:fillscreen::@return
fillscreen::@return: scope:[fillscreen]  from fillscreen::@1
  [66] return 
  to:@return
fillscreen::@2: scope:[fillscreen]  from fillscreen::@1
  [67] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0
  [68] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2
  to:fillscreen::@1


VARIABLE REGISTER WEIGHTS
(byte) current_bit
(byte) current_bit#12 3.0
(byte) current_bit#21 5.833333333333333
(byte) current_bit#29 31.0
(byte) current_bit#5 3.0
(byte*) current_chargen
(byte*) current_chargen#11 3.0
(byte*) current_chargen#19 5.944444444444444
(byte*) current_chargen#27 24.111111111111107
(byte*) current_chargen#5 4.0
(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
(byte*) fillscreen::cursor
(byte*) fillscreen::cursor#1 22.0
(byte*) fillscreen::cursor#2 14.666666666666666
(byte) fillscreen::fill
(byte*) fillscreen::screen
(void()) main()
(byte()) next_char()
(byte) next_char::c
(byte) next_char::c#0 3.0
(byte) next_char::c#1 4.0
(byte) next_char::return
(byte) next_char::return#0 4.0
(byte) next_char::return#1 1.5
(byte*) nxt
(byte*) nxt#14 3.0
(byte*) nxt#18 4.0
(byte*) nxt#19 0.5714285714285714
(byte*) nxt#31 18.41666666666667
(byte*) nxt#35 0.3333333333333333
(byte) scroll
(byte) scroll#10 3.0
(byte) scroll#18 53.75
(byte) scroll#3 3.0
(void()) scroll_bit()
(word~) scroll_bit::$7 4.0
(byte~) scroll_bit::$9 202.0
(byte) scroll_bit::b
(byte) scroll_bit::b#2 101.0
(byte) scroll_bit::bits
(byte) scroll_bit::bits#0 202.0
(word) scroll_bit::c
(word) scroll_bit::c#0 4.0
(byte) scroll_bit::r
(byte) scroll_bit::r#1 151.5
(byte) scroll_bit::r#2 37.875
(byte*) scroll_bit::sc
(byte*) scroll_bit::sc#1 67.33333333333333
(byte*) scroll_bit::sc#2 43.285714285714285
(void()) scroll_hard()
(byte) scroll_hard::i
(byte) scroll_hard::i#1 202.0
(byte) scroll_hard::i#2 191.89999999999995
(void()) scroll_soft()

Initial phi equivalence classes
[ scroll#18 scroll#10 scroll#3 ]
[ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
[ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ]
[ scroll_bit::r#2 scroll_bit::r#1 ]
[ scroll_bit::sc#2 scroll_bit::sc#1 ]
[ scroll_bit::b#2 ]
[ scroll_hard::i#2 scroll_hard::i#1 ]
[ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ]
[ next_char::return#1 next_char::c#0 next_char::c#1 ]
[ fillscreen::cursor#2 fillscreen::cursor#1 ]
Added variable next_char::return#0 to zero page equivalence class [ next_char::return#0 ]
Added variable scroll_bit::c#0 to zero page equivalence class [ scroll_bit::c#0 ]
Added variable scroll_bit::$7 to zero page equivalence class [ scroll_bit::$7 ]
Added variable scroll_bit::bits#0 to zero page equivalence class [ scroll_bit::bits#0 ]
Added variable scroll_bit::$9 to zero page equivalence class [ scroll_bit::$9 ]
Complete equivalence classes
[ scroll#18 scroll#10 scroll#3 ]
[ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
[ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ]
[ scroll_bit::r#2 scroll_bit::r#1 ]
[ scroll_bit::sc#2 scroll_bit::sc#1 ]
[ scroll_bit::b#2 ]
[ scroll_hard::i#2 scroll_hard::i#1 ]
[ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ]
[ next_char::return#1 next_char::c#0 next_char::c#1 ]
[ fillscreen::cursor#2 fillscreen::cursor#1 ]
[ next_char::return#0 ]
[ scroll_bit::c#0 ]
[ scroll_bit::$7 ]
[ scroll_bit::bits#0 ]
[ scroll_bit::$9 ]
Allocated zp ZP_BYTE:2 [ scroll#18 scroll#10 scroll#3 ]
Allocated zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
Allocated zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ]
Allocated zp ZP_BYTE:6 [ scroll_bit::r#2 scroll_bit::r#1 ]
Allocated zp ZP_WORD:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ]
Allocated zp ZP_BYTE:9 [ scroll_bit::b#2 ]
Allocated zp ZP_BYTE:10 [ scroll_hard::i#2 scroll_hard::i#1 ]
Allocated zp ZP_WORD:11 [ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ]
Allocated zp ZP_BYTE:13 [ next_char::return#1 next_char::c#0 next_char::c#1 ]
Allocated zp ZP_WORD:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ]
Allocated zp ZP_BYTE:16 [ next_char::return#0 ]
Allocated zp ZP_WORD:17 [ scroll_bit::c#0 ]
Allocated zp ZP_WORD:19 [ scroll_bit::$7 ]
Allocated zp ZP_BYTE:21 [ scroll_bit::bits#0 ]
Allocated zp ZP_BYTE:22 [ scroll_bit::$9 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// An 8x8 char letter scroller
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label PROCPORT = 1
  .label CHARGEN = $d000
  .label SCREEN = $400
  .label RASTER = $d012
  .label BGCOL = $d020
  .label SCROLL = $d016
  .label scroll = 2
  .label current_bit = 3
  .label current_chargen = 4
  .label nxt = $b
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [5] call fillscreen 
    // [63] phi from main to fillscreen [phi:main->fillscreen]
  fillscreen_from_main:
    jsr fillscreen
    // [6] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [6] phi (byte*) current_chargen#27 = (const byte*) CHARGEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z current_chargen
    lda #>CHARGEN
    sta.z current_chargen+1
    // [6] phi (byte*) nxt#31 = (const byte*) TEXT [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [6] phi (byte) current_bit#29 = (byte) 1 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #1
    sta.z current_bit
    // [6] phi (byte) scroll#18 = (byte) 7 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    lda #7
    sta.z scroll
    jmp __b1
  // Wait for raster
    // [6] phi from main::@1 main::@4 to main::@1 [phi:main::@1/main::@4->main::@1]
  __b1_from___b1:
  __b1_from___b4:
    // [6] phi (byte*) current_chargen#27 = (byte*) current_chargen#27 [phi:main::@1/main::@4->main::@1#0] -- register_copy 
    // [6] phi (byte*) nxt#31 = (byte*) nxt#31 [phi:main::@1/main::@4->main::@1#1] -- register_copy 
    // [6] phi (byte) current_bit#29 = (byte) current_bit#29 [phi:main::@1/main::@4->main::@1#2] -- register_copy 
    // [6] phi (byte) scroll#18 = (byte) scroll#18 [phi:main::@1/main::@4->main::@1#3] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [7] if(*((const byte*) RASTER)!=(byte) $fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp RASTER
    bne __b1_from___b1
    jmp __b2
    // main::@2
  __b2:
    // [8] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [9] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [10] call scroll_soft 
    jsr scroll_soft
    jmp __b4
    // main::@4
  __b4:
    // [11] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BGCOL
    jmp __b1_from___b4
}
  // scroll_soft
scroll_soft: {
    // [12] (byte) scroll#3 ← -- (byte) scroll#18 -- vbuz1=_dec_vbuz1 
    dec.z scroll
    // [13] if((byte) scroll#3!=(byte) $ff) goto scroll_soft::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z scroll
    bne __b1_from_scroll_soft
    // [14] phi from scroll_soft to scroll_soft::@2 [phi:scroll_soft->scroll_soft::@2]
  __b2_from_scroll_soft:
    jmp __b2
    // scroll_soft::@2
  __b2:
    // [15] call scroll_bit 
    jsr scroll_bit
    // [16] phi from scroll_soft::@2 to scroll_soft::@1 [phi:scroll_soft::@2->scroll_soft::@1]
  __b1_from___b2:
    // [16] phi (byte*) current_chargen#11 = (byte*) current_chargen#19 [phi:scroll_soft::@2->scroll_soft::@1#0] -- register_copy 
    // [16] phi (byte*) nxt#14 = (byte*) nxt#35 [phi:scroll_soft::@2->scroll_soft::@1#1] -- register_copy 
    // [16] phi (byte) current_bit#12 = (byte) current_bit#21 [phi:scroll_soft::@2->scroll_soft::@1#2] -- register_copy 
    // [16] phi (byte) scroll#10 = (byte) 7 [phi:scroll_soft::@2->scroll_soft::@1#3] -- vbuz1=vbuc1 
    lda #7
    sta.z scroll
    jmp __b1
    // [16] phi from scroll_soft to scroll_soft::@1 [phi:scroll_soft->scroll_soft::@1]
  __b1_from_scroll_soft:
    // [16] phi (byte*) current_chargen#11 = (byte*) current_chargen#27 [phi:scroll_soft->scroll_soft::@1#0] -- register_copy 
    // [16] phi (byte*) nxt#14 = (byte*) nxt#31 [phi:scroll_soft->scroll_soft::@1#1] -- register_copy 
    // [16] phi (byte) current_bit#12 = (byte) current_bit#29 [phi:scroll_soft->scroll_soft::@1#2] -- register_copy 
    // [16] phi (byte) scroll#10 = (byte) scroll#3 [phi:scroll_soft->scroll_soft::@1#3] -- register_copy 
    jmp __b1
    // scroll_soft::@1
  __b1:
    // [17] *((const byte*) SCROLL) ← (byte) scroll#10 -- _deref_pbuc1=vbuz1 
    lda.z scroll
    sta SCROLL
    jmp __breturn
    // scroll_soft::@return
  __breturn:
    // [18] return 
    rts
}
  // scroll_bit
scroll_bit: {
    .label __7 = $13
    .label __9 = $16
    .label c = $11
    .label bits = $15
    .label sc = 7
    .label r = 6
    .label b = 9
    // [19] (byte) current_bit#5 ← (byte) current_bit#29 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z current_bit
    // [20] if((byte) current_bit#5!=(byte) 0) goto scroll_bit::@1 -- vbuz1_neq_0_then_la1 
    lda.z current_bit
    cmp #0
    bne __b1_from_scroll_bit
    // [21] phi from scroll_bit to scroll_bit::@2 [phi:scroll_bit->scroll_bit::@2]
  __b2_from_scroll_bit:
    jmp __b2
    // scroll_bit::@2
  __b2:
    // [22] call next_char 
    jsr next_char
    // [23] (byte) next_char::return#0 ← (byte) next_char::return#1 -- vbuz1=vbuz2 
    lda.z next_char.return_1
    sta.z next_char.return
    jmp __b8
    // scroll_bit::@8
  __b8:
    // [24] (word) scroll_bit::c#0 ← (byte) next_char::return#0 -- vwuz1=vbuz2 
    lda.z next_char.return
    sta.z c
    lda #0
    sta.z c+1
    // [25] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 -- vwuz1=vwuz2_rol_3 
    lda.z c
    asl
    sta.z __7
    lda.z c+1
    rol
    sta.z __7+1
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    // [26] (byte*) current_chargen#5 ← (const byte*) CHARGEN + (word~) scroll_bit::$7 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z __7
    clc
    adc #<CHARGEN
    sta.z current_chargen
    lda.z __7+1
    adc #>CHARGEN
    sta.z current_chargen+1
    // [27] phi from scroll_bit::@8 to scroll_bit::@1 [phi:scroll_bit::@8->scroll_bit::@1]
  __b1_from___b8:
    // [27] phi (byte*) nxt#35 = (byte*) nxt#19 [phi:scroll_bit::@8->scroll_bit::@1#0] -- register_copy 
    // [27] phi (byte) current_bit#21 = (byte) $80 [phi:scroll_bit::@8->scroll_bit::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta.z current_bit
    // [27] phi (byte*) current_chargen#19 = (byte*) current_chargen#5 [phi:scroll_bit::@8->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // [27] phi from scroll_bit to scroll_bit::@1 [phi:scroll_bit->scroll_bit::@1]
  __b1_from_scroll_bit:
    // [27] phi (byte*) nxt#35 = (byte*) nxt#31 [phi:scroll_bit->scroll_bit::@1#0] -- register_copy 
    // [27] phi (byte) current_bit#21 = (byte) current_bit#5 [phi:scroll_bit->scroll_bit::@1#1] -- register_copy 
    // [27] phi (byte*) current_chargen#19 = (byte*) current_chargen#27 [phi:scroll_bit->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // scroll_bit::@1
  __b1:
    // [28] call scroll_hard 
    // [44] phi from scroll_bit::@1 to scroll_hard [phi:scroll_bit::@1->scroll_hard]
  scroll_hard_from___b1:
    jsr scroll_hard
    jmp __b7
    // scroll_bit::@7
  __b7:
    // asm { sei  }
    sei
    // [30] *((const byte*) PROCPORT) ← (byte) $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [31] phi from scroll_bit::@7 to scroll_bit::@3 [phi:scroll_bit::@7->scroll_bit::@3]
  __b3_from___b7:
    // [31] phi (byte*) scroll_bit::sc#2 = (const byte*) SCREEN+(byte) $28+(byte) $27 [phi:scroll_bit::@7->scroll_bit::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28+$27
    sta.z sc
    lda #>SCREEN+$28+$27
    sta.z sc+1
    // [31] phi (byte) scroll_bit::r#2 = (byte) 0 [phi:scroll_bit::@7->scroll_bit::@3#1] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    jmp __b3
    // [31] phi from scroll_bit::@4 to scroll_bit::@3 [phi:scroll_bit::@4->scroll_bit::@3]
  __b3_from___b4:
    // [31] phi (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#1 [phi:scroll_bit::@4->scroll_bit::@3#0] -- register_copy 
    // [31] phi (byte) scroll_bit::r#2 = (byte) scroll_bit::r#1 [phi:scroll_bit::@4->scroll_bit::@3#1] -- register_copy 
    jmp __b3
    // scroll_bit::@3
  __b3:
    // [32] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#19 + (byte) scroll_bit::r#2) -- vbuz1=pbuz2_derefidx_vbuz3 
    ldy.z r
    lda (current_chargen),y
    sta.z bits
    // [33] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#21 -- vbuz1=vbuz2_band_vbuz3 
    lda.z bits
    and.z current_bit
    sta.z __9
    // [34] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4 -- vbuz1_eq_0_then_la1 
    lda.z __9
    cmp #0
    beq __b4_from___b3
    // [35] phi from scroll_bit::@3 to scroll_bit::@5 [phi:scroll_bit::@3->scroll_bit::@5]
  __b5_from___b3:
    jmp __b5
    // scroll_bit::@5
  __b5:
    // [36] phi from scroll_bit::@5 to scroll_bit::@4 [phi:scroll_bit::@5->scroll_bit::@4]
  __b4_from___b5:
    // [36] phi (byte) scroll_bit::b#2 = (byte) $80+(byte) ' ' [phi:scroll_bit::@5->scroll_bit::@4#0] -- vbuz1=vbuc1 
    lda #$80+' '
    sta.z b
    jmp __b4
    // [36] phi from scroll_bit::@3 to scroll_bit::@4 [phi:scroll_bit::@3->scroll_bit::@4]
  __b4_from___b3:
    // [36] phi (byte) scroll_bit::b#2 = (byte) ' ' [phi:scroll_bit::@3->scroll_bit::@4#0] -- vbuz1=vbuc1 
    lda #' '
    sta.z b
    jmp __b4
    // scroll_bit::@4
  __b4:
    // [37] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 -- _deref_pbuz1=vbuz2 
    lda.z b
    ldy #0
    sta (sc),y
    // [38] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z sc
    sta.z sc
    bcc !+
    inc.z sc+1
  !:
    // [39] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [40] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z r
    bne __b3_from___b4
    jmp __b6
    // scroll_bit::@6
  __b6:
    // [41] *((const byte*) PROCPORT) ← (byte) $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm { cli  }
    cli
    jmp __breturn
    // scroll_bit::@return
  __breturn:
    // [43] return 
    rts
}
  // scroll_hard
scroll_hard: {
    .label i = $a
    // [45] phi from scroll_hard to scroll_hard::@1 [phi:scroll_hard->scroll_hard::@1]
  __b1_from_scroll_hard:
    // [45] phi (byte) scroll_hard::i#2 = (byte) 0 [phi:scroll_hard->scroll_hard::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
  // Hard scroll
    // scroll_hard::@1
  __b1:
    // [46] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$27
    cmp.z i
    bne __b2
    jmp __breturn
    // scroll_hard::@return
  __breturn:
    // [47] return 
    rts
    // scroll_hard::@2
  __b2:
    // [48] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+1,y
    sta SCREEN,y
    // [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*1+1,y
    sta SCREEN+$28*1,y
    // [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*2+1,y
    sta SCREEN+$28*2,y
    // [51] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*3+1,y
    sta SCREEN+$28*3,y
    // [52] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*4+1,y
    sta SCREEN+$28*4,y
    // [53] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*5+1,y
    sta SCREEN+$28*5,y
    // [54] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*6+1,y
    sta SCREEN+$28*6,y
    // [55] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*7+1,y
    sta SCREEN+$28*7,y
    // [56] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [45] phi from scroll_hard::@2 to scroll_hard::@1 [phi:scroll_hard::@2->scroll_hard::@1]
  __b1_from___b2:
    // [45] phi (byte) scroll_hard::i#2 = (byte) scroll_hard::i#1 [phi:scroll_hard::@2->scroll_hard::@1#0] -- register_copy 
    jmp __b1
}
  // next_char
// Find the next char of the scroll text
next_char: {
    .label return = $10
    .label c = $d
    .label return_1 = $d
    // [57] (byte) next_char::c#0 ← *((byte*) nxt#31) -- vbuz1=_deref_pbuz2 
    ldy #0
    lda (nxt),y
    sta.z c
    // [58] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1 -- vbuz1_neq_0_then_la1 
    lda.z c
    cmp #0
    bne __b1_from_next_char
    jmp __b2
    // next_char::@2
  __b2:
    // [59] (byte) next_char::c#1 ← *((const byte*) TEXT) -- vbuz1=_deref_pbuc1 
    lda TEXT
    sta.z c
    // [60] phi from next_char::@2 to next_char::@1 [phi:next_char::@2->next_char::@1]
  __b1_from___b2:
    // [60] phi (byte) next_char::return#1 = (byte) next_char::c#1 [phi:next_char::@2->next_char::@1#0] -- register_copy 
    // [60] phi (byte*) nxt#18 = (const byte*) TEXT [phi:next_char::@2->next_char::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    jmp __b1
    // [60] phi from next_char to next_char::@1 [phi:next_char->next_char::@1]
  __b1_from_next_char:
    // [60] phi (byte) next_char::return#1 = (byte) next_char::c#0 [phi:next_char->next_char::@1#0] -- register_copy 
    // [60] phi (byte*) nxt#18 = (byte*) nxt#31 [phi:next_char->next_char::@1#1] -- register_copy 
    jmp __b1
    // next_char::@1
  __b1:
    // [61] (byte*) nxt#19 ← ++ (byte*) nxt#18 -- pbuz1=_inc_pbuz1 
    inc.z nxt
    bne !+
    inc.z nxt+1
  !:
    jmp __breturn
    // next_char::@return
  __breturn:
    // [62] return 
    rts
}
  // fillscreen
// Fill the screen with one char
fillscreen: {
    .const fill = $20
    .label cursor = $e
    // [64] phi from fillscreen to fillscreen::@1 [phi:fillscreen->fillscreen::@1]
  __b1_from_fillscreen:
    // [64] phi (byte*) fillscreen::cursor#2 = (const byte*) SCREEN [phi:fillscreen->fillscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z cursor
    lda #>SCREEN
    sta.z cursor+1
    jmp __b1
    // fillscreen::@1
  __b1:
    // [65] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z cursor+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z cursor
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    jmp __breturn
    // fillscreen::@return
  __breturn:
    // [66] return 
    rts
    // fillscreen::@2
  __b2:
    // [67] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 -- _deref_pbuz1=vbuc1 
    lda #fill
    ldy #0
    sta (cursor),y
    // [68] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z cursor
    bne !+
    inc.z cursor+1
  !:
    // [64] phi from fillscreen::@2 to fillscreen::@1 [phi:fillscreen::@2->fillscreen::@1]
  __b1_from___b2:
    // [64] phi (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#1 [phi:fillscreen::@2->fillscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  TEXT: .text "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
  .byte 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] if(*((const byte*) RASTER)!=(byte) $fe) goto main::@1 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ( main:2 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ scroll#18 scroll#10 scroll#3 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
Statement [8] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@2 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ( main:2 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ) always clobbers reg byte a 
Statement [24] (word) scroll_bit::c#0 ← (byte) next_char::return#0 [ scroll_bit::c#0 nxt#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ scroll_bit::c#0 nxt#19 ] ) always clobbers reg byte a 
Statement [25] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 [ scroll_bit::$7 nxt#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ scroll_bit::$7 nxt#19 ] ) always clobbers reg byte a 
Statement [26] (byte*) current_chargen#5 ← (const byte*) CHARGEN + (word~) scroll_bit::$7 [ current_chargen#5 nxt#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_chargen#5 nxt#19 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) PROCPORT) ← (byte) $32 [ current_bit#21 nxt#35 current_chargen#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 ] ) always clobbers reg byte a 
Statement [32] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#19 + (byte) scroll_bit::r#2) [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ scroll_bit::r#2 scroll_bit::r#1 ]
Statement [37] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:6 [ scroll_bit::r#2 scroll_bit::r#1 ]
Statement [38] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#1 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#1 ] ) always clobbers reg byte a 
Statement [41] *((const byte*) PROCPORT) ← (byte) $37 [ current_bit#21 nxt#35 current_chargen#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 ] ) always clobbers reg byte a 
Statement [48] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ scroll_hard::i#2 scroll_hard::i#1 ]
Statement [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [51] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [52] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [53] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [54] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [55] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [57] (byte) next_char::c#0 ← *((byte*) nxt#31) [ nxt#31 next_char::c#0 ] ( main:2::scroll_soft:10::scroll_bit:15::next_char:22 [ nxt#31 next_char::c#0 ] ) always clobbers reg byte a reg byte y 
Statement [65] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 [ fillscreen::cursor#2 ] ( main:2::fillscreen:5 [ fillscreen::cursor#2 ] ) always clobbers reg byte a 
Statement [67] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 [ fillscreen::cursor#2 ] ( main:2::fillscreen:5 [ fillscreen::cursor#2 ] ) always clobbers reg byte a reg byte y 
Statement [7] if(*((const byte*) RASTER)!=(byte) $fe) goto main::@1 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ( main:2 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ) always clobbers reg byte a 
Statement [8] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@2 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ( main:2 [ scroll#18 current_bit#29 nxt#31 current_chargen#27 ] ) always clobbers reg byte a 
Statement [24] (word) scroll_bit::c#0 ← (byte) next_char::return#0 [ scroll_bit::c#0 nxt#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ scroll_bit::c#0 nxt#19 ] ) always clobbers reg byte a 
Statement [25] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 [ scroll_bit::$7 nxt#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ scroll_bit::$7 nxt#19 ] ) always clobbers reg byte a 
Statement [26] (byte*) current_chargen#5 ← (const byte*) CHARGEN + (word~) scroll_bit::$7 [ current_chargen#5 nxt#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_chargen#5 nxt#19 ] ) always clobbers reg byte a 
Statement [30] *((const byte*) PROCPORT) ← (byte) $32 [ current_bit#21 nxt#35 current_chargen#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 ] ) always clobbers reg byte a 
Statement [32] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#19 + (byte) scroll_bit::r#2) [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] ) always clobbers reg byte a reg byte y 
Statement [37] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#2 ] ) always clobbers reg byte y 
Statement [38] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#1 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 scroll_bit::r#2 scroll_bit::sc#1 ] ) always clobbers reg byte a 
Statement [41] *((const byte*) PROCPORT) ← (byte) $37 [ current_bit#21 nxt#35 current_chargen#19 ] ( main:2::scroll_soft:10::scroll_bit:15 [ current_bit#21 nxt#35 current_chargen#19 ] ) always clobbers reg byte a 
Statement [48] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [51] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [52] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [53] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [54] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [55] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( main:2::scroll_soft:10::scroll_bit:15::scroll_hard:28 [ current_bit#21 nxt#35 current_chargen#19 scroll_hard::i#2 ] ) always clobbers reg byte a 
Statement [57] (byte) next_char::c#0 ← *((byte*) nxt#31) [ nxt#31 next_char::c#0 ] ( main:2::scroll_soft:10::scroll_bit:15::next_char:22 [ nxt#31 next_char::c#0 ] ) always clobbers reg byte a reg byte y 
Statement [65] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 [ fillscreen::cursor#2 ] ( main:2::fillscreen:5 [ fillscreen::cursor#2 ] ) always clobbers reg byte a 
Statement [67] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 [ fillscreen::cursor#2 ] ( main:2::fillscreen:5 [ fillscreen::cursor#2 ] ) always clobbers reg byte a reg byte y 
Potential registers zp ZP_BYTE:2 [ scroll#18 scroll#10 scroll#3 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ] : zp ZP_BYTE:3 , reg byte x , 
Potential registers zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ] : zp ZP_WORD:4 , 
Potential registers zp ZP_BYTE:6 [ scroll_bit::r#2 scroll_bit::r#1 ] : zp ZP_BYTE:6 , reg byte x , 
Potential registers zp ZP_WORD:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ] : zp ZP_WORD:7 , 
Potential registers zp ZP_BYTE:9 [ scroll_bit::b#2 ] : zp ZP_BYTE:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ scroll_hard::i#2 scroll_hard::i#1 ] : zp ZP_BYTE:10 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:11 [ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ] : zp ZP_WORD:11 , 
Potential registers zp ZP_BYTE:13 [ next_char::return#1 next_char::c#0 next_char::c#1 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_BYTE:16 [ next_char::return#0 ] : zp ZP_BYTE:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:17 [ scroll_bit::c#0 ] : zp ZP_WORD:17 , 
Potential registers zp ZP_WORD:19 [ scroll_bit::$7 ] : zp ZP_WORD:19 , 
Potential registers zp ZP_BYTE:21 [ scroll_bit::bits#0 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:22 [ scroll_bit::$9 ] : zp ZP_BYTE:22 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [scroll_bit] 202: zp ZP_BYTE:21 [ scroll_bit::bits#0 ] 202: zp ZP_BYTE:22 [ scroll_bit::$9 ] 189.38: zp ZP_BYTE:6 [ scroll_bit::r#2 scroll_bit::r#1 ] 110.62: zp ZP_WORD:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ] 101: zp ZP_BYTE:9 [ scroll_bit::b#2 ] 4: zp ZP_WORD:17 [ scroll_bit::c#0 ] 4: zp ZP_WORD:19 [ scroll_bit::$7 ] 
Uplift Scope [scroll_hard] 393.9: zp ZP_BYTE:10 [ scroll_hard::i#2 scroll_hard::i#1 ] 
Uplift Scope [] 59.75: zp ZP_BYTE:2 [ scroll#18 scroll#10 scroll#3 ] 42.83: zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ] 37.06: zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ] 26.32: zp ZP_WORD:11 [ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ] 
Uplift Scope [fillscreen] 36.67: zp ZP_WORD:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] 
Uplift Scope [next_char] 8.5: zp ZP_BYTE:13 [ next_char::return#1 next_char::c#0 next_char::c#1 ] 4: zp ZP_BYTE:16 [ next_char::return#0 ] 
Uplift Scope [main] 
Uplift Scope [scroll_soft] 

Uplifting [scroll_bit] best 27962 combination reg byte a [ scroll_bit::bits#0 ] reg byte a [ scroll_bit::$9 ] reg byte x [ scroll_bit::r#2 scroll_bit::r#1 ] zp ZP_WORD:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ] reg byte a [ scroll_bit::b#2 ] zp ZP_WORD:17 [ scroll_bit::c#0 ] zp ZP_WORD:19 [ scroll_bit::$7 ] 
Limited combination testing to 100 combinations of 128 possible.
Uplifting [scroll_hard] best 24662 combination reg byte x [ scroll_hard::i#2 scroll_hard::i#1 ] 
Uplifting [] best 24350 combination reg byte x [ scroll#18 scroll#10 scroll#3 ] zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ] zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ] zp ZP_WORD:11 [ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ] 
Uplifting [fillscreen] best 24350 combination zp ZP_WORD:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] 
Uplifting [next_char] best 24336 combination reg byte x [ next_char::return#1 next_char::c#0 next_char::c#1 ] reg byte a [ next_char::return#0 ] 
Uplifting [main] best 24336 combination 
Uplifting [scroll_soft] best 24336 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
Uplifting [] best 24336 combination zp ZP_BYTE:3 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ] 
Coalescing zero page register [ zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 ] ] with [ zp ZP_WORD:19 [ scroll_bit::$7 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 scroll_bit::$7 ] ] with [ zp ZP_WORD:17 [ scroll_bit::c#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] ] with [ zp ZP_WORD:4 [ current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 scroll_bit::$7 scroll_bit::c#0 ] ]
Allocated (was zp ZP_BYTE:3) zp ZP_BYTE:2 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
Allocated (was zp ZP_WORD:7) zp ZP_WORD:3 [ scroll_bit::sc#2 scroll_bit::sc#1 ]
Allocated (was zp ZP_WORD:11) zp ZP_WORD:5 [ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ]
Allocated (was zp ZP_WORD:14) zp ZP_WORD:7 [ fillscreen::cursor#2 fillscreen::cursor#1 current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 scroll_bit::$7 scroll_bit::c#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// An 8x8 char letter scroller
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label PROCPORT = 1
  .label CHARGEN = $d000
  .label SCREEN = $400
  .label RASTER = $d012
  .label BGCOL = $d020
  .label SCROLL = $d016
  .label current_bit = 2
  .label current_chargen = 7
  .label nxt = 5
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // [5] call fillscreen 
    // [63] phi from main to fillscreen [phi:main->fillscreen]
  fillscreen_from_main:
    jsr fillscreen
    // [6] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [6] phi (byte*) current_chargen#27 = (const byte*) CHARGEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z current_chargen
    lda #>CHARGEN
    sta.z current_chargen+1
    // [6] phi (byte*) nxt#31 = (const byte*) TEXT [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [6] phi (byte) current_bit#29 = (byte) 1 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #1
    sta.z current_bit
    // [6] phi (byte) scroll#18 = (byte) 7 [phi:main->main::@1#3] -- vbuxx=vbuc1 
    ldx #7
    jmp __b1
  // Wait for raster
    // [6] phi from main::@1 main::@4 to main::@1 [phi:main::@1/main::@4->main::@1]
  __b1_from___b1:
  __b1_from___b4:
    // [6] phi (byte*) current_chargen#27 = (byte*) current_chargen#27 [phi:main::@1/main::@4->main::@1#0] -- register_copy 
    // [6] phi (byte*) nxt#31 = (byte*) nxt#31 [phi:main::@1/main::@4->main::@1#1] -- register_copy 
    // [6] phi (byte) current_bit#29 = (byte) current_bit#29 [phi:main::@1/main::@4->main::@1#2] -- register_copy 
    // [6] phi (byte) scroll#18 = (byte) scroll#18 [phi:main::@1/main::@4->main::@1#3] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [7] if(*((const byte*) RASTER)!=(byte) $fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp RASTER
    bne __b1_from___b1
    jmp __b2
    // main::@2
  __b2:
    // [8] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [9] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // [10] call scroll_soft 
    jsr scroll_soft
    jmp __b4
    // main::@4
  __b4:
    // [11] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BGCOL
    jmp __b1_from___b4
}
  // scroll_soft
scroll_soft: {
    // [12] (byte) scroll#3 ← -- (byte) scroll#18 -- vbuxx=_dec_vbuxx 
    dex
    // [13] if((byte) scroll#3!=(byte) $ff) goto scroll_soft::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b1_from_scroll_soft
    // [14] phi from scroll_soft to scroll_soft::@2 [phi:scroll_soft->scroll_soft::@2]
  __b2_from_scroll_soft:
    jmp __b2
    // scroll_soft::@2
  __b2:
    // [15] call scroll_bit 
    jsr scroll_bit
    // [16] phi from scroll_soft::@2 to scroll_soft::@1 [phi:scroll_soft::@2->scroll_soft::@1]
  __b1_from___b2:
    // [16] phi (byte*) current_chargen#11 = (byte*) current_chargen#19 [phi:scroll_soft::@2->scroll_soft::@1#0] -- register_copy 
    // [16] phi (byte*) nxt#14 = (byte*) nxt#35 [phi:scroll_soft::@2->scroll_soft::@1#1] -- register_copy 
    // [16] phi (byte) current_bit#12 = (byte) current_bit#21 [phi:scroll_soft::@2->scroll_soft::@1#2] -- register_copy 
    // [16] phi (byte) scroll#10 = (byte) 7 [phi:scroll_soft::@2->scroll_soft::@1#3] -- vbuxx=vbuc1 
    ldx #7
    jmp __b1
    // [16] phi from scroll_soft to scroll_soft::@1 [phi:scroll_soft->scroll_soft::@1]
  __b1_from_scroll_soft:
    // [16] phi (byte*) current_chargen#11 = (byte*) current_chargen#27 [phi:scroll_soft->scroll_soft::@1#0] -- register_copy 
    // [16] phi (byte*) nxt#14 = (byte*) nxt#31 [phi:scroll_soft->scroll_soft::@1#1] -- register_copy 
    // [16] phi (byte) current_bit#12 = (byte) current_bit#29 [phi:scroll_soft->scroll_soft::@1#2] -- register_copy 
    // [16] phi (byte) scroll#10 = (byte) scroll#3 [phi:scroll_soft->scroll_soft::@1#3] -- register_copy 
    jmp __b1
    // scroll_soft::@1
  __b1:
    // [17] *((const byte*) SCROLL) ← (byte) scroll#10 -- _deref_pbuc1=vbuxx 
    stx SCROLL
    jmp __breturn
    // scroll_soft::@return
  __breturn:
    // [18] return 
    rts
}
  // scroll_bit
scroll_bit: {
    .label __7 = 7
    .label c = 7
    .label sc = 3
    // [19] (byte) current_bit#5 ← (byte) current_bit#29 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z current_bit
    // [20] if((byte) current_bit#5!=(byte) 0) goto scroll_bit::@1 -- vbuz1_neq_0_then_la1 
    lda.z current_bit
    cmp #0
    bne __b1_from_scroll_bit
    // [21] phi from scroll_bit to scroll_bit::@2 [phi:scroll_bit->scroll_bit::@2]
  __b2_from_scroll_bit:
    jmp __b2
    // scroll_bit::@2
  __b2:
    // [22] call next_char 
    jsr next_char
    // [23] (byte) next_char::return#0 ← (byte) next_char::return#1 -- vbuaa=vbuxx 
    txa
    jmp __b8
    // scroll_bit::@8
  __b8:
    // [24] (word) scroll_bit::c#0 ← (byte) next_char::return#0 -- vwuz1=vbuaa 
    sta.z c
    lda #0
    sta.z c+1
    // [25] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 -- vwuz1=vwuz1_rol_3 
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    // [26] (byte*) current_chargen#5 ← (const byte*) CHARGEN + (word~) scroll_bit::$7 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z current_chargen
    adc #<CHARGEN
    sta.z current_chargen
    lda.z current_chargen+1
    adc #>CHARGEN
    sta.z current_chargen+1
    // [27] phi from scroll_bit::@8 to scroll_bit::@1 [phi:scroll_bit::@8->scroll_bit::@1]
  __b1_from___b8:
    // [27] phi (byte*) nxt#35 = (byte*) nxt#19 [phi:scroll_bit::@8->scroll_bit::@1#0] -- register_copy 
    // [27] phi (byte) current_bit#21 = (byte) $80 [phi:scroll_bit::@8->scroll_bit::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta.z current_bit
    // [27] phi (byte*) current_chargen#19 = (byte*) current_chargen#5 [phi:scroll_bit::@8->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // [27] phi from scroll_bit to scroll_bit::@1 [phi:scroll_bit->scroll_bit::@1]
  __b1_from_scroll_bit:
    // [27] phi (byte*) nxt#35 = (byte*) nxt#31 [phi:scroll_bit->scroll_bit::@1#0] -- register_copy 
    // [27] phi (byte) current_bit#21 = (byte) current_bit#5 [phi:scroll_bit->scroll_bit::@1#1] -- register_copy 
    // [27] phi (byte*) current_chargen#19 = (byte*) current_chargen#27 [phi:scroll_bit->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // scroll_bit::@1
  __b1:
    // [28] call scroll_hard 
    // [44] phi from scroll_bit::@1 to scroll_hard [phi:scroll_bit::@1->scroll_hard]
  scroll_hard_from___b1:
    jsr scroll_hard
    jmp __b7
    // scroll_bit::@7
  __b7:
    // asm { sei  }
    sei
    // [30] *((const byte*) PROCPORT) ← (byte) $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [31] phi from scroll_bit::@7 to scroll_bit::@3 [phi:scroll_bit::@7->scroll_bit::@3]
  __b3_from___b7:
    // [31] phi (byte*) scroll_bit::sc#2 = (const byte*) SCREEN+(byte) $28+(byte) $27 [phi:scroll_bit::@7->scroll_bit::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28+$27
    sta.z sc
    lda #>SCREEN+$28+$27
    sta.z sc+1
    // [31] phi (byte) scroll_bit::r#2 = (byte) 0 [phi:scroll_bit::@7->scroll_bit::@3#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // [31] phi from scroll_bit::@4 to scroll_bit::@3 [phi:scroll_bit::@4->scroll_bit::@3]
  __b3_from___b4:
    // [31] phi (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#1 [phi:scroll_bit::@4->scroll_bit::@3#0] -- register_copy 
    // [31] phi (byte) scroll_bit::r#2 = (byte) scroll_bit::r#1 [phi:scroll_bit::@4->scroll_bit::@3#1] -- register_copy 
    jmp __b3
    // scroll_bit::@3
  __b3:
    // [32] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#19 + (byte) scroll_bit::r#2) -- vbuaa=pbuz1_derefidx_vbuxx 
    txa
    tay
    lda (current_chargen),y
    // [33] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#21 -- vbuaa=vbuaa_band_vbuz1 
    and.z current_bit
    // [34] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4_from___b3
    // [35] phi from scroll_bit::@3 to scroll_bit::@5 [phi:scroll_bit::@3->scroll_bit::@5]
  __b5_from___b3:
    jmp __b5
    // scroll_bit::@5
  __b5:
    // [36] phi from scroll_bit::@5 to scroll_bit::@4 [phi:scroll_bit::@5->scroll_bit::@4]
  __b4_from___b5:
    // [36] phi (byte) scroll_bit::b#2 = (byte) $80+(byte) ' ' [phi:scroll_bit::@5->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #$80+' '
    jmp __b4
    // [36] phi from scroll_bit::@3 to scroll_bit::@4 [phi:scroll_bit::@3->scroll_bit::@4]
  __b4_from___b3:
    // [36] phi (byte) scroll_bit::b#2 = (byte) ' ' [phi:scroll_bit::@3->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #' '
    jmp __b4
    // scroll_bit::@4
  __b4:
    // [37] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sc),y
    // [38] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z sc
    sta.z sc
    bcc !+
    inc.z sc+1
  !:
    // [39] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2 -- vbuxx=_inc_vbuxx 
    inx
    // [40] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3_from___b4
    jmp __b6
    // scroll_bit::@6
  __b6:
    // [41] *((const byte*) PROCPORT) ← (byte) $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm { cli  }
    cli
    jmp __breturn
    // scroll_bit::@return
  __breturn:
    // [43] return 
    rts
}
  // scroll_hard
scroll_hard: {
    // [45] phi from scroll_hard to scroll_hard::@1 [phi:scroll_hard->scroll_hard::@1]
  __b1_from_scroll_hard:
    // [45] phi (byte) scroll_hard::i#2 = (byte) 0 [phi:scroll_hard->scroll_hard::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
  // Hard scroll
    // scroll_hard::@1
  __b1:
    // [46] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$27
    bne __b2
    jmp __breturn
    // scroll_hard::@return
  __breturn:
    // [47] return 
    rts
    // scroll_hard::@2
  __b2:
    // [48] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+1,x
    sta SCREEN,x
    // [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*1+1,x
    sta SCREEN+$28*1,x
    // [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*2+1,x
    sta SCREEN+$28*2,x
    // [51] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*3+1,x
    sta SCREEN+$28*3,x
    // [52] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*4+1,x
    sta SCREEN+$28*4,x
    // [53] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*5+1,x
    sta SCREEN+$28*5,x
    // [54] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*6+1,x
    sta SCREEN+$28*6,x
    // [55] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*7+1,x
    sta SCREEN+$28*7,x
    // [56] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [45] phi from scroll_hard::@2 to scroll_hard::@1 [phi:scroll_hard::@2->scroll_hard::@1]
  __b1_from___b2:
    // [45] phi (byte) scroll_hard::i#2 = (byte) scroll_hard::i#1 [phi:scroll_hard::@2->scroll_hard::@1#0] -- register_copy 
    jmp __b1
}
  // next_char
// Find the next char of the scroll text
next_char: {
    // [57] (byte) next_char::c#0 ← *((byte*) nxt#31) -- vbuxx=_deref_pbuz1 
    ldy #0
    lda (nxt),y
    tax
    // [58] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1_from_next_char
    jmp __b2
    // next_char::@2
  __b2:
    // [59] (byte) next_char::c#1 ← *((const byte*) TEXT) -- vbuxx=_deref_pbuc1 
    ldx TEXT
    // [60] phi from next_char::@2 to next_char::@1 [phi:next_char::@2->next_char::@1]
  __b1_from___b2:
    // [60] phi (byte) next_char::return#1 = (byte) next_char::c#1 [phi:next_char::@2->next_char::@1#0] -- register_copy 
    // [60] phi (byte*) nxt#18 = (const byte*) TEXT [phi:next_char::@2->next_char::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    jmp __b1
    // [60] phi from next_char to next_char::@1 [phi:next_char->next_char::@1]
  __b1_from_next_char:
    // [60] phi (byte) next_char::return#1 = (byte) next_char::c#0 [phi:next_char->next_char::@1#0] -- register_copy 
    // [60] phi (byte*) nxt#18 = (byte*) nxt#31 [phi:next_char->next_char::@1#1] -- register_copy 
    jmp __b1
    // next_char::@1
  __b1:
    // [61] (byte*) nxt#19 ← ++ (byte*) nxt#18 -- pbuz1=_inc_pbuz1 
    inc.z nxt
    bne !+
    inc.z nxt+1
  !:
    jmp __breturn
    // next_char::@return
  __breturn:
    // [62] return 
    rts
}
  // fillscreen
// Fill the screen with one char
fillscreen: {
    .const fill = $20
    .label cursor = 7
    // [64] phi from fillscreen to fillscreen::@1 [phi:fillscreen->fillscreen::@1]
  __b1_from_fillscreen:
    // [64] phi (byte*) fillscreen::cursor#2 = (const byte*) SCREEN [phi:fillscreen->fillscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z cursor
    lda #>SCREEN
    sta.z cursor+1
    jmp __b1
    // fillscreen::@1
  __b1:
    // [65] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z cursor+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z cursor
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    jmp __breturn
    // fillscreen::@return
  __breturn:
    // [66] return 
    rts
    // fillscreen::@2
  __b2:
    // [67] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 -- _deref_pbuz1=vbuc1 
    lda #fill
    ldy #0
    sta (cursor),y
    // [68] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z cursor
    bne !+
    inc.z cursor+1
  !:
    // [64] phi from fillscreen::@2 to fillscreen::@1 [phi:fillscreen::@2->fillscreen::@1]
  __b1_from___b2:
    // [64] phi (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#1 [phi:fillscreen::@2->fillscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  TEXT: .text "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
  .byte 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b8
Removing instruction jmp __b1
Removing instruction jmp __b7
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __bbegin with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from_scroll_soft with __b1
Replacing label __b1_from_scroll_bit with __b1
Replacing label __b3_from___b4 with __b3
Replacing label __b1_from_next_char with __b1
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b4:
Removing instruction __b2_from_scroll_soft:
Removing instruction __b1_from_scroll_soft:
Removing instruction __b2_from_scroll_bit:
Removing instruction __b1_from_scroll_bit:
Removing instruction scroll_hard_from___b1:
Removing instruction __b3_from___b4:
Removing instruction __b5_from___b3:
Removing instruction __b4_from___b5:
Removing instruction __b1_from_next_char:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction fillscreen_from_main:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b2:
Removing instruction __b1_from___b2:
Removing instruction __breturn:
Removing instruction __b2:
Removing instruction __b8:
Removing instruction __b1_from___b8:
Removing instruction __b7:
Removing instruction __b3_from___b7:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __breturn:
Removing instruction __b1_from_scroll_hard:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction __b2:
Removing instruction __b1_from___b2:
Removing instruction __breturn:
Removing instruction __b1_from_fillscreen:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Relabelling long label __b4_from___b3 to b1
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b1:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) BGCOL BGCOL = (byte*) 53280
(const byte*) CHARGEN CHARGEN = (byte*) 53248
(const byte*) PROCPORT PROCPORT = (byte*) 1
(const byte*) RASTER RASTER = (byte*) 53266
(const byte*) SCREEN SCREEN = (byte*) 1024
(const byte*) SCROLL SCROLL = (byte*) 53270
(const byte*) TEXT TEXT = (string) "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
(byte) current_bit
(byte) current_bit#12 current_bit zp ZP_BYTE:2 3.0
(byte) current_bit#21 current_bit zp ZP_BYTE:2 5.833333333333333
(byte) current_bit#29 current_bit zp ZP_BYTE:2 31.0
(byte) current_bit#5 current_bit zp ZP_BYTE:2 3.0
(byte*) current_chargen
(byte*) current_chargen#11 current_chargen zp ZP_WORD:7 3.0
(byte*) current_chargen#19 current_chargen zp ZP_WORD:7 5.944444444444444
(byte*) current_chargen#27 current_chargen zp ZP_WORD:7 24.111111111111107
(byte*) current_chargen#5 current_chargen zp ZP_WORD:7 4.0
(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
(label) fillscreen::@1
(label) fillscreen::@2
(label) fillscreen::@return
(byte*) fillscreen::cursor
(byte*) fillscreen::cursor#1 cursor zp ZP_WORD:7 22.0
(byte*) fillscreen::cursor#2 cursor zp ZP_WORD:7 14.666666666666666
(byte) fillscreen::fill
(const byte) fillscreen::fill#0 fill = (byte) $20
(byte*) fillscreen::screen
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(byte()) next_char()
(label) next_char::@1
(label) next_char::@2
(label) next_char::@return
(byte) next_char::c
(byte) next_char::c#0 reg byte x 3.0
(byte) next_char::c#1 reg byte x 4.0
(byte) next_char::return
(byte) next_char::return#0 reg byte a 4.0
(byte) next_char::return#1 reg byte x 1.5
(byte*) nxt
(byte*) nxt#14 nxt zp ZP_WORD:5 3.0
(byte*) nxt#18 nxt zp ZP_WORD:5 4.0
(byte*) nxt#19 nxt zp ZP_WORD:5 0.5714285714285714
(byte*) nxt#31 nxt zp ZP_WORD:5 18.41666666666667
(byte*) nxt#35 nxt zp ZP_WORD:5 0.3333333333333333
(byte) scroll
(byte) scroll#10 reg byte x 3.0
(byte) scroll#18 reg byte x 53.75
(byte) scroll#3 reg byte x 3.0
(void()) scroll_bit()
(word~) scroll_bit::$7 $7 zp ZP_WORD:7 4.0
(byte~) scroll_bit::$9 reg byte a 202.0
(label) scroll_bit::@1
(label) scroll_bit::@2
(label) scroll_bit::@3
(label) scroll_bit::@4
(label) scroll_bit::@5
(label) scroll_bit::@6
(label) scroll_bit::@7
(label) scroll_bit::@8
(label) scroll_bit::@return
(byte) scroll_bit::b
(byte) scroll_bit::b#2 reg byte a 101.0
(byte) scroll_bit::bits
(byte) scroll_bit::bits#0 reg byte a 202.0
(word) scroll_bit::c
(word) scroll_bit::c#0 c zp ZP_WORD:7 4.0
(byte) scroll_bit::r
(byte) scroll_bit::r#1 reg byte x 151.5
(byte) scroll_bit::r#2 reg byte x 37.875
(byte*) scroll_bit::sc
(byte*) scroll_bit::sc#1 sc zp ZP_WORD:3 67.33333333333333
(byte*) scroll_bit::sc#2 sc zp ZP_WORD:3 43.285714285714285
(void()) scroll_hard()
(label) scroll_hard::@1
(label) scroll_hard::@2
(label) scroll_hard::@return
(byte) scroll_hard::i
(byte) scroll_hard::i#1 reg byte x 202.0
(byte) scroll_hard::i#2 reg byte x 191.89999999999995
(void()) scroll_soft()
(label) scroll_soft::@1
(label) scroll_soft::@2
(label) scroll_soft::@return

reg byte x [ scroll#18 scroll#10 scroll#3 ]
zp ZP_BYTE:2 [ current_bit#29 current_bit#12 current_bit#21 current_bit#5 ]
reg byte x [ scroll_bit::r#2 scroll_bit::r#1 ]
zp ZP_WORD:3 [ scroll_bit::sc#2 scroll_bit::sc#1 ]
reg byte a [ scroll_bit::b#2 ]
reg byte x [ scroll_hard::i#2 scroll_hard::i#1 ]
zp ZP_WORD:5 [ nxt#18 nxt#31 nxt#14 nxt#35 nxt#19 ]
reg byte x [ next_char::return#1 next_char::c#0 next_char::c#1 ]
zp ZP_WORD:7 [ fillscreen::cursor#2 fillscreen::cursor#1 current_chargen#27 current_chargen#11 current_chargen#19 current_chargen#5 scroll_bit::$7 scroll_bit::c#0 ]
reg byte a [ next_char::return#0 ]
reg byte a [ scroll_bit::bits#0 ]
reg byte a [ scroll_bit::$9 ]


FINAL ASSEMBLER
Score: 20886

  // File Comments
// An 8x8 char letter scroller
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label PROCPORT = 1
  .label CHARGEN = $d000
  .label SCREEN = $400
  .label RASTER = $d012
  .label BGCOL = $d020
  .label SCROLL = $d016
  .label current_bit = 2
  .label current_chargen = 7
  .label nxt = 5
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // fillscreen(SCREEN, $20)
    // [5] call fillscreen 
    // [63] phi from main to fillscreen [phi:main->fillscreen]
    jsr fillscreen
    // [6] phi from main to main::@1 [phi:main->main::@1]
    // [6] phi (byte*) current_chargen#27 = (const byte*) CHARGEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z current_chargen
    lda #>CHARGEN
    sta.z current_chargen+1
    // [6] phi (byte*) nxt#31 = (const byte*) TEXT [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [6] phi (byte) current_bit#29 = (byte) 1 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #1
    sta.z current_bit
    // [6] phi (byte) scroll#18 = (byte) 7 [phi:main->main::@1#3] -- vbuxx=vbuc1 
    ldx #7
  // Wait for raster
    // [6] phi from main::@1 main::@4 to main::@1 [phi:main::@1/main::@4->main::@1]
    // [6] phi (byte*) current_chargen#27 = (byte*) current_chargen#27 [phi:main::@1/main::@4->main::@1#0] -- register_copy 
    // [6] phi (byte*) nxt#31 = (byte*) nxt#31 [phi:main::@1/main::@4->main::@1#1] -- register_copy 
    // [6] phi (byte) current_bit#29 = (byte) current_bit#29 [phi:main::@1/main::@4->main::@1#2] -- register_copy 
    // [6] phi (byte) scroll#18 = (byte) scroll#18 [phi:main::@1/main::@4->main::@1#3] -- register_copy 
    // main::@1
  __b1:
    // while(*RASTER!=$fe)
    // [7] if(*((const byte*) RASTER)!=(byte) $fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp RASTER
    bne __b1
    // main::@2
  __b2:
    // while(*RASTER!=$ff)
    // [8] if(*((const byte*) RASTER)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    // main::@3
    // ++*BGCOL;
    // [9] *((const byte*) BGCOL) ← ++ *((const byte*) BGCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BGCOL
    // scroll_soft()
    // [10] call scroll_soft 
    jsr scroll_soft
    // main::@4
    // --*BGCOL;
    // [11] *((const byte*) BGCOL) ← -- *((const byte*) BGCOL) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec BGCOL
    jmp __b1
}
  // scroll_soft
scroll_soft: {
    // if(--scroll==$ff)
    // [12] (byte) scroll#3 ← -- (byte) scroll#18 -- vbuxx=_dec_vbuxx 
    dex
    // [13] if((byte) scroll#3!=(byte) $ff) goto scroll_soft::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b1
    // [14] phi from scroll_soft to scroll_soft::@2 [phi:scroll_soft->scroll_soft::@2]
    // scroll_soft::@2
    // scroll_bit()
    // [15] call scroll_bit 
    jsr scroll_bit
    // [16] phi from scroll_soft::@2 to scroll_soft::@1 [phi:scroll_soft::@2->scroll_soft::@1]
    // [16] phi (byte*) current_chargen#11 = (byte*) current_chargen#19 [phi:scroll_soft::@2->scroll_soft::@1#0] -- register_copy 
    // [16] phi (byte*) nxt#14 = (byte*) nxt#35 [phi:scroll_soft::@2->scroll_soft::@1#1] -- register_copy 
    // [16] phi (byte) current_bit#12 = (byte) current_bit#21 [phi:scroll_soft::@2->scroll_soft::@1#2] -- register_copy 
    // [16] phi (byte) scroll#10 = (byte) 7 [phi:scroll_soft::@2->scroll_soft::@1#3] -- vbuxx=vbuc1 
    ldx #7
    // [16] phi from scroll_soft to scroll_soft::@1 [phi:scroll_soft->scroll_soft::@1]
    // [16] phi (byte*) current_chargen#11 = (byte*) current_chargen#27 [phi:scroll_soft->scroll_soft::@1#0] -- register_copy 
    // [16] phi (byte*) nxt#14 = (byte*) nxt#31 [phi:scroll_soft->scroll_soft::@1#1] -- register_copy 
    // [16] phi (byte) current_bit#12 = (byte) current_bit#29 [phi:scroll_soft->scroll_soft::@1#2] -- register_copy 
    // [16] phi (byte) scroll#10 = (byte) scroll#3 [phi:scroll_soft->scroll_soft::@1#3] -- register_copy 
    // scroll_soft::@1
  __b1:
    // *SCROLL = scroll
    // [17] *((const byte*) SCROLL) ← (byte) scroll#10 -- _deref_pbuc1=vbuxx 
    stx SCROLL
    // scroll_soft::@return
    // }
    // [18] return 
    rts
}
  // scroll_bit
scroll_bit: {
    .label __7 = 7
    .label c = 7
    .label sc = 3
    // current_bit = current_bit/2
    // [19] (byte) current_bit#5 ← (byte) current_bit#29 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z current_bit
    // if(current_bit==0)
    // [20] if((byte) current_bit#5!=(byte) 0) goto scroll_bit::@1 -- vbuz1_neq_0_then_la1 
    lda.z current_bit
    cmp #0
    bne __b1
    // [21] phi from scroll_bit to scroll_bit::@2 [phi:scroll_bit->scroll_bit::@2]
    // scroll_bit::@2
    // next_char()
    // [22] call next_char 
    jsr next_char
    // [23] (byte) next_char::return#0 ← (byte) next_char::return#1 -- vbuaa=vbuxx 
    txa
    // scroll_bit::@8
    // c = next_char()
    // [24] (word) scroll_bit::c#0 ← (byte) next_char::return#0 -- vwuz1=vbuaa 
    sta.z c
    lda #0
    sta.z c+1
    // c*8
    // [25] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 -- vwuz1=vwuz1_rol_3 
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    // current_chargen = CHARGEN+c*8
    // [26] (byte*) current_chargen#5 ← (const byte*) CHARGEN + (word~) scroll_bit::$7 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z current_chargen
    adc #<CHARGEN
    sta.z current_chargen
    lda.z current_chargen+1
    adc #>CHARGEN
    sta.z current_chargen+1
    // [27] phi from scroll_bit::@8 to scroll_bit::@1 [phi:scroll_bit::@8->scroll_bit::@1]
    // [27] phi (byte*) nxt#35 = (byte*) nxt#19 [phi:scroll_bit::@8->scroll_bit::@1#0] -- register_copy 
    // [27] phi (byte) current_bit#21 = (byte) $80 [phi:scroll_bit::@8->scroll_bit::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta.z current_bit
    // [27] phi (byte*) current_chargen#19 = (byte*) current_chargen#5 [phi:scroll_bit::@8->scroll_bit::@1#2] -- register_copy 
    // [27] phi from scroll_bit to scroll_bit::@1 [phi:scroll_bit->scroll_bit::@1]
    // [27] phi (byte*) nxt#35 = (byte*) nxt#31 [phi:scroll_bit->scroll_bit::@1#0] -- register_copy 
    // [27] phi (byte) current_bit#21 = (byte) current_bit#5 [phi:scroll_bit->scroll_bit::@1#1] -- register_copy 
    // [27] phi (byte*) current_chargen#19 = (byte*) current_chargen#27 [phi:scroll_bit->scroll_bit::@1#2] -- register_copy 
    // scroll_bit::@1
  __b1:
    // scroll_hard()
    // [28] call scroll_hard 
    // [44] phi from scroll_bit::@1 to scroll_hard [phi:scroll_bit::@1->scroll_hard]
    jsr scroll_hard
    // scroll_bit::@7
    // asm
    // asm { sei  }
    sei
    // *PROCPORT = $32
    // [30] *((const byte*) PROCPORT) ← (byte) $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [31] phi from scroll_bit::@7 to scroll_bit::@3 [phi:scroll_bit::@7->scroll_bit::@3]
    // [31] phi (byte*) scroll_bit::sc#2 = (const byte*) SCREEN+(byte) $28+(byte) $27 [phi:scroll_bit::@7->scroll_bit::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28+$27
    sta.z sc
    lda #>SCREEN+$28+$27
    sta.z sc+1
    // [31] phi (byte) scroll_bit::r#2 = (byte) 0 [phi:scroll_bit::@7->scroll_bit::@3#1] -- vbuxx=vbuc1 
    ldx #0
    // [31] phi from scroll_bit::@4 to scroll_bit::@3 [phi:scroll_bit::@4->scroll_bit::@3]
    // [31] phi (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#1 [phi:scroll_bit::@4->scroll_bit::@3#0] -- register_copy 
    // [31] phi (byte) scroll_bit::r#2 = (byte) scroll_bit::r#1 [phi:scroll_bit::@4->scroll_bit::@3#1] -- register_copy 
    // scroll_bit::@3
  __b3:
    // bits = current_chargen[r]
    // [32] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#19 + (byte) scroll_bit::r#2) -- vbuaa=pbuz1_derefidx_vbuxx 
    txa
    tay
    lda (current_chargen),y
    // bits & current_bit
    // [33] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#21 -- vbuaa=vbuaa_band_vbuz1 
    and.z current_bit
    // if((bits & current_bit) != 0)
    // [34] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq b1
    // [35] phi from scroll_bit::@3 to scroll_bit::@5 [phi:scroll_bit::@3->scroll_bit::@5]
    // scroll_bit::@5
    // [36] phi from scroll_bit::@5 to scroll_bit::@4 [phi:scroll_bit::@5->scroll_bit::@4]
    // [36] phi (byte) scroll_bit::b#2 = (byte) $80+(byte) ' ' [phi:scroll_bit::@5->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #$80+' '
    jmp __b4
    // [36] phi from scroll_bit::@3 to scroll_bit::@4 [phi:scroll_bit::@3->scroll_bit::@4]
  b1:
    // [36] phi (byte) scroll_bit::b#2 = (byte) ' ' [phi:scroll_bit::@3->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #' '
    // scroll_bit::@4
  __b4:
    // *sc = b
    // [37] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sc),y
    // sc = sc+40
    // [38] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z sc
    sta.z sc
    bcc !+
    inc.z sc+1
  !:
    // for(byte r:0..7)
    // [39] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2 -- vbuxx=_inc_vbuxx 
    inx
    // [40] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3
    // scroll_bit::@6
    // *PROCPORT = $37
    // [41] *((const byte*) PROCPORT) ← (byte) $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm
    // asm { cli  }
    cli
    // scroll_bit::@return
    // }
    // [43] return 
    rts
}
  // scroll_hard
scroll_hard: {
    // [45] phi from scroll_hard to scroll_hard::@1 [phi:scroll_hard->scroll_hard::@1]
    // [45] phi (byte) scroll_hard::i#2 = (byte) 0 [phi:scroll_hard->scroll_hard::@1#0] -- vbuxx=vbuc1 
    ldx #0
  // Hard scroll
    // scroll_hard::@1
  __b1:
    // for(byte i=0;i!=39;i++)
    // [46] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$27
    bne __b2
    // scroll_hard::@return
    // }
    // [47] return 
    rts
    // scroll_hard::@2
  __b2:
    // (SCREEN+40*0)[i]=(SCREEN+40*0)[i+1]
    // [48] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+1,x
    sta SCREEN,x
    // (SCREEN+40*1)[i]=(SCREEN+40*1)[i+1]
    // [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*1+1,x
    sta SCREEN+$28*1,x
    // (SCREEN+40*2)[i]=(SCREEN+40*2)[i+1]
    // [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*2+1,x
    sta SCREEN+$28*2,x
    // (SCREEN+40*3)[i]=(SCREEN+40*3)[i+1]
    // [51] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*3+1,x
    sta SCREEN+$28*3,x
    // (SCREEN+40*4)[i]=(SCREEN+40*4)[i+1]
    // [52] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*4+1,x
    sta SCREEN+$28*4,x
    // (SCREEN+40*5)[i]=(SCREEN+40*5)[i+1]
    // [53] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*5+1,x
    sta SCREEN+$28*5,x
    // (SCREEN+40*6)[i]=(SCREEN+40*6)[i+1]
    // [54] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*6+1,x
    sta SCREEN+$28*6,x
    // (SCREEN+40*7)[i]=(SCREEN+40*7)[i+1]
    // [55] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*7+1,x
    sta SCREEN+$28*7,x
    // for(byte i=0;i!=39;i++)
    // [56] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [45] phi from scroll_hard::@2 to scroll_hard::@1 [phi:scroll_hard::@2->scroll_hard::@1]
    // [45] phi (byte) scroll_hard::i#2 = (byte) scroll_hard::i#1 [phi:scroll_hard::@2->scroll_hard::@1#0] -- register_copy 
    jmp __b1
}
  // next_char
// Find the next char of the scroll text
next_char: {
    // c = *nxt
    // [57] (byte) next_char::c#0 ← *((byte*) nxt#31) -- vbuxx=_deref_pbuz1 
    ldy #0
    lda (nxt),y
    tax
    // if(c==0)
    // [58] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1
    // next_char::@2
    // c = *nxt
    // [59] (byte) next_char::c#1 ← *((const byte*) TEXT) -- vbuxx=_deref_pbuc1 
    ldx TEXT
    // [60] phi from next_char::@2 to next_char::@1 [phi:next_char::@2->next_char::@1]
    // [60] phi (byte) next_char::return#1 = (byte) next_char::c#1 [phi:next_char::@2->next_char::@1#0] -- register_copy 
    // [60] phi (byte*) nxt#18 = (const byte*) TEXT [phi:next_char::@2->next_char::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [60] phi from next_char to next_char::@1 [phi:next_char->next_char::@1]
    // [60] phi (byte) next_char::return#1 = (byte) next_char::c#0 [phi:next_char->next_char::@1#0] -- register_copy 
    // [60] phi (byte*) nxt#18 = (byte*) nxt#31 [phi:next_char->next_char::@1#1] -- register_copy 
    // next_char::@1
  __b1:
    // nxt++;
    // [61] (byte*) nxt#19 ← ++ (byte*) nxt#18 -- pbuz1=_inc_pbuz1 
    inc.z nxt
    bne !+
    inc.z nxt+1
  !:
    // next_char::@return
    // }
    // [62] return 
    rts
}
  // fillscreen
// Fill the screen with one char
fillscreen: {
    .const fill = $20
    .label cursor = 7
    // [64] phi from fillscreen to fillscreen::@1 [phi:fillscreen->fillscreen::@1]
    // [64] phi (byte*) fillscreen::cursor#2 = (const byte*) SCREEN [phi:fillscreen->fillscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z cursor
    lda #>SCREEN
    sta.z cursor+1
    // fillscreen::@1
  __b1:
    // for( byte* cursor = screen; cursor < screen+1000; cursor++)
    // [65] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z cursor+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z cursor
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // fillscreen::@return
    // }
    // [66] return 
    rts
    // fillscreen::@2
  __b2:
    // *cursor = fill
    // [67] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 -- _deref_pbuz1=vbuc1 
    lda #fill
    ldy #0
    sta (cursor),y
    // for( byte* cursor = screen; cursor < screen+1000; cursor++)
    // [68] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z cursor
    bne !+
    inc.z cursor+1
  !:
    // [64] phi from fillscreen::@2 to fillscreen::@1 [phi:fillscreen::@2->fillscreen::@1]
    // [64] phi (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#1 [phi:fillscreen::@2->fillscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  TEXT: .text "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
  .byte 0

