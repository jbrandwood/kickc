byte cnt = 0;
byte cnt2 = 0;
byte[256] SCREEN=$0400;

main();

void main() {
  SCREEN[0]=inccnt();
  cnt++;
  SCREEN[1]=inccnt();
}

byte inccnt() {
    ++cnt;
    ++cnt2;
    return cnt;
}




Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt2 ← ++ (byte) cnt2
PROGRAM
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  proc (void()) main()
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
main::@return:
  return 
  endproc // main()
  proc (byte()) inccnt()
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  goto inccnt::@return
inccnt::@return:
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  endproc // inccnt()

SYMBOLS
(void~) $0
(byte[256]) SCREEN
(byte) cnt
(byte) cnt2
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(void()) main()
(byte~) main::$0
(byte~) main::$1
(label) main::@return

INITIAL CONTROL FLOW GRAPH
@BEGIN: from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: from
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main
  return 
  to:@RETURN
@1: from @BEGIN
  to:@2
inccnt: from
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: from inccnt inccnt::@1
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  to:@RETURN
inccnt::@1: from
  to:inccnt::@return
@2: from @1
  to:@END
@END: from @2

Removing empty block @1
Removing empty block inccnt::@1
Removing empty block @2
CONTROL FLOW GRAPH
@BEGIN: from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@END
main: from
  (byte~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte~) main::$1 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main
  return 
  to:@RETURN
inccnt: from
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) inccnt::return ← (byte) inccnt::return
  return (byte) inccnt::return
  to:@RETURN
@END: from @BEGIN

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies cnt
main modifies cnt2
inccnt modifies cnt
inccnt modifies cnt2

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@BEGIN: from
  (byte) cnt ← (byte) 0
  (byte) cnt2 ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  call main param-assignment
  to:@3
@3: from @BEGIN
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  to:@END
main: from @BEGIN
  (byte) inccnt::return ← call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  *((byte[256]) SCREEN + (byte) 0) ← (byte~) main::$0
  (byte) cnt ← ++ (byte) cnt
  (byte) inccnt::return ← call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  *((byte[256]) SCREEN + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt ← ++ (byte) cnt
  (byte) cnt2 ← ++ (byte) cnt2
  (byte) inccnt::return ← (byte) cnt
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) inccnt::return ← (byte) inccnt::return
  (byte) cnt ← (byte) cnt
  (byte) cnt2 ← (byte) cnt2
  return (byte) inccnt::return
  to:@RETURN
@END: from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@BEGIN: from
  (byte) cnt#0 ← (byte) 0
  (byte) cnt2#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: from @BEGIN
  (byte) cnt2#7 ← phi( @BEGIN/(byte) cnt2#0 )
  (byte) cnt#8 ← phi( @BEGIN/(byte) cnt#0 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  to:@END
main: from @BEGIN
  (byte[256]) SCREEN#3 ← phi( @BEGIN/(byte[256]) SCREEN#0 )
  (byte) cnt2#13 ← phi( @BEGIN/(byte) cnt2#0 )
  (byte) cnt#14 ← phi( @BEGIN/(byte) cnt#0 )
  (byte) inccnt::return#0 ← call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#13 )
  (byte) cnt#9 ← phi( main/(byte) cnt#14 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  (byte) inccnt::return#1 ← call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#2 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#3 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  return (byte) inccnt::return#3
  to:@RETURN
@END: from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@BEGIN: from
  (byte) cnt#0 ← (byte) 0
  (byte) cnt2#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: from @BEGIN
  (byte) cnt2#7 ← phi( @BEGIN/(byte) cnt2#4 )
  (byte) cnt#8 ← phi( @BEGIN/(byte) cnt#5 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  to:@END
main: from @BEGIN
  (byte[256]) SCREEN#3 ← phi( @BEGIN/(byte[256]) SCREEN#0 )
  (byte) cnt2#13 ← phi( @BEGIN/(byte) cnt2#0 )
  (byte) cnt#14 ← phi( @BEGIN/(byte) cnt#0 )
  call inccnt param-assignment
  (byte) inccnt::return#0 ← (byte) inccnt::return#3
  to:main::@1
main::@1: from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#6 )
  (byte) cnt#9 ← phi( main/(byte) cnt#7 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  (byte) inccnt::return#1 ← (byte) inccnt::return#3
  to:main::@2
main::@2: from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#6 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#7 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  return 
  to:@RETURN
@END: from @3

Constant (byte) cnt#0 (byte) 0
Constant (byte) cnt2#0 (byte) 0
Constant (byte[256]) SCREEN#0 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@3
@3: from @BEGIN
  (byte) cnt2#7 ← phi( @BEGIN/(byte) cnt2#4 )
  (byte) cnt#8 ← phi( @BEGIN/(byte) cnt#5 )
  (byte) cnt#1 ← (byte) cnt#8
  (byte) cnt2#1 ← (byte) cnt2#7
  to:@END
main: from @BEGIN
  (byte[256]) SCREEN#3 ← phi( @BEGIN/(word) 1024 )
  (byte) cnt2#13 ← phi( @BEGIN/(byte) 0 )
  (byte) cnt#14 ← phi( @BEGIN/(byte) 0 )
  call inccnt param-assignment
  (byte) inccnt::return#0 ← (byte) inccnt::return#3
  to:main::@1
main::@1: from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt2#8 ← phi( main/(byte) cnt2#6 )
  (byte) cnt#9 ← phi( main/(byte) cnt#7 )
  (byte) inccnt::return#4 ← phi( main/(byte) inccnt::return#0 )
  (byte~) main::$0 ← (byte) inccnt::return#4
  (byte) cnt#2 ← (byte) cnt#9
  (byte) cnt2#2 ← (byte) cnt2#8
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  (byte) inccnt::return#1 ← (byte) inccnt::return#3
  to:main::@2
main::@2: from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt2#9 ← phi( main::@1/(byte) cnt2#6 )
  (byte) cnt#10 ← phi( main::@1/(byte) cnt#7 )
  (byte) inccnt::return#5 ← phi( main::@1/(byte) inccnt::return#1 )
  (byte~) main::$1 ← (byte) inccnt::return#5
  (byte) cnt#4 ← (byte) cnt#10
  (byte) cnt2#3 ← (byte) cnt2#9
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  (byte) cnt2#10 ← phi( main::@2/(byte) cnt2#3 )
  (byte) cnt#11 ← phi( main::@2/(byte) cnt#4 )
  (byte) cnt#5 ← (byte) cnt#11
  (byte) cnt2#4 ← (byte) cnt2#10
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#2 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#6 ← ++ (byte) cnt#12
  (byte) cnt2#5 ← ++ (byte) cnt2#11
  (byte) inccnt::return#2 ← (byte) cnt#6
  to:inccnt::@return
inccnt::@return: from inccnt
  (byte) cnt2#12 ← phi( inccnt/(byte) cnt2#5 )
  (byte) cnt#13 ← phi( inccnt/(byte) cnt#6 )
  (byte) inccnt::return#6 ← phi( inccnt/(byte) inccnt::return#2 )
  (byte) inccnt::return#3 ← (byte) inccnt::return#6
  (byte) cnt#7 ← (byte) cnt#13
  (byte) cnt2#6 ← (byte) cnt2#12
  return 
  to:@RETURN
@END: from @3

Not aliassing across scopes: main::$0 inccnt::return#4
Not aliassing across scopes: main::$1 inccnt::return#5
Not aliassing across scopes: inccnt::return#2 cnt#6
Alias (byte) cnt#1 = (byte) cnt#8 (byte) cnt#5 (byte) cnt#9 (byte) cnt#7 (byte) cnt#2 (byte) cnt#10 (byte) cnt#4 (byte) cnt#11 (byte) cnt#13 (byte) cnt#6 
Alias (byte) cnt2#1 = (byte) cnt2#7 (byte) cnt2#4 (byte) cnt2#8 (byte) cnt2#6 (byte) cnt2#2 (byte) cnt2#9 (byte) cnt2#3 (byte) cnt2#10 (byte) cnt2#12 (byte) cnt2#5 
Alias (byte) inccnt::return#0 = (byte) inccnt::return#3 (byte) inccnt::return#4 (byte) inccnt::return#1 (byte) inccnt::return#5 (byte) inccnt::return#6 (byte) inccnt::return#2 
Alias (byte[256]) SCREEN#1 = (byte[256]) SCREEN#3 (byte[256]) SCREEN#2 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@3
@3: from @BEGIN
  to:@END
main: from @BEGIN
  (byte[256]) SCREEN#1 ← phi( @BEGIN/(word) 1024 )
  (byte) cnt2#13 ← phi( @BEGIN/(byte) 0 )
  (byte) cnt#14 ← phi( @BEGIN/(byte) 0 )
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((byte[256]) SCREEN#1 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) cnt2#13 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) cnt#14 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@RETURN
@END: from @3

Redundant Phi (byte) cnt#14 (byte) 0
Redundant Phi (byte) cnt2#13 (byte) 0
Redundant Phi (byte[256]) SCREEN#1 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@3
@3: from @BEGIN
  to:@END
main: from @BEGIN
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@RETURN
@END: from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 0) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1024 + (byte) 1) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@RETURN
@END: from @BEGIN

Consolidated assigned array index constant in assignment *(1024)
Consolidated assigned array index constant in assignment *(1025)
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@BEGIN: from
  call main param-assignment
  to:@END
main: from @BEGIN
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1025) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@RETURN
@END: from @BEGIN

Not aliassing across scopes: main::$0 inccnt::return#0
Not aliassing across scopes: main::$1 inccnt::return#0
Not aliassing across scopes: inccnt::return#0 cnt#1
Not aliassing across scopes: main::$0 inccnt::return#0
Not aliassing across scopes: main::$1 inccnt::return#0
Not aliassing across scopes: inccnt::return#0 cnt#1
Block Sequence Planned @BEGIN @END main main::@1 main::@2 main::@return inccnt inccnt::@return 
Block Sequence Planned @BEGIN @END main main::@1 main::@2 main::@return inccnt inccnt::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@BEGIN: from
  call main param-assignment
  to:@END
@END: from @BEGIN
main: from @BEGIN
  call inccnt param-assignment
  to:main::@1
main::@1: from main
  (byte~) main::$0 ← (byte) inccnt::return#0
  *((word) 1024) ← (byte~) main::$0
  (byte) cnt#3 ← ++ (byte) cnt#1
  (byte~) cnt#15 ← (byte) cnt#3
  (byte~) cnt2#14 ← (byte) cnt2#1
  call inccnt param-assignment
  to:main::@2
main::@2: from main::@1
  (byte~) main::$1 ← (byte) inccnt::return#0
  *((word) 1025) ← (byte~) main::$1
  to:main::@return
main::@return: from main::@2
  return 
  to:@RETURN
inccnt: from main main::@1
  (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt2#14 )
  (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte~) cnt#15 )
  (byte) cnt#1 ← ++ (byte) cnt#12
  (byte) cnt2#1 ← ++ (byte) cnt2#11
  (byte) inccnt::return#0 ← (byte) cnt#1
  to:inccnt::@return
inccnt::@return: from inccnt
  return 
  to:@RETURN

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:main::@1
main::@1: from main
  [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
  [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ]
  [5] (byte~) cnt#15 ← (byte) cnt#3 [ cnt2#1 cnt#15 ]
  [6] (byte~) cnt2#14 ← (byte) cnt2#1 [ cnt#15 cnt2#14 ]
  [7] call inccnt param-assignment [ inccnt::return#0 ]
  to:main::@2
main::@2: from main::@1
  [8] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  [9] *((word) 1025) ← (byte~) main::$1 [ ]
  to:main::@return
main::@return: from main::@2
  [10] return  [ ]
  to:@RETURN
inccnt: from main main::@1
  [11] (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte~) cnt2#14 ) [ cnt#12 cnt2#11 ]
  [11] (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte~) cnt#15 ) [ cnt#12 cnt2#11 ]
  [12] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ]
  [13] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ]
  [14] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:inccnt::@return
inccnt::@return: from inccnt
  [15] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:@RETURN

Created 2 initial phi equivalence classes
Coalesced [5] cnt#15 ← cnt#3
Coalesced [6] cnt2#14 ← cnt2#1
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @BEGIN @END main main::@1 main::@2 main::@return inccnt inccnt::@return 
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@BEGIN: from
  [0] call main param-assignment [ ]
  to:@END
@END: from @BEGIN
main: from @BEGIN
  [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:main::@1
main::@1: from main
  [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
  [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ]
  [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ]
  [5] call inccnt param-assignment [ inccnt::return#0 ]
  to:main::@2
main::@2: from main::@1
  [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  [7] *((word) 1025) ← (byte~) main::$1 [ ]
  to:main::@return
main::@return: from main::@2
  [8] return  [ ]
  to:@RETURN
inccnt: from main main::@1
  [9] (byte) cnt2#11 ← phi( main/(byte) 0 main::@1/(byte) cnt2#1 ) [ cnt#12 cnt2#11 ]
  [9] (byte) cnt#12 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 ) [ cnt#12 cnt2#11 ]
  [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ]
  [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ]
  [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:inccnt::@return
inccnt::@return: from inccnt
  [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  to:@RETURN

CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 1:inccnt 5:inccnt 

DOMINATORS
@BEGIN dominated by  @BEGIN 
@END dominated by  @BEGIN @END 
main dominated by  @BEGIN main 
main::@1 dominated by  @BEGIN main::@1 main 
main::@2 dominated by  @BEGIN main::@2 main::@1 main 
main::@return dominated by  @BEGIN main::@return main::@2 main::@1 main 
inccnt dominated by  @BEGIN inccnt main 
inccnt::@return dominated by  inccnt::@return @BEGIN inccnt main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [inccnt]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 0.8571428571428571
(byte) cnt#12 4.0
(byte) cnt#3 4.0
(byte) cnt2
(byte) cnt2#1 0.5714285714285714
(byte) cnt2#11 2.0
(byte()) inccnt()
(byte) inccnt::return
(byte) inccnt::return#0 1.5
(void()) main()
(byte~) main::$0 4.0
(byte~) main::$1 4.0

Initial phi equivalence classes
[ cnt#12 cnt#3 ]
[ cnt2#11 cnt2#1 ]
Added variable main::$0 to zero page equivalence class [ main::$0 ]
Added variable main::$1 to zero page equivalence class [ main::$1 ]
Added variable cnt#1 to zero page equivalence class [ cnt#1 ]
Added variable inccnt::return#0 to zero page equivalence class [ inccnt::return#0 ]
Complete equivalence classes
[ cnt#12 cnt#3 ]
[ cnt2#11 cnt2#1 ]
[ main::$0 ]
[ main::$1 ]
[ cnt#1 ]
[ inccnt::return#0 ]
Allocated zp byte:2 to zp byte:2 [ cnt#12 cnt#3 ]
Allocated zp byte:3 to zp byte:3 [ cnt2#11 cnt2#1 ]
Allocated zp byte:4 to zp byte:4 [ main::$0 ]
Allocated zp byte:5 to zp byte:5 [ main::$1 ]
Allocated zp byte:6 to zp byte:6 [ cnt#1 ]
Allocated zp byte:7 to zp byte:7 [ inccnt::return#0 ]
INITIAL ASM
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
  jmp BEND
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
//SEG5 [9] phi from main to inccnt
inccnt_from_main:
//SEG6 [9] phi (byte) cnt2#11 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 3
//SEG7 [9] phi (byte) cnt#12 = (byte) 0 -- zpby1=coby1 
  lda #0
  sta 2
  jsr inccnt
  jmp main__B1
//SEG8 main::@1
main__B1:
//SEG9 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ] -- zpby1=zpby2 
  lda 7
  sta 4
//SEG10 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ] -- _star_cowo1=zpby1 
  lda 4
  sta 1024
//SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ] -- zpby1=_inc_zpby2 
  lda 6
  sta 2
  inc 2
//SEG12 [5] call inccnt param-assignment [ inccnt::return#0 ]
//SEG13 [9] phi from main::@1 to inccnt
inccnt_from_B1:
//SEG14 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
//SEG15 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
  jsr inccnt
  jmp main__B2
//SEG16 main::@2
main__B2:
//SEG17 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ] -- zpby1=zpby2 
  lda 7
  sta 5
//SEG18 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=zpby1 
  lda 5
  sta 1025
  jmp main__Breturn
//SEG19 main::@return
main__Breturn:
//SEG20 [8] return  [ ]
  rts
//SEG21 inccnt
inccnt:
//SEG22 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ] -- zpby1=_inc_zpby2 
  lda 2
  sta 6
  inc 6
//SEG23 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ] -- zpby1=_inc_zpby1 
  inc 3
//SEG24 [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ] -- zpby1=zpby2 
  lda 6
  sta 7
  jmp inccnt__Breturn
//SEG25 inccnt::@return
inccnt__Breturn:
//SEG26 [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  rts

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp byte:2 [ cnt#12 cnt#3 ] : zp byte:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:3 [ cnt2#11 cnt2#1 ] : zp byte:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:4 [ main::$0 ] : zp byte:4 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:5 [ main::$1 ] : zp byte:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:6 [ cnt#1 ] : zp byte:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:7 [ inccnt::return#0 ] : zp byte:7 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 8: zp byte:2 [ cnt#12 cnt#3 ] 2.57: zp byte:3 [ cnt2#11 cnt2#1 ] 0.86: zp byte:6 [ cnt#1 ] 
Uplift Scope [main] 4: zp byte:4 [ main::$0 ] 4: zp byte:5 [ main::$1 ] 
Uplift Scope [inccnt] 1.5: zp byte:7 [ inccnt::return#0 ] 

Uplifting [] best 84 combination reg byte x [ cnt#12 cnt#3 ] reg byte y [ cnt2#11 cnt2#1 ] reg byte x [ cnt#1 ] 
Uplifting [main] best 72 combination reg byte a [ main::$0 ] reg byte a [ main::$1 ] 
Uplifting [inccnt] best 65 combination reg byte a [ inccnt::return#0 ] 
MISSING FRAGMENTS
  zpby1=_inc_xby
  zpby1=_inc_yby
  aby=_inc_xby
  aby=_inc_yby
  yby=_inc_xby
  xby=_inc_yby
Removing instruction jmp BEND
Removing instruction jmp main__B1
Removing instruction jmp main__B2
Removing instruction jmp main__Breturn
Removing instruction jmp inccnt__Breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
//SEG5 [9] phi from main to inccnt
inccnt_from_main:
//SEG6 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
  ldy #0
//SEG7 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
  ldx #0
  jsr inccnt
//SEG8 main::@1
main__B1:
//SEG9 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
  // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
//SEG10 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ] -- _star_cowo1=aby 
  sta 1024
//SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ] -- xby=_inc_xby 
  inx
//SEG12 [5] call inccnt param-assignment [ inccnt::return#0 ]
//SEG13 [9] phi from main::@1 to inccnt
inccnt_from_B1:
//SEG14 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
//SEG15 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
  jsr inccnt
//SEG16 main::@2
main__B2:
//SEG17 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
//SEG18 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
  sta 1025
//SEG19 main::@return
main__Breturn:
//SEG20 [8] return  [ ]
  rts
//SEG21 inccnt
inccnt:
//SEG22 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ] -- xby=_inc_xby 
  inx
//SEG23 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ] -- yby=_inc_yby 
  iny
//SEG24 [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ] -- aby=xby 
  txa
//SEG25 inccnt::@return
inccnt__Breturn:
//SEG26 [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  rts

FINAL SYMBOL TABLE
(label) @BEGIN
(label) @END
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 reg byte x 0.8571428571428571
(byte) cnt#12 reg byte x 4.0
(byte) cnt#3 reg byte x 4.0
(byte) cnt2
(byte) cnt2#1 reg byte y 0.5714285714285714
(byte) cnt2#11 reg byte y 2.0
(byte()) inccnt()
(label) inccnt::@return
(byte) inccnt::return
(byte) inccnt::return#0 reg byte a 1.5
(void()) main()
(byte~) main::$0 reg byte a 4.0
(byte~) main::$1 reg byte a 4.0
(label) main::@1
(label) main::@2
(label) main::@return

reg byte x [ cnt#12 cnt#3 ]
reg byte y [ cnt2#11 cnt2#1 ]
reg byte a [ main::$0 ]
reg byte a [ main::$1 ]
reg byte x [ cnt#1 ]
reg byte a [ inccnt::return#0 ]

FINAL CODE
//SEG0 @BEGIN
BBEGIN:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @END
BEND:
//SEG3 main
main:
//SEG4 [1] call inccnt param-assignment [ inccnt::return#0 cnt#1 cnt2#1 ]
//SEG5 [9] phi from main to inccnt
inccnt_from_main:
//SEG6 [9] phi (byte) cnt2#11 = (byte) 0 -- yby=coby1 
  ldy #0
//SEG7 [9] phi (byte) cnt#12 = (byte) 0 -- xby=coby1 
  ldx #0
  jsr inccnt
//SEG8 main::@1
main__B1:
//SEG9 [2] (byte~) main::$0 ← (byte) inccnt::return#0 [ main::$0 cnt#1 cnt2#1 ]
  // (byte~) main::$0 = (byte) inccnt::return#0  // register copy reg byte a
//SEG10 [3] *((word) 1024) ← (byte~) main::$0 [ cnt#1 cnt2#1 ] -- _star_cowo1=aby 
  sta 1024
//SEG11 [4] (byte) cnt#3 ← ++ (byte) cnt#1 [ cnt#3 cnt2#1 ] -- xby=_inc_xby 
  inx
//SEG12 [5] call inccnt param-assignment [ inccnt::return#0 ]
//SEG13 [9] phi from main::@1 to inccnt
inccnt_from_B1:
//SEG14 [9] phi (byte) cnt2#11 = (byte) cnt2#1 -- register_copy 
//SEG15 [9] phi (byte) cnt#12 = (byte) cnt#3 -- register_copy 
  jsr inccnt
//SEG16 main::@2
main__B2:
//SEG17 [6] (byte~) main::$1 ← (byte) inccnt::return#0 [ main::$1 ]
  // (byte~) main::$1 = (byte) inccnt::return#0  // register copy reg byte a
//SEG18 [7] *((word) 1025) ← (byte~) main::$1 [ ] -- _star_cowo1=aby 
  sta 1025
//SEG19 main::@return
main__Breturn:
//SEG20 [8] return  [ ]
  rts
//SEG21 inccnt
inccnt:
//SEG22 [10] (byte) cnt#1 ← ++ (byte) cnt#12 [ cnt#1 cnt2#11 ] -- xby=_inc_xby 
  inx
//SEG23 [11] (byte) cnt2#1 ← ++ (byte) cnt2#11 [ cnt#1 cnt2#1 ] -- yby=_inc_yby 
  iny
//SEG24 [12] (byte) inccnt::return#0 ← (byte) cnt#1 [ inccnt::return#0 cnt#1 cnt2#1 ] -- aby=xby 
  txa
//SEG25 inccnt::@return
inccnt__Breturn:
//SEG26 [13] return  [ inccnt::return#0 cnt#1 cnt2#1 ]
  rts

