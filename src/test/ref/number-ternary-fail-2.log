Inlined call call __init 

CONTROL FLOW GRAPH SSA

void* malloc(word malloc::size)
malloc: scope:[malloc]  from main
  malloc::size#1 = phi( main/malloc::size#0 )
  heap_head#7 = phi( main/heap_head#13 )
  malloc::$0 = heap_head#7 - malloc::size#1
  malloc::mem#0 = malloc::$0
  heap_head#0 = malloc::mem#0
  malloc::return#0 = ((void*)) malloc::mem#0
  to:malloc::@return
malloc::@return: scope:[malloc]  from malloc
  heap_head#8 = phi( malloc/heap_head#0 )
  malloc::return#3 = phi( malloc/malloc::return#0 )
  malloc::return#1 = malloc::return#3
  heap_head#1 = heap_head#8
  return 
  to:@return

void free(void* free::ptr)
free: scope:[free]  from main::@2
  to:free::@return
free::@return: scope:[free]  from free
  return 
  to:@return

void SolveMaze(byte* SolveMaze::maze , word SolveMaze::width , word SolveMaze::height)
SolveMaze: scope:[SolveMaze]  from main::@1
  SolveMaze::maze#6 = phi( main::@1/SolveMaze::maze#0 )
  SolveMaze::height#2 = phi( main::@1/SolveMaze::height#0 )
  SolveMaze::width#3 = phi( main::@1/SolveMaze::width#0 )
  SolveMaze::forward#0 = 0
  to:SolveMaze::@1
SolveMaze::@1: scope:[SolveMaze]  from SolveMaze SolveMaze::@6 SolveMaze::@7
  SolveMaze::maze#5 = phi( SolveMaze/SolveMaze::maze#6, SolveMaze::@6/SolveMaze::maze#7, SolveMaze::@7/SolveMaze::maze#8 )
  SolveMaze::forward#4 = phi( SolveMaze/SolveMaze::forward#0, SolveMaze::@6/SolveMaze::forward#1, SolveMaze::@7/SolveMaze::forward#2 )
  SolveMaze::height#1 = phi( SolveMaze/SolveMaze::height#2, SolveMaze::@6/SolveMaze::height#3, SolveMaze::@7/SolveMaze::height#4 )
  SolveMaze::width#1 = phi( SolveMaze/SolveMaze::width#3, SolveMaze::@6/SolveMaze::width#4, SolveMaze::@7/SolveMaze::width#5 )
  SolveMaze::$0 = SolveMaze::width#1 - 2
  SolveMaze::$1 = SolveMaze::x != SolveMaze::$0
  SolveMaze::$2 = SolveMaze::height#1 - 2
  SolveMaze::$3 = SolveMaze::y != SolveMaze::$2
  SolveMaze::$4 = SolveMaze::$1 || SolveMaze::$3
  if(SolveMaze::$4) goto SolveMaze::@2
  to:SolveMaze::@return
SolveMaze::@2: scope:[SolveMaze]  from SolveMaze::@1
  SolveMaze::height#8 = phi( SolveMaze::@1/SolveMaze::height#1 )
  SolveMaze::maze#4 = phi( SolveMaze::@1/SolveMaze::maze#5 )
  SolveMaze::forward#3 = phi( SolveMaze::@1/SolveMaze::forward#4 )
  SolveMaze::width#2 = phi( SolveMaze::@1/SolveMaze::width#1 )
  SolveMaze::$5 = SolveMaze::y * SolveMaze::width#2
  SolveMaze::$6 = SolveMaze::$5 + SolveMaze::x
  SolveMaze::$10 = 0 != SolveMaze::forward#3
  if(SolveMaze::$10) goto SolveMaze::@3
  to:SolveMaze::@4
SolveMaze::@3: scope:[SolveMaze]  from SolveMaze::@2
  SolveMaze::height#6 = phi( SolveMaze::@2/SolveMaze::height#8 )
  SolveMaze::width#7 = phi( SolveMaze::@2/SolveMaze::width#2 )
  SolveMaze::maze#2 = phi( SolveMaze::@2/SolveMaze::maze#4 )
  SolveMaze::$8 = 2
  to:SolveMaze::@5
SolveMaze::@4: scope:[SolveMaze]  from SolveMaze::@2
  SolveMaze::height#7 = phi( SolveMaze::@2/SolveMaze::height#8 )
  SolveMaze::width#8 = phi( SolveMaze::@2/SolveMaze::width#2 )
  SolveMaze::maze#3 = phi( SolveMaze::@2/SolveMaze::maze#4 )
  SolveMaze::$7 = 3
  to:SolveMaze::@5
SolveMaze::@5: scope:[SolveMaze]  from SolveMaze::@3 SolveMaze::@4
  SolveMaze::height#5 = phi( SolveMaze::@3/SolveMaze::height#6, SolveMaze::@4/SolveMaze::height#7 )
  SolveMaze::width#6 = phi( SolveMaze::@3/SolveMaze::width#7, SolveMaze::@4/SolveMaze::width#8 )
  SolveMaze::maze#1 = phi( SolveMaze::@3/SolveMaze::maze#2, SolveMaze::@4/SolveMaze::maze#3 )
  SolveMaze::$9 = phi( SolveMaze::@3/SolveMaze::$8, SolveMaze::@4/SolveMaze::$7 )
  SolveMaze::maze#1[SolveMaze::$6] = SolveMaze::$9
  if(1==1) goto SolveMaze::@6
  to:SolveMaze::@7
SolveMaze::@6: scope:[SolveMaze]  from SolveMaze::@5
  SolveMaze::maze#7 = phi( SolveMaze::@5/SolveMaze::maze#1 )
  SolveMaze::height#3 = phi( SolveMaze::@5/SolveMaze::height#5 )
  SolveMaze::width#4 = phi( SolveMaze::@5/SolveMaze::width#6 )
  SolveMaze::forward#1 = 1
  to:SolveMaze::@1
SolveMaze::@7: scope:[SolveMaze]  from SolveMaze::@5
  SolveMaze::maze#8 = phi( SolveMaze::@5/SolveMaze::maze#1 )
  SolveMaze::height#4 = phi( SolveMaze::@5/SolveMaze::height#5 )
  SolveMaze::width#5 = phi( SolveMaze::@5/SolveMaze::width#6 )
  SolveMaze::forward#2 = 0
  to:SolveMaze::@1
SolveMaze::@return: scope:[SolveMaze]  from SolveMaze::@1
  return 
  to:@return

void main()
main: scope:[main]  from __start::@1
  heap_head#13 = phi( __start::@1/heap_head#15 )
  main::maze#0 = (byte*) 0
  main::$0 = main::width * main::height
  malloc::size#0 = main::$0
  call malloc 
  malloc::return#2 = malloc::return#1
  to:main::@1
main::@1: scope:[main]  from main
  heap_head#9 = phi( main/heap_head#1 )
  malloc::return#4 = phi( main/malloc::return#2 )
  main::$1 = malloc::return#4
  heap_head#2 = heap_head#9
  main::maze#1 = ((byte*)) main::$1
  SolveMaze::maze#0 = main::maze#1
  SolveMaze::width#0 = main::width
  SolveMaze::height#0 = main::height
  call SolveMaze 
  to:main::@2
main::@2: scope:[main]  from main::@1
  heap_head#16 = phi( main::@1/heap_head#2 )
  main::maze#2 = phi( main::@1/main::maze#1 )
  free::ptr#0 = (void*)main::maze#2
  call free 
  to:main::@3
main::@3: scope:[main]  from main::@2
  heap_head#14 = phi( main::@2/heap_head#16 )
  asm { loop: jmploop  }
  to:main::@return
main::@return: scope:[main]  from main::@3
  heap_head#10 = phi( main::@3/heap_head#14 )
  heap_head#3 = heap_head#10
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  heap_head#4 = HEAP_TOP
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  heap_head#15 = phi( __start::__init1/heap_head#4 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  heap_head#11 = phi( __start::@1/heap_head#3 )
  heap_head#5 = heap_head#11
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  heap_head#12 = phi( __start::@2/heap_head#5 )
  heap_head#6 = heap_head#12
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* HEAP_TOP = (byte*)$a000
constant byte RADIX::BINARY = 2
constant byte RADIX::DECIMAL = $a
constant byte RADIX::HEXADECIMAL = $10
constant byte RADIX::OCTAL = 8
void SolveMaze(byte* SolveMaze::maze , word SolveMaze::width , word SolveMaze::height)
number~ SolveMaze::$0
bool~ SolveMaze::$1
bool~ SolveMaze::$10
number~ SolveMaze::$2
bool~ SolveMaze::$3
bool~ SolveMaze::$4
word~ SolveMaze::$5
word~ SolveMaze::$6
number~ SolveMaze::$7
number~ SolveMaze::$8
number~ SolveMaze::$9
word SolveMaze::forward
word SolveMaze::forward#0
word SolveMaze::forward#1
word SolveMaze::forward#2
word SolveMaze::forward#3
word SolveMaze::forward#4
word SolveMaze::height
word SolveMaze::height#0
word SolveMaze::height#1
word SolveMaze::height#2
word SolveMaze::height#3
word SolveMaze::height#4
word SolveMaze::height#5
word SolveMaze::height#6
word SolveMaze::height#7
word SolveMaze::height#8
byte* SolveMaze::maze
byte* SolveMaze::maze#0
byte* SolveMaze::maze#1
byte* SolveMaze::maze#2
byte* SolveMaze::maze#3
byte* SolveMaze::maze#4
byte* SolveMaze::maze#5
byte* SolveMaze::maze#6
byte* SolveMaze::maze#7
byte* SolveMaze::maze#8
word SolveMaze::width
word SolveMaze::width#0
word SolveMaze::width#1
word SolveMaze::width#2
word SolveMaze::width#3
word SolveMaze::width#4
word SolveMaze::width#5
word SolveMaze::width#6
word SolveMaze::width#7
word SolveMaze::width#8
constant word SolveMaze::x = 3
constant word SolveMaze::y = 2
void __start()
void free(void* free::ptr)
void* free::ptr
void* free::ptr#0
byte* heap_head
byte* heap_head#0
byte* heap_head#1
byte* heap_head#10
byte* heap_head#11
byte* heap_head#12
byte* heap_head#13
byte* heap_head#14
byte* heap_head#15
byte* heap_head#16
byte* heap_head#2
byte* heap_head#3
byte* heap_head#4
byte* heap_head#5
byte* heap_head#6
byte* heap_head#7
byte* heap_head#8
byte* heap_head#9
void main()
word~ main::$0
void*~ main::$1
constant word main::height = (word)6*2+3
byte* main::maze
byte* main::maze#0
byte* main::maze#1
byte* main::maze#2
constant word main::width = (word)$12*2+3
void* malloc(word malloc::size)
byte*~ malloc::$0
byte* malloc::mem
byte* malloc::mem#0
void* malloc::return
void* malloc::return#0
void* malloc::return#1
void* malloc::return#2
void* malloc::return#3
void* malloc::return#4
word malloc::size
word malloc::size#0
word malloc::size#1

Adding number conversion cast (unumber) 2 in SolveMaze::$0 = SolveMaze::width#1 - 2
Adding number conversion cast (unumber) SolveMaze::$0 in SolveMaze::$0 = SolveMaze::width#1 - (unumber)2
Adding number conversion cast (unumber) 2 in SolveMaze::$2 = SolveMaze::height#1 - 2
Adding number conversion cast (unumber) SolveMaze::$2 in SolveMaze::$2 = SolveMaze::height#1 - (unumber)2
Adding number conversion cast (unumber) 0 in SolveMaze::$10 = 0 != SolveMaze::forward#3
Adding number conversion cast (unumber) SolveMaze::$9 in SolveMaze::maze#1[SolveMaze::$6] = SolveMaze::$9
Adding number conversion cast (unumber) 1 in SolveMaze::forward#1 = 1
Adding number conversion cast (unumber) 0 in SolveMaze::forward#2 = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast malloc::return#0 = (void*)malloc::mem#0
Inlining cast SolveMaze::maze#1[SolveMaze::$6] = (unumber)SolveMaze::$9
Inlining cast SolveMaze::forward#1 = (unumber)1
Inlining cast SolveMaze::forward#2 = (unumber)0
Inlining cast main::maze#1 = (byte*)main::$1
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 40960
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in SolveMaze::$0 = SolveMaze::width#1 - 2
Inferred type updated to word in SolveMaze::$2 = SolveMaze::height#1 - 2
Alias malloc::mem#0 = malloc::$0 
Alias malloc::return#0 = malloc::return#3 malloc::return#1 
Alias heap_head#0 = heap_head#8 heap_head#1 
Alias SolveMaze::width#1 = SolveMaze::width#2 SolveMaze::width#7 SolveMaze::width#8 
Alias SolveMaze::forward#3 = SolveMaze::forward#4 
Alias SolveMaze::maze#2 = SolveMaze::maze#4 SolveMaze::maze#5 SolveMaze::maze#3 
Alias SolveMaze::height#1 = SolveMaze::height#8 SolveMaze::height#6 SolveMaze::height#7 
Alias SolveMaze::width#4 = SolveMaze::width#6 SolveMaze::width#5 
Alias SolveMaze::height#3 = SolveMaze::height#5 SolveMaze::height#4 
Alias SolveMaze::maze#1 = SolveMaze::maze#7 SolveMaze::maze#8 
Alias malloc::size#0 = main::$0 
Alias malloc::return#2 = malloc::return#4 
Alias heap_head#10 = heap_head#2 heap_head#9 heap_head#16 heap_head#14 heap_head#3 
Alias main::maze#1 = main::maze#2 
Alias heap_head#15 = heap_head#4 
Alias heap_head#11 = heap_head#5 heap_head#12 heap_head#6 
Successful SSA optimization Pass2AliasElimination
Alias SolveMaze::maze#1 = SolveMaze::maze#2 
Alias SolveMaze::width#1 = SolveMaze::width#4 
Alias SolveMaze::height#1 = SolveMaze::height#3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values heap_head#7 heap_head#13
Identical Phi Values malloc::size#1 malloc::size#0
Identical Phi Values SolveMaze::width#3 SolveMaze::width#0
Identical Phi Values SolveMaze::height#2 SolveMaze::height#0
Identical Phi Values SolveMaze::maze#6 SolveMaze::maze#0
Identical Phi Values SolveMaze::width#1 SolveMaze::width#3
Identical Phi Values SolveMaze::height#1 SolveMaze::height#2
Identical Phi Values SolveMaze::maze#1 SolveMaze::maze#6
Identical Phi Values heap_head#13 heap_head#15
Identical Phi Values heap_head#10 heap_head#0
Identical Phi Values heap_head#11 heap_head#10
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition SolveMaze::$10 [18] if(0!=SolveMaze::forward#3) goto SolveMaze::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting || if()-condition to two if()s [13] SolveMaze::$4 = SolveMaze::$1 || SolveMaze::$3
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [29] malloc::size#0 = main::width * main::height
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant SolveMaze::forward#0 = 0
Constant SolveMaze::$8 = 2
Constant SolveMaze::$7 = 3
Constant SolveMaze::forward#1 = 1
Constant SolveMaze::forward#2 = 0
Constant main::maze#0 = (byte*) 0
Constant malloc::size#0 = main::width*main::height
Constant SolveMaze::width#0 = main::width
Constant SolveMaze::height#0 = main::height
Constant heap_head#15 = HEAP_TOP
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [23] if(1==1) goto SolveMaze::@6
Successful SSA optimization Pass2ConstantIfs
De-inlining pointer[w] to *(pointer+w)   [22] SolveMaze::maze#0[SolveMaze::$6] = (unumber)SolveMaze::$9
Successful SSA optimization Pass2DeInlineWordDerefIdx
Removing PHI-reference to removed block (SolveMaze::@7) in block SolveMaze::@1
Removing unused block SolveMaze::@7
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused variable heap_head#0 and assignment [1] heap_head#0 = malloc::mem#0
Eliminating unused variable free::ptr#0 and assignment [24] free::ptr#0 = (void*)main::maze#1
Eliminating unused constant SolveMaze::forward#2
Eliminating unused constant main::maze#0
Successful SSA optimization PassNEliminateUnusedVars
Removing call to empty procedure [23] call free 
Removing unused procedure free
Removing unused procedure block free
Removing unused procedure block free::@return
Successful SSA optimization PassNEliminateEmptyProcedure
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Simple Condition SolveMaze::$1 [8] if(SolveMaze::x!=SolveMaze::$0) goto SolveMaze::@2
Simple Condition SolveMaze::$3 [24] if(SolveMaze::y!=SolveMaze::$2) goto SolveMaze::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [0] malloc::mem#0 = heap_head#15 - malloc::size#0
Constant right-side identified [4] SolveMaze::$0 = SolveMaze::width#0 - 2
Constant right-side identified [6] SolveMaze::$2 = SolveMaze::height#0 - 2
Constant right-side identified [9] SolveMaze::$5 = SolveMaze::y * SolveMaze::width#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant malloc::mem#0 = heap_head#15-malloc::size#0
Constant SolveMaze::$0 = SolveMaze::width#0-2
Constant SolveMaze::$2 = SolveMaze::height#0-2
Constant SolveMaze::$5 = SolveMaze::y*SolveMaze::width#0
Successful SSA optimization Pass2ConstantIdentification
Constant malloc::return#0 = (void*)malloc::mem#0
Successful SSA optimization Pass2ConstantIdentification
Constant malloc::return#2 = malloc::return#0
Successful SSA optimization Pass2ConstantIdentification
Constant main::$1 = malloc::return#2
Successful SSA optimization Pass2ConstantIdentification
Constant main::maze#1 = (byte*)main::$1
Successful SSA optimization Pass2ConstantIdentification
Constant SolveMaze::maze#0 = main::maze#1
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [8] if(SolveMaze::x!=SolveMaze::$0) goto SolveMaze::@2
if() condition always true - replacing block destination [24] if(SolveMaze::y!=SolveMaze::$2) goto SolveMaze::@2
Successful SSA optimization Pass2ConstantIfs
Removing unused block SolveMaze::@return
Removing unused block SolveMaze::@8
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant SolveMaze::$0
Eliminating unused constant SolveMaze::$2
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant SolveMaze::height#0
Successful SSA optimization PassNEliminateUnusedVars
Constant right-side identified [2] SolveMaze::$6 = SolveMaze::$5 + SolveMaze::x
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant SolveMaze::$6 = SolveMaze::$5+SolveMaze::x
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [4] SolveMaze::$11 = SolveMaze::maze#0 + SolveMaze::$6
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant SolveMaze::$11 = SolveMaze::maze#0+SolveMaze::$6
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with different constant siblings malloc::return#2
Inlining constant with var siblings SolveMaze::forward#0
Inlining constant with var siblings SolveMaze::forward#1
Constant inlined malloc::return#2 = malloc::return#0
Constant inlined main::$1 = malloc::return#0
Constant inlined heap_head#15 = HEAP_TOP
Constant inlined SolveMaze::$8 = 2
Constant inlined SolveMaze::$11 = main::maze#1+SolveMaze::y*main::width+SolveMaze::x
Constant inlined SolveMaze::$7 = 3
Constant inlined SolveMaze::$6 = SolveMaze::y*main::width+SolveMaze::x
Constant inlined SolveMaze::$5 = SolveMaze::y*main::width
Constant inlined SolveMaze::maze#0 = main::maze#1
Constant inlined SolveMaze::width#0 = main::width
Constant inlined SolveMaze::forward#0 = 0
Constant inlined SolveMaze::forward#1 = 1
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $12
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Successful SSA optimization PassNFinalizeNumberTypeConversions
Adding number conversion cast (unumber) SolveMaze::$9 in [3] SolveMaze::$9 = phi( SolveMaze::@3/2, SolveMaze::@4/3 )
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast SolveMaze::$9
Successful SSA optimization PassNCastSimplification
Inferred type updated to byte for SolveMaze::$9
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of malloc
Adding NOP phi() at start of SolveMaze
Adding NOP phi() at start of SolveMaze::@4
Adding NOP phi() at start of SolveMaze::@6
Adding NOP phi() at start of SolveMaze::@3
CALL GRAPH
Calls in [main] to malloc:1 SolveMaze:3 

Created 2 initial phi equivalence classes
Coalesced down to 2 phi equivalence classes
Culled Empty Block label main::@2
Culled Empty Block label SolveMaze::@4
Culled Empty Block label SolveMaze::@6
Renumbering block SolveMaze::@5 to SolveMaze::@4
Renumbering block main::@3 to main::@2
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of malloc
Adding NOP phi() at start of SolveMaze
Adding NOP phi() at start of SolveMaze::@3

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call malloc 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call SolveMaze 
  to:main::@2
main::@2: scope:[main]  from main::@1
  asm { loop: jmploop  }
  to:main::@return
main::@return: scope:[main]  from main::@2
  [5] return 
  to:@return

void* malloc(word malloc::size)
malloc: scope:[malloc]  from main
  [6] phi()
  to:malloc::@return
malloc::@return: scope:[malloc]  from malloc
  [7] return 
  to:@return

void SolveMaze(byte* SolveMaze::maze , word SolveMaze::width , word SolveMaze::height)
SolveMaze: scope:[SolveMaze]  from main::@1
  [8] phi()
  to:SolveMaze::@1
SolveMaze::@1: scope:[SolveMaze]  from SolveMaze SolveMaze::@4
  [9] SolveMaze::forward#3 = phi( SolveMaze/0, SolveMaze::@4/1 )
  to:SolveMaze::@2
SolveMaze::@2: scope:[SolveMaze]  from SolveMaze::@1
  [10] if(0!=SolveMaze::forward#3) goto SolveMaze::@3
  to:SolveMaze::@4
SolveMaze::@3: scope:[SolveMaze]  from SolveMaze::@2
  [11] phi()
  to:SolveMaze::@4
SolveMaze::@4: scope:[SolveMaze]  from SolveMaze::@2 SolveMaze::@3
  [12] SolveMaze::$9 = phi( SolveMaze::@3/2, SolveMaze::@2/3 )
  [13] *(main::maze#1+SolveMaze::y*main::width+SolveMaze::x) = SolveMaze::$9
  to:SolveMaze::@1


VARIABLE REGISTER WEIGHTS
void SolveMaze(byte* SolveMaze::maze , word SolveMaze::width , word SolveMaze::height)
byte~ SolveMaze::$9 101.0
word SolveMaze::forward
word SolveMaze::forward#3 101.0
word SolveMaze::height
byte* SolveMaze::maze
word SolveMaze::width
byte* heap_head
void main()
byte* main::maze
void* malloc(word malloc::size)
byte* malloc::mem
void* malloc::return
word malloc::size

Initial phi equivalence classes
[ SolveMaze::forward#3 ]
[ SolveMaze::$9 ]
Complete equivalence classes
[ SolveMaze::forward#3 ]
[ SolveMaze::$9 ]
Allocated zp[2]:2 [ SolveMaze::forward#3 ]
Allocated zp[1]:4 [ SolveMaze::$9 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [10] if(0!=SolveMaze::forward#3) goto SolveMaze::@3 [ ] ( SolveMaze:3 [ ] { }  ) always clobbers reg byte a 
Potential registers zp[2]:2 [ SolveMaze::forward#3 ] : zp[2]:2 , 
Potential registers zp[1]:4 [ SolveMaze::$9 ] : zp[1]:4 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [SolveMaze] 101: zp[2]:2 [ SolveMaze::forward#3 ] 101: zp[1]:4 [ SolveMaze::$9 ] 
Uplift Scope [malloc] 
Uplift Scope [RADIX] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [SolveMaze] best 611 combination zp[2]:2 [ SolveMaze::forward#3 ] reg byte a [ SolveMaze::$9 ] 
Uplifting [malloc] best 611 combination 
Uplifting [RADIX] best 611 combination 
Uplifting [main] best 611 combination 
Uplifting [] best 611 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Failing number type resolving in ternary operator
// Currently fails in the ternary operator with number-issues if integer literal is not specified!
  // Upstart
  // Commodore 64 PRG executable file
.file [name="number-ternary-fail-2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  // Top of the heap used by malloc()
  .label HEAP_TOP = $a000
.segment Code
  // main
main: {
    .label width = $12*2+3
    .label height = 6*2+3
    .label maze = malloc.return
    // [1] call malloc 
    // [6] phi from main to malloc [phi:main->malloc]
  malloc_from_main:
    jsr malloc
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call SolveMaze 
    // [8] phi from main::@1 to SolveMaze [phi:main::@1->SolveMaze]
  SolveMaze_from___b1:
    jsr SolveMaze
    jmp __b2
    // main::@2
  __b2:
    // asm { loop: jmploop  }
  loop:
    jmp loop
    jmp __breturn
    // main::@return
  __breturn:
    // [5] return 
    rts
}
  // malloc
// Allocates a block of size chars of memory, returning a pointer to the beginning of the block.
// The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.
malloc: {
    .const size = main.width*main.height
    .label mem = HEAP_TOP-size
    .label return = mem
    jmp __breturn
    // malloc::@return
  __breturn:
    // [7] return 
    rts
}
  // SolveMaze
SolveMaze: {
    .const x = 3
    .const y = 2
    .label forward = 2
    // [9] phi from SolveMaze to SolveMaze::@1 [phi:SolveMaze->SolveMaze::@1]
  __b1_from_SolveMaze:
    // [9] phi SolveMaze::forward#3 = 0 [phi:SolveMaze->SolveMaze::@1#0] -- vwuz1=vwuc1 
    lda #<0
    sta.z forward
    lda #>0
    sta.z forward+1
    jmp __b1
    // SolveMaze::@1
  __b1:
    jmp __b2
    // SolveMaze::@2
  __b2:
    // [10] if(0!=SolveMaze::forward#3) goto SolveMaze::@3 -- 0_neq_vwuz1_then_la1 
    lda.z forward
    ora.z forward+1
    bne __b3_from___b2
    // [12] phi from SolveMaze::@2 to SolveMaze::@4 [phi:SolveMaze::@2->SolveMaze::@4]
  __b4_from___b2:
    // [12] phi SolveMaze::$9 = 3 [phi:SolveMaze::@2->SolveMaze::@4#0] -- vbuaa=vbuc1 
    lda #3
    jmp __b4
    // [11] phi from SolveMaze::@2 to SolveMaze::@3 [phi:SolveMaze::@2->SolveMaze::@3]
  __b3_from___b2:
    jmp __b3
    // SolveMaze::@3
  __b3:
    // [12] phi from SolveMaze::@3 to SolveMaze::@4 [phi:SolveMaze::@3->SolveMaze::@4]
  __b4_from___b3:
    // [12] phi SolveMaze::$9 = 2 [phi:SolveMaze::@3->SolveMaze::@4#0] -- vbuaa=vbuc1 
    lda #2
    jmp __b4
    // SolveMaze::@4
  __b4:
    // [13] *(main::maze#1+SolveMaze::y*main::width+SolveMaze::x) = SolveMaze::$9 -- _deref_pbuc1=vbuaa 
    sta main.maze+y*main.width+x
    // [9] phi from SolveMaze::@4 to SolveMaze::@1 [phi:SolveMaze::@4->SolveMaze::@1]
  __b1_from___b4:
    // [9] phi SolveMaze::forward#3 = 1 [phi:SolveMaze::@4->SolveMaze::@1#0] -- vwuz1=vbuc1 
    lda #<1
    sta.z forward
    lda #>1
    sta.z forward+1
    jmp __b1
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #>0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b3_from___b2 with __b3
Replacing label __b1 with __b2
Removing instruction __b1_from_main:
Removing instruction SolveMaze_from___b1:
Removing instruction __b2:
Removing instruction __b1:
Removing instruction __b3_from___b2:
Removing instruction __b4_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction malloc_from_main:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b1_from_SolveMaze:
Removing instruction __b4_from___b2:
Removing instruction __b1_from___b4:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction rts
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
constant byte* HEAP_TOP = (byte*) 40960
constant byte RADIX::BINARY = 2
constant byte RADIX::DECIMAL = $a
constant byte RADIX::HEXADECIMAL = $10
constant byte RADIX::OCTAL = 8
void SolveMaze(byte* SolveMaze::maze , word SolveMaze::width , word SolveMaze::height)
byte~ SolveMaze::$9 reg byte a 101.0
word SolveMaze::forward
word SolveMaze::forward#3 forward zp[2]:2 101.0
word SolveMaze::height
byte* SolveMaze::maze
word SolveMaze::width
constant word SolveMaze::x = 3
constant word SolveMaze::y = 2
byte* heap_head
void main()
constant word main::height = (word)6*2+3
byte* main::maze
constant byte* main::maze#1 maze = (byte*)malloc::return#0
constant word main::width = (word)$12*2+3
void* malloc(word malloc::size)
byte* malloc::mem
constant byte* malloc::mem#0 mem = HEAP_TOP-malloc::size#0
void* malloc::return
constant void* malloc::return#0 return = (void*)malloc::mem#0
word malloc::size
constant word malloc::size#0 size = main::width*main::height

zp[2]:2 [ SolveMaze::forward#3 ]
reg byte a [ SolveMaze::$9 ]


FINAL ASSEMBLER
Score: 426

  // File Comments
// Failing number type resolving in ternary operator
// Currently fails in the ternary operator with number-issues if integer literal is not specified!
  // Upstart
  // Commodore 64 PRG executable file
.file [name="number-ternary-fail-2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  // Top of the heap used by malloc()
  .label HEAP_TOP = $a000
.segment Code
  // main
main: {
    .label width = $12*2+3
    .label height = 6*2+3
    .label maze = malloc.return
    // malloc(width * height)
    // [1] call malloc 
    // [6] phi from main to malloc [phi:main->malloc]
    jsr malloc
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // SolveMaze(maze, width, height)
    // [3] call SolveMaze 
    // [8] phi from main::@1 to SolveMaze [phi:main::@1->SolveMaze]
    jsr SolveMaze
    // main::@2
    // asm
    // asm { loop: jmploop  }
  loop:
    jmp loop
    // main::@return
    // }
    // [5] return 
}
  // malloc
// Allocates a block of size chars of memory, returning a pointer to the beginning of the block.
// The content of the newly allocated block of memory is not initialized, remaining with indeterminate values.
malloc: {
    .const size = main.width*main.height
    .label mem = HEAP_TOP-size
    .label return = mem
    // malloc::@return
    // [7] return 
    rts
}
  // SolveMaze
SolveMaze: {
    .const x = 3
    .const y = 2
    .label forward = 2
    // [9] phi from SolveMaze to SolveMaze::@1 [phi:SolveMaze->SolveMaze::@1]
    // [9] phi SolveMaze::forward#3 = 0 [phi:SolveMaze->SolveMaze::@1#0] -- vwuz1=vwuc1 
    lda #<0
    sta.z forward
    sta.z forward+1
    // SolveMaze::@1
    // SolveMaze::@2
  __b2:
    // forward ? 2 : 3
    // [10] if(0!=SolveMaze::forward#3) goto SolveMaze::@3 -- 0_neq_vwuz1_then_la1 
    lda.z forward
    ora.z forward+1
    bne __b3
    // [12] phi from SolveMaze::@2 to SolveMaze::@4 [phi:SolveMaze::@2->SolveMaze::@4]
    // [12] phi SolveMaze::$9 = 3 [phi:SolveMaze::@2->SolveMaze::@4#0] -- vbuaa=vbuc1 
    lda #3
    jmp __b4
    // [11] phi from SolveMaze::@2 to SolveMaze::@3 [phi:SolveMaze::@2->SolveMaze::@3]
    // SolveMaze::@3
  __b3:
    // forward ? 2 : 3
    // [12] phi from SolveMaze::@3 to SolveMaze::@4 [phi:SolveMaze::@3->SolveMaze::@4]
    // [12] phi SolveMaze::$9 = 2 [phi:SolveMaze::@3->SolveMaze::@4#0] -- vbuaa=vbuc1 
    lda #2
    // SolveMaze::@4
  __b4:
    // maze[y * width + x] = forward ? 2 : 3
    // [13] *(main::maze#1+SolveMaze::y*main::width+SolveMaze::x) = SolveMaze::$9 -- _deref_pbuc1=vbuaa 
    sta main.maze+y*main.width+x
    // [9] phi from SolveMaze::@4 to SolveMaze::@1 [phi:SolveMaze::@4->SolveMaze::@1]
    // [9] phi SolveMaze::forward#3 = 1 [phi:SolveMaze::@4->SolveMaze::@1#0] -- vwuz1=vbuc1 
    lda #<1
    sta.z forward
    lda #>1
    sta.z forward+1
    jmp __b2
}
  // File Data

