Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call _init 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from _start::@1
  (byte*) current_chargen#31 ← phi( _start::@1/(byte*) current_chargen#23 )
  (byte*) nxt#38 ← phi( _start::@1/(byte*) nxt#28 )
  (byte) current_bit#32 ← phi( _start::@1/(byte) current_bit#25 )
  (byte) scroll#21 ← phi( _start::@1/(byte) scroll#17 )
  (byte*) fillscreen::screen#0 ← (const byte*) SCREEN
  (byte) fillscreen::fill#0 ← (number) $20
  call fillscreen 
  to:main::@4
main::@4: scope:[main]  from main
  (byte*) current_chargen#30 ← phi( main/(byte*) current_chargen#31 )
  (byte*) nxt#36 ← phi( main/(byte*) nxt#38 )
  (byte) current_bit#31 ← phi( main/(byte) current_bit#32 )
  (byte) scroll#20 ← phi( main/(byte) scroll#21 )
  to:main::@1
main::@1: scope:[main]  from main::@1 main::@4 main::@5
  (byte*) current_chargen#28 ← phi( main::@1/(byte*) current_chargen#28 main::@4/(byte*) current_chargen#30 main::@5/(byte*) current_chargen#0 )
  (byte*) nxt#33 ← phi( main::@1/(byte*) nxt#33 main::@4/(byte*) nxt#36 main::@5/(byte*) nxt#0 )
  (byte) current_bit#30 ← phi( main::@1/(byte) current_bit#30 main::@4/(byte) current_bit#31 main::@5/(byte) current_bit#0 )
  (byte) scroll#19 ← phi( main::@1/(byte) scroll#19 main::@4/(byte) scroll#20 main::@5/(byte) scroll#0 )
  (bool~) main::$1 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) != (number) $fe
  if((bool~) main::$1) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@2
  (byte*) current_chargen#24 ← phi( main::@1/(byte*) current_chargen#28 main::@2/(byte*) current_chargen#24 )
  (byte*) nxt#29 ← phi( main::@1/(byte*) nxt#33 main::@2/(byte*) nxt#29 )
  (byte) current_bit#26 ← phi( main::@1/(byte) current_bit#30 main::@2/(byte) current_bit#26 )
  (byte) scroll#18 ← phi( main::@1/(byte) scroll#19 main::@2/(byte) scroll#18 )
  (bool~) main::$2 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) != (number) $ff
  if((bool~) main::$2) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte*) current_chargen#17 ← phi( main::@2/(byte*) current_chargen#24 )
  (byte*) nxt#23 ← phi( main::@2/(byte*) nxt#29 )
  (byte) current_bit#19 ← phi( main::@2/(byte) current_bit#26 )
  (byte) scroll#15 ← phi( main::@2/(byte) scroll#18 )
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← ++ *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR)
  call scroll_soft 
  to:main::@5
main::@5: scope:[main]  from main::@3
  (byte*) current_chargen#9 ← phi( main::@3/(byte*) current_chargen#3 )
  (byte*) nxt#12 ← phi( main::@3/(byte*) nxt#3 )
  (byte) current_bit#10 ← phi( main::@3/(byte) current_bit#3 )
  (byte) scroll#8 ← phi( main::@3/(byte) scroll#4 )
  (byte) scroll#0 ← (byte) scroll#8
  (byte) current_bit#0 ← (byte) current_bit#10
  (byte*) nxt#0 ← (byte*) nxt#12
  (byte*) current_chargen#0 ← (byte*) current_chargen#9
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← -- *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR)
  if(true) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@5
  (byte*) current_chargen#10 ← phi( main::@5/(byte*) current_chargen#0 )
  (byte*) nxt#13 ← phi( main::@5/(byte*) nxt#0 )
  (byte) current_bit#11 ← phi( main::@5/(byte) current_bit#0 )
  (byte) scroll#9 ← phi( main::@5/(byte) scroll#0 )
  (byte) scroll#1 ← (byte) scroll#9
  (byte) current_bit#1 ← (byte) current_bit#11
  (byte*) nxt#1 ← (byte*) nxt#13
  (byte*) current_chargen#1 ← (byte*) current_chargen#10
  return 
  to:@return

(void()) scroll_soft()
scroll_soft: scope:[scroll_soft]  from main::@3
  (byte*) current_chargen#25 ← phi( main::@3/(byte*) current_chargen#17 )
  (byte*) nxt#30 ← phi( main::@3/(byte*) nxt#23 )
  (byte) current_bit#27 ← phi( main::@3/(byte) current_bit#19 )
  (byte) scroll#10 ← phi( main::@3/(byte) scroll#15 )
  (byte) scroll#2 ← -- (byte) scroll#10
  (bool~) scroll_soft::$0 ← (byte) scroll#2 == (number) $ff
  (bool~) scroll_soft::$1 ← ! (bool~) scroll_soft::$0
  if((bool~) scroll_soft::$1) goto scroll_soft::@1
  to:scroll_soft::@2
scroll_soft::@1: scope:[scroll_soft]  from scroll_soft scroll_soft::@3
  (byte*) current_chargen#19 ← phi( scroll_soft/(byte*) current_chargen#25 scroll_soft::@3/(byte*) current_chargen#2 )
  (byte*) nxt#25 ← phi( scroll_soft/(byte*) nxt#30 scroll_soft::@3/(byte*) nxt#2 )
  (byte) current_bit#21 ← phi( scroll_soft/(byte) current_bit#27 scroll_soft::@3/(byte) current_bit#2 )
  (byte) scroll#11 ← phi( scroll_soft/(byte) scroll#2 scroll_soft::@3/(byte) scroll#16 )
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) scroll#11
  to:scroll_soft::@return
scroll_soft::@2: scope:[scroll_soft]  from scroll_soft
  (byte*) current_chargen#18 ← phi( scroll_soft/(byte*) current_chargen#25 )
  (byte*) nxt#24 ← phi( scroll_soft/(byte*) nxt#30 )
  (byte) current_bit#20 ← phi( scroll_soft/(byte) current_bit#27 )
  (byte) scroll#3 ← (number) 7
  call scroll_bit 
  to:scroll_soft::@3
scroll_soft::@3: scope:[scroll_soft]  from scroll_soft::@2
  (byte) scroll#16 ← phi( scroll_soft::@2/(byte) scroll#3 )
  (byte*) current_chargen#11 ← phi( scroll_soft::@2/(byte*) current_chargen#5 )
  (byte*) nxt#14 ← phi( scroll_soft::@2/(byte*) nxt#5 )
  (byte) current_bit#12 ← phi( scroll_soft::@2/(byte) current_bit#6 )
  (byte) current_bit#2 ← (byte) current_bit#12
  (byte*) nxt#2 ← (byte*) nxt#14
  (byte*) current_chargen#2 ← (byte*) current_chargen#11
  to:scroll_soft::@1
scroll_soft::@return: scope:[scroll_soft]  from scroll_soft::@1
  (byte*) current_chargen#12 ← phi( scroll_soft::@1/(byte*) current_chargen#19 )
  (byte*) nxt#15 ← phi( scroll_soft::@1/(byte*) nxt#25 )
  (byte) current_bit#13 ← phi( scroll_soft::@1/(byte) current_bit#21 )
  (byte) scroll#12 ← phi( scroll_soft::@1/(byte) scroll#11 )
  (byte) scroll#4 ← (byte) scroll#12
  (byte) current_bit#3 ← (byte) current_bit#13
  (byte*) nxt#3 ← (byte*) nxt#15
  (byte*) current_chargen#3 ← (byte*) current_chargen#12
  return 
  to:@return

(void()) scroll_bit()
scroll_bit: scope:[scroll_bit]  from scroll_soft::@2
  (byte*) current_chargen#29 ← phi( scroll_soft::@2/(byte*) current_chargen#18 )
  (byte*) nxt#31 ← phi( scroll_soft::@2/(byte*) nxt#24 )
  (byte) current_bit#14 ← phi( scroll_soft::@2/(byte) current_bit#20 )
  (number~) scroll_bit::$0 ← (byte) current_bit#14 / (number) 2
  (byte) current_bit#4 ← (number~) scroll_bit::$0
  (bool~) scroll_bit::$1 ← (byte) current_bit#4 == (number) 0
  (bool~) scroll_bit::$2 ← ! (bool~) scroll_bit::$1
  if((bool~) scroll_bit::$2) goto scroll_bit::@1
  to:scroll_bit::@2
scroll_bit::@1: scope:[scroll_bit]  from scroll_bit scroll_bit::@8
  (byte*) nxt#39 ← phi( scroll_bit/(byte*) nxt#31 scroll_bit::@8/(byte*) nxt#4 )
  (byte) current_bit#28 ← phi( scroll_bit/(byte) current_bit#4 scroll_bit::@8/(byte) current_bit#5 )
  (byte*) current_chargen#26 ← phi( scroll_bit/(byte*) current_chargen#29 scroll_bit::@8/(byte*) current_chargen#4 )
  call scroll_hard 
  to:scroll_bit::@7
scroll_bit::@7: scope:[scroll_bit]  from scroll_bit::@1
  (byte*) nxt#37 ← phi( scroll_bit::@1/(byte*) nxt#39 )
  (byte) current_bit#23 ← phi( scroll_bit::@1/(byte) current_bit#28 )
  (byte*) current_chargen#21 ← phi( scroll_bit::@1/(byte*) current_chargen#26 )
  asm { sei  }
  *((const nomodify byte*) PROCPORT) ← (number) $32
  (byte*~) scroll_bit::$4 ← (const byte*) SCREEN + (number) $28
  (byte*~) scroll_bit::$5 ← (byte*~) scroll_bit::$4 + (number) $27
  (byte*) scroll_bit::sc#0 ← (byte*~) scroll_bit::$5
  (byte) scroll_bit::r#0 ← (byte) 0
  to:scroll_bit::@3
scroll_bit::@2: scope:[scroll_bit]  from scroll_bit
  (byte*) nxt#26 ← phi( scroll_bit/(byte*) nxt#31 )
  call next_char 
  (byte) next_char::return#0 ← (byte) next_char::return#2
  to:scroll_bit::@8
scroll_bit::@8: scope:[scroll_bit]  from scroll_bit::@2
  (byte*) nxt#16 ← phi( scroll_bit::@2/(byte*) nxt#8 )
  (byte) next_char::return#3 ← phi( scroll_bit::@2/(byte) next_char::return#0 )
  (byte~) scroll_bit::$6 ← (byte) next_char::return#3
  (byte*) nxt#4 ← (byte*) nxt#16
  (word) scroll_bit::c#0 ← (byte~) scroll_bit::$6
  (number~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (number) 8
  (byte*~) scroll_bit::$8 ← (const nomodify byte*) CHARGEN + (number~) scroll_bit::$7
  (byte*) current_chargen#4 ← (byte*~) scroll_bit::$8
  (byte) current_bit#5 ← (number) $80
  to:scroll_bit::@1
scroll_bit::@3: scope:[scroll_bit]  from scroll_bit::@4 scroll_bit::@7
  (byte*) nxt#34 ← phi( scroll_bit::@4/(byte*) nxt#32 scroll_bit::@7/(byte*) nxt#37 )
  (byte*) scroll_bit::sc#3 ← phi( scroll_bit::@4/(byte*) scroll_bit::sc#1 scroll_bit::@7/(byte*) scroll_bit::sc#0 )
  (byte) current_bit#15 ← phi( scroll_bit::@4/(byte) current_bit#22 scroll_bit::@7/(byte) current_bit#23 )
  (byte) scroll_bit::r#2 ← phi( scroll_bit::@4/(byte) scroll_bit::r#1 scroll_bit::@7/(byte) scroll_bit::r#0 )
  (byte*) current_chargen#13 ← phi( scroll_bit::@4/(byte*) current_chargen#20 scroll_bit::@7/(byte*) current_chargen#21 )
  (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#13 + (byte) scroll_bit::r#2)
  (byte) scroll_bit::b#0 ← (byte) ' '
  (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#15
  (bool~) scroll_bit::$10 ← (byte~) scroll_bit::$9 != (number) 0
  (bool~) scroll_bit::$11 ← ! (bool~) scroll_bit::$10
  if((bool~) scroll_bit::$11) goto scroll_bit::@4
  to:scroll_bit::@5
scroll_bit::@4: scope:[scroll_bit]  from scroll_bit::@3 scroll_bit::@5
  (byte*) nxt#32 ← phi( scroll_bit::@3/(byte*) nxt#34 scroll_bit::@5/(byte*) nxt#35 )
  (byte) current_bit#22 ← phi( scroll_bit::@3/(byte) current_bit#15 scroll_bit::@5/(byte) current_bit#29 )
  (byte*) current_chargen#20 ← phi( scroll_bit::@3/(byte*) current_chargen#13 scroll_bit::@5/(byte*) current_chargen#27 )
  (byte) scroll_bit::r#3 ← phi( scroll_bit::@3/(byte) scroll_bit::r#2 scroll_bit::@5/(byte) scroll_bit::r#4 )
  (byte*) scroll_bit::sc#2 ← phi( scroll_bit::@3/(byte*) scroll_bit::sc#3 scroll_bit::@5/(byte*) scroll_bit::sc#4 )
  (byte) scroll_bit::b#2 ← phi( scroll_bit::@3/(byte) scroll_bit::b#0 scroll_bit::@5/(byte) scroll_bit::b#1 )
  *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2
  (byte*~) scroll_bit::$12 ← (byte*) scroll_bit::sc#2 + (number) $28
  (byte*) scroll_bit::sc#1 ← (byte*~) scroll_bit::$12
  (byte) scroll_bit::r#1 ← (byte) scroll_bit::r#3 + rangenext(0,7)
  (bool~) scroll_bit::$13 ← (byte) scroll_bit::r#1 != rangelast(0,7)
  if((bool~) scroll_bit::$13) goto scroll_bit::@3
  to:scroll_bit::@6
scroll_bit::@5: scope:[scroll_bit]  from scroll_bit::@3
  (byte*) nxt#35 ← phi( scroll_bit::@3/(byte*) nxt#34 )
  (byte) current_bit#29 ← phi( scroll_bit::@3/(byte) current_bit#15 )
  (byte*) current_chargen#27 ← phi( scroll_bit::@3/(byte*) current_chargen#13 )
  (byte) scroll_bit::r#4 ← phi( scroll_bit::@3/(byte) scroll_bit::r#2 )
  (byte*) scroll_bit::sc#4 ← phi( scroll_bit::@3/(byte*) scroll_bit::sc#3 )
  (byte) scroll_bit::b#1 ← (number) $80+(byte) ' '
  to:scroll_bit::@4
scroll_bit::@6: scope:[scroll_bit]  from scroll_bit::@4
  (byte*) current_chargen#22 ← phi( scroll_bit::@4/(byte*) current_chargen#20 )
  (byte*) nxt#27 ← phi( scroll_bit::@4/(byte*) nxt#32 )
  (byte) current_bit#24 ← phi( scroll_bit::@4/(byte) current_bit#22 )
  *((const nomodify byte*) PROCPORT) ← (number) $37
  asm { cli  }
  to:scroll_bit::@return
scroll_bit::@return: scope:[scroll_bit]  from scroll_bit::@6
  (byte*) current_chargen#14 ← phi( scroll_bit::@6/(byte*) current_chargen#22 )
  (byte*) nxt#17 ← phi( scroll_bit::@6/(byte*) nxt#27 )
  (byte) current_bit#16 ← phi( scroll_bit::@6/(byte) current_bit#24 )
  (byte) current_bit#6 ← (byte) current_bit#16
  (byte*) nxt#5 ← (byte*) nxt#17
  (byte*) current_chargen#5 ← (byte*) current_chargen#14
  return 
  to:@return

(byte()) next_char()
next_char: scope:[next_char]  from scroll_bit::@2
  (byte*) nxt#18 ← phi( scroll_bit::@2/(byte*) nxt#26 )
  (byte) next_char::c#0 ← *((byte*) nxt#18)
  (bool~) next_char::$0 ← (byte) next_char::c#0 == (number) 0
  (bool~) next_char::$1 ← ! (bool~) next_char::$0
  if((bool~) next_char::$1) goto next_char::@1
  to:next_char::@2
next_char::@1: scope:[next_char]  from next_char next_char::@2
  (byte) next_char::c#2 ← phi( next_char/(byte) next_char::c#0 next_char::@2/(byte) next_char::c#1 )
  (byte*) nxt#19 ← phi( next_char/(byte*) nxt#18 next_char::@2/(byte*) nxt#7 )
  (byte*) nxt#6 ← ++ (byte*) nxt#19
  (byte) next_char::return#1 ← (byte) next_char::c#2
  to:next_char::@return
next_char::@2: scope:[next_char]  from next_char
  (byte*) nxt#7 ← (const byte*) TEXT
  (byte) next_char::c#1 ← *((byte*) nxt#7)
  to:next_char::@1
next_char::@return: scope:[next_char]  from next_char::@1
  (byte*) nxt#20 ← phi( next_char::@1/(byte*) nxt#6 )
  (byte) next_char::return#4 ← phi( next_char::@1/(byte) next_char::return#1 )
  (byte) next_char::return#2 ← (byte) next_char::return#4
  (byte*) nxt#8 ← (byte*) nxt#20
  return 
  to:@return

(void()) scroll_hard()
scroll_hard: scope:[scroll_hard]  from scroll_bit::@1
  (byte) scroll_hard::i#0 ← (byte) 0
  to:scroll_hard::@1
scroll_hard::@1: scope:[scroll_hard]  from scroll_hard scroll_hard::@2
  (byte) scroll_hard::i#2 ← phi( scroll_hard/(byte) scroll_hard::i#0 scroll_hard::@2/(byte) scroll_hard::i#1 )
  (bool~) scroll_hard::$0 ← (byte) scroll_hard::i#2 != (number) $27
  if((bool~) scroll_hard::$0) goto scroll_hard::@2
  to:scroll_hard::@return
scroll_hard::@2: scope:[scroll_hard]  from scroll_hard::@1
  (byte) scroll_hard::i#3 ← phi( scroll_hard::@1/(byte) scroll_hard::i#2 )
  (byte*~) scroll_hard::$1 ← (const byte*) SCREEN + (number) $28*(number) 0
  (byte*~) scroll_hard::$2 ← (const byte*) SCREEN + (number) $28*(number) 0
  (number~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$1 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$2 + (number~) scroll_hard::$3)
  (byte*~) scroll_hard::$4 ← (const byte*) SCREEN + (number) $28*(number) 1
  (byte*~) scroll_hard::$5 ← (const byte*) SCREEN + (number) $28*(number) 1
  (number~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$4 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$5 + (number~) scroll_hard::$6)
  (byte*~) scroll_hard::$7 ← (const byte*) SCREEN + (number) $28*(number) 2
  (byte*~) scroll_hard::$8 ← (const byte*) SCREEN + (number) $28*(number) 2
  (number~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$7 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$8 + (number~) scroll_hard::$9)
  (byte*~) scroll_hard::$10 ← (const byte*) SCREEN + (number) $28*(number) 3
  (byte*~) scroll_hard::$11 ← (const byte*) SCREEN + (number) $28*(number) 3
  (number~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$10 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$11 + (number~) scroll_hard::$12)
  (byte*~) scroll_hard::$13 ← (const byte*) SCREEN + (number) $28*(number) 4
  (byte*~) scroll_hard::$14 ← (const byte*) SCREEN + (number) $28*(number) 4
  (number~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$13 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$14 + (number~) scroll_hard::$15)
  (byte*~) scroll_hard::$16 ← (const byte*) SCREEN + (number) $28*(number) 5
  (byte*~) scroll_hard::$17 ← (const byte*) SCREEN + (number) $28*(number) 5
  (number~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$16 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$17 + (number~) scroll_hard::$18)
  (byte*~) scroll_hard::$19 ← (const byte*) SCREEN + (number) $28*(number) 6
  (byte*~) scroll_hard::$20 ← (const byte*) SCREEN + (number) $28*(number) 6
  (number~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$19 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$20 + (number~) scroll_hard::$21)
  (byte*~) scroll_hard::$22 ← (const byte*) SCREEN + (number) $28*(number) 7
  (byte*~) scroll_hard::$23 ← (const byte*) SCREEN + (number) $28*(number) 7
  (number~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (number) 1
  *((byte*~) scroll_hard::$22 + (byte) scroll_hard::i#3) ← *((byte*~) scroll_hard::$23 + (number~) scroll_hard::$24)
  (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#3
  to:scroll_hard::@1
scroll_hard::@return: scope:[scroll_hard]  from scroll_hard::@1
  return 
  to:@return

(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
fillscreen: scope:[fillscreen]  from main
  (byte) fillscreen::fill#3 ← phi( main/(byte) fillscreen::fill#0 )
  (byte*) fillscreen::screen#1 ← phi( main/(byte*) fillscreen::screen#0 )
  (byte*) fillscreen::cursor#0 ← (byte*) fillscreen::screen#1
  to:fillscreen::@1
fillscreen::@1: scope:[fillscreen]  from fillscreen fillscreen::@2
  (byte) fillscreen::fill#2 ← phi( fillscreen/(byte) fillscreen::fill#3 fillscreen::@2/(byte) fillscreen::fill#1 )
  (byte*) fillscreen::cursor#2 ← phi( fillscreen/(byte*) fillscreen::cursor#0 fillscreen::@2/(byte*) fillscreen::cursor#1 )
  (byte*) fillscreen::screen#2 ← phi( fillscreen/(byte*) fillscreen::screen#1 fillscreen::@2/(byte*) fillscreen::screen#3 )
  (byte*~) fillscreen::$0 ← (byte*) fillscreen::screen#2 + (number) $3e8
  (bool~) fillscreen::$1 ← (byte*) fillscreen::cursor#2 < (byte*~) fillscreen::$0
  if((bool~) fillscreen::$1) goto fillscreen::@2
  to:fillscreen::@return
fillscreen::@2: scope:[fillscreen]  from fillscreen::@1
  (byte*) fillscreen::screen#3 ← phi( fillscreen::@1/(byte*) fillscreen::screen#2 )
  (byte*) fillscreen::cursor#3 ← phi( fillscreen::@1/(byte*) fillscreen::cursor#2 )
  (byte) fillscreen::fill#1 ← phi( fillscreen::@1/(byte) fillscreen::fill#2 )
  *((byte*) fillscreen::cursor#3) ← (byte) fillscreen::fill#1
  (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#3
  to:fillscreen::@1
fillscreen::@return: scope:[fillscreen]  from fillscreen::@1
  return 
  to:@return

(void()) _start()
_start: scope:[_start]  from
  to:_start::_init1
_start::_init1: scope:[_start]  from _start
  (byte) scroll#5 ← (byte) 7
  (byte*) current_chargen#6 ← (const nomodify byte*) CHARGEN
  (byte) current_bit#7 ← (byte) 1
  (byte*) nxt#9 ← (const byte*) TEXT
  to:_start::@1
_start::@1: scope:[_start]  from _start::_init1
  (byte*) current_chargen#23 ← phi( _start::_init1/(byte*) current_chargen#6 )
  (byte*) nxt#28 ← phi( _start::_init1/(byte*) nxt#9 )
  (byte) current_bit#25 ← phi( _start::_init1/(byte) current_bit#7 )
  (byte) scroll#17 ← phi( _start::_init1/(byte) scroll#5 )
  call main 
  to:_start::@2
_start::@2: scope:[_start]  from _start::@1
  (byte*) current_chargen#15 ← phi( _start::@1/(byte*) current_chargen#1 )
  (byte*) nxt#21 ← phi( _start::@1/(byte*) nxt#1 )
  (byte) current_bit#17 ← phi( _start::@1/(byte) current_bit#1 )
  (byte) scroll#13 ← phi( _start::@1/(byte) scroll#1 )
  (byte) scroll#6 ← (byte) scroll#13
  (byte) current_bit#8 ← (byte) current_bit#17
  (byte*) nxt#10 ← (byte*) nxt#21
  (byte*) current_chargen#7 ← (byte*) current_chargen#15
  to:_start::@return
_start::@return: scope:[_start]  from _start::@2
  (byte*) nxt#22 ← phi( _start::@2/(byte*) nxt#10 )
  (byte) current_bit#18 ← phi( _start::@2/(byte) current_bit#8 )
  (byte*) current_chargen#16 ← phi( _start::@2/(byte*) current_chargen#7 )
  (byte) scroll#14 ← phi( _start::@2/(byte) scroll#6 )
  (byte) scroll#7 ← (byte) scroll#14
  (byte*) current_chargen#8 ← (byte*) current_chargen#16
  (byte) current_bit#9 ← (byte) current_bit#18
  (byte*) nxt#11 ← (byte*) nxt#22
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify byte*) CHARGEN = (byte*)(number) $d000
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = (byte) $21
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = (byte) $16
(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER = (byte) $12
(const nomodify byte*) PROCPORT = (byte*)(number) 1
(const byte*) SCREEN = (byte*)(number) $400
(const byte*) TEXT = (byte*) "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
(const nomodify struct MOS6569_VICII*) VICII = (struct MOS6569_VICII*)(number) $d000
(void()) _start()
(label) _start::@1
(label) _start::@2
(label) _start::@return
(label) _start::_init1
(byte) current_bit
(byte) current_bit#0
(byte) current_bit#1
(byte) current_bit#10
(byte) current_bit#11
(byte) current_bit#12
(byte) current_bit#13
(byte) current_bit#14
(byte) current_bit#15
(byte) current_bit#16
(byte) current_bit#17
(byte) current_bit#18
(byte) current_bit#19
(byte) current_bit#2
(byte) current_bit#20
(byte) current_bit#21
(byte) current_bit#22
(byte) current_bit#23
(byte) current_bit#24
(byte) current_bit#25
(byte) current_bit#26
(byte) current_bit#27
(byte) current_bit#28
(byte) current_bit#29
(byte) current_bit#3
(byte) current_bit#30
(byte) current_bit#31
(byte) current_bit#32
(byte) current_bit#4
(byte) current_bit#5
(byte) current_bit#6
(byte) current_bit#7
(byte) current_bit#8
(byte) current_bit#9
(byte*) current_chargen
(byte*) current_chargen#0
(byte*) current_chargen#1
(byte*) current_chargen#10
(byte*) current_chargen#11
(byte*) current_chargen#12
(byte*) current_chargen#13
(byte*) current_chargen#14
(byte*) current_chargen#15
(byte*) current_chargen#16
(byte*) current_chargen#17
(byte*) current_chargen#18
(byte*) current_chargen#19
(byte*) current_chargen#2
(byte*) current_chargen#20
(byte*) current_chargen#21
(byte*) current_chargen#22
(byte*) current_chargen#23
(byte*) current_chargen#24
(byte*) current_chargen#25
(byte*) current_chargen#26
(byte*) current_chargen#27
(byte*) current_chargen#28
(byte*) current_chargen#29
(byte*) current_chargen#3
(byte*) current_chargen#30
(byte*) current_chargen#31
(byte*) current_chargen#4
(byte*) current_chargen#5
(byte*) current_chargen#6
(byte*) current_chargen#7
(byte*) current_chargen#8
(byte*) current_chargen#9
(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
(byte*~) fillscreen::$0
(bool~) fillscreen::$1
(label) fillscreen::@1
(label) fillscreen::@2
(label) fillscreen::@return
(byte*) fillscreen::cursor
(byte*) fillscreen::cursor#0
(byte*) fillscreen::cursor#1
(byte*) fillscreen::cursor#2
(byte*) fillscreen::cursor#3
(byte) fillscreen::fill
(byte) fillscreen::fill#0
(byte) fillscreen::fill#1
(byte) fillscreen::fill#2
(byte) fillscreen::fill#3
(byte*) fillscreen::screen
(byte*) fillscreen::screen#0
(byte*) fillscreen::screen#1
(byte*) fillscreen::screen#2
(byte*) fillscreen::screen#3
(void()) main()
(bool~) main::$1
(bool~) main::$2
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@return
(byte()) next_char()
(bool~) next_char::$0
(bool~) next_char::$1
(label) next_char::@1
(label) next_char::@2
(label) next_char::@return
(byte) next_char::c
(byte) next_char::c#0
(byte) next_char::c#1
(byte) next_char::c#2
(byte) next_char::return
(byte) next_char::return#0
(byte) next_char::return#1
(byte) next_char::return#2
(byte) next_char::return#3
(byte) next_char::return#4
(byte*) nxt
(byte*) nxt#0
(byte*) nxt#1
(byte*) nxt#10
(byte*) nxt#11
(byte*) nxt#12
(byte*) nxt#13
(byte*) nxt#14
(byte*) nxt#15
(byte*) nxt#16
(byte*) nxt#17
(byte*) nxt#18
(byte*) nxt#19
(byte*) nxt#2
(byte*) nxt#20
(byte*) nxt#21
(byte*) nxt#22
(byte*) nxt#23
(byte*) nxt#24
(byte*) nxt#25
(byte*) nxt#26
(byte*) nxt#27
(byte*) nxt#28
(byte*) nxt#29
(byte*) nxt#3
(byte*) nxt#30
(byte*) nxt#31
(byte*) nxt#32
(byte*) nxt#33
(byte*) nxt#34
(byte*) nxt#35
(byte*) nxt#36
(byte*) nxt#37
(byte*) nxt#38
(byte*) nxt#39
(byte*) nxt#4
(byte*) nxt#5
(byte*) nxt#6
(byte*) nxt#7
(byte*) nxt#8
(byte*) nxt#9
(byte) scroll
(byte) scroll#0
(byte) scroll#1
(byte) scroll#10
(byte) scroll#11
(byte) scroll#12
(byte) scroll#13
(byte) scroll#14
(byte) scroll#15
(byte) scroll#16
(byte) scroll#17
(byte) scroll#18
(byte) scroll#19
(byte) scroll#2
(byte) scroll#20
(byte) scroll#21
(byte) scroll#3
(byte) scroll#4
(byte) scroll#5
(byte) scroll#6
(byte) scroll#7
(byte) scroll#8
(byte) scroll#9
(void()) scroll_bit()
(number~) scroll_bit::$0
(bool~) scroll_bit::$1
(bool~) scroll_bit::$10
(bool~) scroll_bit::$11
(byte*~) scroll_bit::$12
(bool~) scroll_bit::$13
(bool~) scroll_bit::$2
(byte*~) scroll_bit::$4
(byte*~) scroll_bit::$5
(byte~) scroll_bit::$6
(number~) scroll_bit::$7
(byte*~) scroll_bit::$8
(byte~) scroll_bit::$9
(label) scroll_bit::@1
(label) scroll_bit::@2
(label) scroll_bit::@3
(label) scroll_bit::@4
(label) scroll_bit::@5
(label) scroll_bit::@6
(label) scroll_bit::@7
(label) scroll_bit::@8
(label) scroll_bit::@return
(byte) scroll_bit::b
(byte) scroll_bit::b#0
(byte) scroll_bit::b#1
(byte) scroll_bit::b#2
(byte) scroll_bit::bits
(byte) scroll_bit::bits#0
(word) scroll_bit::c
(word) scroll_bit::c#0
(byte) scroll_bit::r
(byte) scroll_bit::r#0
(byte) scroll_bit::r#1
(byte) scroll_bit::r#2
(byte) scroll_bit::r#3
(byte) scroll_bit::r#4
(byte*) scroll_bit::sc
(byte*) scroll_bit::sc#0
(byte*) scroll_bit::sc#1
(byte*) scroll_bit::sc#2
(byte*) scroll_bit::sc#3
(byte*) scroll_bit::sc#4
(void()) scroll_hard()
(bool~) scroll_hard::$0
(byte*~) scroll_hard::$1
(byte*~) scroll_hard::$10
(byte*~) scroll_hard::$11
(number~) scroll_hard::$12
(byte*~) scroll_hard::$13
(byte*~) scroll_hard::$14
(number~) scroll_hard::$15
(byte*~) scroll_hard::$16
(byte*~) scroll_hard::$17
(number~) scroll_hard::$18
(byte*~) scroll_hard::$19
(byte*~) scroll_hard::$2
(byte*~) scroll_hard::$20
(number~) scroll_hard::$21
(byte*~) scroll_hard::$22
(byte*~) scroll_hard::$23
(number~) scroll_hard::$24
(number~) scroll_hard::$3
(byte*~) scroll_hard::$4
(byte*~) scroll_hard::$5
(number~) scroll_hard::$6
(byte*~) scroll_hard::$7
(byte*~) scroll_hard::$8
(number~) scroll_hard::$9
(label) scroll_hard::@1
(label) scroll_hard::@2
(label) scroll_hard::@return
(byte) scroll_hard::i
(byte) scroll_hard::i#0
(byte) scroll_hard::i#1
(byte) scroll_hard::i#2
(byte) scroll_hard::i#3
(void()) scroll_soft()
(bool~) scroll_soft::$0
(bool~) scroll_soft::$1
(label) scroll_soft::@1
(label) scroll_soft::@2
(label) scroll_soft::@3
(label) scroll_soft::@return

Adding number conversion cast (unumber) $20 in (byte) fillscreen::fill#0 ← (number) $20
Adding number conversion cast (unumber) $fe in (bool~) main::$1 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) != (number) $fe
Adding number conversion cast (unumber) $ff in (bool~) main::$2 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) != (number) $ff
Adding number conversion cast (unumber) $ff in (bool~) scroll_soft::$0 ← (byte) scroll#2 == (number) $ff
Adding number conversion cast (unumber) 7 in (byte) scroll#3 ← (number) 7
Adding number conversion cast (unumber) 2 in (number~) scroll_bit::$0 ← (byte) current_bit#14 / (number) 2
Adding number conversion cast (unumber) scroll_bit::$0 in (number~) scroll_bit::$0 ← (byte) current_bit#14 / (unumber)(number) 2
Adding number conversion cast (unumber) 0 in (bool~) scroll_bit::$1 ← (byte) current_bit#4 == (number) 0
Adding number conversion cast (unumber) $32 in *((const nomodify byte*) PROCPORT) ← (number) $32
Adding number conversion cast (unumber) $28 in (byte*~) scroll_bit::$4 ← (const byte*) SCREEN + (number) $28
Adding number conversion cast (unumber) $27 in (byte*~) scroll_bit::$5 ← (byte*~) scroll_bit::$4 + (number) $27
Adding number conversion cast (unumber) 8 in (number~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (number) 8
Adding number conversion cast (unumber) scroll_bit::$7 in (number~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (unumber)(number) 8
Adding number conversion cast (unumber) $80 in (byte) current_bit#5 ← (number) $80
Adding number conversion cast (unumber) 0 in (bool~) scroll_bit::$10 ← (byte~) scroll_bit::$9 != (number) 0
Adding number conversion cast (unumber) $28 in (byte*~) scroll_bit::$12 ← (byte*) scroll_bit::sc#2 + (number) $28
Adding number conversion cast (unumber) $80+' ' in (byte) scroll_bit::b#1 ← (number) $80+(byte) ' '
Adding number conversion cast (unumber) $80 in (byte) scroll_bit::b#1 ← ((unumber)) (number) $80+(byte) ' '
Adding number conversion cast (unumber) $37 in *((const nomodify byte*) PROCPORT) ← (number) $37
Adding number conversion cast (unumber) 0 in (bool~) next_char::$0 ← (byte) next_char::c#0 == (number) 0
Adding number conversion cast (unumber) $27 in (bool~) scroll_hard::$0 ← (byte) scroll_hard::i#2 != (number) $27
Adding number conversion cast (unumber) $28*0 in (byte*~) scroll_hard::$1 ← (const byte*) SCREEN + (number) $28*(number) 0
Adding number conversion cast (unumber) $28*0 in (byte*~) scroll_hard::$2 ← (const byte*) SCREEN + (number) $28*(number) 0
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$3 in (number~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*1 in (byte*~) scroll_hard::$4 ← (const byte*) SCREEN + (number) $28*(number) 1
Adding number conversion cast (unumber) $28*1 in (byte*~) scroll_hard::$5 ← (const byte*) SCREEN + (number) $28*(number) 1
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$6 in (number~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*2 in (byte*~) scroll_hard::$7 ← (const byte*) SCREEN + (number) $28*(number) 2
Adding number conversion cast (unumber) $28*2 in (byte*~) scroll_hard::$8 ← (const byte*) SCREEN + (number) $28*(number) 2
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$9 in (number~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*3 in (byte*~) scroll_hard::$10 ← (const byte*) SCREEN + (number) $28*(number) 3
Adding number conversion cast (unumber) $28*3 in (byte*~) scroll_hard::$11 ← (const byte*) SCREEN + (number) $28*(number) 3
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$12 in (number~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*4 in (byte*~) scroll_hard::$13 ← (const byte*) SCREEN + (number) $28*(number) 4
Adding number conversion cast (unumber) $28*4 in (byte*~) scroll_hard::$14 ← (const byte*) SCREEN + (number) $28*(number) 4
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$15 in (number~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*5 in (byte*~) scroll_hard::$16 ← (const byte*) SCREEN + (number) $28*(number) 5
Adding number conversion cast (unumber) $28*5 in (byte*~) scroll_hard::$17 ← (const byte*) SCREEN + (number) $28*(number) 5
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$18 in (number~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*6 in (byte*~) scroll_hard::$19 ← (const byte*) SCREEN + (number) $28*(number) 6
Adding number conversion cast (unumber) $28*6 in (byte*~) scroll_hard::$20 ← (const byte*) SCREEN + (number) $28*(number) 6
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$21 in (number~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $28*7 in (byte*~) scroll_hard::$22 ← (const byte*) SCREEN + (number) $28*(number) 7
Adding number conversion cast (unumber) $28*7 in (byte*~) scroll_hard::$23 ← (const byte*) SCREEN + (number) $28*(number) 7
Adding number conversion cast (unumber) 1 in (number~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (number) 1
Adding number conversion cast (unumber) scroll_hard::$24 in (number~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $3e8 in (byte*~) fillscreen::$0 ← (byte*) fillscreen::screen#2 + (number) $3e8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte) fillscreen::fill#0 ← (unumber)(number) $20
Inlining cast (byte) scroll#3 ← (unumber)(number) 7
Inlining cast *((const nomodify byte*) PROCPORT) ← (unumber)(number) $32
Inlining cast (byte) current_bit#5 ← (unumber)(number) $80
Inlining cast (byte) scroll_bit::b#1 ← (unumber)(unumber)(number) $80+(byte) ' '
Inlining cast *((const nomodify byte*) PROCPORT) ← (unumber)(number) $37
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (struct MOS6569_VICII*) 53248
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $20
Simplifying constant integer cast $fe
Simplifying constant integer cast $ff
Simplifying constant integer cast $ff
Simplifying constant integer cast 7
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast $32
Simplifying constant integer cast $28
Simplifying constant integer cast $27
Simplifying constant integer cast 8
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast (unumber)(number) $80+(byte) ' '
Simplifying constant integer cast $80
Simplifying constant integer cast $37
Simplifying constant integer cast 0
Simplifying constant integer cast $27
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $3e8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) $fe
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) $37
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3e8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) scroll_bit::$0 ← (byte) current_bit#14 / (byte) 2
Inferred type updated to word in (unumber~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (byte) 8
Inferred type updated to byte in (unumber~) scroll_hard::$3 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$6 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$9 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$12 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$15 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$18 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$21 ← (byte) scroll_hard::i#3 + (byte) 1
Inferred type updated to byte in (unumber~) scroll_hard::$24 ← (byte) scroll_hard::i#3 + (byte) 1
Inversing boolean not [30] (bool~) scroll_soft::$1 ← (byte) scroll#2 != (byte) $ff from [29] (bool~) scroll_soft::$0 ← (byte) scroll#2 == (byte) $ff
Inversing boolean not [51] (bool~) scroll_bit::$2 ← (byte) current_bit#4 != (byte) 0 from [50] (bool~) scroll_bit::$1 ← (byte) current_bit#4 == (byte) 0
Inversing boolean not [78] (bool~) scroll_bit::$11 ← (byte~) scroll_bit::$9 == (byte) 0 from [77] (bool~) scroll_bit::$10 ← (byte~) scroll_bit::$9 != (byte) 0
Inversing boolean not [100] (bool~) next_char::$1 ← (byte) next_char::c#0 != (byte) 0 from [99] (bool~) next_char::$0 ← (byte) next_char::c#0 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias scroll#20 = scroll#21 
Alias current_bit#31 = current_bit#32 
Alias nxt#36 = nxt#38 
Alias current_chargen#30 = current_chargen#31 
Alias scroll#15 = scroll#18 
Alias current_bit#19 = current_bit#26 
Alias nxt#23 = nxt#29 
Alias current_chargen#17 = current_chargen#24 
Alias scroll#0 = scroll#8 scroll#9 scroll#1 
Alias current_bit#0 = current_bit#10 current_bit#11 current_bit#1 
Alias nxt#0 = nxt#12 nxt#13 nxt#1 
Alias current_chargen#0 = current_chargen#9 current_chargen#10 current_chargen#1 
Alias current_bit#20 = current_bit#27 
Alias nxt#24 = nxt#30 
Alias current_chargen#18 = current_chargen#25 
Alias scroll#16 = scroll#3 
Alias current_bit#12 = current_bit#2 
Alias nxt#14 = nxt#2 
Alias current_chargen#11 = current_chargen#2 
Alias scroll#11 = scroll#12 scroll#4 
Alias current_bit#13 = current_bit#21 current_bit#3 
Alias nxt#15 = nxt#25 nxt#3 
Alias current_chargen#12 = current_chargen#19 current_chargen#3 
Alias current_bit#4 = scroll_bit::$0 
Alias current_chargen#21 = current_chargen#26 
Alias current_bit#23 = current_bit#28 
Alias nxt#37 = nxt#39 
Alias scroll_bit::sc#0 = scroll_bit::$5 
Alias nxt#26 = nxt#31 
Alias next_char::return#0 = next_char::return#3 
Alias nxt#16 = nxt#4 
Alias scroll_bit::c#0 = scroll_bit::$6 
Alias current_chargen#4 = scroll_bit::$8 
Alias scroll_bit::sc#1 = scroll_bit::$12 
Alias scroll_bit::sc#3 = scroll_bit::sc#4 
Alias scroll_bit::r#2 = scroll_bit::r#4 
Alias current_chargen#13 = current_chargen#27 
Alias current_bit#15 = current_bit#29 
Alias nxt#34 = nxt#35 
Alias current_bit#16 = current_bit#24 current_bit#22 current_bit#6 
Alias nxt#17 = nxt#27 nxt#32 nxt#5 
Alias current_chargen#14 = current_chargen#22 current_chargen#20 current_chargen#5 
Alias next_char::return#1 = next_char::c#2 next_char::return#4 next_char::return#2 
Alias nxt#20 = nxt#6 nxt#8 
Alias scroll_hard::i#2 = scroll_hard::i#3 
Alias fillscreen::cursor#0 = fillscreen::screen#1 
Alias fillscreen::fill#1 = fillscreen::fill#2 
Alias fillscreen::cursor#2 = fillscreen::cursor#3 
Alias fillscreen::screen#2 = fillscreen::screen#3 
Alias scroll#17 = scroll#5 
Alias current_bit#25 = current_bit#7 
Alias nxt#28 = nxt#9 
Alias current_chargen#23 = current_chargen#6 
Alias scroll#13 = scroll#6 scroll#14 scroll#7 
Alias current_bit#17 = current_bit#8 current_bit#18 current_bit#9 
Alias nxt#10 = nxt#21 nxt#22 nxt#11 
Alias current_chargen#15 = current_chargen#7 current_chargen#16 current_chargen#8 
Successful SSA optimization Pass2AliasElimination
Alias scroll_bit::sc#2 = scroll_bit::sc#3 
Alias scroll_bit::r#2 = scroll_bit::r#3 
Alias current_chargen#13 = current_chargen#14 
Alias current_bit#15 = current_bit#16 
Alias nxt#17 = nxt#34 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) scroll#20 (byte) scroll#17
Identical Phi Values (byte) current_bit#31 (byte) current_bit#25
Identical Phi Values (byte*) nxt#36 (byte*) nxt#28
Identical Phi Values (byte*) current_chargen#30 (byte*) current_chargen#23
Identical Phi Values (byte) scroll#15 (byte) scroll#19
Identical Phi Values (byte) current_bit#19 (byte) current_bit#30
Identical Phi Values (byte*) nxt#23 (byte*) nxt#33
Identical Phi Values (byte*) current_chargen#17 (byte*) current_chargen#28
Identical Phi Values (byte) scroll#0 (byte) scroll#11
Identical Phi Values (byte) current_bit#0 (byte) current_bit#13
Identical Phi Values (byte*) nxt#0 (byte*) nxt#15
Identical Phi Values (byte*) current_chargen#0 (byte*) current_chargen#12
Identical Phi Values (byte) scroll#10 (byte) scroll#15
Identical Phi Values (byte) current_bit#20 (byte) current_bit#19
Identical Phi Values (byte*) nxt#24 (byte*) nxt#23
Identical Phi Values (byte*) current_chargen#18 (byte*) current_chargen#17
Identical Phi Values (byte) current_bit#12 (byte) current_bit#15
Identical Phi Values (byte*) nxt#14 (byte*) nxt#17
Identical Phi Values (byte*) current_chargen#11 (byte*) current_chargen#13
Identical Phi Values (byte) current_bit#14 (byte) current_bit#20
Identical Phi Values (byte*) nxt#26 (byte*) nxt#24
Identical Phi Values (byte*) current_chargen#29 (byte*) current_chargen#18
Identical Phi Values (byte*) nxt#16 (byte*) nxt#20
Identical Phi Values (byte*) current_chargen#13 (byte*) current_chargen#21
Identical Phi Values (byte) current_bit#15 (byte) current_bit#23
Identical Phi Values (byte*) nxt#17 (byte*) nxt#37
Identical Phi Values (byte*) nxt#18 (byte*) nxt#26
Identical Phi Values (byte*) fillscreen::cursor#0 (byte*) fillscreen::screen#0
Identical Phi Values (byte) fillscreen::fill#3 (byte) fillscreen::fill#0
Identical Phi Values (byte*) fillscreen::screen#2 (byte*) fillscreen::cursor#0
Identical Phi Values (byte) fillscreen::fill#1 (byte) fillscreen::fill#3
Identical Phi Values (byte) scroll#13 (byte) scroll#0
Identical Phi Values (byte) current_bit#17 (byte) current_bit#0
Identical Phi Values (byte*) nxt#10 (byte*) nxt#0
Identical Phi Values (byte*) current_chargen#15 (byte*) current_chargen#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$1 [6] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1
Simple Condition (bool~) main::$2 [9] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2
Simple Condition (bool~) scroll_soft::$1 [19] if((byte) scroll#2!=(byte) $ff) goto scroll_soft::@1
Simple Condition (bool~) scroll_bit::$2 [29] if((byte) current_bit#4!=(byte) 0) goto scroll_bit::@1
Simple Condition (bool~) scroll_bit::$11 [49] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4
Simple Condition (bool~) scroll_bit::$13 [55] if((byte) scroll_bit::r#1!=rangelast(0,7)) goto scroll_bit::@3
Simple Condition (bool~) next_char::$1 [63] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1
Simple Condition (bool~) scroll_hard::$0 [72] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2
Simple Condition (bool~) fillscreen::$1 [111] if((byte*) fillscreen::cursor#2<(byte*~) fillscreen::$0) goto fillscreen::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [34] (byte*~) scroll_bit::$4 ← (const byte*) SCREEN + (byte) $28
Constant right-side identified [73] (byte*~) scroll_hard::$1 ← (const byte*) SCREEN + (byte)(number) $28*(number) 0
Constant right-side identified [74] (byte*~) scroll_hard::$2 ← (const byte*) SCREEN + (byte)(number) $28*(number) 0
Constant right-side identified [77] (byte*~) scroll_hard::$4 ← (const byte*) SCREEN + (byte)(number) $28*(number) 1
Constant right-side identified [78] (byte*~) scroll_hard::$5 ← (const byte*) SCREEN + (byte)(number) $28*(number) 1
Constant right-side identified [81] (byte*~) scroll_hard::$7 ← (const byte*) SCREEN + (byte)(number) $28*(number) 2
Constant right-side identified [82] (byte*~) scroll_hard::$8 ← (const byte*) SCREEN + (byte)(number) $28*(number) 2
Constant right-side identified [85] (byte*~) scroll_hard::$10 ← (const byte*) SCREEN + (byte)(number) $28*(number) 3
Constant right-side identified [86] (byte*~) scroll_hard::$11 ← (const byte*) SCREEN + (byte)(number) $28*(number) 3
Constant right-side identified [89] (byte*~) scroll_hard::$13 ← (const byte*) SCREEN + (byte)(number) $28*(number) 4
Constant right-side identified [90] (byte*~) scroll_hard::$14 ← (const byte*) SCREEN + (byte)(number) $28*(number) 4
Constant right-side identified [93] (byte*~) scroll_hard::$16 ← (const byte*) SCREEN + (byte)(number) $28*(number) 5
Constant right-side identified [94] (byte*~) scroll_hard::$17 ← (const byte*) SCREEN + (byte)(number) $28*(number) 5
Constant right-side identified [97] (byte*~) scroll_hard::$19 ← (const byte*) SCREEN + (byte)(number) $28*(number) 6
Constant right-side identified [98] (byte*~) scroll_hard::$20 ← (const byte*) SCREEN + (byte)(number) $28*(number) 6
Constant right-side identified [101] (byte*~) scroll_hard::$22 ← (const byte*) SCREEN + (word)(number) $28*(number) 7
Constant right-side identified [102] (byte*~) scroll_hard::$23 ← (const byte*) SCREEN + (word)(number) $28*(number) 7
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) fillscreen::screen#0 = SCREEN
Constant (const byte) fillscreen::fill#0 = $20
Constant (const byte) scroll#16 = 7
Constant (const byte*) scroll_bit::$4 = SCREEN+$28
Constant (const byte) scroll_bit::r#0 = 0
Constant (const byte) current_bit#5 = $80
Constant (const byte) scroll_bit::b#0 = ' '
Constant (const byte) scroll_bit::b#1 = $80+' '
Constant (const byte*) nxt#7 = TEXT
Constant (const byte) scroll_hard::i#0 = 0
Constant (const byte*) scroll_hard::$1 = SCREEN+(byte)$28*0
Constant (const byte*) scroll_hard::$2 = SCREEN+(byte)$28*0
Constant (const byte*) scroll_hard::$4 = SCREEN+(byte)$28*1
Constant (const byte*) scroll_hard::$5 = SCREEN+(byte)$28*1
Constant (const byte*) scroll_hard::$7 = SCREEN+(byte)$28*2
Constant (const byte*) scroll_hard::$8 = SCREEN+(byte)$28*2
Constant (const byte*) scroll_hard::$10 = SCREEN+(byte)$28*3
Constant (const byte*) scroll_hard::$11 = SCREEN+(byte)$28*3
Constant (const byte*) scroll_hard::$13 = SCREEN+(byte)$28*4
Constant (const byte*) scroll_hard::$14 = SCREEN+(byte)$28*4
Constant (const byte*) scroll_hard::$16 = SCREEN+(byte)$28*5
Constant (const byte*) scroll_hard::$17 = SCREEN+(byte)$28*5
Constant (const byte*) scroll_hard::$19 = SCREEN+(byte)$28*6
Constant (const byte*) scroll_hard::$20 = SCREEN+(byte)$28*6
Constant (const byte*) scroll_hard::$22 = SCREEN+(word)$28*7
Constant (const byte*) scroll_hard::$23 = SCREEN+(word)$28*7
Constant (const byte) scroll#17 = 7
Constant (const byte*) current_chargen#23 = CHARGEN
Constant (const byte) current_bit#25 = 1
Constant (const byte*) nxt#28 = TEXT
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [14] if(true) goto main::@1
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [53] scroll_bit::r#1 ← ++ scroll_bit::r#2 to ++
Resolved ranged comparison value [55] if(scroll_bit::r#1!=rangelast(0,7)) goto scroll_bit::@3 to (number) 8
Simplifying constant evaluating to zero (byte)(number) $28*(number) 0 in 
Simplifying constant evaluating to zero (byte)(number) $28*(number) 0 in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero SCREEN in 
Simplifying expression containing zero SCREEN in 
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure _start
Removing unused procedure block _start
Removing unused procedure block _start::_init1
Removing unused procedure block _start::@1
Removing unused procedure block _start::@2
Removing unused procedure block _start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 8 in [33] if((byte) scroll_bit::r#1!=(number) 8) goto scroll_bit::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [19] (byte*) scroll_bit::sc#0 ← (const byte*) scroll_bit::$4 + (byte) $27
Constant right-side identified [64] (byte*~) fillscreen::$0 ← (const byte*) fillscreen::screen#0 + (word) $3e8
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) scroll_bit::sc#0 = scroll_bit::$4+$27
Constant (const byte*) fillscreen::$0 = fillscreen::screen#0+$3e8
Successful SSA optimization Pass2ConstantIdentification
Rewriting division to use shift [13] (byte) current_bit#4 ← (byte) current_bit#30 / (byte) 2
Rewriting multiplication to use shift [22] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 * (byte) 8
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) scroll_bit::r#0
Inlining constant with var siblings (const byte) scroll_bit::b#0
Inlining constant with var siblings (const byte) scroll_bit::b#1
Inlining constant with var siblings (const byte*) scroll_bit::sc#0
Inlining constant with var siblings (const byte) scroll_hard::i#0
Inlining constant with var siblings (const byte) scroll#16
Inlining constant with var siblings (const byte) current_bit#5
Inlining constant with var siblings (const byte*) nxt#7
Inlining constant with var siblings (const byte) scroll#17
Inlining constant with var siblings (const byte*) current_chargen#23
Inlining constant with var siblings (const byte) current_bit#25
Inlining constant with var siblings (const byte*) nxt#28
Constant inlined scroll_hard::$4 = (const byte*) SCREEN+(byte)(number) $28*(number) 1
Constant inlined current_chargen#23 = (const nomodify byte*) CHARGEN
Constant inlined scroll_hard::$5 = (const byte*) SCREEN+(byte)(number) $28*(number) 1
Constant inlined scroll_hard::$2 = (const byte*) SCREEN
Constant inlined scroll_hard::$1 = (const byte*) SCREEN
Constant inlined scroll_hard::$23 = (const byte*) SCREEN+(word)(number) $28*(number) 7
Constant inlined current_bit#25 = (byte) 1
Constant inlined scroll_bit::r#0 = (byte) 0
Constant inlined fillscreen::screen#0 = (const byte*) SCREEN
Constant inlined current_bit#5 = (byte) $80
Constant inlined nxt#7 = (const byte*) TEXT
Constant inlined scroll_hard::$8 = (const byte*) SCREEN+(byte)(number) $28*(number) 2
Constant inlined scroll_hard::$7 = (const byte*) SCREEN+(byte)(number) $28*(number) 2
Constant inlined scroll_hard::$20 = (const byte*) SCREEN+(byte)(number) $28*(number) 6
Constant inlined scroll_hard::$22 = (const byte*) SCREEN+(word)(number) $28*(number) 7
Constant inlined scroll_hard::i#0 = (byte) 0
Constant inlined scroll_bit::$4 = (const byte*) SCREEN+(byte) $28
Constant inlined scroll_bit::b#0 = (byte) ' '
Constant inlined fillscreen::$0 = (const byte*) SCREEN+(word) $3e8
Constant inlined scroll_bit::b#1 = (byte) $80+(byte) ' '
Constant inlined scroll_hard::$13 = (const byte*) SCREEN+(byte)(number) $28*(number) 4
Constant inlined scroll_hard::$14 = (const byte*) SCREEN+(byte)(number) $28*(number) 4
Constant inlined scroll_hard::$16 = (const byte*) SCREEN+(byte)(number) $28*(number) 5
Constant inlined scroll_hard::$17 = (const byte*) SCREEN+(byte)(number) $28*(number) 5
Constant inlined scroll_hard::$19 = (const byte*) SCREEN+(byte)(number) $28*(number) 6
Constant inlined nxt#28 = (const byte*) TEXT
Constant inlined scroll#17 = (byte) 7
Constant inlined scroll_bit::sc#0 = (const byte*) SCREEN+(byte) $28+(byte) $27
Constant inlined scroll#16 = (byte) 7
Constant inlined scroll_hard::$10 = (const byte*) SCREEN+(byte)(number) $28*(number) 3
Constant inlined scroll_hard::$11 = (const byte*) SCREEN+(byte)(number) $28*(number) 3
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(SCREEN+1 + scroll_hard::$3)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*1+1 + scroll_hard::$6)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*2+1 + scroll_hard::$9)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*3+1 + scroll_hard::$12)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*4+1 + scroll_hard::$15)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*5+1 + scroll_hard::$18)
Consolidated array index constant in assignment *(SCREEN+(byte)$28*6+1 + scroll_hard::$21)
Consolidated array index constant in assignment *(SCREEN+(word)$28*7+1 + scroll_hard::$24)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias scroll_hard::i#2 = scroll_hard::$3 scroll_hard::$6 scroll_hard::$9 scroll_hard::$12 scroll_hard::$15 scroll_hard::$18 scroll_hard::$21 scroll_hard::$24 
Successful SSA optimization Pass2AliasElimination
Added new block during phi lifting main::@6(between main::@1 and main::@1)
Added new block during phi lifting scroll_soft::@4(between scroll_soft and scroll_soft::@1)
Added new block during phi lifting scroll_bit::@9(between scroll_bit and scroll_bit::@1)
Added new block during phi lifting scroll_bit::@10(between scroll_bit::@4 and scroll_bit::@3)
Added new block during phi lifting next_char::@3(between next_char and next_char::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of scroll_soft::@2
Adding NOP phi() at start of scroll_bit::@2
Adding NOP phi() at start of scroll_bit::@5
Adding NOP phi() at start of scroll_hard
Adding NOP phi() at start of fillscreen
CALL GRAPH
Calls in [main] to fillscreen:1 scroll_soft:7 
Calls in [scroll_soft] to scroll_bit:20 
Calls in [scroll_bit] to next_char:34 scroll_hard:42 

Created 18 initial phi equivalence classes
Coalesced [9] scroll#23 ← scroll#11
Coalesced [10] current_bit#34 ← current_bit#13
Coalesced [11] nxt#41 ← nxt#15
Coalesced [12] current_chargen#33 ← current_chargen#12
Coalesced (already) [13] scroll#22 ← scroll#19
Coalesced (already) [14] current_bit#33 ← current_bit#30
Coalesced (already) [15] nxt#40 ← nxt#33
Coalesced (already) [16] current_chargen#32 ← current_chargen#28
Coalesced [21] current_bit#36 ← current_bit#23
Coalesced [22] nxt#43 ← nxt#37
Coalesced [23] current_chargen#35 ← current_chargen#21
Coalesced [27] scroll#24 ← scroll#2
Coalesced (already) [28] current_bit#35 ← current_bit#30
Coalesced (already) [29] nxt#42 ← nxt#33
Coalesced (already) [30] current_chargen#34 ← current_chargen#28
Coalesced [39] current_chargen#37 ← current_chargen#4
Coalesced [40] nxt#45 ← nxt#20
Coalesced [58] scroll_bit::r#5 ← scroll_bit::r#1
Coalesced [59] scroll_bit::sc#5 ← scroll_bit::sc#1
Coalesced (already) [60] current_chargen#36 ← current_chargen#28
Coalesced [61] current_bit#37 ← current_bit#4
Coalesced (already) [62] nxt#44 ← nxt#33
Coalesced [76] scroll_hard::i#4 ← scroll_hard::i#1
Coalesced [80] next_char::return#6 ← next_char::c#1
Coalesced [84] nxt#46 ← nxt#33
Coalesced [85] next_char::return#5 ← next_char::c#0
Coalesced [92] fillscreen::cursor#4 ← fillscreen::cursor#1
Coalesced down to 10 phi equivalence classes
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@6
Culled Empty Block (label) scroll_soft::@3
Culled Empty Block (label) scroll_soft::@4
Culled Empty Block (label) scroll_bit::@10
Culled Empty Block (label) scroll_bit::@9
Culled Empty Block (label) next_char::@3
Renumbering block main::@5 to main::@4
Adding NOP phi() at start of main
Adding NOP phi() at start of scroll_soft::@2
Adding NOP phi() at start of scroll_bit::@2
Adding NOP phi() at start of scroll_bit::@5
Adding NOP phi() at start of scroll_hard
Adding NOP phi() at start of fillscreen

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call fillscreen 
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@4
  [2] (byte*) current_chargen#28 ← phi( main::@1/(byte*) current_chargen#28 main/(const nomodify byte*) CHARGEN main::@4/(byte*) current_chargen#12 )
  [2] (byte*) nxt#33 ← phi( main::@1/(byte*) nxt#33 main/(const byte*) TEXT main::@4/(byte*) nxt#15 )
  [2] (byte) current_bit#30 ← phi( main::@1/(byte) current_bit#30 main/(byte) 1 main::@4/(byte) current_bit#13 )
  [2] (byte) scroll#19 ← phi( main::@1/(byte) scroll#19 main/(byte) 7 main::@4/(byte) scroll#11 )
  [3] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@2
  [4] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  [5] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← ++ *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR)
  [6] call scroll_soft 
  to:main::@4
main::@4: scope:[main]  from main::@3
  [7] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← -- *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR)
  to:main::@1

(void()) scroll_soft()
scroll_soft: scope:[scroll_soft]  from main::@3
  [8] (byte) scroll#2 ← -- (byte) scroll#19
  [9] if((byte) scroll#2!=(byte) $ff) goto scroll_soft::@1
  to:scroll_soft::@2
scroll_soft::@2: scope:[scroll_soft]  from scroll_soft
  [10] phi()
  [11] call scroll_bit 
  to:scroll_soft::@1
scroll_soft::@1: scope:[scroll_soft]  from scroll_soft scroll_soft::@2
  [12] (byte*) current_chargen#12 ← phi( scroll_soft/(byte*) current_chargen#28 scroll_soft::@2/(byte*) current_chargen#21 )
  [12] (byte*) nxt#15 ← phi( scroll_soft/(byte*) nxt#33 scroll_soft::@2/(byte*) nxt#37 )
  [12] (byte) current_bit#13 ← phi( scroll_soft/(byte) current_bit#30 scroll_soft::@2/(byte) current_bit#23 )
  [12] (byte) scroll#11 ← phi( scroll_soft/(byte) scroll#2 scroll_soft::@2/(byte) 7 )
  [13] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) scroll#11
  to:scroll_soft::@return
scroll_soft::@return: scope:[scroll_soft]  from scroll_soft::@1
  [14] return 
  to:@return

(void()) scroll_bit()
scroll_bit: scope:[scroll_bit]  from scroll_soft::@2
  [15] (byte) current_bit#4 ← (byte) current_bit#30 >> (byte) 1
  [16] if((byte) current_bit#4!=(byte) 0) goto scroll_bit::@1
  to:scroll_bit::@2
scroll_bit::@2: scope:[scroll_bit]  from scroll_bit
  [17] phi()
  [18] call next_char 
  [19] (byte) next_char::return#0 ← (byte) next_char::return#1
  to:scroll_bit::@8
scroll_bit::@8: scope:[scroll_bit]  from scroll_bit::@2
  [20] (word) scroll_bit::c#0 ← (byte) next_char::return#0
  [21] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3
  [22] (byte*) current_chargen#4 ← (const nomodify byte*) CHARGEN + (word~) scroll_bit::$7
  to:scroll_bit::@1
scroll_bit::@1: scope:[scroll_bit]  from scroll_bit scroll_bit::@8
  [23] (byte*) nxt#37 ← phi( scroll_bit/(byte*) nxt#33 scroll_bit::@8/(byte*) nxt#20 )
  [23] (byte) current_bit#23 ← phi( scroll_bit/(byte) current_bit#4 scroll_bit::@8/(byte) $80 )
  [23] (byte*) current_chargen#21 ← phi( scroll_bit/(byte*) current_chargen#28 scroll_bit::@8/(byte*) current_chargen#4 )
  [24] call scroll_hard 
  to:scroll_bit::@7
scroll_bit::@7: scope:[scroll_bit]  from scroll_bit::@1
  asm { sei  }
  [26] *((const nomodify byte*) PROCPORT) ← (byte) $32
  to:scroll_bit::@3
scroll_bit::@3: scope:[scroll_bit]  from scroll_bit::@4 scroll_bit::@7
  [27] (byte*) scroll_bit::sc#2 ← phi( scroll_bit::@4/(byte*) scroll_bit::sc#1 scroll_bit::@7/(const byte*) SCREEN+(byte) $28+(byte) $27 )
  [27] (byte) scroll_bit::r#2 ← phi( scroll_bit::@4/(byte) scroll_bit::r#1 scroll_bit::@7/(byte) 0 )
  [28] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#21 + (byte) scroll_bit::r#2)
  [29] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#23
  [30] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4
  to:scroll_bit::@5
scroll_bit::@5: scope:[scroll_bit]  from scroll_bit::@3
  [31] phi()
  to:scroll_bit::@4
scroll_bit::@4: scope:[scroll_bit]  from scroll_bit::@3 scroll_bit::@5
  [32] (byte) scroll_bit::b#2 ← phi( scroll_bit::@3/(byte) ' ' scroll_bit::@5/(byte) $80+(byte) ' ' )
  [33] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2
  [34] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28
  [35] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2
  [36] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3
  to:scroll_bit::@6
scroll_bit::@6: scope:[scroll_bit]  from scroll_bit::@4
  [37] *((const nomodify byte*) PROCPORT) ← (byte) $37
  asm { cli  }
  to:scroll_bit::@return
scroll_bit::@return: scope:[scroll_bit]  from scroll_bit::@6
  [39] return 
  to:@return

(void()) scroll_hard()
scroll_hard: scope:[scroll_hard]  from scroll_bit::@1
  [40] phi()
  to:scroll_hard::@1
scroll_hard::@1: scope:[scroll_hard]  from scroll_hard scroll_hard::@2
  [41] (byte) scroll_hard::i#2 ← phi( scroll_hard/(byte) 0 scroll_hard::@2/(byte) scroll_hard::i#1 )
  [42] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2
  to:scroll_hard::@return
scroll_hard::@return: scope:[scroll_hard]  from scroll_hard::@1
  [43] return 
  to:@return
scroll_hard::@2: scope:[scroll_hard]  from scroll_hard::@1
  [44] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2)
  [45] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2)
  [46] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2)
  [47] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2)
  [48] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2)
  [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2)
  [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2)
  [51] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2)
  [52] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2
  to:scroll_hard::@1

(byte()) next_char()
next_char: scope:[next_char]  from scroll_bit::@2
  [53] (byte) next_char::c#0 ← *((byte*) nxt#33)
  [54] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1
  to:next_char::@2
next_char::@2: scope:[next_char]  from next_char
  [55] (byte) next_char::c#1 ← *((const byte*) TEXT)
  to:next_char::@1
next_char::@1: scope:[next_char]  from next_char next_char::@2
  [56] (byte) next_char::return#1 ← phi( next_char/(byte) next_char::c#0 next_char::@2/(byte) next_char::c#1 )
  [56] (byte*) nxt#19 ← phi( next_char/(byte*) nxt#33 next_char::@2/(const byte*) TEXT )
  [57] (byte*) nxt#20 ← ++ (byte*) nxt#19
  to:next_char::@return
next_char::@return: scope:[next_char]  from next_char::@1
  [58] return 
  to:@return

(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
fillscreen: scope:[fillscreen]  from main
  [59] phi()
  to:fillscreen::@1
fillscreen::@1: scope:[fillscreen]  from fillscreen fillscreen::@2
  [60] (byte*) fillscreen::cursor#2 ← phi( fillscreen/(const byte*) SCREEN fillscreen::@2/(byte*) fillscreen::cursor#1 )
  [61] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2
  to:fillscreen::@return
fillscreen::@return: scope:[fillscreen]  from fillscreen::@1
  [62] return 
  to:@return
fillscreen::@2: scope:[fillscreen]  from fillscreen::@1
  [63] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0
  [64] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2
  to:fillscreen::@1


VARIABLE REGISTER WEIGHTS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(byte) current_bit
(byte) current_bit#13 42.599999999999994
(byte) current_bit#23 5616.833333333334
(byte) current_bit#30 187.85714285714286
(byte) current_bit#4 1501.5
(byte*) current_chargen
(byte*) current_chargen#12 42.599999999999994
(byte*) current_chargen#21 5672.444444444444
(byte*) current_chargen#28 146.11111111111111
(byte*) current_chargen#4 2002.0
(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
(byte*) fillscreen::cursor
(byte*) fillscreen::cursor#1 202.0
(byte*) fillscreen::cursor#2 134.66666666666666
(byte) fillscreen::fill
(byte*) fillscreen::screen
(void()) main()
(byte()) next_char()
(byte) next_char::c
(byte) next_char::c#0 15001.5
(byte) next_char::c#1 20002.0
(byte) next_char::return
(byte) next_char::return#0 2002.0
(byte) next_char::return#1 5250.75
(byte*) nxt
(byte*) nxt#15 42.599999999999994
(byte*) nxt#19 20002.0
(byte*) nxt#20 1571.7142857142858
(byte*) nxt#33 1776.4166666666665
(byte*) nxt#37 116.83333333333334
(byte) scroll
(byte) scroll#11 42.599999999999994
(byte) scroll#19 78.5
(byte) scroll#2 151.5
(void()) scroll_bit()
(word~) scroll_bit::$7 2002.0
(byte~) scroll_bit::$9 200002.0
(byte) scroll_bit::b
(byte) scroll_bit::b#2 100001.0
(byte) scroll_bit::bits
(byte) scroll_bit::bits#0 200002.0
(word) scroll_bit::c
(word) scroll_bit::c#0 2002.0
(byte) scroll_bit::r
(byte) scroll_bit::r#1 150001.5
(byte) scroll_bit::r#2 37500.375
(byte*) scroll_bit::sc
(byte*) scroll_bit::sc#1 66667.33333333333
(byte*) scroll_bit::sc#2 42857.57142857143
(void()) scroll_hard()
(byte) scroll_hard::i
(byte) scroll_hard::i#1 2000002.0
(byte) scroll_hard::i#2 1900001.9000000006
(void()) scroll_soft()

Initial phi equivalence classes
[ scroll#19 scroll#11 scroll#2 ]
[ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
[ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ]
[ scroll_bit::r#2 scroll_bit::r#1 ]
[ scroll_bit::sc#2 scroll_bit::sc#1 ]
[ scroll_bit::b#2 ]
[ scroll_hard::i#2 scroll_hard::i#1 ]
[ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ]
[ next_char::return#1 next_char::c#0 next_char::c#1 ]
[ fillscreen::cursor#2 fillscreen::cursor#1 ]
Added variable next_char::return#0 to live range equivalence class [ next_char::return#0 ]
Added variable scroll_bit::c#0 to live range equivalence class [ scroll_bit::c#0 ]
Added variable scroll_bit::$7 to live range equivalence class [ scroll_bit::$7 ]
Added variable scroll_bit::bits#0 to live range equivalence class [ scroll_bit::bits#0 ]
Added variable scroll_bit::$9 to live range equivalence class [ scroll_bit::$9 ]
Complete equivalence classes
[ scroll#19 scroll#11 scroll#2 ]
[ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
[ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ]
[ scroll_bit::r#2 scroll_bit::r#1 ]
[ scroll_bit::sc#2 scroll_bit::sc#1 ]
[ scroll_bit::b#2 ]
[ scroll_hard::i#2 scroll_hard::i#1 ]
[ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ]
[ next_char::return#1 next_char::c#0 next_char::c#1 ]
[ fillscreen::cursor#2 fillscreen::cursor#1 ]
[ next_char::return#0 ]
[ scroll_bit::c#0 ]
[ scroll_bit::$7 ]
[ scroll_bit::bits#0 ]
[ scroll_bit::$9 ]
Allocated zp[1]:2 [ scroll#19 scroll#11 scroll#2 ]
Allocated zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
Allocated zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ]
Allocated zp[1]:6 [ scroll_bit::r#2 scroll_bit::r#1 ]
Allocated zp[2]:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ]
Allocated zp[1]:9 [ scroll_bit::b#2 ]
Allocated zp[1]:10 [ scroll_hard::i#2 scroll_hard::i#1 ]
Allocated zp[2]:11 [ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ]
Allocated zp[1]:13 [ next_char::return#1 next_char::c#0 next_char::c#1 ]
Allocated zp[2]:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ]
Allocated zp[1]:16 [ next_char::return#0 ]
Allocated zp[2]:17 [ scroll_bit::c#0 ]
Allocated zp[2]:19 [ scroll_bit::$7 ]
Allocated zp[1]:21 [ scroll_bit::bits#0 ]
Allocated zp[1]:22 [ scroll_bit::$9 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// An 8x8 char letter scroller
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = $21
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = $16
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The address of the CHARGEN character set
  .label CHARGEN = $d000
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  .label SCREEN = $400
  // Soft-scroll using $d016 - trigger bit-scroll/char-scroll when needed
  .label scroll = 2
  .label current_bit = 3
  // Scroll the next bit from the current char onto the screen - trigger next char if needed
  .label current_chargen = 4
  .label nxt = $b
  // main
main: {
    // [1] call fillscreen 
    // [59] phi from main to fillscreen [phi:main->fillscreen]
  fillscreen_from_main:
    jsr fillscreen
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [2] phi (byte*) current_chargen#28 = (const nomodify byte*) CHARGEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z current_chargen
    lda #>CHARGEN
    sta.z current_chargen+1
    // [2] phi (byte*) nxt#33 = (const byte*) TEXT [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [2] phi (byte) current_bit#30 = (byte) 1 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #1
    sta.z current_bit
    // [2] phi (byte) scroll#19 = (byte) 7 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    lda #7
    sta.z scroll
    jmp __b1
  // Wait for raster
    // [2] phi from main::@1 main::@4 to main::@1 [phi:main::@1/main::@4->main::@1]
  __b1_from___b1:
  __b1_from___b4:
    // [2] phi (byte*) current_chargen#28 = (byte*) current_chargen#28 [phi:main::@1/main::@4->main::@1#0] -- register_copy 
    // [2] phi (byte*) nxt#33 = (byte*) nxt#33 [phi:main::@1/main::@4->main::@1#1] -- register_copy 
    // [2] phi (byte) current_bit#30 = (byte) current_bit#30 [phi:main::@1/main::@4->main::@1#2] -- register_copy 
    // [2] phi (byte) scroll#19 = (byte) scroll#19 [phi:main::@1/main::@4->main::@1#3] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [3] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    bne __b1_from___b1
    jmp __b2
    // main::@2
  __b2:
    // [4] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [5] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← ++ *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    // [6] call scroll_soft 
    jsr scroll_soft
    jmp __b4
    // main::@4
  __b4:
    // [7] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← -- *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    jmp __b1_from___b4
}
  // scroll_soft
scroll_soft: {
    // [8] (byte) scroll#2 ← -- (byte) scroll#19 -- vbuz1=_dec_vbuz1 
    dec.z scroll
    // [9] if((byte) scroll#2!=(byte) $ff) goto scroll_soft::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z scroll
    bne __b1_from_scroll_soft
    // [10] phi from scroll_soft to scroll_soft::@2 [phi:scroll_soft->scroll_soft::@2]
  __b2_from_scroll_soft:
    jmp __b2
    // scroll_soft::@2
  __b2:
    // [11] call scroll_bit 
    jsr scroll_bit
    // [12] phi from scroll_soft::@2 to scroll_soft::@1 [phi:scroll_soft::@2->scroll_soft::@1]
  __b1_from___b2:
    // [12] phi (byte*) current_chargen#12 = (byte*) current_chargen#21 [phi:scroll_soft::@2->scroll_soft::@1#0] -- register_copy 
    // [12] phi (byte*) nxt#15 = (byte*) nxt#37 [phi:scroll_soft::@2->scroll_soft::@1#1] -- register_copy 
    // [12] phi (byte) current_bit#13 = (byte) current_bit#23 [phi:scroll_soft::@2->scroll_soft::@1#2] -- register_copy 
    // [12] phi (byte) scroll#11 = (byte) 7 [phi:scroll_soft::@2->scroll_soft::@1#3] -- vbuz1=vbuc1 
    lda #7
    sta.z scroll
    jmp __b1
    // [12] phi from scroll_soft to scroll_soft::@1 [phi:scroll_soft->scroll_soft::@1]
  __b1_from_scroll_soft:
    // [12] phi (byte*) current_chargen#12 = (byte*) current_chargen#28 [phi:scroll_soft->scroll_soft::@1#0] -- register_copy 
    // [12] phi (byte*) nxt#15 = (byte*) nxt#33 [phi:scroll_soft->scroll_soft::@1#1] -- register_copy 
    // [12] phi (byte) current_bit#13 = (byte) current_bit#30 [phi:scroll_soft->scroll_soft::@1#2] -- register_copy 
    // [12] phi (byte) scroll#11 = (byte) scroll#2 [phi:scroll_soft->scroll_soft::@1#3] -- register_copy 
    jmp __b1
    // scroll_soft::@1
  __b1:
    // [13] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) scroll#11 -- _deref_pbuc1=vbuz1 
    lda.z scroll
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    jmp __breturn
    // scroll_soft::@return
  __breturn:
    // [14] return 
    rts
}
  // scroll_bit
scroll_bit: {
    .label __7 = $13
    .label __9 = $16
    .label c = $11
    .label bits = $15
    .label sc = 7
    .label r = 6
    .label b = 9
    // [15] (byte) current_bit#4 ← (byte) current_bit#30 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z current_bit
    // [16] if((byte) current_bit#4!=(byte) 0) goto scroll_bit::@1 -- vbuz1_neq_0_then_la1 
    lda.z current_bit
    cmp #0
    bne __b1_from_scroll_bit
    // [17] phi from scroll_bit to scroll_bit::@2 [phi:scroll_bit->scroll_bit::@2]
  __b2_from_scroll_bit:
    jmp __b2
    // scroll_bit::@2
  __b2:
    // [18] call next_char 
    jsr next_char
    // [19] (byte) next_char::return#0 ← (byte) next_char::return#1 -- vbuz1=vbuz2 
    lda.z next_char.return_1
    sta.z next_char.return
    jmp __b8
    // scroll_bit::@8
  __b8:
    // [20] (word) scroll_bit::c#0 ← (byte) next_char::return#0 -- vwuz1=vbuz2 
    lda.z next_char.return
    sta.z c
    lda #0
    sta.z c+1
    // [21] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 -- vwuz1=vwuz2_rol_3 
    lda.z c
    asl
    sta.z __7
    lda.z c+1
    rol
    sta.z __7+1
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    // [22] (byte*) current_chargen#4 ← (const nomodify byte*) CHARGEN + (word~) scroll_bit::$7 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z __7
    clc
    adc #<CHARGEN
    sta.z current_chargen
    lda.z __7+1
    adc #>CHARGEN
    sta.z current_chargen+1
    // [23] phi from scroll_bit::@8 to scroll_bit::@1 [phi:scroll_bit::@8->scroll_bit::@1]
  __b1_from___b8:
    // [23] phi (byte*) nxt#37 = (byte*) nxt#20 [phi:scroll_bit::@8->scroll_bit::@1#0] -- register_copy 
    // [23] phi (byte) current_bit#23 = (byte) $80 [phi:scroll_bit::@8->scroll_bit::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta.z current_bit
    // [23] phi (byte*) current_chargen#21 = (byte*) current_chargen#4 [phi:scroll_bit::@8->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // [23] phi from scroll_bit to scroll_bit::@1 [phi:scroll_bit->scroll_bit::@1]
  __b1_from_scroll_bit:
    // [23] phi (byte*) nxt#37 = (byte*) nxt#33 [phi:scroll_bit->scroll_bit::@1#0] -- register_copy 
    // [23] phi (byte) current_bit#23 = (byte) current_bit#4 [phi:scroll_bit->scroll_bit::@1#1] -- register_copy 
    // [23] phi (byte*) current_chargen#21 = (byte*) current_chargen#28 [phi:scroll_bit->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // scroll_bit::@1
  __b1:
    // [24] call scroll_hard 
    // [40] phi from scroll_bit::@1 to scroll_hard [phi:scroll_bit::@1->scroll_hard]
  scroll_hard_from___b1:
    jsr scroll_hard
    jmp __b7
    // scroll_bit::@7
  __b7:
    // asm { sei  }
    sei
    // [26] *((const nomodify byte*) PROCPORT) ← (byte) $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [27] phi from scroll_bit::@7 to scroll_bit::@3 [phi:scroll_bit::@7->scroll_bit::@3]
  __b3_from___b7:
    // [27] phi (byte*) scroll_bit::sc#2 = (const byte*) SCREEN+(byte) $28+(byte) $27 [phi:scroll_bit::@7->scroll_bit::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28+$27
    sta.z sc
    lda #>SCREEN+$28+$27
    sta.z sc+1
    // [27] phi (byte) scroll_bit::r#2 = (byte) 0 [phi:scroll_bit::@7->scroll_bit::@3#1] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    jmp __b3
    // [27] phi from scroll_bit::@4 to scroll_bit::@3 [phi:scroll_bit::@4->scroll_bit::@3]
  __b3_from___b4:
    // [27] phi (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#1 [phi:scroll_bit::@4->scroll_bit::@3#0] -- register_copy 
    // [27] phi (byte) scroll_bit::r#2 = (byte) scroll_bit::r#1 [phi:scroll_bit::@4->scroll_bit::@3#1] -- register_copy 
    jmp __b3
    // scroll_bit::@3
  __b3:
    // [28] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#21 + (byte) scroll_bit::r#2) -- vbuz1=pbuz2_derefidx_vbuz3 
    ldy.z r
    lda (current_chargen),y
    sta.z bits
    // [29] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#23 -- vbuz1=vbuz2_band_vbuz3 
    lda.z bits
    and.z current_bit
    sta.z __9
    // [30] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4 -- vbuz1_eq_0_then_la1 
    lda.z __9
    cmp #0
    beq __b4_from___b3
    // [31] phi from scroll_bit::@3 to scroll_bit::@5 [phi:scroll_bit::@3->scroll_bit::@5]
  __b5_from___b3:
    jmp __b5
    // scroll_bit::@5
  __b5:
    // [32] phi from scroll_bit::@5 to scroll_bit::@4 [phi:scroll_bit::@5->scroll_bit::@4]
  __b4_from___b5:
    // [32] phi (byte) scroll_bit::b#2 = (byte) $80+(byte) ' ' [phi:scroll_bit::@5->scroll_bit::@4#0] -- vbuz1=vbuc1 
    lda #$80+' '
    sta.z b
    jmp __b4
    // [32] phi from scroll_bit::@3 to scroll_bit::@4 [phi:scroll_bit::@3->scroll_bit::@4]
  __b4_from___b3:
    // [32] phi (byte) scroll_bit::b#2 = (byte) ' ' [phi:scroll_bit::@3->scroll_bit::@4#0] -- vbuz1=vbuc1 
    lda #' '
    sta.z b
    jmp __b4
    // scroll_bit::@4
  __b4:
    // [33] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 -- _deref_pbuz1=vbuz2 
    lda.z b
    ldy #0
    sta (sc),y
    // [34] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z sc
    sta.z sc
    bcc !+
    inc.z sc+1
  !:
    // [35] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [36] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z r
    bne __b3_from___b4
    jmp __b6
    // scroll_bit::@6
  __b6:
    // [37] *((const nomodify byte*) PROCPORT) ← (byte) $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm { cli  }
    cli
    jmp __breturn
    // scroll_bit::@return
  __breturn:
    // [39] return 
    rts
}
  // scroll_hard
scroll_hard: {
    .label i = $a
    // [41] phi from scroll_hard to scroll_hard::@1 [phi:scroll_hard->scroll_hard::@1]
  __b1_from_scroll_hard:
    // [41] phi (byte) scroll_hard::i#2 = (byte) 0 [phi:scroll_hard->scroll_hard::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
  // Hard scroll
    // scroll_hard::@1
  __b1:
    // [42] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$27
    cmp.z i
    bne __b2
    jmp __breturn
    // scroll_hard::@return
  __breturn:
    // [43] return 
    rts
    // scroll_hard::@2
  __b2:
    // [44] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+1,y
    sta SCREEN,y
    // [45] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*1+1,y
    sta SCREEN+$28*1,y
    // [46] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*2+1,y
    sta SCREEN+$28*2,y
    // [47] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*3+1,y
    sta SCREEN+$28*3,y
    // [48] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*4+1,y
    sta SCREEN+$28*4,y
    // [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*5+1,y
    sta SCREEN+$28*5,y
    // [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*6+1,y
    sta SCREEN+$28*6,y
    // [51] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda SCREEN+$28*7+1,y
    sta SCREEN+$28*7,y
    // [52] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [41] phi from scroll_hard::@2 to scroll_hard::@1 [phi:scroll_hard::@2->scroll_hard::@1]
  __b1_from___b2:
    // [41] phi (byte) scroll_hard::i#2 = (byte) scroll_hard::i#1 [phi:scroll_hard::@2->scroll_hard::@1#0] -- register_copy 
    jmp __b1
}
  // next_char
// Find the next char of the scroll text
next_char: {
    .label return = $10
    .label c = $d
    .label return_1 = $d
    // [53] (byte) next_char::c#0 ← *((byte*) nxt#33) -- vbuz1=_deref_pbuz2 
    ldy #0
    lda (nxt),y
    sta.z c
    // [54] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1 -- vbuz1_neq_0_then_la1 
    lda.z c
    cmp #0
    bne __b1_from_next_char
    jmp __b2
    // next_char::@2
  __b2:
    // [55] (byte) next_char::c#1 ← *((const byte*) TEXT) -- vbuz1=_deref_pbuc1 
    lda TEXT
    sta.z c
    // [56] phi from next_char::@2 to next_char::@1 [phi:next_char::@2->next_char::@1]
  __b1_from___b2:
    // [56] phi (byte) next_char::return#1 = (byte) next_char::c#1 [phi:next_char::@2->next_char::@1#0] -- register_copy 
    // [56] phi (byte*) nxt#19 = (const byte*) TEXT [phi:next_char::@2->next_char::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    jmp __b1
    // [56] phi from next_char to next_char::@1 [phi:next_char->next_char::@1]
  __b1_from_next_char:
    // [56] phi (byte) next_char::return#1 = (byte) next_char::c#0 [phi:next_char->next_char::@1#0] -- register_copy 
    // [56] phi (byte*) nxt#19 = (byte*) nxt#33 [phi:next_char->next_char::@1#1] -- register_copy 
    jmp __b1
    // next_char::@1
  __b1:
    // [57] (byte*) nxt#20 ← ++ (byte*) nxt#19 -- pbuz1=_inc_pbuz1 
    inc.z nxt
    bne !+
    inc.z nxt+1
  !:
    jmp __breturn
    // next_char::@return
  __breturn:
    // [58] return 
    rts
}
  // fillscreen
// Fill the screen with one char
fillscreen: {
    .const fill = $20
    .label cursor = $e
    // [60] phi from fillscreen to fillscreen::@1 [phi:fillscreen->fillscreen::@1]
  __b1_from_fillscreen:
    // [60] phi (byte*) fillscreen::cursor#2 = (const byte*) SCREEN [phi:fillscreen->fillscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z cursor
    lda #>SCREEN
    sta.z cursor+1
    jmp __b1
    // fillscreen::@1
  __b1:
    // [61] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z cursor+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z cursor
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    jmp __breturn
    // fillscreen::@return
  __breturn:
    // [62] return 
    rts
    // fillscreen::@2
  __b2:
    // [63] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 -- _deref_pbuz1=vbuc1 
    lda #fill
    ldy #0
    sta (cursor),y
    // [64] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z cursor
    bne !+
    inc.z cursor+1
  !:
    // [60] phi from fillscreen::@2 to fillscreen::@1 [phi:fillscreen::@2->fillscreen::@1]
  __b1_from___b2:
    // [60] phi (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#1 [phi:fillscreen::@2->fillscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  TEXT: .text "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
  .byte 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [3] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1 [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] (  [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ scroll#19 scroll#11 scroll#2 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
Statement [4] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2 [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] (  [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] { }  ) always clobbers reg byte a 
Statement [20] (word) scroll_bit::c#0 ← (byte) next_char::return#0 [ scroll_bit::c#0 nxt#20 ] ( scroll_soft:6::scroll_bit:11 [ scroll_bit::c#0 nxt#20 ] { }  ) always clobbers reg byte a 
Statement [21] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 [ scroll_bit::$7 nxt#20 ] ( scroll_soft:6::scroll_bit:11 [ scroll_bit::$7 nxt#20 ] { }  ) always clobbers reg byte a 
Statement [22] (byte*) current_chargen#4 ← (const nomodify byte*) CHARGEN + (word~) scroll_bit::$7 [ current_chargen#4 nxt#20 ] ( scroll_soft:6::scroll_bit:11 [ current_chargen#4 nxt#20 ] { }  ) always clobbers reg byte a 
Statement [26] *((const nomodify byte*) PROCPORT) ← (byte) $32 [ current_bit#23 nxt#37 current_chargen#21 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 ] { }  ) always clobbers reg byte a 
Statement [28] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#21 + (byte) scroll_bit::r#2) [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ scroll_bit::r#2 scroll_bit::r#1 ]
Statement [33] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
Removing always clobbered register reg byte y as potential for zp[1]:6 [ scroll_bit::r#2 scroll_bit::r#1 ]
Statement [34] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#1 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#1 ] { }  ) always clobbers reg byte a 
Statement [37] *((const nomodify byte*) PROCPORT) ← (byte) $37 [ current_bit#23 nxt#37 current_chargen#21 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 ] { }  ) always clobbers reg byte a 
Statement [44] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ scroll_hard::i#2 scroll_hard::i#1 ]
Statement [45] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [46] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [47] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [48] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [51] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [53] (byte) next_char::c#0 ← *((byte*) nxt#33) [ nxt#33 next_char::c#0 ] ( scroll_soft:6::scroll_bit:11::next_char:18 [ nxt#33 next_char::c#0 ] { { next_char::return#0 = next_char::return#1 } }  ) always clobbers reg byte a reg byte y 
Statement [61] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 [ fillscreen::cursor#2 ] ( fillscreen:1 [ fillscreen::cursor#2 ] { }  ) always clobbers reg byte a 
Statement [63] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 [ fillscreen::cursor#2 ] ( fillscreen:1 [ fillscreen::cursor#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [3] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1 [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] (  [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] { }  ) always clobbers reg byte a 
Statement [4] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2 [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] (  [ scroll#19 current_bit#30 nxt#33 current_chargen#28 ] { }  ) always clobbers reg byte a 
Statement [20] (word) scroll_bit::c#0 ← (byte) next_char::return#0 [ scroll_bit::c#0 nxt#20 ] ( scroll_soft:6::scroll_bit:11 [ scroll_bit::c#0 nxt#20 ] { }  ) always clobbers reg byte a 
Statement [21] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 [ scroll_bit::$7 nxt#20 ] ( scroll_soft:6::scroll_bit:11 [ scroll_bit::$7 nxt#20 ] { }  ) always clobbers reg byte a 
Statement [22] (byte*) current_chargen#4 ← (const nomodify byte*) CHARGEN + (word~) scroll_bit::$7 [ current_chargen#4 nxt#20 ] ( scroll_soft:6::scroll_bit:11 [ current_chargen#4 nxt#20 ] { }  ) always clobbers reg byte a 
Statement [26] *((const nomodify byte*) PROCPORT) ← (byte) $32 [ current_bit#23 nxt#37 current_chargen#21 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 ] { }  ) always clobbers reg byte a 
Statement [28] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#21 + (byte) scroll_bit::r#2) [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 scroll_bit::bits#0 ] { }  ) always clobbers reg byte a reg byte y 
Statement [33] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#2 ] { }  ) always clobbers reg byte y 
Statement [34] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#1 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 scroll_bit::r#2 scroll_bit::sc#1 ] { }  ) always clobbers reg byte a 
Statement [37] *((const nomodify byte*) PROCPORT) ← (byte) $37 [ current_bit#23 nxt#37 current_chargen#21 ] ( scroll_soft:6::scroll_bit:11 [ current_bit#23 nxt#37 current_chargen#21 ] { }  ) always clobbers reg byte a 
Statement [44] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [45] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [46] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [47] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [48] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [51] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) [ scroll_hard::i#2 ] ( scroll_soft:6::scroll_bit:11::scroll_hard:24 [ current_bit#23 nxt#37 current_chargen#21 scroll_hard::i#2 ] { }  ) always clobbers reg byte a 
Statement [53] (byte) next_char::c#0 ← *((byte*) nxt#33) [ nxt#33 next_char::c#0 ] ( scroll_soft:6::scroll_bit:11::next_char:18 [ nxt#33 next_char::c#0 ] { { next_char::return#0 = next_char::return#1 } }  ) always clobbers reg byte a reg byte y 
Statement [61] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 [ fillscreen::cursor#2 ] ( fillscreen:1 [ fillscreen::cursor#2 ] { }  ) always clobbers reg byte a 
Statement [63] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 [ fillscreen::cursor#2 ] ( fillscreen:1 [ fillscreen::cursor#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ scroll#19 scroll#11 scroll#2 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ] : zp[1]:3 , reg byte x , 
Potential registers zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ] : zp[2]:4 , 
Potential registers zp[1]:6 [ scroll_bit::r#2 scroll_bit::r#1 ] : zp[1]:6 , reg byte x , 
Potential registers zp[2]:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ] : zp[2]:7 , 
Potential registers zp[1]:9 [ scroll_bit::b#2 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ scroll_hard::i#2 scroll_hard::i#1 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ next_char::return#1 next_char::c#0 next_char::c#1 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] : zp[2]:14 , 
Potential registers zp[1]:16 [ next_char::return#0 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:17 [ scroll_bit::c#0 ] : zp[2]:17 , 
Potential registers zp[2]:19 [ scroll_bit::$7 ] : zp[2]:19 , 
Potential registers zp[1]:21 [ scroll_bit::bits#0 ] : zp[1]:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:22 [ scroll_bit::$9 ] : zp[1]:22 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [scroll_hard] 3,900,003.9: zp[1]:10 [ scroll_hard::i#2 scroll_hard::i#1 ] 
Uplift Scope [scroll_bit] 200,002: zp[1]:21 [ scroll_bit::bits#0 ] 200,002: zp[1]:22 [ scroll_bit::$9 ] 187,501.88: zp[1]:6 [ scroll_bit::r#2 scroll_bit::r#1 ] 109,524.9: zp[2]:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ] 100,001: zp[1]:9 [ scroll_bit::b#2 ] 2,002: zp[2]:17 [ scroll_bit::c#0 ] 2,002: zp[2]:19 [ scroll_bit::$7 ] 
Uplift Scope [next_char] 40,254.25: zp[1]:13 [ next_char::return#1 next_char::c#0 next_char::c#1 ] 2,002: zp[1]:16 [ next_char::return#0 ] 
Uplift Scope [] 23,509.56: zp[2]:11 [ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ] 7,863.16: zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ] 7,348.79: zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ] 272.6: zp[1]:2 [ scroll#19 scroll#11 scroll#2 ] 
Uplift Scope [fillscreen] 336.67: zp[2]:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [main] 
Uplift Scope [scroll_soft] 

Uplifting [scroll_hard] best 27550 combination reg byte x [ scroll_hard::i#2 scroll_hard::i#1 ] 
Uplifting [scroll_bit] best 24650 combination reg byte a [ scroll_bit::bits#0 ] reg byte a [ scroll_bit::$9 ] reg byte x [ scroll_bit::r#2 scroll_bit::r#1 ] zp[2]:7 [ scroll_bit::sc#2 scroll_bit::sc#1 ] reg byte a [ scroll_bit::b#2 ] zp[2]:17 [ scroll_bit::c#0 ] zp[2]:19 [ scroll_bit::$7 ] 
Limited combination testing to 100 combinations of 128 possible.
Uplifting [next_char] best 24636 combination reg byte x [ next_char::return#1 next_char::c#0 next_char::c#1 ] reg byte a [ next_char::return#0 ] 
Uplifting [] best 24324 combination zp[2]:11 [ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ] zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ] zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ] reg byte x [ scroll#19 scroll#11 scroll#2 ] 
Uplifting [fillscreen] best 24324 combination zp[2]:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] 
Uplifting [MOS6526_CIA] best 24324 combination 
Uplifting [MOS6569_VICII] best 24324 combination 
Uplifting [MOS6581_SID] best 24324 combination 
Uplifting [main] best 24324 combination 
Uplifting [scroll_soft] best 24324 combination 
Attempting to uplift remaining variables inzp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
Uplifting [] best 24324 combination zp[1]:3 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ] 
Coalescing zero page register [ zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 ] ] with [ zp[2]:19 [ scroll_bit::$7 ] ] - score: 1
Coalescing zero page register [ zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 scroll_bit::$7 ] ] with [ zp[2]:17 [ scroll_bit::c#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:14 [ fillscreen::cursor#2 fillscreen::cursor#1 ] ] with [ zp[2]:4 [ current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 scroll_bit::$7 scroll_bit::c#0 ] ]
Allocated (was zp[1]:3) zp[1]:2 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
Allocated (was zp[2]:7) zp[2]:3 [ scroll_bit::sc#2 scroll_bit::sc#1 ]
Allocated (was zp[2]:11) zp[2]:5 [ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ]
Allocated (was zp[2]:14) zp[2]:7 [ fillscreen::cursor#2 fillscreen::cursor#1 current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 scroll_bit::$7 scroll_bit::c#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// An 8x8 char letter scroller
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = $21
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = $16
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The address of the CHARGEN character set
  .label CHARGEN = $d000
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  .label SCREEN = $400
  .label current_bit = 2
  // Scroll the next bit from the current char onto the screen - trigger next char if needed
  .label current_chargen = 7
  .label nxt = 5
  // main
main: {
    // [1] call fillscreen 
    // [59] phi from main to fillscreen [phi:main->fillscreen]
  fillscreen_from_main:
    jsr fillscreen
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [2] phi (byte*) current_chargen#28 = (const nomodify byte*) CHARGEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z current_chargen
    lda #>CHARGEN
    sta.z current_chargen+1
    // [2] phi (byte*) nxt#33 = (const byte*) TEXT [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [2] phi (byte) current_bit#30 = (byte) 1 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #1
    sta.z current_bit
    // [2] phi (byte) scroll#19 = (byte) 7 [phi:main->main::@1#3] -- vbuxx=vbuc1 
    ldx #7
    jmp __b1
  // Wait for raster
    // [2] phi from main::@1 main::@4 to main::@1 [phi:main::@1/main::@4->main::@1]
  __b1_from___b1:
  __b1_from___b4:
    // [2] phi (byte*) current_chargen#28 = (byte*) current_chargen#28 [phi:main::@1/main::@4->main::@1#0] -- register_copy 
    // [2] phi (byte*) nxt#33 = (byte*) nxt#33 [phi:main::@1/main::@4->main::@1#1] -- register_copy 
    // [2] phi (byte) current_bit#30 = (byte) current_bit#30 [phi:main::@1/main::@4->main::@1#2] -- register_copy 
    // [2] phi (byte) scroll#19 = (byte) scroll#19 [phi:main::@1/main::@4->main::@1#3] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [3] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    bne __b1_from___b1
    jmp __b2
    // main::@2
  __b2:
    // [4] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [5] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← ++ *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    // [6] call scroll_soft 
    jsr scroll_soft
    jmp __b4
    // main::@4
  __b4:
    // [7] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← -- *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    jmp __b1_from___b4
}
  // scroll_soft
scroll_soft: {
    // [8] (byte) scroll#2 ← -- (byte) scroll#19 -- vbuxx=_dec_vbuxx 
    dex
    // [9] if((byte) scroll#2!=(byte) $ff) goto scroll_soft::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b1_from_scroll_soft
    // [10] phi from scroll_soft to scroll_soft::@2 [phi:scroll_soft->scroll_soft::@2]
  __b2_from_scroll_soft:
    jmp __b2
    // scroll_soft::@2
  __b2:
    // [11] call scroll_bit 
    jsr scroll_bit
    // [12] phi from scroll_soft::@2 to scroll_soft::@1 [phi:scroll_soft::@2->scroll_soft::@1]
  __b1_from___b2:
    // [12] phi (byte*) current_chargen#12 = (byte*) current_chargen#21 [phi:scroll_soft::@2->scroll_soft::@1#0] -- register_copy 
    // [12] phi (byte*) nxt#15 = (byte*) nxt#37 [phi:scroll_soft::@2->scroll_soft::@1#1] -- register_copy 
    // [12] phi (byte) current_bit#13 = (byte) current_bit#23 [phi:scroll_soft::@2->scroll_soft::@1#2] -- register_copy 
    // [12] phi (byte) scroll#11 = (byte) 7 [phi:scroll_soft::@2->scroll_soft::@1#3] -- vbuxx=vbuc1 
    ldx #7
    jmp __b1
    // [12] phi from scroll_soft to scroll_soft::@1 [phi:scroll_soft->scroll_soft::@1]
  __b1_from_scroll_soft:
    // [12] phi (byte*) current_chargen#12 = (byte*) current_chargen#28 [phi:scroll_soft->scroll_soft::@1#0] -- register_copy 
    // [12] phi (byte*) nxt#15 = (byte*) nxt#33 [phi:scroll_soft->scroll_soft::@1#1] -- register_copy 
    // [12] phi (byte) current_bit#13 = (byte) current_bit#30 [phi:scroll_soft->scroll_soft::@1#2] -- register_copy 
    // [12] phi (byte) scroll#11 = (byte) scroll#2 [phi:scroll_soft->scroll_soft::@1#3] -- register_copy 
    jmp __b1
    // scroll_soft::@1
  __b1:
    // [13] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) scroll#11 -- _deref_pbuc1=vbuxx 
    stx VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    jmp __breturn
    // scroll_soft::@return
  __breturn:
    // [14] return 
    rts
}
  // scroll_bit
scroll_bit: {
    .label __7 = 7
    .label c = 7
    .label sc = 3
    // [15] (byte) current_bit#4 ← (byte) current_bit#30 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z current_bit
    // [16] if((byte) current_bit#4!=(byte) 0) goto scroll_bit::@1 -- vbuz1_neq_0_then_la1 
    lda.z current_bit
    cmp #0
    bne __b1_from_scroll_bit
    // [17] phi from scroll_bit to scroll_bit::@2 [phi:scroll_bit->scroll_bit::@2]
  __b2_from_scroll_bit:
    jmp __b2
    // scroll_bit::@2
  __b2:
    // [18] call next_char 
    jsr next_char
    // [19] (byte) next_char::return#0 ← (byte) next_char::return#1 -- vbuaa=vbuxx 
    txa
    jmp __b8
    // scroll_bit::@8
  __b8:
    // [20] (word) scroll_bit::c#0 ← (byte) next_char::return#0 -- vwuz1=vbuaa 
    sta.z c
    lda #0
    sta.z c+1
    // [21] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 -- vwuz1=vwuz1_rol_3 
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    // [22] (byte*) current_chargen#4 ← (const nomodify byte*) CHARGEN + (word~) scroll_bit::$7 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z current_chargen
    adc #<CHARGEN
    sta.z current_chargen
    lda.z current_chargen+1
    adc #>CHARGEN
    sta.z current_chargen+1
    // [23] phi from scroll_bit::@8 to scroll_bit::@1 [phi:scroll_bit::@8->scroll_bit::@1]
  __b1_from___b8:
    // [23] phi (byte*) nxt#37 = (byte*) nxt#20 [phi:scroll_bit::@8->scroll_bit::@1#0] -- register_copy 
    // [23] phi (byte) current_bit#23 = (byte) $80 [phi:scroll_bit::@8->scroll_bit::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta.z current_bit
    // [23] phi (byte*) current_chargen#21 = (byte*) current_chargen#4 [phi:scroll_bit::@8->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // [23] phi from scroll_bit to scroll_bit::@1 [phi:scroll_bit->scroll_bit::@1]
  __b1_from_scroll_bit:
    // [23] phi (byte*) nxt#37 = (byte*) nxt#33 [phi:scroll_bit->scroll_bit::@1#0] -- register_copy 
    // [23] phi (byte) current_bit#23 = (byte) current_bit#4 [phi:scroll_bit->scroll_bit::@1#1] -- register_copy 
    // [23] phi (byte*) current_chargen#21 = (byte*) current_chargen#28 [phi:scroll_bit->scroll_bit::@1#2] -- register_copy 
    jmp __b1
    // scroll_bit::@1
  __b1:
    // [24] call scroll_hard 
    // [40] phi from scroll_bit::@1 to scroll_hard [phi:scroll_bit::@1->scroll_hard]
  scroll_hard_from___b1:
    jsr scroll_hard
    jmp __b7
    // scroll_bit::@7
  __b7:
    // asm { sei  }
    sei
    // [26] *((const nomodify byte*) PROCPORT) ← (byte) $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [27] phi from scroll_bit::@7 to scroll_bit::@3 [phi:scroll_bit::@7->scroll_bit::@3]
  __b3_from___b7:
    // [27] phi (byte*) scroll_bit::sc#2 = (const byte*) SCREEN+(byte) $28+(byte) $27 [phi:scroll_bit::@7->scroll_bit::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28+$27
    sta.z sc
    lda #>SCREEN+$28+$27
    sta.z sc+1
    // [27] phi (byte) scroll_bit::r#2 = (byte) 0 [phi:scroll_bit::@7->scroll_bit::@3#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // [27] phi from scroll_bit::@4 to scroll_bit::@3 [phi:scroll_bit::@4->scroll_bit::@3]
  __b3_from___b4:
    // [27] phi (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#1 [phi:scroll_bit::@4->scroll_bit::@3#0] -- register_copy 
    // [27] phi (byte) scroll_bit::r#2 = (byte) scroll_bit::r#1 [phi:scroll_bit::@4->scroll_bit::@3#1] -- register_copy 
    jmp __b3
    // scroll_bit::@3
  __b3:
    // [28] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#21 + (byte) scroll_bit::r#2) -- vbuaa=pbuz1_derefidx_vbuxx 
    txa
    tay
    lda (current_chargen),y
    // [29] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#23 -- vbuaa=vbuaa_band_vbuz1 
    and.z current_bit
    // [30] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b4_from___b3
    // [31] phi from scroll_bit::@3 to scroll_bit::@5 [phi:scroll_bit::@3->scroll_bit::@5]
  __b5_from___b3:
    jmp __b5
    // scroll_bit::@5
  __b5:
    // [32] phi from scroll_bit::@5 to scroll_bit::@4 [phi:scroll_bit::@5->scroll_bit::@4]
  __b4_from___b5:
    // [32] phi (byte) scroll_bit::b#2 = (byte) $80+(byte) ' ' [phi:scroll_bit::@5->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #$80+' '
    jmp __b4
    // [32] phi from scroll_bit::@3 to scroll_bit::@4 [phi:scroll_bit::@3->scroll_bit::@4]
  __b4_from___b3:
    // [32] phi (byte) scroll_bit::b#2 = (byte) ' ' [phi:scroll_bit::@3->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #' '
    jmp __b4
    // scroll_bit::@4
  __b4:
    // [33] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sc),y
    // [34] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z sc
    sta.z sc
    bcc !+
    inc.z sc+1
  !:
    // [35] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3_from___b4
    jmp __b6
    // scroll_bit::@6
  __b6:
    // [37] *((const nomodify byte*) PROCPORT) ← (byte) $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm { cli  }
    cli
    jmp __breturn
    // scroll_bit::@return
  __breturn:
    // [39] return 
    rts
}
  // scroll_hard
scroll_hard: {
    // [41] phi from scroll_hard to scroll_hard::@1 [phi:scroll_hard->scroll_hard::@1]
  __b1_from_scroll_hard:
    // [41] phi (byte) scroll_hard::i#2 = (byte) 0 [phi:scroll_hard->scroll_hard::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
  // Hard scroll
    // scroll_hard::@1
  __b1:
    // [42] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$27
    bne __b2
    jmp __breturn
    // scroll_hard::@return
  __breturn:
    // [43] return 
    rts
    // scroll_hard::@2
  __b2:
    // [44] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+1,x
    sta SCREEN,x
    // [45] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*1+1,x
    sta SCREEN+$28*1,x
    // [46] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*2+1,x
    sta SCREEN+$28*2,x
    // [47] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*3+1,x
    sta SCREEN+$28*3,x
    // [48] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*4+1,x
    sta SCREEN+$28*4,x
    // [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*5+1,x
    sta SCREEN+$28*5,x
    // [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*6+1,x
    sta SCREEN+$28*6,x
    // [51] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*7+1,x
    sta SCREEN+$28*7,x
    // [52] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [41] phi from scroll_hard::@2 to scroll_hard::@1 [phi:scroll_hard::@2->scroll_hard::@1]
  __b1_from___b2:
    // [41] phi (byte) scroll_hard::i#2 = (byte) scroll_hard::i#1 [phi:scroll_hard::@2->scroll_hard::@1#0] -- register_copy 
    jmp __b1
}
  // next_char
// Find the next char of the scroll text
next_char: {
    // [53] (byte) next_char::c#0 ← *((byte*) nxt#33) -- vbuxx=_deref_pbuz1 
    ldy #0
    lda (nxt),y
    tax
    // [54] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1_from_next_char
    jmp __b2
    // next_char::@2
  __b2:
    // [55] (byte) next_char::c#1 ← *((const byte*) TEXT) -- vbuxx=_deref_pbuc1 
    ldx TEXT
    // [56] phi from next_char::@2 to next_char::@1 [phi:next_char::@2->next_char::@1]
  __b1_from___b2:
    // [56] phi (byte) next_char::return#1 = (byte) next_char::c#1 [phi:next_char::@2->next_char::@1#0] -- register_copy 
    // [56] phi (byte*) nxt#19 = (const byte*) TEXT [phi:next_char::@2->next_char::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    jmp __b1
    // [56] phi from next_char to next_char::@1 [phi:next_char->next_char::@1]
  __b1_from_next_char:
    // [56] phi (byte) next_char::return#1 = (byte) next_char::c#0 [phi:next_char->next_char::@1#0] -- register_copy 
    // [56] phi (byte*) nxt#19 = (byte*) nxt#33 [phi:next_char->next_char::@1#1] -- register_copy 
    jmp __b1
    // next_char::@1
  __b1:
    // [57] (byte*) nxt#20 ← ++ (byte*) nxt#19 -- pbuz1=_inc_pbuz1 
    inc.z nxt
    bne !+
    inc.z nxt+1
  !:
    jmp __breturn
    // next_char::@return
  __breturn:
    // [58] return 
    rts
}
  // fillscreen
// Fill the screen with one char
fillscreen: {
    .const fill = $20
    .label cursor = 7
    // [60] phi from fillscreen to fillscreen::@1 [phi:fillscreen->fillscreen::@1]
  __b1_from_fillscreen:
    // [60] phi (byte*) fillscreen::cursor#2 = (const byte*) SCREEN [phi:fillscreen->fillscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z cursor
    lda #>SCREEN
    sta.z cursor+1
    jmp __b1
    // fillscreen::@1
  __b1:
    // [61] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z cursor+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z cursor
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    jmp __breturn
    // fillscreen::@return
  __breturn:
    // [62] return 
    rts
    // fillscreen::@2
  __b2:
    // [63] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 -- _deref_pbuz1=vbuc1 
    lda #fill
    ldy #0
    sta (cursor),y
    // [64] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z cursor
    bne !+
    inc.z cursor+1
  !:
    // [60] phi from fillscreen::@2 to fillscreen::@1 [phi:fillscreen::@2->fillscreen::@1]
  __b1_from___b2:
    // [60] phi (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#1 [phi:fillscreen::@2->fillscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  TEXT: .text "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
  .byte 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b8
Removing instruction jmp __b1
Removing instruction jmp __b7
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b4
Removing instruction jmp __b6
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b2
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b4 with __b1
Replacing label __b1_from_scroll_soft with __b1
Replacing label __b1_from_scroll_bit with __b1
Replacing label __b3_from___b4 with __b3
Replacing label __b1_from_next_char with __b1
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b4:
Removing instruction __b2_from_scroll_soft:
Removing instruction __b1_from_scroll_soft:
Removing instruction __b2_from_scroll_bit:
Removing instruction __b1_from_scroll_bit:
Removing instruction scroll_hard_from___b1:
Removing instruction __b3_from___b4:
Removing instruction __b5_from___b3:
Removing instruction __b4_from___b5:
Removing instruction __b1_from_next_char:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction fillscreen_from_main:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b2:
Removing instruction __b1_from___b2:
Removing instruction __breturn:
Removing instruction __b2:
Removing instruction __b8:
Removing instruction __b1_from___b8:
Removing instruction __b7:
Removing instruction __b3_from___b7:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction __breturn:
Removing instruction __b1_from_scroll_hard:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction __b2:
Removing instruction __b1_from___b2:
Removing instruction __breturn:
Removing instruction __b1_from_fillscreen:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Relabelling long label __b4_from___b3 to __b2
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(const nomodify byte*) CHARGEN = (byte*) 53248
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = (byte) $21
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = (byte) $16
(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER = (byte) $12
(const nomodify byte*) PROCPORT = (byte*) 1
(const byte*) SCREEN = (byte*) 1024
(const byte*) TEXT = (byte*) "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
(const nomodify struct MOS6569_VICII*) VICII = (struct MOS6569_VICII*) 53248
(byte) current_bit
(byte) current_bit#13 current_bit zp[1]:2 42.599999999999994
(byte) current_bit#23 current_bit zp[1]:2 5616.833333333334
(byte) current_bit#30 current_bit zp[1]:2 187.85714285714286
(byte) current_bit#4 current_bit zp[1]:2 1501.5
(byte*) current_chargen
(byte*) current_chargen#12 current_chargen zp[2]:7 42.599999999999994
(byte*) current_chargen#21 current_chargen zp[2]:7 5672.444444444444
(byte*) current_chargen#28 current_chargen zp[2]:7 146.11111111111111
(byte*) current_chargen#4 current_chargen zp[2]:7 2002.0
(void()) fillscreen((byte*) fillscreen::screen , (byte) fillscreen::fill)
(label) fillscreen::@1
(label) fillscreen::@2
(label) fillscreen::@return
(byte*) fillscreen::cursor
(byte*) fillscreen::cursor#1 cursor zp[2]:7 202.0
(byte*) fillscreen::cursor#2 cursor zp[2]:7 134.66666666666666
(byte) fillscreen::fill
(const byte) fillscreen::fill#0 fill = (byte) $20
(byte*) fillscreen::screen
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(byte()) next_char()
(label) next_char::@1
(label) next_char::@2
(label) next_char::@return
(byte) next_char::c
(byte) next_char::c#0 reg byte x 15001.5
(byte) next_char::c#1 reg byte x 20002.0
(byte) next_char::return
(byte) next_char::return#0 reg byte a 2002.0
(byte) next_char::return#1 reg byte x 5250.75
(byte*) nxt
(byte*) nxt#15 nxt zp[2]:5 42.599999999999994
(byte*) nxt#19 nxt zp[2]:5 20002.0
(byte*) nxt#20 nxt zp[2]:5 1571.7142857142858
(byte*) nxt#33 nxt zp[2]:5 1776.4166666666665
(byte*) nxt#37 nxt zp[2]:5 116.83333333333334
(byte) scroll
(byte) scroll#11 reg byte x 42.599999999999994
(byte) scroll#19 reg byte x 78.5
(byte) scroll#2 reg byte x 151.5
(void()) scroll_bit()
(word~) scroll_bit::$7 zp[2]:7 2002.0
(byte~) scroll_bit::$9 reg byte a 200002.0
(label) scroll_bit::@1
(label) scroll_bit::@2
(label) scroll_bit::@3
(label) scroll_bit::@4
(label) scroll_bit::@5
(label) scroll_bit::@6
(label) scroll_bit::@7
(label) scroll_bit::@8
(label) scroll_bit::@return
(byte) scroll_bit::b
(byte) scroll_bit::b#2 reg byte a 100001.0
(byte) scroll_bit::bits
(byte) scroll_bit::bits#0 reg byte a 200002.0
(word) scroll_bit::c
(word) scroll_bit::c#0 c zp[2]:7 2002.0
(byte) scroll_bit::r
(byte) scroll_bit::r#1 reg byte x 150001.5
(byte) scroll_bit::r#2 reg byte x 37500.375
(byte*) scroll_bit::sc
(byte*) scroll_bit::sc#1 sc zp[2]:3 66667.33333333333
(byte*) scroll_bit::sc#2 sc zp[2]:3 42857.57142857143
(void()) scroll_hard()
(label) scroll_hard::@1
(label) scroll_hard::@2
(label) scroll_hard::@return
(byte) scroll_hard::i
(byte) scroll_hard::i#1 reg byte x 2000002.0
(byte) scroll_hard::i#2 reg byte x 1900001.9000000006
(void()) scroll_soft()
(label) scroll_soft::@1
(label) scroll_soft::@2
(label) scroll_soft::@return

reg byte x [ scroll#19 scroll#11 scroll#2 ]
zp[1]:2 [ current_bit#30 current_bit#13 current_bit#23 current_bit#4 ]
reg byte x [ scroll_bit::r#2 scroll_bit::r#1 ]
zp[2]:3 [ scroll_bit::sc#2 scroll_bit::sc#1 ]
reg byte a [ scroll_bit::b#2 ]
reg byte x [ scroll_hard::i#2 scroll_hard::i#1 ]
zp[2]:5 [ nxt#19 nxt#33 nxt#15 nxt#37 nxt#20 ]
reg byte x [ next_char::return#1 next_char::c#0 next_char::c#1 ]
zp[2]:7 [ fillscreen::cursor#2 fillscreen::cursor#1 current_chargen#28 current_chargen#12 current_chargen#21 current_chargen#4 scroll_bit::$7 scroll_bit::c#0 ]
reg byte a [ next_char::return#0 ]
reg byte a [ scroll_bit::bits#0 ]
reg byte a [ scroll_bit::$9 ]


FINAL ASSEMBLER
Score: 20886

  // File Comments
// An 8x8 char letter scroller
// Commodore 64 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_BG_COLOR = $21
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = $16
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The address of the CHARGEN character set
  .label CHARGEN = $d000
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  .label SCREEN = $400
  .label current_bit = 2
  // Scroll the next bit from the current char onto the screen - trigger next char if needed
  .label current_chargen = 7
  .label nxt = 5
  // main
main: {
    // fillscreen(SCREEN, $20)
    // [1] call fillscreen 
    // [59] phi from main to fillscreen [phi:main->fillscreen]
    jsr fillscreen
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // [2] phi (byte*) current_chargen#28 = (const nomodify byte*) CHARGEN [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARGEN
    sta.z current_chargen
    lda #>CHARGEN
    sta.z current_chargen+1
    // [2] phi (byte*) nxt#33 = (const byte*) TEXT [phi:main->main::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [2] phi (byte) current_bit#30 = (byte) 1 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #1
    sta.z current_bit
    // [2] phi (byte) scroll#19 = (byte) 7 [phi:main->main::@1#3] -- vbuxx=vbuc1 
    ldx #7
  // Wait for raster
    // [2] phi from main::@1 main::@4 to main::@1 [phi:main::@1/main::@4->main::@1]
    // [2] phi (byte*) current_chargen#28 = (byte*) current_chargen#28 [phi:main::@1/main::@4->main::@1#0] -- register_copy 
    // [2] phi (byte*) nxt#33 = (byte*) nxt#33 [phi:main::@1/main::@4->main::@1#1] -- register_copy 
    // [2] phi (byte) current_bit#30 = (byte) current_bit#30 [phi:main::@1/main::@4->main::@1#2] -- register_copy 
    // [2] phi (byte) scroll#19 = (byte) scroll#19 [phi:main::@1/main::@4->main::@1#3] -- register_copy 
    // main::@1
  __b1:
    // while(VICII->RASTER!=$fe)
    // [3] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    bne __b1
    // main::@2
  __b2:
    // while(VICII->RASTER!=$ff)
    // [4] if(*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)!=(byte) $ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    bne __b2
    // main::@3
    // ++VICII->BG_COLOR;
    // [5] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← ++ *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    // scroll_soft()
    // [6] call scroll_soft 
    jsr scroll_soft
    // main::@4
    // --VICII->BG_COLOR;
    // [7] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) ← -- *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_BG_COLOR) -- _deref_pbuc1=_dec__deref_pbuc1 
    dec VICII+OFFSET_STRUCT_MOS6569_VICII_BG_COLOR
    jmp __b1
}
  // scroll_soft
scroll_soft: {
    // if(--scroll==$ff)
    // [8] (byte) scroll#2 ← -- (byte) scroll#19 -- vbuxx=_dec_vbuxx 
    dex
    // [9] if((byte) scroll#2!=(byte) $ff) goto scroll_soft::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b1
    // [10] phi from scroll_soft to scroll_soft::@2 [phi:scroll_soft->scroll_soft::@2]
    // scroll_soft::@2
    // scroll_bit()
    // [11] call scroll_bit 
    jsr scroll_bit
    // [12] phi from scroll_soft::@2 to scroll_soft::@1 [phi:scroll_soft::@2->scroll_soft::@1]
    // [12] phi (byte*) current_chargen#12 = (byte*) current_chargen#21 [phi:scroll_soft::@2->scroll_soft::@1#0] -- register_copy 
    // [12] phi (byte*) nxt#15 = (byte*) nxt#37 [phi:scroll_soft::@2->scroll_soft::@1#1] -- register_copy 
    // [12] phi (byte) current_bit#13 = (byte) current_bit#23 [phi:scroll_soft::@2->scroll_soft::@1#2] -- register_copy 
    // [12] phi (byte) scroll#11 = (byte) 7 [phi:scroll_soft::@2->scroll_soft::@1#3] -- vbuxx=vbuc1 
    ldx #7
    // [12] phi from scroll_soft to scroll_soft::@1 [phi:scroll_soft->scroll_soft::@1]
    // [12] phi (byte*) current_chargen#12 = (byte*) current_chargen#28 [phi:scroll_soft->scroll_soft::@1#0] -- register_copy 
    // [12] phi (byte*) nxt#15 = (byte*) nxt#33 [phi:scroll_soft->scroll_soft::@1#1] -- register_copy 
    // [12] phi (byte) current_bit#13 = (byte) current_bit#30 [phi:scroll_soft->scroll_soft::@1#2] -- register_copy 
    // [12] phi (byte) scroll#11 = (byte) scroll#2 [phi:scroll_soft->scroll_soft::@1#3] -- register_copy 
    // scroll_soft::@1
  __b1:
    // VICII->CONTROL2 = scroll
    // [13] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) scroll#11 -- _deref_pbuc1=vbuxx 
    stx VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    // scroll_soft::@return
    // }
    // [14] return 
    rts
}
  // scroll_bit
scroll_bit: {
    .label __7 = 7
    .label c = 7
    .label sc = 3
    // current_bit = current_bit/2
    // [15] (byte) current_bit#4 ← (byte) current_bit#30 >> (byte) 1 -- vbuz1=vbuz1_ror_1 
    lsr.z current_bit
    // if(current_bit==0)
    // [16] if((byte) current_bit#4!=(byte) 0) goto scroll_bit::@1 -- vbuz1_neq_0_then_la1 
    lda.z current_bit
    cmp #0
    bne __b1
    // [17] phi from scroll_bit to scroll_bit::@2 [phi:scroll_bit->scroll_bit::@2]
    // scroll_bit::@2
    // next_char()
    // [18] call next_char 
    jsr next_char
    // [19] (byte) next_char::return#0 ← (byte) next_char::return#1 -- vbuaa=vbuxx 
    txa
    // scroll_bit::@8
    // c = next_char()
    // [20] (word) scroll_bit::c#0 ← (byte) next_char::return#0 -- vwuz1=vbuaa 
    sta.z c
    lda #0
    sta.z c+1
    // c*8
    // [21] (word~) scroll_bit::$7 ← (word) scroll_bit::c#0 << (byte) 3 -- vwuz1=vwuz1_rol_3 
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    asl.z __7
    rol.z __7+1
    // current_chargen = CHARGEN+c*8
    // [22] (byte*) current_chargen#4 ← (const nomodify byte*) CHARGEN + (word~) scroll_bit::$7 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z current_chargen
    adc #<CHARGEN
    sta.z current_chargen
    lda.z current_chargen+1
    adc #>CHARGEN
    sta.z current_chargen+1
    // [23] phi from scroll_bit::@8 to scroll_bit::@1 [phi:scroll_bit::@8->scroll_bit::@1]
    // [23] phi (byte*) nxt#37 = (byte*) nxt#20 [phi:scroll_bit::@8->scroll_bit::@1#0] -- register_copy 
    // [23] phi (byte) current_bit#23 = (byte) $80 [phi:scroll_bit::@8->scroll_bit::@1#1] -- vbuz1=vbuc1 
    lda #$80
    sta.z current_bit
    // [23] phi (byte*) current_chargen#21 = (byte*) current_chargen#4 [phi:scroll_bit::@8->scroll_bit::@1#2] -- register_copy 
    // [23] phi from scroll_bit to scroll_bit::@1 [phi:scroll_bit->scroll_bit::@1]
    // [23] phi (byte*) nxt#37 = (byte*) nxt#33 [phi:scroll_bit->scroll_bit::@1#0] -- register_copy 
    // [23] phi (byte) current_bit#23 = (byte) current_bit#4 [phi:scroll_bit->scroll_bit::@1#1] -- register_copy 
    // [23] phi (byte*) current_chargen#21 = (byte*) current_chargen#28 [phi:scroll_bit->scroll_bit::@1#2] -- register_copy 
    // scroll_bit::@1
  __b1:
    // scroll_hard()
    // [24] call scroll_hard 
    // [40] phi from scroll_bit::@1 to scroll_hard [phi:scroll_bit::@1->scroll_hard]
    jsr scroll_hard
    // scroll_bit::@7
    // asm
    // asm { sei  }
    sei
    // *PROCPORT = $32
    // [26] *((const nomodify byte*) PROCPORT) ← (byte) $32 -- _deref_pbuc1=vbuc2 
    lda #$32
    sta PROCPORT
    // [27] phi from scroll_bit::@7 to scroll_bit::@3 [phi:scroll_bit::@7->scroll_bit::@3]
    // [27] phi (byte*) scroll_bit::sc#2 = (const byte*) SCREEN+(byte) $28+(byte) $27 [phi:scroll_bit::@7->scroll_bit::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN+$28+$27
    sta.z sc
    lda #>SCREEN+$28+$27
    sta.z sc+1
    // [27] phi (byte) scroll_bit::r#2 = (byte) 0 [phi:scroll_bit::@7->scroll_bit::@3#1] -- vbuxx=vbuc1 
    ldx #0
    // [27] phi from scroll_bit::@4 to scroll_bit::@3 [phi:scroll_bit::@4->scroll_bit::@3]
    // [27] phi (byte*) scroll_bit::sc#2 = (byte*) scroll_bit::sc#1 [phi:scroll_bit::@4->scroll_bit::@3#0] -- register_copy 
    // [27] phi (byte) scroll_bit::r#2 = (byte) scroll_bit::r#1 [phi:scroll_bit::@4->scroll_bit::@3#1] -- register_copy 
    // scroll_bit::@3
  __b3:
    // bits = current_chargen[r]
    // [28] (byte) scroll_bit::bits#0 ← *((byte*) current_chargen#21 + (byte) scroll_bit::r#2) -- vbuaa=pbuz1_derefidx_vbuxx 
    txa
    tay
    lda (current_chargen),y
    // bits & current_bit
    // [29] (byte~) scroll_bit::$9 ← (byte) scroll_bit::bits#0 & (byte) current_bit#23 -- vbuaa=vbuaa_band_vbuz1 
    and.z current_bit
    // if((bits & current_bit) != 0)
    // [30] if((byte~) scroll_bit::$9==(byte) 0) goto scroll_bit::@4 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b2
    // [31] phi from scroll_bit::@3 to scroll_bit::@5 [phi:scroll_bit::@3->scroll_bit::@5]
    // scroll_bit::@5
    // [32] phi from scroll_bit::@5 to scroll_bit::@4 [phi:scroll_bit::@5->scroll_bit::@4]
    // [32] phi (byte) scroll_bit::b#2 = (byte) $80+(byte) ' ' [phi:scroll_bit::@5->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #$80+' '
    jmp __b4
    // [32] phi from scroll_bit::@3 to scroll_bit::@4 [phi:scroll_bit::@3->scroll_bit::@4]
  __b2:
    // [32] phi (byte) scroll_bit::b#2 = (byte) ' ' [phi:scroll_bit::@3->scroll_bit::@4#0] -- vbuaa=vbuc1 
    lda #' '
    // scroll_bit::@4
  __b4:
    // *sc = b
    // [33] *((byte*) scroll_bit::sc#2) ← (byte) scroll_bit::b#2 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sc),y
    // sc = sc+40
    // [34] (byte*) scroll_bit::sc#1 ← (byte*) scroll_bit::sc#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z sc
    sta.z sc
    bcc !+
    inc.z sc+1
  !:
    // for(char r:0..7)
    // [35] (byte) scroll_bit::r#1 ← ++ (byte) scroll_bit::r#2 -- vbuxx=_inc_vbuxx 
    inx
    // [36] if((byte) scroll_bit::r#1!=(byte) 8) goto scroll_bit::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3
    // scroll_bit::@6
    // *PROCPORT = $37
    // [37] *((const nomodify byte*) PROCPORT) ← (byte) $37 -- _deref_pbuc1=vbuc2 
    lda #$37
    sta PROCPORT
    // asm
    // asm { cli  }
    cli
    // scroll_bit::@return
    // }
    // [39] return 
    rts
}
  // scroll_hard
scroll_hard: {
    // [41] phi from scroll_hard to scroll_hard::@1 [phi:scroll_hard->scroll_hard::@1]
    // [41] phi (byte) scroll_hard::i#2 = (byte) 0 [phi:scroll_hard->scroll_hard::@1#0] -- vbuxx=vbuc1 
    ldx #0
  // Hard scroll
    // scroll_hard::@1
  __b1:
    // for(char i=0;i!=39;i++)
    // [42] if((byte) scroll_hard::i#2!=(byte) $27) goto scroll_hard::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$27
    bne __b2
    // scroll_hard::@return
    // }
    // [43] return 
    rts
    // scroll_hard::@2
  __b2:
    // (SCREEN+40*0)[i]=(SCREEN+40*0)[i+1]
    // [44] *((const byte*) SCREEN + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+1,x
    sta SCREEN,x
    // (SCREEN+40*1)[i]=(SCREEN+40*1)[i+1]
    // [45] *((const byte*) SCREEN+(byte)(number) $28*(number) 1 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 1+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*1+1,x
    sta SCREEN+$28*1,x
    // (SCREEN+40*2)[i]=(SCREEN+40*2)[i+1]
    // [46] *((const byte*) SCREEN+(byte)(number) $28*(number) 2 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 2+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*2+1,x
    sta SCREEN+$28*2,x
    // (SCREEN+40*3)[i]=(SCREEN+40*3)[i+1]
    // [47] *((const byte*) SCREEN+(byte)(number) $28*(number) 3 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 3+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*3+1,x
    sta SCREEN+$28*3,x
    // (SCREEN+40*4)[i]=(SCREEN+40*4)[i+1]
    // [48] *((const byte*) SCREEN+(byte)(number) $28*(number) 4 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 4+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*4+1,x
    sta SCREEN+$28*4,x
    // (SCREEN+40*5)[i]=(SCREEN+40*5)[i+1]
    // [49] *((const byte*) SCREEN+(byte)(number) $28*(number) 5 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 5+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*5+1,x
    sta SCREEN+$28*5,x
    // (SCREEN+40*6)[i]=(SCREEN+40*6)[i+1]
    // [50] *((const byte*) SCREEN+(byte)(number) $28*(number) 6 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(byte)(number) $28*(number) 6+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*6+1,x
    sta SCREEN+$28*6,x
    // (SCREEN+40*7)[i]=(SCREEN+40*7)[i+1]
    // [51] *((const byte*) SCREEN+(word)(number) $28*(number) 7 + (byte) scroll_hard::i#2) ← *((const byte*) SCREEN+(word)(number) $28*(number) 7+(byte) 1 + (byte) scroll_hard::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda SCREEN+$28*7+1,x
    sta SCREEN+$28*7,x
    // for(char i=0;i!=39;i++)
    // [52] (byte) scroll_hard::i#1 ← ++ (byte) scroll_hard::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [41] phi from scroll_hard::@2 to scroll_hard::@1 [phi:scroll_hard::@2->scroll_hard::@1]
    // [41] phi (byte) scroll_hard::i#2 = (byte) scroll_hard::i#1 [phi:scroll_hard::@2->scroll_hard::@1#0] -- register_copy 
    jmp __b1
}
  // next_char
// Find the next char of the scroll text
next_char: {
    // c = *nxt
    // [53] (byte) next_char::c#0 ← *((byte*) nxt#33) -- vbuxx=_deref_pbuz1 
    ldy #0
    lda (nxt),y
    tax
    // if(c==0)
    // [54] if((byte) next_char::c#0!=(byte) 0) goto next_char::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1
    // next_char::@2
    // c = *nxt
    // [55] (byte) next_char::c#1 ← *((const byte*) TEXT) -- vbuxx=_deref_pbuc1 
    ldx TEXT
    // [56] phi from next_char::@2 to next_char::@1 [phi:next_char::@2->next_char::@1]
    // [56] phi (byte) next_char::return#1 = (byte) next_char::c#1 [phi:next_char::@2->next_char::@1#0] -- register_copy 
    // [56] phi (byte*) nxt#19 = (const byte*) TEXT [phi:next_char::@2->next_char::@1#1] -- pbuz1=pbuc1 
    lda #<TEXT
    sta.z nxt
    lda #>TEXT
    sta.z nxt+1
    // [56] phi from next_char to next_char::@1 [phi:next_char->next_char::@1]
    // [56] phi (byte) next_char::return#1 = (byte) next_char::c#0 [phi:next_char->next_char::@1#0] -- register_copy 
    // [56] phi (byte*) nxt#19 = (byte*) nxt#33 [phi:next_char->next_char::@1#1] -- register_copy 
    // next_char::@1
  __b1:
    // nxt++;
    // [57] (byte*) nxt#20 ← ++ (byte*) nxt#19 -- pbuz1=_inc_pbuz1 
    inc.z nxt
    bne !+
    inc.z nxt+1
  !:
    // next_char::@return
    // }
    // [58] return 
    rts
}
  // fillscreen
// Fill the screen with one char
fillscreen: {
    .const fill = $20
    .label cursor = 7
    // [60] phi from fillscreen to fillscreen::@1 [phi:fillscreen->fillscreen::@1]
    // [60] phi (byte*) fillscreen::cursor#2 = (const byte*) SCREEN [phi:fillscreen->fillscreen::@1#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z cursor
    lda #>SCREEN
    sta.z cursor+1
    // fillscreen::@1
  __b1:
    // for( char* cursor = screen; cursor < screen+1000; cursor++)
    // [61] if((byte*) fillscreen::cursor#2<(const byte*) SCREEN+(word) $3e8) goto fillscreen::@2 -- pbuz1_lt_pbuc1_then_la1 
    lda.z cursor+1
    cmp #>SCREEN+$3e8
    bcc __b2
    bne !+
    lda.z cursor
    cmp #<SCREEN+$3e8
    bcc __b2
  !:
    // fillscreen::@return
    // }
    // [62] return 
    rts
    // fillscreen::@2
  __b2:
    // *cursor = fill
    // [63] *((byte*) fillscreen::cursor#2) ← (const byte) fillscreen::fill#0 -- _deref_pbuz1=vbuc1 
    lda #fill
    ldy #0
    sta (cursor),y
    // for( char* cursor = screen; cursor < screen+1000; cursor++)
    // [64] (byte*) fillscreen::cursor#1 ← ++ (byte*) fillscreen::cursor#2 -- pbuz1=_inc_pbuz1 
    inc.z cursor
    bne !+
    inc.z cursor+1
  !:
    // [60] phi from fillscreen::@2 to fillscreen::@1 [phi:fillscreen::@2->fillscreen::@1]
    // [60] phi (byte*) fillscreen::cursor#2 = (byte*) fillscreen::cursor#1 [phi:fillscreen::@2->fillscreen::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
  TEXT: .text "-= this is rex of camelot testing a scroller created in kickc. kickc is an optimizing c-compiler for 6502 assembler. =-     "
  .byte 0

