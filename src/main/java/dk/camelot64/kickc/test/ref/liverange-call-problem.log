// Live ranges were not functioning properly, when multiple method calls were chained - each modifying different vars.
// w1 and w2 ended up having the same zero-page register as their live range was not propagated properly

word w1 = 0;
word w2 = 0;

void main() {
    incw1();
    incw2();
    incw1();
    incw2();
}

void incw1() {
    w1++;
}

void incw2() {
    w2++;
}

Adding pre/post-modifier (word) w1 ← ++ (word) w1
Adding pre/post-modifier (word) w2 ← ++ (word) w2
PROGRAM
  (word) w1 ← (byte/signed byte/word/signed word) 0
  (word) w2 ← (byte/signed byte/word/signed word) 0
proc (void()) main()
  (void~) main::$0 ← call incw1 
  (void~) main::$1 ← call incw2 
  (void~) main::$2 ← call incw1 
  (void~) main::$3 ← call incw2 
main::@return:
  return 
endproc // main()
proc (void()) incw1()
  (word) w1 ← ++ (word) w1
incw1::@return:
  return 
endproc // incw1()
proc (void()) incw2()
  (word) w2 ← ++ (word) w2
incw2::@return:
  return 
endproc // incw2()
  call main 

SYMBOLS
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(void~) main::$0
(void~) main::$1
(void~) main::$2
(void~) main::$3
(label) main::@return
(word) w1
(word) w2

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (word) w1 ← (byte/signed byte/word/signed word) 0
  (word) w2 ← (byte/signed byte/word/signed word) 0
  to:@1
main: scope:[main]  from
  (void~) main::$0 ← call incw1 
  (void~) main::$1 ← call incw2 
  (void~) main::$2 ← call incw1 
  (void~) main::$3 ← call incw2 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
incw1: scope:[incw1]  from
  (word) w1 ← ++ (word) w1
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
@2: scope:[]  from @1
  to:@3
incw2: scope:[incw2]  from
  (word) w2 ← ++ (word) w2
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @2
  call main 
  to:@end
@end: scope:[]  from @3

Eliminating unused variable - keeping the call (void~) main::$0
Eliminating unused variable - keeping the call (void~) main::$1
Eliminating unused variable - keeping the call (void~) main::$2
Eliminating unused variable - keeping the call (void~) main::$3
Removing empty block @1
Removing empty block @2
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (word) w1 ← (byte/signed byte/word/signed word) 0
  (word) w2 ← (byte/signed byte/word/signed word) 0
  to:@3
main: scope:[main]  from
  call incw1 
  call incw2 
  call incw1 
  call incw2 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
incw1: scope:[incw1]  from
  (word) w1 ← ++ (word) w1
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from
  (word) w2 ← ++ (word) w2
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main 
  to:@end
@end: scope:[]  from @3

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies w1
main modifies w2
incw1 modifies w1
incw2 modifies w2

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (word) w1 ← (byte/signed byte/word/signed word) 0
  (word) w2 ← (byte/signed byte/word/signed word) 0
  to:@3
main: scope:[main]  from @3
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (word) w1 ← (word) w1
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (word) w2 ← (word) w2
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (word) w1 ← (word) w1
  call incw2 param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  (word) w2 ← (word) w2
  to:main::@return
main::@return: scope:[main]  from main::@4
  (word) w1 ← (word) w1
  (word) w2 ← (word) w2
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1 ← ++ (word) w1
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  (word) w1 ← (word) w1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2 ← ++ (word) w2
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  (word) w2 ← (word) w2
  return 
  to:@return
@3: scope:[]  from @begin
  call main param-assignment
  to:@4
@4: scope:[]  from @3
  (word) w1 ← (word) w1
  (word) w2 ← (word) w2
  to:@end
@end: scope:[]  from @4

Completing Phi functions...
Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (word) w1#0 ← (byte/signed byte/word/signed word) 0
  (word) w2#0 ← (byte/signed byte/word/signed word) 0
  to:@3
main: scope:[main]  from @3
  (word) w2#16 ← phi( @3/(word) w2#15 )
  (word) w1#13 ← phi( @3/(word) w1#16 )
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (word) w2#13 ← phi( main/(word) w2#16 )
  (word) w1#7 ← phi( main/(word) w1#13 )
  (word) w1#1 ← (word) w1#7
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (word) w1#14 ← phi( main::@1/(word) w1#1 )
  (word) w2#7 ← phi( main::@1/(word) w2#13 )
  (word) w2#1 ← (word) w2#7
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (word) w2#14 ← phi( main::@2/(word) w2#1 )
  (word) w1#8 ← phi( main::@2/(word) w1#14 )
  (word) w1#2 ← (word) w1#8
  call incw2 param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  (word) w1#15 ← phi( main::@3/(word) w1#2 )
  (word) w2#8 ← phi( main::@3/(word) w2#14 )
  (word) w2#2 ← (word) w2#8
  to:main::@return
main::@return: scope:[main]  from main::@4
  (word) w2#9 ← phi( main::@4/(word) w2#2 )
  (word) w1#9 ← phi( main::@4/(word) w1#15 )
  (word) w1#3 ← (word) w1#9
  (word) w2#3 ← (word) w2#9
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(word) w1#13 main::@2/(word) w1#14 )
  (word) w1#4 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  (word) w1#11 ← phi( incw1/(word) w1#4 )
  (word) w1#5 ← (word) w1#11
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(word) w2#13 main::@3/(word) w2#14 )
  (word) w2#4 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  (word) w2#11 ← phi( incw2/(word) w2#4 )
  (word) w2#5 ← (word) w2#11
  return 
  to:@return
@3: scope:[]  from @begin
  (word) w2#15 ← phi( @begin/(word) w2#0 )
  (word) w1#16 ← phi( @begin/(word) w1#0 )
  call main param-assignment
  to:@4
@4: scope:[]  from @3
  (word) w2#12 ← phi( @3/(word) w2#15 )
  (word) w1#12 ← phi( @3/(word) w1#16 )
  (word) w1#6 ← (word) w1#12
  (word) w2#6 ← (word) w2#12
  to:@end
@end: scope:[]  from @4

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (word) w1#0 ← (byte/signed byte/word/signed word) 0
  (word) w2#0 ← (byte/signed byte/word/signed word) 0
  to:@3
main: scope:[main]  from @3
  (word) w2#16 ← phi( @3/(word) w2#15 )
  (word) w1#13 ← phi( @3/(word) w1#16 )
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (word) w2#13 ← phi( main/(word) w2#16 )
  (word) w1#7 ← phi( main/(word) w1#5 )
  (word) w1#1 ← (word) w1#7
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (word) w1#14 ← phi( main::@1/(word) w1#1 )
  (word) w2#7 ← phi( main::@1/(word) w2#5 )
  (word) w2#1 ← (word) w2#7
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (word) w2#14 ← phi( main::@2/(word) w2#1 )
  (word) w1#8 ← phi( main::@2/(word) w1#5 )
  (word) w1#2 ← (word) w1#8
  call incw2 param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  (word) w1#15 ← phi( main::@3/(word) w1#2 )
  (word) w2#8 ← phi( main::@3/(word) w2#5 )
  (word) w2#2 ← (word) w2#8
  to:main::@return
main::@return: scope:[main]  from main::@4
  (word) w2#9 ← phi( main::@4/(word) w2#2 )
  (word) w1#9 ← phi( main::@4/(word) w1#15 )
  (word) w1#3 ← (word) w1#9
  (word) w2#3 ← (word) w2#9
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(word) w1#13 main::@2/(word) w1#14 )
  (word) w1#4 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  (word) w1#11 ← phi( incw1/(word) w1#4 )
  (word) w1#5 ← (word) w1#11
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(word) w2#13 main::@3/(word) w2#14 )
  (word) w2#4 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  (word) w2#11 ← phi( incw2/(word) w2#4 )
  (word) w2#5 ← (word) w2#11
  return 
  to:@return
@3: scope:[]  from @begin
  (word) w2#15 ← phi( @begin/(word) w2#0 )
  (word) w1#16 ← phi( @begin/(word) w1#0 )
  call main param-assignment
  to:@4
@4: scope:[]  from @3
  (word) w2#12 ← phi( @3/(word) w2#3 )
  (word) w1#12 ← phi( @3/(word) w1#3 )
  (word) w1#6 ← (word) w1#12
  (word) w2#6 ← (word) w2#12
  to:@end
@end: scope:[]  from @4

INITIAL SSA SYMBOL TABLE
(label) @3
(label) @4
(label) @begin
(label) @end
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(word) w1
(word) w1#0
(word) w1#1
(word) w1#10
(word) w1#11
(word) w1#12
(word) w1#13
(word) w1#14
(word) w1#15
(word) w1#16
(word) w1#2
(word) w1#3
(word) w1#4
(word) w1#5
(word) w1#6
(word) w1#7
(word) w1#8
(word) w1#9
(word) w2
(word) w2#0
(word) w2#1
(word) w2#10
(word) w2#11
(word) w2#12
(word) w2#13
(word) w2#14
(word) w2#15
(word) w2#16
(word) w2#2
(word) w2#3
(word) w2#4
(word) w2#5
(word) w2#6
(word) w2#7
(word) w2#8
(word) w2#9

Not aliassing across scopes: w1#13 w1#16
Not aliassing across scopes: w2#16 w2#15
Not aliassing across scopes: w1#7 w1#5
Not aliassing across scopes: w2#7 w2#5
Not aliassing across scopes: w1#8 w1#5
Not aliassing across scopes: w2#8 w2#5
Not aliassing across scopes: w1#10 w1#13
Not aliassing across scopes: w2#10 w2#13
Not aliassing across scopes: w1#12 w1#3
Not aliassing across scopes: w2#12 w2#3
Alias (word) w2#13 = (word) w2#16 
Alias (word) w1#1 = (word) w1#7 (word) w1#14 
Alias (word) w2#1 = (word) w2#7 (word) w2#14 
Alias (word) w1#15 = (word) w1#2 (word) w1#8 (word) w1#9 (word) w1#3 
Alias (word) w2#2 = (word) w2#8 (word) w2#9 (word) w2#3 
Alias (word) w1#11 = (word) w1#4 (word) w1#5 
Alias (word) w2#11 = (word) w2#4 (word) w2#5 
Alias (word) w1#0 = (word) w1#16 
Alias (word) w2#0 = (word) w2#15 
Alias (word) w1#12 = (word) w1#6 
Alias (word) w2#12 = (word) w2#6 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (word) w1#0 ← (byte/signed byte/word/signed word) 0
  (word) w2#0 ← (byte/signed byte/word/signed word) 0
  to:@3
main: scope:[main]  from @3
  (word) w2#13 ← phi( @3/(word) w2#0 )
  (word) w1#13 ← phi( @3/(word) w1#0 )
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (word) w1#1 ← phi( main/(word) w1#11 )
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (word) w2#1 ← phi( main::@1/(word) w2#11 )
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (word) w1#15 ← phi( main::@2/(word) w1#11 )
  call incw2 param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  (word) w2#2 ← phi( main::@3/(word) w2#11 )
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(word) w1#13 main::@2/(word) w1#1 )
  (word) w1#11 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(word) w2#13 main::@3/(word) w2#1 )
  (word) w2#11 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main param-assignment
  to:@4
@4: scope:[]  from @3
  (word) w2#12 ← phi( @3/(word) w2#2 )
  (word) w1#12 ← phi( @3/(word) w1#15 )
  to:@end
@end: scope:[]  from @4

Not aliassing across scopes: w1#13 w1#0
Not aliassing across scopes: w2#13 w2#0
Not aliassing across scopes: w1#1 w1#11
Not aliassing across scopes: w2#1 w2#11
Not aliassing across scopes: w1#15 w1#11
Not aliassing across scopes: w2#2 w2#11
Not aliassing across scopes: w1#10 w1#13
Not aliassing across scopes: w2#10 w2#13
Not aliassing across scopes: w1#12 w1#15
Not aliassing across scopes: w2#12 w2#2
Redundant Phi (word) w1#13 (word) w1#0
Redundant Phi (word) w2#13 (word) w2#0
Redundant Phi (word) w1#1 (word) w1#11
Redundant Phi (word) w2#1 (word) w2#11
Redundant Phi (word) w1#15 (word) w1#11
Redundant Phi (word) w2#2 (word) w2#11
Redundant Phi (word) w1#12 (word) w1#15
Redundant Phi (word) w2#12 (word) w2#2
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (word) w1#0 ← (byte/signed byte/word/signed word) 0
  (word) w2#0 ← (byte/signed byte/word/signed word) 0
  to:@3
main: scope:[main]  from @3
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call incw2 param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(word) w1#0 main::@2/(word) w1#11 )
  (word) w1#11 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(word) w2#0 main::@3/(word) w2#11 )
  (word) w2#11 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main param-assignment
  to:@4
@4: scope:[]  from @3
  to:@end
@end: scope:[]  from @4

Constant (const word) w1#0 = 0
Constant (const word) w2#0 = 0
Succesful SSA optimization Pass2ConstantIdentification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@3
main: scope:[main]  from @3
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call incw2 param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(const word) w1#0 main::@2/(word) w1#11 )
  (word) w1#11 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(const word) w2#0 main::@3/(word) w2#11 )
  (word) w2#11 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main param-assignment
  to:@4
@4: scope:[]  from @3
  to:@end
@end: scope:[]  from @4

Culled Empty Block (label) main::@4
Culled Empty Block (label) @4
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@3
main: scope:[main]  from @3
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call incw2 param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(const word) w1#0 main::@2/(word) w1#11 )
  (word) w1#11 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(const word) w2#0 main::@3/(word) w2#11 )
  (word) w2#11 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @3

Inlining constant with var siblings (const word) w1#0
Inlining constant with var siblings (const word) w1#0
Inlining constant with var siblings (const word) w2#0
Inlining constant with var siblings (const word) w2#0
Constant inlined w1#0 = (byte/signed byte/word/signed word) 0
Constant inlined w2#0 = (byte/signed byte/word/signed word) 0
Succesful SSA optimization Pass2ConstantInlining
CONTROL FLOW GRAPH
@begin: scope:[]  from
  to:@3
main: scope:[main]  from @3
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call incw2 param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(byte/signed byte/word/signed word) 0 main::@2/(word) w1#11 )
  (word) w1#11 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(byte/signed byte/word/signed word) 0 main::@3/(word) w2#11 )
  (word) w2#11 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
@3: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @3

FINAL SYMBOL TABLE
(label) @3
(label) @begin
(label) @end
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(word) w1
(word) w1#10
(word) w1#11
(word) w2
(word) w2#10
(word) w2#11

Block Sequence Planned @begin @3 @end main main::@1 main::@2 main::@3 main::@return incw2 incw2::@return incw1 incw1::@return 
Block Sequence Planned @begin @3 @end main main::@1 main::@2 main::@3 main::@return incw2 incw2::@return incw1 incw1::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  to:@3
@3: scope:[]  from @begin
  call main param-assignment
  to:@end
@end: scope:[]  from @3
main: scope:[main]  from @3
  call incw1 param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call incw2 param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (word~) w1#17 ← (word) w1#11
  call incw1 param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  (word~) w2#17 ← (word) w2#11
  call incw2 param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  (word) w2#10 ← phi( main::@1/(byte/signed byte/word/signed word) 0 main::@3/(word~) w2#17 )
  (word) w2#11 ← ++ (word) w2#10
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  return 
  to:@return
incw1: scope:[incw1]  from main main::@2
  (word) w1#10 ← phi( main/(byte/signed byte/word/signed word) 0 main::@2/(word~) w1#17 )
  (word) w1#11 ← ++ (word) w1#10
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  return 
  to:@return

Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to incw1:5 incw2:7 incw1:9 incw2:11 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  [0] phi() [ ]
  to:@3
@3: scope:[]  from @begin
  [1] phi() [ ]
  [2] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @3
  [3] phi() [ ]
main: scope:[main]  from @3
  [4] phi() [ ]
  [5] call incw1 param-assignment [ w1#11 ]
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi() [ w1#11 ]
  [7] call incw2 param-assignment [ w1#11 w2#11 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] (word~) w1#17 ← (word) w1#11 [ w1#17 w2#11 ]
  [9] call incw1 param-assignment [ w2#11 ]
  to:main::@3
main::@3: scope:[main]  from main::@2
  [10] (word~) w2#17 ← (word) w2#11 [ w2#17 ]
  [11] call incw2 param-assignment [ ]
  to:main::@return
main::@return: scope:[main]  from main::@3
  [12] return  [ ]
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  [13] (word) w2#10 ← phi( main::@1/(byte/signed byte/word/signed word) 0 main::@3/(word~) w2#17 ) [ w2#10 ]
  [14] (word) w2#11 ← ++ (word) w2#10 [ w2#11 ]
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  [15] return  [ w2#11 ]
  to:@return
incw1: scope:[incw1]  from main main::@2
  [16] (word) w1#10 ← phi( main/(byte/signed byte/word/signed word) 0 main::@2/(word~) w1#17 ) [ w1#10 ]
  [17] (word) w1#11 ← ++ (word) w1#10 [ w1#11 ]
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  [18] return  [ w1#11 ]
  to:@return

Created 2 initial phi equivalence classes
Coalesced [8] w1#17 ← w1#11
Coalesced [10] w2#17 ← w2#11
Coalesced down to 2 phi equivalence classes
Block Sequence Planned @begin @3 @end main main::@1 main::@2 main::@3 main::@return incw2 incw2::@return incw1 incw1::@return 
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of main::@3
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - BEFORE EFFECTIVE LIVE RANGES
@begin: scope:[]  from
  [0] phi() [ ]
  to:@3
@3: scope:[]  from @begin
  [1] phi() [ ]
  [2] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @3
  [3] phi() [ ]
main: scope:[main]  from @3
  [4] phi() [ ]
  [5] call incw1 param-assignment [ w1#11 ]
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi() [ w1#11 ]
  [7] call incw2 param-assignment [ w2#11 w1#11 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] phi() [ w2#11 w1#11 ]
  [9] call incw1 param-assignment [ w2#11 ]
  to:main::@3
main::@3: scope:[main]  from main::@2
  [10] phi() [ w2#11 ]
  [11] call incw2 param-assignment [ ]
  to:main::@return
main::@return: scope:[main]  from main::@3
  [12] return  [ ]
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  [13] (word) w2#10 ← phi( main::@1/(byte/signed byte/word/signed word) 0 main::@3/(word) w2#11 ) [ w2#10 ]
  [14] (word) w2#11 ← ++ (word) w2#10 [ w2#11 ]
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  [15] return  [ w2#11 ]
  to:@return
incw1: scope:[incw1]  from main main::@2
  [16] (word) w1#10 ← phi( main/(byte/signed byte/word/signed word) 0 main::@2/(word) w1#11 ) [ w1#10 ]
  [17] (word) w1#11 ← ++ (word) w1#10 [ w1#11 ]
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  [18] return  [ w1#11 ]
  to:@return

CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] phi() [ ] ( )
  to:@3
@3: scope:[]  from @begin
  [1] phi() [ ] ( )
  [2] call main param-assignment [ ] ( )
  to:@end
@end: scope:[]  from @3
  [3] phi() [ ] ( )
main: scope:[main]  from @3
  [4] phi() [ ] ( main:2 [ ] )
  [5] call incw1 param-assignment [ w1#11 ] ( main:2 [ w1#11 ] )
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi() [ w1#11 ] ( main:2 [ w1#11 ] )
  [7] call incw2 param-assignment [ w2#11 w1#11 ] ( main:2 [ w2#11 w1#11 ] )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] phi() [ w2#11 w1#11 ] ( main:2 [ w2#11 w1#11 ] )
  [9] call incw1 param-assignment [ w2#11 ] ( main:2 [ w2#11 ] )
  to:main::@3
main::@3: scope:[main]  from main::@2
  [10] phi() [ w2#11 ] ( main:2 [ w2#11 ] )
  [11] call incw2 param-assignment [ ] ( main:2 [ ] )
  to:main::@return
main::@return: scope:[main]  from main::@3
  [12] return  [ ] ( main:2 [ ] )
  to:@return
incw2: scope:[incw2]  from main::@1 main::@3
  [13] (word) w2#10 ← phi( main::@1/(byte/signed byte/word/signed word) 0 main::@3/(word) w2#11 ) [ w2#10 ] ( main:2::incw2:7 [ w1#11 w2#10 ] main:2::incw2:11 [ w2#10 ] )
  [14] (word) w2#11 ← ++ (word) w2#10 [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] )
  to:incw2::@return
incw2::@return: scope:[incw2]  from incw2
  [15] return  [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] )
  to:@return
incw1: scope:[incw1]  from main main::@2
  [16] (word) w1#10 ← phi( main/(byte/signed byte/word/signed word) 0 main::@2/(word) w1#11 ) [ w1#10 ] ( main:2::incw1:5 [ w1#10 ] main:2::incw1:9 [ w2#11 w1#10 ] )
  [17] (word) w1#11 ← ++ (word) w1#10 [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] )
  to:incw1::@return
incw1::@return: scope:[incw1]  from incw1
  [18] return  [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] )
  to:@return

DOMINATORS
@begin dominated by  @begin 
@3 dominated by  @begin @3 
@end dominated by  @begin @3 @end 
main dominated by  @begin @3 main 
main::@1 dominated by  @begin @3 main::@1 main 
main::@2 dominated by  @begin @3 main::@1 main::@2 main 
main::@3 dominated by  @begin @3 main::@1 main::@2 main main::@3 
main::@return dominated by  main::@return @begin @3 main::@1 main::@2 main main::@3 
incw2 dominated by  incw2 @begin @3 main::@1 main 
incw2::@return dominated by  incw2 @begin @3 incw2::@return main::@1 main 
incw1 dominated by  @begin @3 incw1 main 
incw1::@return dominated by  @begin @3 incw1 main incw1::@return 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [incw1]
Found 0 loops in scope [incw2]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(void()) incw1()
(void()) incw2()
(void()) main()
(word) w1
(word) w1#10 4.0
(word) w1#11 0.6666666666666666
(word) w2
(word) w2#10 4.0
(word) w2#11 0.6666666666666666

Initial phi equivalence classes
[ w2#10 w2#11 ]
[ w1#10 w1#11 ]
Complete equivalence classes
[ w2#10 w2#11 ]
[ w1#10 w1#11 ]
Allocated zp ZP_WORD:2 [ w2#10 w2#11 ]
Allocated zp ZP_WORD:4 [ w1#10 w1#11 ]
INITIAL ASM
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label w1 = 4
  .label w2 = 2
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @3 [phi:@begin->@3]
b3_from_bbegin:
  jmp b3
//SEG4 @3
b3:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @3 to main [phi:@3->main]
main_from_b3:
  jsr main
//SEG7 [3] phi from @3 to @end [phi:@3->@end]
bend_from_b3:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call incw1 param-assignment [ w1#11 ] ( main:2 [ w1#11 ] )
  //SEG11 [16] phi from main to incw1 [phi:main->incw1]
  incw1_from_main:
  //SEG12 [16] phi (word) w1#10 = (byte/signed byte/word/signed word) 0 [phi:main->incw1#0] -- vwuz1=vbuc1 
    lda #0
    sta w1
    lda #0
    sta w1+1
    jsr incw1
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG14 main::@1
  b1:
  //SEG15 [7] call incw2 param-assignment [ w2#11 w1#11 ] ( main:2 [ w2#11 w1#11 ] )
  //SEG16 [13] phi from main::@1 to incw2 [phi:main::@1->incw2]
  incw2_from_b1:
  //SEG17 [13] phi (word) w2#10 = (byte/signed byte/word/signed word) 0 [phi:main::@1->incw2#0] -- vwuz1=vbuc1 
    lda #0
    sta w2
    lda #0
    sta w2+1
    jsr incw2
  //SEG18 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG19 main::@2
  b2:
  //SEG20 [9] call incw1 param-assignment [ w2#11 ] ( main:2 [ w2#11 ] )
  //SEG21 [16] phi from main::@2 to incw1 [phi:main::@2->incw1]
  incw1_from_b2:
  //SEG22 [16] phi (word) w1#10 = (word) w1#11 [phi:main::@2->incw1#0] -- register_copy 
    jsr incw1
  //SEG23 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  b3_from_b2:
    jmp b3
  //SEG24 main::@3
  b3:
  //SEG25 [11] call incw2 param-assignment [ ] ( main:2 [ ] )
  //SEG26 [13] phi from main::@3 to incw2 [phi:main::@3->incw2]
  incw2_from_b3:
  //SEG27 [13] phi (word) w2#10 = (word) w2#11 [phi:main::@3->incw2#0] -- register_copy 
    jsr incw2
    jmp breturn
  //SEG28 main::@return
  breturn:
  //SEG29 [12] return  [ ] ( main:2 [ ] )
    rts
}
//SEG30 incw2
incw2: {
  //SEG31 [14] (word) w2#11 ← ++ (word) w2#10 [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] ) -- vwuz1=_inc_vwuz1 
    inc w2
    bne !+
    inc w2+1
  !:
    jmp breturn
  //SEG32 incw2::@return
  breturn:
  //SEG33 [15] return  [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] )
    rts
}
//SEG34 incw1
incw1: {
  //SEG35 [17] (word) w1#11 ← ++ (word) w1#10 [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] ) -- vwuz1=_inc_vwuz1 
    inc w1
    bne !+
    inc w1+1
  !:
    jmp breturn
  //SEG36 incw1::@return
  breturn:
  //SEG37 [18] return  [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] )
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ZP_WORD:2 [ w2#10 w2#11 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_WORD:4 [ w1#10 w1#11 ] : zp ZP_WORD:4 , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 4.67: zp ZP_WORD:2 [ w2#10 w2#11 ] 4.67: zp ZP_WORD:4 [ w1#10 w1#11 ] 
Uplift Scope [main] 
Uplift Scope [incw1] 
Uplift Scope [incw2] 

Uplifting [] best 120 combination zp ZP_WORD:2 [ w2#10 w2#11 ] zp ZP_WORD:4 [ w1#10 w1#11 ] 
Uplifting [main] best 120 combination 
Uplifting [incw1] best 120 combination 
Uplifting [incw2] best 120 combination 

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label w1 = 4
  .label w2 = 2
//SEG2 @begin
bbegin:
//SEG3 [1] phi from @begin to @3 [phi:@begin->@3]
b3_from_bbegin:
  jmp b3
//SEG4 @3
b3:
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @3 to main [phi:@3->main]
main_from_b3:
  jsr main
//SEG7 [3] phi from @3 to @end [phi:@3->@end]
bend_from_b3:
  jmp bend
//SEG8 @end
bend:
//SEG9 main
main: {
  //SEG10 [5] call incw1 param-assignment [ w1#11 ] ( main:2 [ w1#11 ] )
  //SEG11 [16] phi from main to incw1 [phi:main->incw1]
  incw1_from_main:
  //SEG12 [16] phi (word) w1#10 = (byte/signed byte/word/signed word) 0 [phi:main->incw1#0] -- vwuz1=vbuc1 
    lda #0
    sta w1
    lda #0
    sta w1+1
    jsr incw1
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
  //SEG14 main::@1
  b1:
  //SEG15 [7] call incw2 param-assignment [ w2#11 w1#11 ] ( main:2 [ w2#11 w1#11 ] )
  //SEG16 [13] phi from main::@1 to incw2 [phi:main::@1->incw2]
  incw2_from_b1:
  //SEG17 [13] phi (word) w2#10 = (byte/signed byte/word/signed word) 0 [phi:main::@1->incw2#0] -- vwuz1=vbuc1 
    lda #0
    sta w2
    lda #0
    sta w2+1
    jsr incw2
  //SEG18 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG19 main::@2
  b2:
  //SEG20 [9] call incw1 param-assignment [ w2#11 ] ( main:2 [ w2#11 ] )
  //SEG21 [16] phi from main::@2 to incw1 [phi:main::@2->incw1]
  incw1_from_b2:
  //SEG22 [16] phi (word) w1#10 = (word) w1#11 [phi:main::@2->incw1#0] -- register_copy 
    jsr incw1
  //SEG23 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  b3_from_b2:
    jmp b3
  //SEG24 main::@3
  b3:
  //SEG25 [11] call incw2 param-assignment [ ] ( main:2 [ ] )
  //SEG26 [13] phi from main::@3 to incw2 [phi:main::@3->incw2]
  incw2_from_b3:
  //SEG27 [13] phi (word) w2#10 = (word) w2#11 [phi:main::@3->incw2#0] -- register_copy 
    jsr incw2
    jmp breturn
  //SEG28 main::@return
  breturn:
  //SEG29 [12] return  [ ] ( main:2 [ ] )
    rts
}
//SEG30 incw2
incw2: {
  //SEG31 [14] (word) w2#11 ← ++ (word) w2#10 [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] ) -- vwuz1=_inc_vwuz1 
    inc w2
    bne !+
    inc w2+1
  !:
    jmp breturn
  //SEG32 incw2::@return
  breturn:
  //SEG33 [15] return  [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] )
    rts
}
//SEG34 incw1
incw1: {
  //SEG35 [17] (word) w1#11 ← ++ (word) w1#10 [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] ) -- vwuz1=_inc_vwuz1 
    inc w1
    bne !+
    inc w1+1
  !:
    jmp breturn
  //SEG36 incw1::@return
  breturn:
  //SEG37 [18] return  [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] )
    rts
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b3
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Removing instruction b3_from_bbegin:
Removing instruction main_from_b3:
Removing instruction bend_from_b3:
Removing instruction b1_from_main:
Removing instruction incw2_from_b1:
Removing instruction b2_from_b1:
Removing instruction incw1_from_b2:
Removing instruction b3_from_b2:
Removing instruction incw2_from_b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction b3:
Removing instruction bend:
Removing instruction incw1_from_main:
Removing instruction b1:
Removing instruction b2:
Removing instruction b3:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @3
(label) @begin
(label) @end
(void()) incw1()
(label) incw1::@return
(void()) incw2()
(label) incw2::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(word) w1
(word) w1#10 w1 zp ZP_WORD:4 4.0
(word) w1#11 w1 zp ZP_WORD:4 0.6666666666666666
(word) w2
(word) w2#10 w2 zp ZP_WORD:2 4.0
(word) w2#11 w2 zp ZP_WORD:2 0.6666666666666666

zp ZP_WORD:2 [ w2#10 w2#11 ]
zp ZP_WORD:4 [ w1#10 w1#11 ]

FINAL CODE
//SEG0 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG1 Global Constants & labels
  .label w1 = 4
  .label w2 = 2
//SEG2 @begin
//SEG3 [1] phi from @begin to @3 [phi:@begin->@3]
//SEG4 @3
//SEG5 [2] call main param-assignment [ ] ( )
//SEG6 [4] phi from @3 to main [phi:@3->main]
  jsr main
//SEG7 [3] phi from @3 to @end [phi:@3->@end]
//SEG8 @end
//SEG9 main
main: {
  //SEG10 [5] call incw1 param-assignment [ w1#11 ] ( main:2 [ w1#11 ] )
  //SEG11 [16] phi from main to incw1 [phi:main->incw1]
  //SEG12 [16] phi (word) w1#10 = (byte/signed byte/word/signed word) 0 [phi:main->incw1#0] -- vwuz1=vbuc1 
    lda #0
    sta w1
    sta w1+1
    jsr incw1
  //SEG13 [6] phi from main to main::@1 [phi:main->main::@1]
  //SEG14 main::@1
  //SEG15 [7] call incw2 param-assignment [ w2#11 w1#11 ] ( main:2 [ w2#11 w1#11 ] )
  //SEG16 [13] phi from main::@1 to incw2 [phi:main::@1->incw2]
  //SEG17 [13] phi (word) w2#10 = (byte/signed byte/word/signed word) 0 [phi:main::@1->incw2#0] -- vwuz1=vbuc1 
    lda #0
    sta w2
    sta w2+1
    jsr incw2
  //SEG18 [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG19 main::@2
  //SEG20 [9] call incw1 param-assignment [ w2#11 ] ( main:2 [ w2#11 ] )
  //SEG21 [16] phi from main::@2 to incw1 [phi:main::@2->incw1]
  //SEG22 [16] phi (word) w1#10 = (word) w1#11 [phi:main::@2->incw1#0] -- register_copy 
    jsr incw1
  //SEG23 [10] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  //SEG24 main::@3
  //SEG25 [11] call incw2 param-assignment [ ] ( main:2 [ ] )
  //SEG26 [13] phi from main::@3 to incw2 [phi:main::@3->incw2]
  //SEG27 [13] phi (word) w2#10 = (word) w2#11 [phi:main::@3->incw2#0] -- register_copy 
    jsr incw2
  //SEG28 main::@return
  //SEG29 [12] return  [ ] ( main:2 [ ] )
    rts
}
//SEG30 incw2
incw2: {
  //SEG31 [14] (word) w2#11 ← ++ (word) w2#10 [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] ) -- vwuz1=_inc_vwuz1 
    inc w2
    bne !+
    inc w2+1
  !:
  //SEG32 incw2::@return
  //SEG33 [15] return  [ w2#11 ] ( main:2::incw2:7 [ w1#11 w2#11 ] main:2::incw2:11 [ w2#11 ] )
    rts
}
//SEG34 incw1
incw1: {
  //SEG35 [17] (word) w1#11 ← ++ (word) w1#10 [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] ) -- vwuz1=_inc_vwuz1 
    inc w1
    bne !+
    inc w1+1
  !:
  //SEG36 incw1::@return
  //SEG37 [18] return  [ w1#11 ] ( main:2::incw1:5 [ w1#11 ] main:2::incw1:9 [ w2#11 w1#11 ] )
    rts
}

