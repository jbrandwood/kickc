// Tetris Game Implementation
import "c64"
import "memory"
import "keyboard"

byte* SCREEN = $400;	

// The size of the playfield
const byte PLAYFIELD_LINES = 22;
const byte PLAYFIELD_COLS = 10;

// The playfield.  0 is empty non-zero is color. 
// The playfield is layed out line by line, meaning the first 10 bytes are line 1, the next 10 line 2 and so forth, 
byte[PLAYFIELD_LINES*PLAYFIELD_COLS] playfield;

// Pointers to the screen address for rendering each playfield line
byte*[PLAYFIELD_LINES+3] screen_lines;

// Pointers to the playfield address for each playfield line
byte*[PLAYFIELD_LINES] playfield_lines;

// The current moving piece. Points to the start of the piece definition.
byte* current_piece = 0;

// The curent piece orientation - each piece have 4 orientations (00/$10/$20/$30). 
// The orientation chooses one of the 4 sub-graphics of the piece.
byte current_piece_orientation = 0; 

// Pointer to the current piece in the current orientation. Updated each time current_piece_orientation is updated.
byte* current_piece_gfx = 0;

// The color of the current piece
byte current_piece_color = 0;

// Position of top left corner of current moving piece on the playfield
byte current_xpos = 3;
byte current_ypos = 0;

// The rate of moving down the current piece (number of frames between moves if movedown is not not forced)
const byte current_movedown_rate = 50;

// The rate of moving down the current piece fast (number of frames between moves if movedown is not not forced)
const byte current_movedown_rate_fast = 5;

// Counts down til next movedown of current piece
byte current_movedown_counter = 0;

void main() {
	asm { sei }
	init();
	spawn_current();
	render_playfield();
	render_current();
	while(true) { 
		// Wait for a frame to pass
		while(*RASTER!=$ff) {}
		while(*RASTER!=$fe) {}
		(*BORDERCOL)++;
		// Scan keyboard events
		keyboard_event_scan();
		byte key_event = keyboard_event_get();
		byte render = 0;
		render += play_movedown(key_event);
		render += play_moveother(key_event);
		if(render!=0) {
			(*BORDERCOL)++;
			render_playfield();
			render_current();
			(*BORDERCOL)--;			
		}
		(*BORDERCOL)--;			
	}
}

// Move down the current piece 
// Return non-zero if a render is needed 
byte play_movedown(byte key_event) {
		// Handle moving down current piece	
		++current_movedown_counter;
		byte movedown = 0;
		// As soon as space is pressed move down once
		if(key_event==KEY_SPACE) {
			movedown++;
		} 
		// While space is held down move down faster
		if(keyboard_event_pressed(KEY_SPACE)!=0) {
			if(current_movedown_counter>=current_movedown_rate_fast) {
				movedown++;
			}
		} 
		// Move down slowly otherwise
		if(current_movedown_counter>=current_movedown_rate) {
			movedown++;
		}
		// Attempt movedown 
		if(movedown!=0) {
			if(collision(current_ypos+1, current_xpos)==COLLISION_NONE) {
				// Move current piece down
				current_ypos++;
			} else {
				// Lock current piece 
				lock_current();
				// Spawn a new piece
				spawn_current();
			}
			current_movedown_counter = 0;
			return 1;								
		}
		return 0;			
}

// No collision
const byte COLLISION_NONE = 0;
// Playfield piece collision (cell on top of other cell on the playfield)
const byte COLLISION_PLAYFIELD = 1;
// Bottom collision (cell below bottom of the playfield)
const byte COLLISION_BOTTOM = 2;
// Left side collision (cell beyond the left side of the playfield)
const byte COLLISION_LEFT = 4;
// Right side collision (cell beyond the right side of the playfield)
const byte COLLISION_RIGHT = 8;

// Test if there is a collision between the current piece moved to (x, y) and anything on the playfield or the playfield boundaries
// Returns information about the type of the collision detected 
byte collision(byte ypos, byte xpos) {
	byte i = 0;
	for(byte l:0..3) {		
		byte line = ypos + l;
		byte* playfield_line = playfield_lines[line<<1];
		for(byte c:0..3) {
			if(current_piece_gfx[i++]!=0) {
				if(line>=PLAYFIELD_LINES) {
					// Below the playfield bottom
					return COLLISION_BOTTOM;
				}
				byte col = xpos+c;
				if((col&$80)!=0) {
					// Beyond left side of the playfield
					return COLLISION_LEFT;					
				}
				if(col>=PLAYFIELD_COLS) {
					// Beyond left side of the playfield
					return COLLISION_RIGHT;					
				}
				if(playfield_line[col]!=0) {
					// Collision with a playfield cell
					return COLLISION_PLAYFIELD;
				}
			}
		}
	}
	return COLLISION_NONE;
}

// Lock the current piece onto the playfield
void lock_current() {
	byte i = 0;
	for(byte l:0..3) {		
		byte line = current_ypos + l;
		byte* playfield_line = playfield_lines[line<<1];
		for(byte c:0..3) {
			byte cell = current_piece_gfx[i++];
			if(cell!=0) {
				byte col = current_xpos + c;
				playfield_line[col] = current_piece_color;
			}
		}
	}
}

// Spawn a new piece
void spawn_current() {
	current_piece = piece_t;
	current_piece_orientation = 0;
	current_piece_gfx = current_piece + current_piece_orientation;
	current_piece_color = GREEN;
	current_xpos = 3;
	current_ypos = 0;
}

// Move left/right or rotate the current piece
// Return non-zero if a render is needed 
byte play_moveother(byte key_event) {
		byte render = 0;
		// Handle other keyboard events
		if((key_event&$80)==0) {
			// New keyboard event
			if(key_event==KEY_COMMA) {
				if(collision(current_ypos,current_xpos-1)==COLLISION_NONE) {				
					current_xpos--;
					render++;
				}
			} else if(key_event==KEY_DOT) {
				if(collision(current_ypos,current_xpos+1)==COLLISION_NONE) {				
					current_xpos++;
					render++;
				}
			} else if(key_event==KEY_Z) {
				current_piece_orientation = (current_piece_orientation-$10)&$3f;
				current_piece_gfx = current_piece + current_piece_orientation;
				render++;
			} else if(key_event==KEY_X) {
				current_piece_orientation = (current_piece_orientation+$10)&$3f;
				current_piece_gfx = current_piece + current_piece_orientation;
				render++;
			}
		}
		return render;
}

// Initialize the screen and data tables 
void init() {
	// Clear the screen
	fill(SCREEN,1000,$a0);
	fill(COLS,1000,BLACK);
	// Initialize the screen line pointers;
	byte* li = COLS + 40 + 15;
	for(byte i:0..PLAYFIELD_LINES+2) {
		screen_lines[i<<1] = li;
		li += 40;
	}
	// Initialize the playfield line pointers;
	byte* pli = playfield;
	for(byte j:0..PLAYFIELD_LINES-1) {
		playfield_lines[j<<1] = pli;
		pli += 10;
	}
	// Prepare the playfield frame
	byte* line = COLS + 14;
	for(byte l:0..PLAYFIELD_LINES+1) {
		for(byte c:0..PLAYFIELD_COLS+1) {
			*(line+c) = DARK_GREY;
		}
		line +=40;
	}

}

// Render the static playfield on the screen
void render_playfield() {
	byte i = 0;
	for(byte l:0..PLAYFIELD_LINES-1) {		
		byte* line = screen_lines[l<<1];
		for(byte c:0..PLAYFIELD_COLS-1) {
			*(line+c) = playfield[i++];
		}
	}	
}


// Render the current moving piece at position (current_xpos, current_ypos)
void render_current() {
	byte i = 0;
	for(byte l:0..3) {		
		byte line = current_ypos + l;
		if(line<PLAYFIELD_LINES) {
			byte* screen_line = screen_lines[line<<1];
			for(byte c:0..3) {
				byte current_cell = current_piece_gfx[i++];
				if(current_cell!=0) {
					byte xpos = current_xpos+c;
					if(xpos<PLAYFIELD_COLS) {
						screen_line[xpos] = current_piece_color;
					}
				}
			}
		}
	}
}


// The T-piece
align($40) byte[4*4*4] piece_t = { 
	1, 1, 1, 0,  
	0, 1, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,

	0, 0, 1, 0,
	0, 1, 1, 0,
	0, 0, 1, 0,
	0, 0, 0, 0,

	0, 0, 0, 0,
	0, 1, 0, 0,
	1, 1, 1, 0,
	0, 0, 0, 0,

	1, 0, 0, 0,
	1, 1, 0, 0,
	1, 0, 0, 0,
	0, 0, 0, 0
};

// The S-piece
align($40) byte[4*4*4] piece_s = { 
	0, 0, 0, 0,  
	0, 1, 1, 0,
	1, 1, 0, 0,
	0, 0, 0, 0,

	1, 0, 0, 0,
	1, 1, 0, 0,
	0, 1, 0, 0,
	0, 0, 0, 0,

	0, 0, 0, 0,
	0, 1, 1, 0,
	1, 1, 0, 0,
	0, 0, 0, 0,

	1, 0, 0, 0,
	1, 1, 0, 0,
	0, 1, 0, 0,
	0, 0, 0, 0

};

// The Z-piece
align($40) byte[4*4*4] piece_z = { 
	0, 0, 0, 0,  
	1, 1, 0, 0,
	0, 1, 1, 0,
	0, 0, 0, 0,

	0, 1, 0, 0,
	1, 1, 0, 0,
	1, 0, 0, 0,
	0, 0, 0, 0,

	0, 0, 0, 0,  
	1, 1, 0, 0,
	0, 1, 1, 0,
	0, 0, 0, 0,

	0, 1, 0, 0,
	1, 1, 0, 0,
	1, 0, 0, 0,
	0, 0, 0, 0

};

// The L-piece
align($40) byte[4*4*4] piece_l = { 
	0, 0, 0, 0,  
	1, 1, 1, 0,
	1, 0, 0, 0,
	0, 0, 0, 0,

	1, 1, 0, 0,
	0, 1, 0, 0,
	0, 1, 0, 0,
	0, 0, 0, 0,

	0, 0, 1, 0,  
	1, 1, 1, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,

	0, 1, 0, 0,
	0, 1, 0, 0,
	0, 1, 1, 0,
	0, 0, 0, 0

};

// The J-piece
align($40) byte[4*4*4] piece_j = { 
	1, 0, 0, 0,  
	1, 1, 1, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,

	0, 1, 1, 0,
	0, 1, 0, 0,
	0, 1, 0, 0,
	0, 0, 0, 0,

	0, 0, 0, 0,  
	1, 1, 1, 0,
	0, 0, 1, 0,
	0, 0, 0, 0,

	0, 1, 0, 0,
	0, 1, 0, 0,
	1, 1, 0, 0,
	0, 0, 0, 0

};

// The O-piece
align($40) byte[4*4*4] piece_o = { 
	1, 1, 0, 0,  
	1, 1, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,

	1, 1, 0, 0,  
	1, 1, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,

	1, 1, 0, 0,  
	1, 1, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0,

	1, 1, 0, 0,  
	1, 1, 0, 0,
	0, 0, 0, 0,
	0, 0, 0, 0

};

// The I-piece
align($40) byte[4*4*4] piece_i = { 
	0, 0, 0, 0,  
	0, 0, 0, 0,
	1, 1, 1, 1,
	0, 0, 0, 0,

	0, 1, 0, 0,  
	0, 1, 0, 0,
	0, 1, 0, 0,
	0, 1, 0, 0,

	0, 0, 0, 0,  
	0, 0, 0, 0,
	1, 1, 1, 1,
	0, 0, 0, 0,

	0, 1, 0, 0,  
	0, 1, 0, 0,
	0, 1, 0, 0,
	0, 1, 0, 0

};
