
void main()
main: scope:[main]  from
  [0] phi()
  [1] call loadFileToMemory 
  [2] loadFileToMemory::return#0 = loadFileToMemory::return#1
  to:main::@4
main::@4: scope:[main]  from main
  [3] main::status#0 = loadFileToMemory::return#0
  [4] if(main::status#0==$ff) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4
  [5] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_BORDER_COLOR) = 2
  [6] error::err#0 = main::status#0
  [7] call error 
  to:main::@1
main::@1: scope:[main]  from main::@2 main::@4
  [8] *((byte*)VICII+OFFSET_STRUCT_MOS6569_VICII_SPRITES_ENABLE) = 1
  to:main::toSpritePtr1
main::toSpritePtr1: scope:[main]  from main::@1
  [9] phi()
  to:main::@3
main::@3: scope:[main]  from main::toSpritePtr1
  [10] *SPRITES_PTR = main::toSpritePtr1_return#0
  [11] *SPRITES_COLOR = GREEN
  [12] *SPRITES_XPOS = $15
  [13] *SPRITES_YPOS = $33
  to:main::@return
main::@return: scope:[main]  from main::@3
  [14] return 
  to:@return

byte loadFileToMemory(byte loadFileToMemory::device , byte* loadFileToMemory::filename , byte* loadFileToMemory::address)
loadFileToMemory: scope:[loadFileToMemory]  from main
  [15] phi()
  [16] call setnam 
  to:loadFileToMemory::@1
loadFileToMemory::@1: scope:[loadFileToMemory]  from loadFileToMemory
  [17] phi()
  [18] call setlfs 
  to:loadFileToMemory::@2
loadFileToMemory::@2: scope:[loadFileToMemory]  from loadFileToMemory::@1
  [19] phi()
  [20] call load 
  [21] load::return#0 = load::return#1
  to:loadFileToMemory::@3
loadFileToMemory::@3: scope:[loadFileToMemory]  from loadFileToMemory::@2
  [22] loadFileToMemory::return#1 = load::return#0
  to:loadFileToMemory::@return
loadFileToMemory::@return: scope:[loadFileToMemory]  from loadFileToMemory::@3
  [23] return 
  to:@return

void error(byte error::err)
error: scope:[error]  from main::@2
  [24] *error::errCode = error::err#0
  asm { ldxerrCode jsr$a437  }
  to:error::@return
error::@return: scope:[error]  from error
  [26] return 
  to:@return

void setnam(byte* setnam::filename)
setnam: scope:[setnam]  from loadFileToMemory
  [27] phi()
  [28] call strlen 
  [29] strlen::return#2 = strlen::len#2
  to:setnam::@1
setnam::@1: scope:[setnam]  from setnam
  [30] setnam::$0 = strlen::return#2
  [31] *setnam::filename_len = (byte)setnam::$0
  [32] *setnam::filename_ptr = main::filename
  asm { ldafilename_len ldxfilename_ptr ldyfilename_ptr+1 jsr$ffbd  }
  to:setnam::@return
setnam::@return: scope:[setnam]  from setnam::@1
  [34] return 
  to:@return

void setlfs(byte setlfs::device)
setlfs: scope:[setlfs]  from loadFileToMemory::@1
  [35] *setlfs::deviceNum = loadFileToMemory::device#0
  asm { ldxdeviceNum lda#1 ldy#0 jsr$ffba  }
  to:setlfs::@return
setlfs::@return: scope:[setlfs]  from setlfs
  [37] return 
  to:@return

byte load(byte* load::address , bool load::verify)
load: scope:[load]  from loadFileToMemory::@2
  [38] *load::loadOrVerify = 0
  [39] *load::loadAddress = LOAD_SPRITE
  asm { ldxloadAddress ldyloadAddress+1 ldaloadOrVerify jsr$ffd5 bcserror lda#$ff error: stastatus  }
  [41] load::return#1 = *load::status
  to:load::@return
load::@return: scope:[load]  from load
  [42] return 
  to:@return

word strlen(byte* strlen::str)
strlen: scope:[strlen]  from setnam
  [43] phi()
  to:strlen::@1
strlen::@1: scope:[strlen]  from strlen strlen::@2
  [44] strlen::len#2 = phi( strlen/0, strlen::@2/strlen::len#1 )
  [44] strlen::str#2 = phi( strlen/main::filename, strlen::@2/strlen::str#0 )
  [45] if(0!=*strlen::str#2) goto strlen::@2
  to:strlen::@return
strlen::@return: scope:[strlen]  from strlen::@1
  [46] return 
  to:@return
strlen::@2: scope:[strlen]  from strlen::@1
  [47] strlen::len#1 = ++ strlen::len#2
  [48] strlen::str#0 = ++ strlen::str#2
  to:strlen::@1
