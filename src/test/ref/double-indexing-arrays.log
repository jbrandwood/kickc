Inlined call call _init 

CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from _start::@1
  (byte) main::x#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) main::x#2 ← phi( main/(byte) main::x#0 main::@1/(byte) main::x#1 )
  *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2)
  *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2))
  (number~) main::$0 ← (number) $c8 + (byte) main::x#2
  (number~) main::$1 ← (number) $c8 + (byte) main::x#2
  *((const byte*) SCREEN + (number~) main::$0) ← *((const byte*) MAPDATA + (number~) main::$1)
  (number~) main::$2 ← (number) $c8 + (byte) main::x#2
  (number~) main::$3 ← (number) $c8 + (byte) main::x#2
  *((const byte*) COLS + (number~) main::$2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (number~) main::$3))
  (number~) main::$4 ← (number) $190 + (byte) main::x#2
  (number~) main::$5 ← (number) $190 + (byte) main::x#2
  *((const byte*) SCREEN + (number~) main::$4) ← *((const byte*) MAPDATA + (number~) main::$5)
  (number~) main::$6 ← (number) $190 + (byte) main::x#2
  (number~) main::$7 ← (number) $190 + (byte) main::x#2
  *((const byte*) COLS + (number~) main::$6) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (number~) main::$7))
  (number~) main::$8 ← (number) $258 + (byte) main::x#2
  (number~) main::$9 ← (number) $258 + (byte) main::x#2
  *((const byte*) SCREEN + (number~) main::$8) ← *((const byte*) MAPDATA + (number~) main::$9)
  (number~) main::$10 ← (number) $258 + (byte) main::x#2
  (number~) main::$11 ← (number) $258 + (byte) main::x#2
  *((const byte*) COLS + (number~) main::$10) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA + (number~) main::$11))
  (number~) main::$12 ← (number) $320 + (byte) main::x#2
  (number~) main::$13 ← (number) $320 + (byte) main::x#2
  *((const byte*) SCREEN + (number~) main::$12) ← *((const byte*) MAPDATA + (number~) main::$13)
  (number~) main::$14 ← (number) $320 + (byte) main::x#2
  (number~) main::$15 ← (number) $320 + (byte) main::x#2
  *((const byte*) COLS + (number~) main::$14) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA + (number~) main::$15))
  (byte) main::x#1 ← (byte) main::x#2 + rangenext(0,$c8)
  (bool~) main::$16 ← (byte) main::x#1 != rangelast(0,$c8)
  if((bool~) main::$16) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return

(void()) _start()
_start: scope:[_start]  from
  to:_start::_init1
_start::_init1: scope:[_start]  from _start
  to:_start::@1
_start::@1: scope:[_start]  from _start::_init1
  call main 
  to:_start::@2
_start::@2: scope:[_start]  from _start::@1
  to:_start::@return
_start::@return: scope:[_start]  from _start::@2
  return 
  to:@return

SYMBOL TABLE SSA
(const byte*) COLORMAP1[(number) $100]  = { fill( $100, 0) }
(const byte*) COLORMAP2[(number) $100]  = { fill( $100, 0) }
(const byte*) COLS = (byte*)(number) $d800
(const byte*) MAPDATA[(number) $3e8]  = { fill( $3e8, 0) }
(const byte*) SCREEN = (byte*)(number) $400
(void()) _start()
(label) _start::@1
(label) _start::@2
(label) _start::@return
(label) _start::_init1
(void()) main()
(number~) main::$0
(number~) main::$1
(number~) main::$10
(number~) main::$11
(number~) main::$12
(number~) main::$13
(number~) main::$14
(number~) main::$15
(bool~) main::$16
(number~) main::$2
(number~) main::$3
(number~) main::$4
(number~) main::$5
(number~) main::$6
(number~) main::$7
(number~) main::$8
(number~) main::$9
(label) main::@1
(label) main::@return
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#2

Adding number conversion cast (unumber) $c8 in (number~) main::$0 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$0 in (number~) main::$0 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $c8 in (number~) main::$1 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $c8 in (number~) main::$2 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$2 in (number~) main::$2 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $c8 in (number~) main::$3 ← (number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (unumber)(number) $c8 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$4 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$4 in (number~) main::$4 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$5 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$5 in (number~) main::$5 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$6 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $190 in (number~) main::$7 ← (number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) main::$7 in (number~) main::$7 ← (unumber)(number) $190 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$8 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$8 in (number~) main::$8 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$9 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$9 in (number~) main::$9 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$10 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$10 in (number~) main::$10 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $258 in (number~) main::$11 ← (number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) main::$11 in (number~) main::$11 ← (unumber)(number) $258 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$12 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$12 in (number~) main::$12 ← (unumber)(number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$13 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$13 in (number~) main::$13 ← (unumber)(number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$14 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$14 in (number~) main::$14 ← (unumber)(number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) $320 in (number~) main::$15 ← (number) $320 + (byte) main::x#2
Adding number conversion cast (unumber) main::$15 in (number~) main::$15 ← (unumber)(number) $320 + (byte) main::x#2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 55296
Simplifying constant integer cast $c8
Simplifying constant integer cast $c8
Simplifying constant integer cast $c8
Simplifying constant integer cast $c8
Simplifying constant integer cast $190
Simplifying constant integer cast $190
Simplifying constant integer cast $190
Simplifying constant integer cast $190
Simplifying constant integer cast $258
Simplifying constant integer cast $258
Simplifying constant integer cast $258
Simplifying constant integer cast $258
Simplifying constant integer cast $320
Simplifying constant integer cast $320
Simplifying constant integer cast $320
Simplifying constant integer cast $320
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $190
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $258
Finalized unsigned number type (word) $320
Finalized unsigned number type (word) $320
Finalized unsigned number type (word) $320
Finalized unsigned number type (word) $320
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$0 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to byte in (unumber~) main::$1 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to byte in (unumber~) main::$2 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to byte in (unumber~) main::$3 ← (byte) $c8 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$4 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$5 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$6 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$7 ← (word) $190 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$8 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$9 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$10 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$11 ← (word) $258 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$12 ← (word) $320 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$13 ← (word) $320 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$14 ← (word) $320 + (byte) main::x#2
Inferred type updated to word in (unumber~) main::$15 ← (word) $320 + (byte) main::x#2
Simple Condition (bool~) main::$16 [30] if((byte) main::x#1!=rangelast(0,$c8)) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) main::x#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [28] main::x#1 ← ++ main::x#2 to ++
Resolved ranged comparison value [30] if(main::x#1!=rangelast(0,$c8)) goto main::@1 to (number) $c9
De-inlining pointer[w] to *(pointer+w)   [12] *((const byte*) SCREEN + (word~) main::$4) ← *((const byte*) MAPDATA + (word~) main::$5)
De-inlining pointer[w] to *(pointer+w)   [12] *((const byte*) SCREEN + (word~) main::$4) ← *((byte*~) main::$17)
De-inlining pointer[w] to *(pointer+w)   [15] *((const byte*) COLS + (word~) main::$6) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (word~) main::$7))
De-inlining pointer[w] to *(pointer+w)   [15] *((const byte*) COLS + (word~) main::$6) ← *((const byte*) COLORMAP1 + *((byte*~) main::$19))
De-inlining pointer[w] to *(pointer+w)   [18] *((const byte*) SCREEN + (word~) main::$8) ← *((const byte*) MAPDATA + (word~) main::$9)
De-inlining pointer[w] to *(pointer+w)   [18] *((const byte*) SCREEN + (word~) main::$8) ← *((byte*~) main::$21)
De-inlining pointer[w] to *(pointer+w)   [21] *((const byte*) COLS + (word~) main::$10) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA + (word~) main::$11))
De-inlining pointer[w] to *(pointer+w)   [21] *((const byte*) COLS + (word~) main::$10) ← *((const byte*) COLORMAP2 + *((byte*~) main::$23))
De-inlining pointer[w] to *(pointer+w)   [24] *((const byte*) SCREEN + (word~) main::$12) ← *((const byte*) MAPDATA + (word~) main::$13)
De-inlining pointer[w] to *(pointer+w)   [24] *((const byte*) SCREEN + (word~) main::$12) ← *((byte*~) main::$25)
De-inlining pointer[w] to *(pointer+w)   [27] *((const byte*) COLS + (word~) main::$14) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA + (word~) main::$15))
De-inlining pointer[w] to *(pointer+w)   [27] *((const byte*) COLS + (word~) main::$14) ← *((const byte*) COLORMAP2 + *((byte*~) main::$27))
Successful SSA optimization Pass2DeInlineWordDerefIdx
Removing unused procedure _start
Removing unused procedure block _start
Removing unused procedure block _start::_init1
Removing unused procedure block _start::@1
Removing unused procedure block _start::@2
Removing unused procedure block _start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) $c9 in [40] if((byte) main::x#1!=(number) $c9) goto main::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $c9
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $c9
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const byte) main::x#0
Constant inlined main::x#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(MAPDATA+$c8 + main::$1)
Consolidated array index constant in assignment *(SCREEN+$c8 + main::$0)
Consolidated array index constant in assignment *(MAPDATA+$c8 + main::$3)
Consolidated array index constant in assignment *(COLS+$c8 + main::$2)
Consolidated constant in assignment main::$17
Consolidated constant in assignment main::$18
Consolidated constant in assignment main::$19
Consolidated constant in assignment main::$20
Consolidated constant in assignment main::$21
Consolidated constant in assignment main::$22
Consolidated constant in assignment main::$23
Consolidated constant in assignment main::$24
Consolidated constant in assignment main::$25
Consolidated constant in assignment main::$26
Consolidated constant in assignment main::$27
Consolidated constant in assignment main::$28
Successful SSA optimization Pass2ConstantAdditionElimination
Alias main::x#2 = main::$0 main::$1 main::$2 main::$3 main::$4 main::$5 main::$6 main::$7 main::$8 main::$9 main::$10 main::$11 main::$12 main::$13 main::$14 main::$15 
Successful SSA optimization Pass2AliasElimination
Converting *(pointer+n) to pointer[n] [7] *((byte*~) main::$18) ← *((byte*~) main::$17)  -- *(MAPDATA+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [7] *((byte*~) main::$18) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)  -- *(SCREEN+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [10] *((byte*~) main::$20) ← *((const byte*) COLORMAP1 + *((byte*~) main::$19))  -- *(MAPDATA+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [10] *((byte*~) main::$20) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2))  -- *(COLS+$190 + main::x#2)
Converting *(pointer+n) to pointer[n] [13] *((byte*~) main::$22) ← *((byte*~) main::$21)  -- *(MAPDATA+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [13] *((byte*~) main::$22) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)  -- *(SCREEN+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [16] *((byte*~) main::$24) ← *((const byte*) COLORMAP2 + *((byte*~) main::$23))  -- *(MAPDATA+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [16] *((byte*~) main::$24) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2))  -- *(COLS+$258 + main::x#2)
Converting *(pointer+n) to pointer[n] [19] *((byte*~) main::$26) ← *((byte*~) main::$25)  -- *(MAPDATA+$320 + main::x#2)
Converting *(pointer+n) to pointer[n] [19] *((byte*~) main::$26) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)  -- *(SCREEN+$320 + main::x#2)
Converting *(pointer+n) to pointer[n] [22] *((byte*~) main::$28) ← *((const byte*) COLORMAP2 + *((byte*~) main::$27))  -- *(MAPDATA+$320 + main::x#2)
Converting *(pointer+n) to pointer[n] [22] *((byte*~) main::$28) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2))  -- *(COLS+$320 + main::x#2)
Successful SSA optimization Pass2InlineDerefIdx
Eliminating unused variable (byte*~) main::$17 and assignment [5] (byte*~) main::$17 ← (const byte*) MAPDATA+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$18 and assignment [6] (byte*~) main::$18 ← (const byte*) SCREEN+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$19 and assignment [8] (byte*~) main::$19 ← (const byte*) MAPDATA+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$20 and assignment [9] (byte*~) main::$20 ← (const byte*) COLS+(word) $190 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$21 and assignment [11] (byte*~) main::$21 ← (const byte*) MAPDATA+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$22 and assignment [12] (byte*~) main::$22 ← (const byte*) SCREEN+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$23 and assignment [14] (byte*~) main::$23 ← (const byte*) MAPDATA+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$24 and assignment [15] (byte*~) main::$24 ← (const byte*) COLS+(word) $258 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$25 and assignment [17] (byte*~) main::$25 ← (const byte*) MAPDATA+(word) $320 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$26 and assignment [18] (byte*~) main::$26 ← (const byte*) SCREEN+(word) $320 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$27 and assignment [20] (byte*~) main::$27 ← (const byte*) MAPDATA+(word) $320 + (byte) main::x#2
Eliminating unused variable (byte*~) main::$28 and assignment [21] (byte*~) main::$28 ← (const byte*) COLS+(word) $320 + (byte) main::x#2
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting main::@2(between main::@1 and main::@1)
Adding NOP phi() at start of main
CALL GRAPH

Created 1 initial phi equivalence classes
Coalesced [15] main::x#3 ← main::x#1
Coalesced down to 1 phi equivalence classes
Culled Empty Block (label) main::@2
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [1] (byte) main::x#2 ← phi( main/(byte) 0 main::@1/(byte) main::x#1 )
  [2] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2)
  [3] *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2))
  [4] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2)
  [5] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2))
  [6] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)
  [7] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2))
  [8] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)
  [9] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2))
  [10] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)
  [11] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2))
  [12] (byte) main::x#1 ← ++ (byte) main::x#2
  [13] if((byte) main::x#1!=(byte) $c9) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@1
  [14] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte) main::x
(byte) main::x#1 16.5
(byte) main::x#2 22.0

Initial phi equivalence classes
[ main::x#2 main::x#1 ]
Complete equivalence classes
[ main::x#2 main::x#1 ]
Allocated zp[1]:2 [ main::x#2 main::x#1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Tests that constant offset indexing into arrays is handled correctly
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
  // main
main: {
    .label x = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    jmp __b1
    // [1] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  __b1_from___b1:
    // [1] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [2] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z x
    lda MAPDATA,y
    sta SCREEN,y
    // [3] *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz1) 
    ldx.z x
    ldy MAPDATA,x
    lda COLORMAP1,y
    sta COLS,x
    // [4] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z x
    lda MAPDATA+$c8,y
    sta SCREEN+$c8,y
    // [5] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz1) 
    ldx.z x
    ldy MAPDATA+$c8,x
    lda COLORMAP1,y
    sta COLS+$c8,x
    // [6] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z x
    lda MAPDATA+$190,y
    sta SCREEN+$190,y
    // [7] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz1) 
    ldx.z x
    ldy MAPDATA+$190,x
    lda COLORMAP1,y
    sta COLS+$190,x
    // [8] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z x
    lda MAPDATA+$258,y
    sta SCREEN+$258,y
    // [9] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz1) 
    ldx.z x
    ldy MAPDATA+$258,x
    lda COLORMAP2,y
    sta COLS+$258,x
    // [10] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z x
    lda MAPDATA+$320,y
    sta SCREEN+$320,y
    // [11] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz1) 
    ldx.z x
    ldy MAPDATA+$320,x
    lda COLORMAP2,y
    sta COLS+$320,x
    // [12] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [13] if((byte) main::x#1!=(byte) $c9) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$c9
    cmp.z x
    bne __b1_from___b1
    jmp __breturn
    // main::@return
  __breturn:
    // [14] return 
    rts
}
  // File Data
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [2] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::x#2 main::x#1 ]
Statement [3] *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [4] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [5] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [7] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [9] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [10] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [11] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [2] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [3] *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [4] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [5] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [7] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [9] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [10] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Statement [11] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)) [ main::x#2 ] (  [ main::x#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::x#2 main::x#1 ] : zp[1]:2 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 38.5: zp[1]:2 [ main::x#2 main::x#1 ] 
Uplift Scope [] 

Uplifting [main] best 1356 combination reg byte x [ main::x#2 main::x#1 ] 
Uplifting [] best 1356 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests that constant offset indexing into arrays is handled correctly
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [1] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  __b1_from___b1:
    // [1] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [2] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA,x
    sta SCREEN,x
    // [3] *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA,x
    lda COLORMAP1,y
    sta COLS,x
    // [4] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$c8,x
    sta SCREEN+$c8,x
    // [5] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$c8,x
    lda COLORMAP1,y
    sta COLS+$c8,x
    // [6] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$190,x
    sta SCREEN+$190,x
    // [7] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$190,x
    lda COLORMAP1,y
    sta COLS+$190,x
    // [8] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$258,x
    sta SCREEN+$258,x
    // [9] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$258,x
    lda COLORMAP2,y
    sta COLS+$258,x
    // [10] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$320,x
    sta SCREEN+$320,x
    // [11] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$320,x
    lda COLORMAP2,y
    sta COLS+$320,x
    // [12] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [13] if((byte) main::x#1!=(byte) $c9) goto main::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$c9
    bne __b1_from___b1
    jmp __breturn
    // main::@return
  __breturn:
    // [14] return 
    rts
}
  // File Data
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b1 with __b1
Removing instruction __b1_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
(const byte*) COLORMAP1[(number) $100]  = { fill( $100, 0) }
(const byte*) COLORMAP2[(number) $100]  = { fill( $100, 0) }
(const byte*) COLS = (byte*) 55296
(const byte*) MAPDATA[(number) $3e8]  = { fill( $3e8, 0) }
(const byte*) SCREEN = (byte*) 1024
(void()) main()
(label) main::@1
(label) main::@return
(byte) main::x
(byte) main::x#1 reg byte x 16.5
(byte) main::x#2 reg byte x 22.0

reg byte x [ main::x#2 main::x#1 ]


FINAL ASSEMBLER
Score: 1266

  // File Comments
// Tests that constant offset indexing into arrays is handled correctly
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  .label COLS = $d800
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi (byte) main::x#2 = (byte) 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [1] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
    // [1] phi (byte) main::x#2 = (byte) main::x#1 [phi:main::@1->main::@1#0] -- register_copy 
    // main::@1
  __b1:
    // SCREEN[x] = MAPDATA[x]
    // [2] *((const byte*) SCREEN + (byte) main::x#2) ← *((const byte*) MAPDATA + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA,x
    sta SCREEN,x
    // COLS[x] = COLORMAP1[MAPDATA[x]]
    // [3] *((const byte*) COLS + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA,x
    lda COLORMAP1,y
    sta COLS,x
    // SCREEN[200+x] = MAPDATA[200+x]
    // [4] *((const byte*) SCREEN+(byte) $c8 + (byte) main::x#2) ← *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$c8,x
    sta SCREEN+$c8,x
    // COLS[200+x] = COLORMAP1[MAPDATA[200+x]]
    // [5] *((const byte*) COLS+(byte) $c8 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(byte) $c8 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$c8,x
    lda COLORMAP1,y
    sta COLS+$c8,x
    // SCREEN[400+x] = MAPDATA[400+x]
    // [6] *((const byte*) SCREEN+(word) $190 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$190,x
    sta SCREEN+$190,x
    // COLS[400+x] = COLORMAP1[MAPDATA[400+x]]
    // [7] *((const byte*) COLS+(word) $190 + (byte) main::x#2) ← *((const byte*) COLORMAP1 + *((const byte*) MAPDATA+(word) $190 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$190,x
    lda COLORMAP1,y
    sta COLS+$190,x
    // SCREEN[600+x] = MAPDATA[600+x]
    // [8] *((const byte*) SCREEN+(word) $258 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$258,x
    sta SCREEN+$258,x
    // COLS[600+x] = COLORMAP2[MAPDATA[600+x]]
    // [9] *((const byte*) COLS+(word) $258 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $258 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$258,x
    lda COLORMAP2,y
    sta COLS+$258,x
    // SCREEN[800+x] = MAPDATA[800+x]
    // [10] *((const byte*) SCREEN+(word) $320 + (byte) main::x#2) ← *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MAPDATA+$320,x
    sta SCREEN+$320,x
    // COLS[800+x] = COLORMAP2[MAPDATA[800+x]]
    // [11] *((const byte*) COLS+(word) $320 + (byte) main::x#2) ← *((const byte*) COLORMAP2 + *((const byte*) MAPDATA+(word) $320 + (byte) main::x#2)) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_(pbuc3_derefidx_vbuxx) 
    ldy MAPDATA+$320,x
    lda COLORMAP2,y
    sta COLS+$320,x
    // for (byte x: 0..200)
    // [12] (byte) main::x#1 ← ++ (byte) main::x#2 -- vbuxx=_inc_vbuxx 
    inx
    // [13] if((byte) main::x#1!=(byte) $c9) goto main::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$c9
    bne __b1
    // main::@return
    // }
    // [14] return 
    rts
}
  // File Data
  MAPDATA: .fill $3e8, 0
  COLORMAP1: .fill $100, 0
  COLORMAP2: .fill $100, 0

