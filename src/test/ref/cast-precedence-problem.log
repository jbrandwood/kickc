Identified constant variable (byte*) main::SCREEN
Identified constant variable (byte) main::min
Identified constant variable (byte) main::max
Identified constant variable (byte*) main::BGCOL
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@4

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@1
main: scope:[main]  from @1
  (byte*) main::SCREEN#0 ← ((byte*)) (number) $400
  (byte) main::min#0 ← (number) $a
  (byte) main::max#0 ← (number) $c8
  (byte~) main::$0 ← (byte) main::min#0 + (byte) main::max#0
  (word) main::sumw#0 ← (byte~) main::$0
  (word~) main::$1 ← (word) main::sumw#0 >> (number) 1
  (byte~) main::$2 ← ((byte)) (word~) main::$1
  (number~) main::$3 ← (byte~) main::$2 + (number) 1
  (byte) main::midw#0 ← (number~) main::$3
  *((byte*) main::SCREEN#0 + (number) 0) ← (byte) main::midw#0
  (byte~) main::$4 ← (byte) main::min#0 + (byte) main::max#0
  (byte) main::sumb#0 ← (byte~) main::$4
  (byte~) main::$5 ← (byte) main::sumb#0 >> (number) 1
  (number~) main::$6 ← (byte~) main::$5 + (number) 1
  (byte) main::midb#0 ← (number~) main::$6
  *((byte*) main::SCREEN#0 + (number) 1) ← (byte) main::midb#0
  (byte*) main::BGCOL#0 ← ((byte*)) (number) $d021
  (bool~) main::$7 ← *((byte*) main::SCREEN#0 + (number) 0) == *((byte*) main::SCREEN#0 + (number) 1)
  if((bool~) main::$7) goto main::@1
  to:main::@3
main::@1: scope:[main]  from main
  *((byte*) main::BGCOL#0) ← (number) 5
  to:main::@return
main::@3: scope:[main]  from main
  *((byte*) main::BGCOL#0) ← (number) 2
  to:main::@return
main::@return: scope:[main]  from main::@1 main::@3
  return 
  to:@return
@1: scope:[]  from @begin
  call main 
  to:@2
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

SYMBOL TABLE SSA
(label) @1
(label) @2
(label) @begin
(label) @end
(void()) main()
(byte~) main::$0
(word~) main::$1
(byte~) main::$2
(number~) main::$3
(byte~) main::$4
(byte~) main::$5
(number~) main::$6
(bool~) main::$7
(label) main::@1
(label) main::@3
(label) main::@return
(byte*) main::BGCOL
(byte*) main::BGCOL#0
(byte*) main::SCREEN
(byte*) main::SCREEN#0
(byte) main::max
(byte) main::max#0
(byte) main::midb
(byte) main::midb#0
(byte) main::midw
(byte) main::midw#0
(byte) main::min
(byte) main::min#0
(byte) main::sumb
(byte) main::sumb#0
(word) main::sumw
(word) main::sumw#0

Adding number conversion cast (unumber) $a in (byte) main::min#0 ← (number) $a
Adding number conversion cast (unumber) $c8 in (byte) main::max#0 ← (number) $c8
Adding number conversion cast (unumber) 1 in (word~) main::$1 ← (word) main::sumw#0 >> (number) 1
Adding number conversion cast (unumber) 1 in (number~) main::$3 ← (byte~) main::$2 + (number) 1
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (byte~) main::$2 + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in *((byte*) main::SCREEN#0 + (number) 0) ← (byte) main::midw#0
Adding number conversion cast (unumber) 1 in (byte~) main::$5 ← (byte) main::sumb#0 >> (number) 1
Adding number conversion cast (unumber) 1 in (number~) main::$6 ← (byte~) main::$5 + (number) 1
Adding number conversion cast (unumber) main::$6 in (number~) main::$6 ← (byte~) main::$5 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in *((byte*) main::SCREEN#0 + (number) 1) ← (byte) main::midb#0
Adding number conversion cast (unumber) 0 in (bool~) main::$7 ← *((byte*) main::SCREEN#0 + (number) 0) == *((byte*) main::SCREEN#0 + (number) 1)
Adding number conversion cast (unumber) 1 in (bool~) main::$7 ← *((byte*) main::SCREEN#0 + (unumber)(number) 0) == *((byte*) main::SCREEN#0 + (number) 1)
Adding number conversion cast (unumber) 5 in *((byte*) main::BGCOL#0) ← (number) 5
Adding number conversion cast (unumber) 2 in *((byte*) main::BGCOL#0) ← (number) 2
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) main::SCREEN#0 ← (byte*)(number) $400
Inlining cast (byte) main::min#0 ← (unumber)(number) $a
Inlining cast (byte) main::max#0 ← (unumber)(number) $c8
Inlining cast (byte~) main::$2 ← (byte)(word~) main::$1
Inlining cast (byte*) main::BGCOL#0 ← (byte*)(number) $d021
Inlining cast *((byte*) main::BGCOL#0) ← (unumber)(number) 5
Inlining cast *((byte*) main::BGCOL#0) ← (unumber)(number) 2
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $a
Simplifying constant integer cast $c8
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant pointer cast (byte*) 53281
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 5
Simplifying constant integer cast 2
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $c8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) 2
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$3 ← (byte~) main::$2 + (byte) 1
Inferred type updated to byte in (unumber~) main::$6 ← (byte~) main::$5 + (byte) 1
Alias (word) main::sumw#0 = (byte~) main::$0 
Alias (byte) main::midw#0 = (byte~) main::$3 
Alias (byte) main::sumb#0 = (byte~) main::$4 
Alias (byte) main::midb#0 = (byte~) main::$6 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) main::$7 [18] if(*((byte*) main::SCREEN#0 + (byte) 0)==*((byte*) main::SCREEN#0 + (byte) 1)) goto main::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) main::SCREEN#0 = (byte*) 1024
Constant (const byte) main::min#0 = $a
Constant (const byte) main::max#0 = $c8
Constant (const byte*) main::BGCOL#0 = (byte*) 53281
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero main::SCREEN#0 in [9] *((const byte*) main::SCREEN#0 + (byte) 0) ← (byte) main::midw#0
Simplifying expression containing zero main::SCREEN#0 in [18] if(*((const byte*) main::SCREEN#0 + (byte) 0)==*((const byte*) main::SCREEN#0 + (byte) 1)) goto main::@1
Successful SSA optimization PassNSimplifyExpressionWithZero
Constant right-side identified [0] (word) main::sumw#0 ← (const byte) main::min#0 + (const byte) main::max#0
Constant right-side identified [5] (byte) main::sumb#0 ← (const byte) main::min#0 + (const byte) main::max#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::sumw#0 = main::min#0+main::max#0
Constant (const byte) main::sumb#0 = main::min#0+main::max#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [0] (word~) main::$1 ← (const word) main::sumw#0 >> (byte) 1
Constant right-side identified [4] (byte~) main::$5 ← (const byte) main::sumb#0 >> (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::$1 = main::sumw#0>>1
Constant (const byte) main::$5 = main::sumb#0>>1
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)main::$1 in [1] (byte~) main::$2 ← (byte)(const word) main::$1
Successful SSA optimization Pass2ConstantValues
Constant right-side identified [3] (byte) main::midb#0 ← (const byte) main::$5 + (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::$2 = (byte)main::$1
Constant (const byte) main::midb#0 = main::$5+1
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [0] (byte) main::midw#0 ← (const byte) main::$2 + (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) main::midw#0 = main::$2+1
Successful SSA optimization Pass2ConstantIdentification
Constant inlined main::$5 = (const byte) main::sumb#0>>(byte) 1
Constant inlined main::$1 = (const word) main::sumw#0>>(byte) 1
Constant inlined main::$2 = (byte)(const word) main::sumw#0>>(byte) 1
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(main::SCREEN#0+1)
Consolidated array index constant in *(main::SCREEN#0+1)
Successful SSA optimization Pass2ConstantAdditionElimination
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
CALL GRAPH
Calls in [] to main:2 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) @2
Renumbering block main::@3 to main::@2
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] *((const byte*) main::SCREEN#0) ← (const byte) main::midw#0
  [5] *((const byte*) main::SCREEN#0+(byte) 1) ← (const byte) main::midb#0
  [6] if(*((const byte*) main::SCREEN#0)==*((const byte*) main::SCREEN#0+(byte) 1)) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main
  [7] *((const byte*) main::BGCOL#0) ← (byte) 2
  to:main::@return
main::@return: scope:[main]  from main::@1 main::@2
  [8] return 
  to:@return
main::@1: scope:[main]  from main
  [9] *((const byte*) main::BGCOL#0) ← (byte) 5
  to:main::@return


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte*) main::BGCOL
(byte*) main::SCREEN
(byte) main::max
(byte) main::midb
(byte) main::midw
(byte) main::min
(byte) main::sumb
(word) main::sumw

Initial phi equivalence classes
Complete equivalence classes

INITIAL ASM
Target platform is c64basic
  // File Comments
// Tests that casting inside constants in the output handles precedence between cast and + correctly - should generate the following KA-expression ($ff & sumw>>1)+1
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label SCREEN = $400
    .const min = $a
    .const max = $c8
    .label BGCOL = $d021
    .const sumw = min+max
    .const sumb = min+max
    .const midb = (sumb>>1)+1
    .const midw = (sumw>>1)+1
    // [4] *((const byte*) main::SCREEN#0) ← (const byte) main::midw#0 -- _deref_pbuc1=vbuc2 
    lda #midw
    sta SCREEN
    // [5] *((const byte*) main::SCREEN#0+(byte) 1) ← (const byte) main::midb#0 -- _deref_pbuc1=vbuc2 
    lda #midb
    sta SCREEN+1
    // [6] if(*((const byte*) main::SCREEN#0)==*((const byte*) main::SCREEN#0+(byte) 1)) goto main::@1 -- _deref_pbuc1_eq__deref_pbuc2_then_la1 
    lda SCREEN
    cmp SCREEN+1
    beq b1
    jmp b2
    // main::@2
  b2:
    // [7] *((const byte*) main::BGCOL#0) ← (byte) 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta BGCOL
    jmp breturn
    // main::@return
  breturn:
    // [8] return 
    rts
    // main::@1
  b1:
    // [9] *((const byte*) main::BGCOL#0) ← (byte) 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta BGCOL
    jmp breturn
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [4] *((const byte*) main::SCREEN#0) ← (const byte) main::midw#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [5] *((const byte*) main::SCREEN#0+(byte) 1) ← (const byte) main::midb#0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [6] if(*((const byte*) main::SCREEN#0)==*((const byte*) main::SCREEN#0+(byte) 1)) goto main::@1 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [7] *((const byte*) main::BGCOL#0) ← (byte) 2 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] *((const byte*) main::BGCOL#0) ← (byte) 5 [ ] ( main:2 [ ] ) always clobbers reg byte a 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [main] best 61 combination 
Uplifting [] best 61 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Tests that casting inside constants in the output handles precedence between cast and + correctly - should generate the following KA-expression ($ff & sumw>>1)+1
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label SCREEN = $400
    .const min = $a
    .const max = $c8
    .label BGCOL = $d021
    .const sumw = min+max
    .const sumb = min+max
    .const midb = (sumb>>1)+1
    .const midw = (sumw>>1)+1
    // [4] *((const byte*) main::SCREEN#0) ← (const byte) main::midw#0 -- _deref_pbuc1=vbuc2 
    lda #midw
    sta SCREEN
    // [5] *((const byte*) main::SCREEN#0+(byte) 1) ← (const byte) main::midb#0 -- _deref_pbuc1=vbuc2 
    lda #midb
    sta SCREEN+1
    // [6] if(*((const byte*) main::SCREEN#0)==*((const byte*) main::SCREEN#0+(byte) 1)) goto main::@1 -- _deref_pbuc1_eq__deref_pbuc2_then_la1 
    lda SCREEN
    cmp SCREEN+1
    beq b1
    jmp b2
    // main::@2
  b2:
    // [7] *((const byte*) main::BGCOL#0) ← (byte) 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta BGCOL
    jmp breturn
    // main::@return
  breturn:
    // [8] return 
    rts
    // main::@1
  b1:
    // [9] *((const byte*) main::BGCOL#0) ← (byte) 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta BGCOL
    jmp breturn
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b2
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction bend_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp breturn
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction bbegin:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::BGCOL
(const byte*) main::BGCOL#0 BGCOL = (byte*) 53281
(byte*) main::SCREEN
(const byte*) main::SCREEN#0 SCREEN = (byte*) 1024
(byte) main::max
(const byte) main::max#0 max = (byte) $c8
(byte) main::midb
(const byte) main::midb#0 midb = (const byte) main::sumb#0>>(byte) 1+(byte) 1
(byte) main::midw
(const byte) main::midw#0 midw = (byte)(const word) main::sumw#0>>(byte) 1+(byte) 1
(byte) main::min
(const byte) main::min#0 min = (byte) $a
(byte) main::sumb
(const byte) main::sumb#0 sumb = (const byte) main::min#0+(const byte) main::max#0
(word) main::sumw
(const word) main::sumw#0 sumw = (const byte) main::min#0+(const byte) main::max#0



FINAL ASSEMBLER
Score: 46

  // File Comments
// Tests that casting inside constants in the output handles precedence between cast and + correctly - should generate the following KA-expression ($ff & sumw>>1)+1
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label SCREEN = $400
    .const min = $a
    .const max = $c8
    .label BGCOL = $d021
    .const sumw = min+max
    .const sumb = min+max
    .const midb = (sumb>>1)+1
    .const midw = (sumw>>1)+1
    // SCREEN[0] = midw
    // [4] *((const byte*) main::SCREEN#0) ← (const byte) main::midw#0 -- _deref_pbuc1=vbuc2 
    lda #midw
    sta SCREEN
    // SCREEN[1] = midb
    // [5] *((const byte*) main::SCREEN#0+(byte) 1) ← (const byte) main::midb#0 -- _deref_pbuc1=vbuc2 
    lda #midb
    sta SCREEN+1
    // if(SCREEN[0]==SCREEN[1])
    // [6] if(*((const byte*) main::SCREEN#0)==*((const byte*) main::SCREEN#0+(byte) 1)) goto main::@1 -- _deref_pbuc1_eq__deref_pbuc2_then_la1 
    lda SCREEN
    cmp SCREEN+1
    beq b1
    // main::@2
    // *BGCOL = 2
    // [7] *((const byte*) main::BGCOL#0) ← (byte) 2 -- _deref_pbuc1=vbuc2 
    lda #2
    sta BGCOL
    // main::@return
    // }
    // [8] return 
    rts
    // main::@1
  b1:
    // *BGCOL = 5
    // [9] *((const byte*) main::BGCOL#0) ← (byte) 5 -- _deref_pbuc1=vbuc2 
    lda #5
    sta BGCOL
    rts
}
  // File Data

