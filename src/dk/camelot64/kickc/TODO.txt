Features
- Move the main code into a main() function, and disallow code outside functions. The main function per default has no parameters and exits with RTS.
- Add a for loop for(init;condition;increment) {stmt} -> { init; do { stmt; increment } while (condition) }
- Implement Register Allocation (that utilize real registers - and non-zeropage memory)
- Add Fixed Point number types
- Add imports
- Add structs
- Let { stmt } introduce a new anonymous scope.
- Add preprocessing / find a way to allow some functions to run at compile time
- Implement inline compilation of functions (and a mechanism for choosing which methods / calls to inline)
- Add ability to call ASM code from KC.
- Add ability to call KC code from ASM. (Maybe declare some functions external to ensure their interface is well defined. Maybe generate ASM call stubs.)
- Add inline ASM (maybe?)
- Handle long branches
+ Create a proper main function for the compiler
+ Add ++/-- incrementing/decrementing operators.

Process/Code Structure Improvement
- Make each phase return a separate object graph (allowing for keeeping the history in memory & performing rollbacks)
- Refactor Expression Operator Implementation & Evaluation into one class per operator
- Improve error messages to give better context
- Offer to compile resulting ASM with KickAssembler
+ Implemenent Assertions for the output of different phases (ensuring that the result of the phase is consistent)

Testing
- Test that the parse tree for specific KC syntax is as expected. Use a print function for the parse tree to generate output for comparison.
- Test the ICL result of a specific phase on a specific ICL input. Create an ICL syntax for parsing directly to ICL and a printer for the syntax.
- Emulate/Run the ASM for a specific KC program compiled. Compare the emulated ASM output to output calculated by executing directly on the KC tree.
- Add assert statements to the language. Create KC programs that test the compiler by compiling, running and testing assertions.
+ Test the ASM program output resulting from compiling specific KC program input.

Optimizations
- Optimize phi transitions by ensuring that identical phi-transitions with regards to register allocation are collected into a single transition.
- Optimize register allocation by combining with knowledge of ASM program cost (bytes/cycles) and different ASM fragments with different clobbering.
- Optimize by finding optimal sequence for multiple phi assignments in entry-segments.
- Optimize by allowing resequencing of statements and phi assignemtns in a final phase. Perhaps by converting phi statements to "normal" statements and using some optimization step.

Usages
- Implement library for memory allocation in main memory
- Implement library for output on the screen (using basic functions)

Real Usage
- Implement library for fast multiply (mul.asm)
- Implement spline library (spline.asm)
- Implement polygon filler for complex polygons.
- Implement a true type font renderer.