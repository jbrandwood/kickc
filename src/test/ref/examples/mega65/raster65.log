Resolved forward reference SCROLL_TEXT to (const byte*) SCROLL_TEXT
Resolved forward reference MEGA_LOGO to (const byte*) MEGA_LOGO
Resolved forward reference MEGA_LOGO to (const byte*) MEGA_LOGO
Resolved forward reference PAL_RED to (const byte*) PAL_RED
Resolved forward reference PAL_GREEN to (const byte*) PAL_GREEN
Resolved forward reference PAL_BLUE to (const byte*) PAL_BLUE
Resolved forward reference irq to interrupt(HARDWARE_STACK)(void()) irq()
Resolved forward reference GREET_COUNT to (const nomodify byte) GREET_COUNT
Resolved forward reference PAL_GREEN to (const byte*) PAL_GREEN
Resolved forward reference GREETING to (const byte*) GREETING
Resolved forward reference SCROLL_TEXT to (const byte*) SCROLL_TEXT
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call __init 

CONTROL FLOW GRAPH SSA

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main
  (byte) memset::c#4 ← phi( main/(byte) memset::c#0 )
  (void*) memset::str#3 ← phi( main/(void*) memset::str#0 )
  (word) memset::num#1 ← phi( main/(word) memset::num#0 )
  (bool~) memset::$0 ← (word) memset::num#1 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  (void*) memset::str#1 ← phi( memset/(void*) memset::str#3 memset::@3/(void*) memset::str#4 )
  (void*) memset::return#0 ← (void*) memset::str#1
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#3 ← phi( memset/(byte) memset::c#4 )
  (word) memset::num#2 ← phi( memset/(word) memset::num#1 )
  (void*) memset::str#2 ← phi( memset/(void*) memset::str#3 )
  (byte*~) memset::$4 ← (byte*)(void*) memset::str#2
  (byte*~) memset::$2 ← (byte*~) memset::$4 + (word) memset::num#2
  (byte*) memset::end#0 ← (byte*~) memset::$2
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#2
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  (byte) memset::c#2 ← phi( memset::@2/(byte) memset::c#3 memset::@4/(byte) memset::c#1 )
  (void*) memset::str#4 ← phi( memset::@2/(void*) memset::str#2 memset::@4/(void*) memset::str#5 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@4/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@4/(byte*) memset::dst#1 )
  (bool~) memset::$3 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  (void*) memset::str#5 ← phi( memset::@3/(void*) memset::str#4 )
  (byte*) memset::end#2 ← phi( memset::@3/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@3/(byte*) memset::dst#2 )
  (byte) memset::c#1 ← phi( memset::@3/(byte) memset::c#2 )
  *((byte*) memset::dst#3) ← (byte) memset::c#1
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#3 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#3
  return 
  to:@return

(void()) main()
main: scope:[main]  from __start::@1
  *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (number) $47
  *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (number) $53
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (number) $40
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (number) $40
  asm { lda#0  }
  call *((const void()*) songInit) 
  (void*) memset::str#0 ← (void*)(const nomodify byte*) SCREEN
  (byte) memset::c#0 ← (byte) ' '
  (word) memset::num#0 ← (number) $28*(number) $19
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:main::@10
main::@10: scope:[main]  from main
  (byte) main::i1#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main::@10 main::@2
  (byte) main::i1#2 ← phi( main::@10/(byte) main::i1#0 main::@2/(byte) main::i1#1 )
  (byte~) main::$2 ← sizeof  (const byte*) MEGA_LOGO
  (bool~) main::$3 ← (byte) main::i1#2 < (byte~) main::$2
  if((bool~) main::$3) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte) main::i1#3 ← phi( main::@1/(byte) main::i1#2 )
  *((const nomodify byte*) SCREEN+(const nomodify byte) LOGO_ROW*(number) $28 + (byte) main::i1#3) ← *((const byte*) MEGA_LOGO + (byte) main::i1#3)
  (byte) main::i1#1 ← ++ (byte) main::i1#3
  to:main::@1
main::@3: scope:[main]  from main::@1
  (byte) main::i2#0 ← (byte) 0
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@5
  (byte) main::i2#2 ← phi( main::@3/(byte) main::i2#0 main::@5/(byte) main::i2#1 )
  (bool~) main::$4 ← (byte) main::i2#2 < (number) $28
  if((bool~) main::$4) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  (byte) main::i2#3 ← phi( main::@4/(byte) main::i2#2 )
  *((const nomodify byte*) SCREEN+(const nomodify byte) GREET_ROW*(number) $28 + (byte) main::i2#3) ← (byte) '*'
  (byte) main::i2#1 ← ++ (byte) main::i2#3
  to:main::@4
main::@6: scope:[main]  from main::@4
  (byte) main::i#0 ← (byte) 0
  to:main::@7
main::@7: scope:[main]  from main::@6 main::@7
  (byte) main::i#2 ← phi( main::@6/(byte) main::i#0 main::@7/(byte) main::i#1 )
  *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2)
  *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2)
  *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2)
  (byte) main::i#1 ← ++ (byte) main::i#2
  (bool~) main::$5 ← (byte) main::i#1 != (number) 0
  if((bool~) main::$5) goto main::@7
  to:main::@8
main::@8: scope:[main]  from main::@7
  asm { sei  }
  *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (number) $7f
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq()
  *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK
  *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (number) 1
  asm { cli  }
  to:main::@9
main::@9: scope:[main]  from main::@8 main::@9
  to:main::@9
main::@return: scope:[main]  from
  return 
  to:@return

interrupt(HARDWARE_STACK)(void()) irq()
irq: scope:[irq]  from
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (number) $80
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (number) 0
  (volatile byte) sin_idx ← ++ (volatile byte) sin_idx
  (byte) irq::wobble_idx#0 ← (volatile byte) sin_idx
  (byte) irq::line#0 ← (byte) 0
  to:irq::@1
irq::@1: scope:[irq]  from irq irq::@9
  (byte) irq::wobble_idx#4 ← phi( irq/(byte) irq::wobble_idx#0 irq::@9/(byte) irq::wobble_idx#5 )
  (byte) irq::line#2 ← phi( irq/(byte) irq::line#0 irq::@9/(byte) irq::line#1 )
  (bool~) irq::$4 ← (byte) irq::line#2 != (const nomodify byte) RASTER_LINES
  if((bool~) irq::$4) goto irq::@2
  to:irq::@3
irq::@2: scope:[irq]  from irq::@1
  (byte) irq::wobble_idx#3 ← phi( irq::@1/(byte) irq::wobble_idx#4 )
  (byte) irq::line#3 ← phi( irq::@1/(byte) irq::line#2 )
  (byte) irq::col#0 ← *((const byte*) rasters + (byte) irq::line#3)
  *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR) ← (byte) irq::col#0
  *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR) ← (byte) irq::col#0
  (bool~) irq::$5 ← (byte) irq::line#3 < (const nomodify byte) SCROLL_Y
  if((bool~) irq::$5) goto irq::@4
  to:irq::@10
irq::@3: scope:[irq]  from irq::@1
  call *((const void()*) songPlay) 
  (byte) irq::sin_col#0 ← (volatile byte) sin_idx
  (byte) irq::i#0 ← (byte) 0
  to:irq::@16
irq::@4: scope:[irq]  from irq::@2
  (byte) irq::line#13 ← phi( irq::@2/(byte) irq::line#3 )
  (byte) irq::wobble_idx#2 ← phi( irq::@2/(byte) irq::wobble_idx#3 )
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#2)
  (byte) irq::wobble_idx#1 ← ++ (byte) irq::wobble_idx#2
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (number) $66
  to:irq::@7
irq::@10: scope:[irq]  from irq::@2
  (byte) irq::wobble_idx#14 ← phi( irq::@2/(byte) irq::wobble_idx#3 )
  (byte) irq::line#4 ← phi( irq::@2/(byte) irq::line#3 )
  (bool~) irq::$6 ← (byte) irq::line#4 == (const nomodify byte) SCROLL_Y
  if((bool~) irq::$6) goto irq::@5
  to:irq::@11
irq::@5: scope:[irq]  from irq::@10
  (byte) irq::wobble_idx#12 ← phi( irq::@10/(byte) irq::wobble_idx#14 )
  (byte) irq::line#14 ← phi( irq::@10/(byte) irq::line#4 )
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (number) $50
  *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft
  to:irq::@7
irq::@11: scope:[irq]  from irq::@10
  (byte) irq::wobble_idx#15 ← phi( irq::@10/(byte) irq::wobble_idx#14 )
  (byte) irq::line#5 ← phi( irq::@10/(byte) irq::line#4 )
  (bool~) irq::$7 ← (byte) irq::line#5 == (const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS
  if((bool~) irq::$7) goto irq::@6
  to:irq::@12
irq::@6: scope:[irq]  from irq::@11
  (byte) irq::wobble_idx#13 ← phi( irq::@11/(byte) irq::wobble_idx#15 )
  (byte) irq::line#15 ← phi( irq::@11/(byte) irq::line#5 )
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (number) $50
  to:irq::@7
irq::@12: scope:[irq]  from irq::@11
  (byte) irq::wobble_idx#8 ← phi( irq::@11/(byte) irq::wobble_idx#15 )
  (byte) irq::line#6 ← phi( irq::@11/(byte) irq::line#5 )
  (bool~) irq::$8 ← (byte) irq::line#6 == (const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(number) 1
  (bool~) irq::$9 ← ! (bool~) irq::$8
  if((bool~) irq::$9) goto irq::@7
  to:irq::@13
irq::@13: scope:[irq]  from irq::@12
  (byte) irq::wobble_idx#9 ← phi( irq::@12/(byte) irq::wobble_idx#8 )
  (byte) irq::line#10 ← phi( irq::@12/(byte) irq::line#6 )
  (byte) irq::zoomval#0 ← *((const byte*) SINUS + (volatile byte) greet_zoomx)
  (volatile byte) greet_zoomx ← ++ (volatile byte) greet_zoomx
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) irq::zoomval#0
  (number~) irq::$10 ← (byte) irq::zoomval#0 + (number) 1
  *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (number~) irq::$10
  (bool~) irq::$11 ← (volatile byte) greet_zoomx == (number) 0
  (bool~) irq::$12 ← ! (bool~) irq::$11
  if((bool~) irq::$12) goto irq::@7
  to:irq::@14
irq::@14: scope:[irq]  from irq::@13
  (byte) irq::wobble_idx#10 ← phi( irq::@13/(byte) irq::wobble_idx#9 )
  (byte) irq::line#11 ← phi( irq::@13/(byte) irq::line#10 )
  (volatile byte) greet_idx ← ++ (volatile byte) greet_idx
  (bool~) irq::$13 ← (volatile byte) greet_idx == (const nomodify byte) GREET_COUNT
  (bool~) irq::$14 ← ! (bool~) irq::$13
  if((bool~) irq::$14) goto irq::@7
  to:irq::@15
irq::@15: scope:[irq]  from irq::@14
  (byte) irq::wobble_idx#11 ← phi( irq::@14/(byte) irq::wobble_idx#10 )
  (byte) irq::line#12 ← phi( irq::@14/(byte) irq::line#11 )
  (volatile byte) greet_idx ← (number) 0
  to:irq::@7
irq::@7: scope:[irq]  from irq::@12 irq::@13 irq::@14 irq::@15 irq::@4 irq::@5 irq::@6
  (byte) irq::wobble_idx#7 ← phi( irq::@12/(byte) irq::wobble_idx#8 irq::@13/(byte) irq::wobble_idx#9 irq::@14/(byte) irq::wobble_idx#10 irq::@15/(byte) irq::wobble_idx#11 irq::@4/(byte) irq::wobble_idx#1 irq::@5/(byte) irq::wobble_idx#12 irq::@6/(byte) irq::wobble_idx#13 )
  (byte) irq::line#9 ← phi( irq::@12/(byte) irq::line#6 irq::@13/(byte) irq::line#10 irq::@14/(byte) irq::line#11 irq::@15/(byte) irq::line#12 irq::@4/(byte) irq::line#13 irq::@5/(byte) irq::line#14 irq::@6/(byte) irq::line#15 )
  (byte) irq::raster#0 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq::@8
irq::@8: scope:[irq]  from irq::@7 irq::@8
  (byte) irq::wobble_idx#6 ← phi( irq::@7/(byte) irq::wobble_idx#7 irq::@8/(byte) irq::wobble_idx#6 )
  (byte) irq::line#8 ← phi( irq::@7/(byte) irq::line#9 irq::@8/(byte) irq::line#8 )
  (byte) irq::raster#1 ← phi( irq::@7/(byte) irq::raster#0 irq::@8/(byte) irq::raster#1 )
  (bool~) irq::$15 ← (byte) irq::raster#1 == *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)
  if((bool~) irq::$15) goto irq::@8
  to:irq::@9
irq::@9: scope:[irq]  from irq::@8
  (byte) irq::wobble_idx#5 ← phi( irq::@8/(byte) irq::wobble_idx#6 )
  (byte) irq::line#7 ← phi( irq::@8/(byte) irq::line#8 )
  (byte) irq::line#1 ← ++ (byte) irq::line#7
  to:irq::@1
irq::@16: scope:[irq]  from irq::@17 irq::@3
  (byte) irq::sin_col#3 ← phi( irq::@17/(byte) irq::sin_col#1 irq::@3/(byte) irq::sin_col#0 )
  (byte) irq::i#2 ← phi( irq::@17/(byte) irq::i#1 irq::@3/(byte) irq::i#0 )
  (bool~) irq::$16 ← (byte) irq::i#2 < (number) $28
  if((bool~) irq::$16) goto irq::@17
  to:irq::@18
irq::@17: scope:[irq]  from irq::@16
  (byte) irq::i#3 ← phi( irq::@16/(byte) irq::i#2 )
  (byte) irq::sin_col#2 ← phi( irq::@16/(byte) irq::sin_col#3 )
  (number~) irq::$17 ← *((const byte*) SINUS + (byte) irq::sin_col#2) / (number) 4
  (byte) irq::col1#0 ← (number~) irq::$17
  *((const nomodify byte*) COLORRAM+(const nomodify byte) GREET_ROW*(number) $28 + (byte) irq::i#3) ← (byte) irq::col1#0
  (byte) irq::col1#1 ← (byte) irq::col1#0 / (number) 2
  *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 0*(number) $28-(number) 1 + (byte) irq::i#3) ← (byte) irq::col1#1
  *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 1*(number) $28-(number) 2 + (byte) irq::i#3) ← (byte) irq::col1#1
  *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 2*(number) $28-(number) 3 + (byte) irq::i#3) ← (byte) irq::col1#1
  *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 3*(number) $28-(number) 4 + (byte) irq::i#3) ← (byte) irq::col1#1
  *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 4*(number) $28-(number) 5 + (byte) irq::i#3) ← (byte) irq::col1#1
  *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 5*(number) $28-(number) 6 + (byte) irq::i#3) ← (byte) irq::col1#1
  *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i#3) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2)
  (byte) irq::sin_col#1 ← ++ (byte) irq::sin_col#2
  (byte) irq::i#1 ← ++ (byte) irq::i#3
  to:irq::@16
irq::@18: scope:[irq]  from irq::@16
  (byte) irq::l#0 ← (byte) 0
  to:irq::@19
irq::@19: scope:[irq]  from irq::@18 irq::@20
  (byte) irq::l#2 ← phi( irq::@18/(byte) irq::l#0 irq::@20/(byte) irq::l#1 )
  (bool~) irq::$18 ← (byte) irq::l#2 != (const nomodify byte) RASTER_LINES
  if((bool~) irq::$18) goto irq::@20
  to:irq::@21
irq::@20: scope:[irq]  from irq::@19
  (byte) irq::l#3 ← phi( irq::@19/(byte) irq::l#2 )
  *((const byte*) rasters + (byte) irq::l#3) ← (number) 0
  (byte) irq::l#1 ← ++ (byte) irq::l#3
  to:irq::@19
irq::@21: scope:[irq]  from irq::@19
  (byte) irq::sin_bar#0 ← (volatile byte) sin_idx
  (byte) irq::barcnt#0 ← (byte) 0
  to:irq::@22
irq::@22: scope:[irq]  from irq::@21 irq::@30
  (byte) irq::sin_bar#4 ← phi( irq::@21/(byte) irq::sin_bar#0 irq::@30/(byte) irq::sin_bar#1 )
  (byte) irq::barcnt#2 ← phi( irq::@21/(byte) irq::barcnt#0 irq::@30/(byte) irq::barcnt#1 )
  (bool~) irq::$19 ← (byte) irq::barcnt#2 < (number) $10
  if((bool~) irq::$19) goto irq::@23
  to:irq::@24
irq::@23: scope:[irq]  from irq::@22
  (byte) irq::barcnt#3 ← phi( irq::@22/(byte) irq::barcnt#2 )
  (byte) irq::sin_bar#2 ← phi( irq::@22/(byte) irq::sin_bar#4 )
  (byte) irq::idx#0 ← *((const byte*) SINUS + (byte) irq::sin_bar#2)
  (number~) irq::$20 ← (byte) irq::barcnt#3 * (number) $10
  (byte) irq::barcol#0 ← (number~) irq::$20
  (byte) irq::i1#0 ← (byte) 0
  to:irq::@25
irq::@24: scope:[irq]  from irq::@22
  (byte) irq::i3#0 ← (byte) 0
  to:irq::@31
irq::@25: scope:[irq]  from irq::@23 irq::@26
  (byte) irq::barcnt#8 ← phi( irq::@23/(byte) irq::barcnt#3 irq::@26/(byte) irq::barcnt#9 )
  (byte) irq::sin_bar#8 ← phi( irq::@23/(byte) irq::sin_bar#2 irq::@26/(byte) irq::sin_bar#9 )
  (byte) irq::idx#5 ← phi( irq::@23/(byte) irq::idx#0 irq::@26/(byte) irq::idx#1 )
  (byte) irq::barcol#5 ← phi( irq::@23/(byte) irq::barcol#0 irq::@26/(byte) irq::barcol#1 )
  (byte) irq::i1#2 ← phi( irq::@23/(byte) irq::i1#0 irq::@26/(byte) irq::i1#1 )
  (bool~) irq::$21 ← (byte) irq::i1#2 < (number) $10
  if((bool~) irq::$21) goto irq::@26
  to:irq::@27
irq::@26: scope:[irq]  from irq::@25
  (byte) irq::barcnt#9 ← phi( irq::@25/(byte) irq::barcnt#8 )
  (byte) irq::sin_bar#9 ← phi( irq::@25/(byte) irq::sin_bar#8 )
  (byte) irq::i1#3 ← phi( irq::@25/(byte) irq::i1#2 )
  (byte) irq::idx#3 ← phi( irq::@25/(byte) irq::idx#5 )
  (byte) irq::barcol#3 ← phi( irq::@25/(byte) irq::barcol#5 )
  *((const byte*) rasters + (byte) irq::idx#3) ← (byte) irq::barcol#3
  (byte) irq::idx#1 ← ++ (byte) irq::idx#3
  (byte) irq::barcol#1 ← ++ (byte) irq::barcol#3
  (byte) irq::i1#1 ← ++ (byte) irq::i1#3
  to:irq::@25
irq::@27: scope:[irq]  from irq::@25
  (byte) irq::barcnt#6 ← phi( irq::@25/(byte) irq::barcnt#8 )
  (byte) irq::sin_bar#6 ← phi( irq::@25/(byte) irq::sin_bar#8 )
  (byte) irq::idx#7 ← phi( irq::@25/(byte) irq::idx#5 )
  (byte) irq::barcol#7 ← phi( irq::@25/(byte) irq::barcol#5 )
  (byte) irq::i2#0 ← (byte) 0
  to:irq::@28
irq::@28: scope:[irq]  from irq::@27 irq::@29
  (byte) irq::barcnt#5 ← phi( irq::@27/(byte) irq::barcnt#6 irq::@29/(byte) irq::barcnt#7 )
  (byte) irq::sin_bar#5 ← phi( irq::@27/(byte) irq::sin_bar#6 irq::@29/(byte) irq::sin_bar#7 )
  (byte) irq::idx#6 ← phi( irq::@27/(byte) irq::idx#7 irq::@29/(byte) irq::idx#2 )
  (byte) irq::barcol#6 ← phi( irq::@27/(byte) irq::barcol#7 irq::@29/(byte) irq::barcol#2 )
  (byte) irq::i2#2 ← phi( irq::@27/(byte) irq::i2#0 irq::@29/(byte) irq::i2#1 )
  (bool~) irq::$22 ← (byte) irq::i2#2 < (number) $f
  if((bool~) irq::$22) goto irq::@29
  to:irq::@30
irq::@29: scope:[irq]  from irq::@28
  (byte) irq::barcnt#7 ← phi( irq::@28/(byte) irq::barcnt#5 )
  (byte) irq::sin_bar#7 ← phi( irq::@28/(byte) irq::sin_bar#5 )
  (byte) irq::i2#3 ← phi( irq::@28/(byte) irq::i2#2 )
  (byte) irq::idx#4 ← phi( irq::@28/(byte) irq::idx#6 )
  (byte) irq::barcol#4 ← phi( irq::@28/(byte) irq::barcol#6 )
  (byte) irq::barcol#2 ← -- (byte) irq::barcol#4
  *((const byte*) rasters + (byte) irq::idx#4) ← (byte) irq::barcol#2
  (byte) irq::idx#2 ← ++ (byte) irq::idx#4
  (byte) irq::i2#1 ← ++ (byte) irq::i2#3
  to:irq::@28
irq::@30: scope:[irq]  from irq::@28
  (byte) irq::barcnt#4 ← phi( irq::@28/(byte) irq::barcnt#5 )
  (byte) irq::sin_bar#3 ← phi( irq::@28/(byte) irq::sin_bar#5 )
  (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#3 + (number) $a
  (byte) irq::barcnt#1 ← ++ (byte) irq::barcnt#4
  to:irq::@22
irq::@31: scope:[irq]  from irq::@24 irq::@32
  (byte) irq::i3#2 ← phi( irq::@24/(byte) irq::i3#0 irq::@32/(byte) irq::i3#1 )
  (bool~) irq::$23 ← (byte) irq::i3#2 < (number) $13
  if((bool~) irq::$23) goto irq::@32
  to:irq::@33
irq::@32: scope:[irq]  from irq::@31
  (byte) irq::i3#3 ← phi( irq::@31/(byte) irq::i3#2 )
  (byte~) irq::$24 ← (const nomodify byte) SCROLL_Y + (byte) irq::i3#3
  (byte~) irq::$25 ← (const nomodify byte) SCROLL_Y + (byte) irq::i3#3
  (number~) irq::$26 ← *((const byte*) rasters + (byte~) irq::$25) / (number) 2
  (number~) irq::$27 ← (number~) irq::$26 & (number) 7
  *((const byte*) rasters + (byte~) irq::$24) ← (number~) irq::$27
  (byte) irq::i3#1 ← ++ (byte) irq::i3#3
  to:irq::@31
irq::@33: scope:[irq]  from irq::@31
  (number~) irq::$1 ← (volatile byte) greet_idx * (number) $10
  (byte) irq::greet_offset#0 ← (number~) irq::$1
  (byte) irq::i4#0 ← (byte) 0
  to:irq::@34
irq::@34: scope:[irq]  from irq::@33 irq::@35
  (byte) irq::greet_offset#3 ← phi( irq::@33/(byte) irq::greet_offset#0 irq::@35/(byte) irq::greet_offset#1 )
  (byte) irq::i4#2 ← phi( irq::@33/(byte) irq::i4#0 irq::@35/(byte) irq::i4#1 )
  (bool~) irq::$28 ← (byte) irq::i4#2 < (number) $10
  if((bool~) irq::$28) goto irq::@35
  to:irq::@36
irq::@35: scope:[irq]  from irq::@34
  (byte) irq::i4#3 ← phi( irq::@34/(byte) irq::i4#2 )
  (byte) irq::greet_offset#2 ← phi( irq::@34/(byte) irq::greet_offset#3 )
  (number~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (number) $bf
  *((const nomodify byte*) SCREEN+(const nomodify byte) GREET_ROW*(number) $28+(number) $d + (byte) irq::i4#3) ← (number~) irq::$29
  (byte) irq::greet_offset#1 ← ++ (byte) irq::greet_offset#2
  (byte) irq::i4#1 ← ++ (byte) irq::i4#3
  to:irq::@34
irq::@36: scope:[irq]  from irq::@34
  (volatile byte) scroll_soft ← -- (volatile byte) scroll_soft
  (bool~) irq::$2 ← (volatile byte) scroll_soft == (number) $ff
  (bool~) irq::$3 ← ! (bool~) irq::$2
  if((bool~) irq::$3) goto irq::@return
  to:irq::@37
irq::@37: scope:[irq]  from irq::@36
  (volatile byte) scroll_soft ← (number) 7
  (byte) irq::i5#0 ← (byte) 0
  to:irq::@38
irq::@38: scope:[irq]  from irq::@37 irq::@39
  (byte) irq::i5#2 ← phi( irq::@37/(byte) irq::i5#0 irq::@39/(byte) irq::i5#1 )
  (bool~) irq::$30 ← (byte) irq::i5#2 < (number) $27
  if((bool~) irq::$30) goto irq::@39
  to:irq::@40
irq::@39: scope:[irq]  from irq::@38
  (byte) irq::i5#3 ← phi( irq::@38/(byte) irq::i5#2 )
  *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i5#3) ← *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28+(number) 1 + (byte) irq::i5#3)
  (byte) irq::i5#1 ← ++ (byte) irq::i5#3
  to:irq::@38
irq::@40: scope:[irq]  from irq::@38
  (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr)
  (volatile byte*) scroll_ptr ← ++ (volatile byte*) scroll_ptr
  (bool~) irq::$31 ← (byte) irq::nxt#0 == (number) 0
  (bool~) irq::$32 ← ! (bool~) irq::$31
  if((bool~) irq::$32) goto irq::@42
  to:irq::@41
irq::@42: scope:[irq]  from irq::@40 irq::@41
  (byte) irq::nxt#2 ← phi( irq::@40/(byte) irq::nxt#0 irq::@41/(byte) irq::nxt#1 )
  (number~) irq::$33 ← (byte) irq::nxt#2 & (number) $bf
  *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28+(number) $27) ← (number~) irq::$33
  to:irq::@return
irq::@41: scope:[irq]  from irq::@40
  (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT
  (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr)
  to:irq::@42
irq::@return: scope:[irq]  from irq::@36 irq::@42
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  (volatile byte) sin_idx ← (byte) 0
  (volatile byte) scroll_soft ← (byte) 7
  (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT
  (volatile byte) greet_zoomx ← (byte) 0
  (volatile byte) greet_idx ← (byte) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*)(number) $dc00
(const nomodify byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const nomodify byte*) COLORRAM = (byte*)(number) $d800
(const nomodify byte*) DEFAULT_SCREEN = (byte*)(number) $400
(byte) DMA_LIST_F018A::command
(word) DMA_LIST_F018A::count
(byte*) DMA_LIST_F018A::dest
(byte) DMA_LIST_F018A::dest_bank
(word) DMA_LIST_F018A::modulo
(byte*) DMA_LIST_F018A::src
(byte) DMA_LIST_F018A::src_bank
(byte) DMA_LIST_F018B::command
(word) DMA_LIST_F018B::count
(byte*) DMA_LIST_F018B::dest
(byte) DMA_LIST_F018B::dest_bank
(word) DMA_LIST_F018B::modulo
(byte*) DMA_LIST_F018B::src
(byte) DMA_LIST_F018B::src_bank
(byte) DMA_LIST_F018B::sub_command
(byte) F018_DMAGIC::ADDRBANK
(byte) F018_DMAGIC::ADDRLSB
(byte) F018_DMAGIC::ADDRLSBTRIG
(byte) F018_DMAGIC::ADDRMB
(byte) F018_DMAGIC::ADDRMSB
(byte) F018_DMAGIC::EN018B
(byte) F018_DMAGIC::ETRIG
(byte) F018_DMAGIC::MISC
(const byte*) F018_DMAGIC::UNUSED1[(number) 8]  = { fill( 8, 0) }
(byte) F018_DMAGIC::UNUSED2
(const byte*) GREETING[]  = (byte*) "   DOUBLEFLASH        ADTBM          SY2002          TAYGER         SERIOUSLY   LIBI IN PARADIZE       LGB          BLUEWAYSW        SAUSAGE       BIT SHIFTER     INDIOCOLIFA     GRUMPYNINJA      0-LIMITS         CHEVERON     DR. COMMODORE "
(const nomodify byte) GREET_COUNT = (byte) $f
(const nomodify byte) GREET_ROW = (byte) $14
(const nomodify void()**) HARDWARE_IRQ = (void()**)(number) $fffe
(const nomodify byte) IRQ_RASTER = (byte) 1
(const nomodify byte) IRQ_Y = (byte) $16
(const nomodify byte) LOGO_ROW = (byte) 3
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(const byte*) MEGA_LOGO[]  = { (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf }
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL = (byte) $5a
(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = (byte) $31
(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = (byte) $54
(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0 = (byte) $6f
(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = (byte) $5c
(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = (byte) $4c
(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR = (byte) $21
(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR = (byte) $20
(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY = (byte) $2f
(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = (byte) $d
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = (byte) $11
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = (byte) $16
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = (byte) $1a
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = (byte) $19
(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER = (byte) $12
(const nomodify byte*) PALETTE_BLUE = (byte*)(number) $d300
(const nomodify byte*) PALETTE_GREEN = (byte*)(number) $d200
(const nomodify byte*) PALETTE_RED = (byte*)(number) $d100
(const byte*) PAL_BLUE[]  = { (byte) 0, (byte) $f3, (byte) $d4, (byte) $b5, (byte) $a6, (byte) $97, (byte) $88, (byte) $79, (byte) $1a, (byte) $fa, (byte) $eb, (byte) $ec, (byte) $bd, (byte) $be, (byte) $af, (byte) $ff, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $c0, (byte) $b1, (byte) $a2, (byte) $a3, (byte) $34, (byte) $35, (byte) $26, (byte) $27, (byte) $f7, (byte) $f8, (byte) $f9, (byte) $ea, (byte) 0, (byte) 0, (byte) $30, (byte) $11, (byte) $22, (byte) $13, (byte) $14, (byte) 5, (byte) $b5, (byte) $96, (byte) $97, (byte) $98, (byte) $79, (byte) $6a, (byte) $5b, (byte) $4c, (byte) $81, (byte) $42, (byte) $43, (byte) $34, (byte) 5, (byte) 6, (byte) $f6, (byte) $f7, (byte) $78, (byte) $69, (byte) $5a, (byte) $5b, (byte) $4c, (byte) $3d, (byte) $1e, (byte) $f, (byte) $17, (byte) $c7, (byte) $a8, (byte) $89, (byte) $5a, (byte) $5b, (byte) $3c, (byte) $1d, (byte) $ad, (byte) $9e, (byte) $7f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $78, (byte) 9, (byte) $e9, (byte) $ca, (byte) $ab, (byte) $7c, (byte) $5d, (byte) $5e, (byte) $de, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $59, (byte) $a, (byte) $ca, (byte) $bb, (byte) $8c, (byte) $6d, (byte) $3e, (byte) $2f, (byte) $bf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $49, (byte) $f9, (byte) $da, (byte) $ab, (byte) $7c, (byte) $5d, (byte) $2e, (byte) $2f, (byte) $af, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $48, (byte) $d8, (byte) $b9, (byte) $aa, (byte) $7b, (byte) $5c, (byte) $2d, (byte) $2e, (byte) $be, (byte) $9f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) 7, (byte) $97, (byte) $88, (byte) $69, (byte) $4a, (byte) $2b, (byte) $1c, (byte) $2d, (byte) $9d, (byte) $7e, (byte) $6f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $81, (byte) $62, (byte) $53, (byte) $44, (byte) 5, (byte) 6, (byte) $f6, (byte) $e7, (byte) $78, (byte) $69, (byte) $5a, (byte) $5b, (byte) $3c, (byte) $2d, (byte) $2e, (byte) $1f, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $b0, (byte) $b1, (byte) $a2, (byte) $b3, (byte) $44, (byte) $35, (byte) $36, (byte) $37, (byte) 8, (byte) $f8, (byte) $a, (byte) $b, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $70, (byte) $61, (byte) $62, (byte) $f2, (byte) $e3, (byte) $d4, (byte) $c5, (byte) $b6, (byte) $b7, (byte) $b8, (byte) $99, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $f0, (byte) $f1, (byte) $82, (byte) $83, (byte) $84, (byte) $85, (byte) $66, (byte) $57, (byte) $58, (byte) $59, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $70, (byte) $61, (byte) $62, (byte) $e2, (byte) $e3, (byte) $d4, (byte) $d5, (byte) $b6, (byte) $a7, (byte) $b8, (byte) $a9, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $a0, (byte) $b1, (byte) $a2, (byte) $a3, (byte) $44, (byte) $35, (byte) $26, (byte) $37, (byte) $f7, (byte) $19, (byte) $f9, (byte) $fa }
(const byte*) PAL_GREEN[]  = { (byte) 0, (byte) $e3, (byte) $c4, (byte) $b5, (byte) $96, (byte) $87, (byte) $78, (byte) $79, (byte) $a, (byte) $fa, (byte) $eb, (byte) $dc, (byte) $bd, (byte) $ae, (byte) $af, (byte) $ff, (byte) $e2, (byte) $b3, (byte) $a4, (byte) $85, (byte) $76, (byte) $67, (byte) $48, (byte) $49, (byte) $d9, (byte) $da, (byte) $bb, (byte) $bc, (byte) $8d, (byte) $8e, (byte) $7f, (byte) $ff, (byte) $42, (byte) 3, (byte) 4, (byte) $e4, (byte) $d5, (byte) $c6, (byte) $b7, (byte) $a8, (byte) $39, (byte) $3a, (byte) $1b, (byte) $2c, (byte) $fc, (byte) $fd, (byte) $de, (byte) $df, (byte) $61, (byte) $32, (byte) $13, (byte) 4, (byte) $e4, (byte) $e5, (byte) $d6, (byte) $d7, (byte) $78, (byte) $59, (byte) $4a, (byte) $4b, (byte) $2c, (byte) $1d, (byte) $e, (byte) $fe, (byte) $e0, (byte) $b1, (byte) $a2, (byte) $93, (byte) $74, (byte) $75, (byte) $56, (byte) $57, (byte) $e7, (byte) $d8, (byte) $79, (byte) $ca, (byte) $ab, (byte) $9c, (byte) $9d, (byte) $8e, (byte) $f0, (byte) $d1, (byte) $c2, (byte) $a3, (byte) $84, (byte) $85, (byte) $76, (byte) $77, (byte) 8, (byte) 9, (byte) $f9, (byte) $fa, (byte) $db, (byte) $cc, (byte) $bd, (byte) $ae, (byte) $61, (byte) $22, (byte) $23, (byte) $14, (byte) $f4, (byte) $e5, (byte) $d6, (byte) $c7, (byte) $58, (byte) $59, (byte) $3a, (byte) $3b, (byte) $1c, (byte) $d, (byte) $fd, (byte) $fe, (byte) $92, (byte) $53, (byte) $44, (byte) $35, (byte) $16, (byte) $f6, (byte) $e7, (byte) $e8, (byte) $79, (byte) $6a, (byte) $5b, (byte) $4c, (byte) $2d, (byte) $3e, (byte) $1f, (byte) $ef, (byte) $53, (byte) $14, (byte) 5, (byte) $e5, (byte) $c6, (byte) $b7, (byte) $a8, (byte) $99, (byte) $2a, (byte) $2b, (byte) $c, (byte) $d, (byte) $dd, (byte) $ce, (byte) $cf, (byte) $ff, (byte) $f3, (byte) $b4, (byte) $95, (byte) $86, (byte) $57, (byte) $38, (byte) $29, (byte) $1a, (byte) $ba, (byte) $ab, (byte) $9c, (byte) $8d, (byte) $6e, (byte) $5f, (byte) $ff, (byte) $ff, (byte) $95, (byte) $56, (byte) $27, (byte) $18, (byte) $e8, (byte) $d9, (byte) $ca, (byte) $bb, (byte) $4c, (byte) $3d, (byte) $2e, (byte) $1f, (byte) $ef, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $c5, (byte) $86, (byte) $57, (byte) $38, (byte) $19, (byte) $a, (byte) $ea, (byte) $db, (byte) $6c, (byte) $5d, (byte) $3e, (byte) $3f, (byte) $ef, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $65, (byte) $26, (byte) 7, (byte) $e7, (byte) $c8, (byte) $b9, (byte) $9a, (byte) $9b, (byte) $2c, (byte) $1d, (byte) $fd, (byte) $fe, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $b4, (byte) $75, (byte) $56, (byte) $37, (byte) $28, (byte) $19, (byte) $e9, (byte) $ea, (byte) $7b, (byte) $6c, (byte) $5d, (byte) $4e, (byte) $2f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $c3, (byte) $94, (byte) $75, (byte) $56, (byte) $47, (byte) $38, (byte) $19, (byte) $1a, (byte) $aa, (byte) $ab, (byte) $7c, (byte) $7d, (byte) $5e, (byte) $4f, (byte) $ff, (byte) $ff, (byte) $e2, (byte) $a3, (byte) $94, (byte) $85, (byte) $76, (byte) $67, (byte) $38, (byte) $49, (byte) $d9, (byte) $ca, (byte) $ab, (byte) $bc, (byte) $7d, (byte) $7e, (byte) $6f, (byte) $ff }
(const byte*) PAL_RED[]  = { (byte) 0, (byte) $f3, (byte) $d4, (byte) $b5, (byte) $a6, (byte) $97, (byte) $88, (byte) $79, (byte) $1a, (byte) $fa, (byte) $eb, (byte) $ec, (byte) $bd, (byte) $be, (byte) $af, (byte) $ff, (byte) $16, (byte) $c6, (byte) $a7, (byte) $88, (byte) $49, (byte) $5a, (byte) $2b, (byte) $1c, (byte) $ac, (byte) $ad, (byte) $8e, (byte) $8f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $c6, (byte) $77, (byte) $48, (byte) $29, (byte) $e9, (byte) $fa, (byte) $cb, (byte) $cc, (byte) $5d, (byte) $4e, (byte) $2f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $57, (byte) $18, (byte) $f8, (byte) $d9, (byte) $aa, (byte) $8b, (byte) $6c, (byte) $5d, (byte) $ed, (byte) $de, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $26, (byte) $e6, (byte) $b7, (byte) $a8, (byte) $69, (byte) $5a, (byte) $3b, (byte) $3c, (byte) $dc, (byte) $cd, (byte) $ae, (byte) $9f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $65, (byte) $16, (byte) $17, (byte) $f7, (byte) $d8, (byte) $b9, (byte) $9a, (byte) $8b, (byte) $2c, (byte) $d, (byte) $fd, (byte) $ee, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $64, (byte) $15, (byte) 6, (byte) $e6, (byte) $c7, (byte) $a8, (byte) $99, (byte) $8a, (byte) $1b, (byte) $c, (byte) $fc, (byte) $fd, (byte) $ee, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $12, (byte) $d2, (byte) $d3, (byte) $b4, (byte) $95, (byte) $86, (byte) $77, (byte) $78, (byte) 9, (byte) $69, (byte) $ea, (byte) $fb, (byte) $dc, (byte) $ad, (byte) $ae, (byte) $af, (byte) $f0, (byte) $c1, (byte) $c2, (byte) $a3, (byte) $84, (byte) $85, (byte) $76, (byte) $67, (byte) 8, (byte) $f8, (byte) $e9, (byte) $da, (byte) $db, (byte) $bc, (byte) $bd, (byte) $ae, (byte) $40, (byte) $11, (byte) $12, (byte) $f2, (byte) $e3, (byte) $d4, (byte) $c5, (byte) $c6, (byte) $47, (byte) $38, (byte) $39, (byte) $2a, (byte) $1b, (byte) $c, (byte) $d, (byte) $ed, (byte) 0, (byte) 0, (byte) $f0, (byte) $d1, (byte) $c2, (byte) $b3, (byte) $a4, (byte) $95, (byte) $36, (byte) $27, (byte) $28, (byte) $29, (byte) $f9, (byte) $ea, (byte) $eb, (byte) $ec, (byte) $70, (byte) $41, (byte) $22, (byte) $23, (byte) $f3, (byte) $f4, (byte) $e5, (byte) $e6, (byte) $77, (byte) $78, (byte) $69, (byte) $7a, (byte) $3b, (byte) $3c, (byte) $3d, (byte) $3e, (byte) $a1, (byte) $82, (byte) $63, (byte) $54, (byte) $35, (byte) $26, (byte) 7, (byte) 8, (byte) $98, (byte) $99, (byte) $8a, (byte) $7b, (byte) $5c, (byte) $5d, (byte) $3e, (byte) $3f, (byte) $33, (byte) 4, (byte) $d4, (byte) $d5, (byte) $a6, (byte) $a7, (byte) $88, (byte) $89, (byte) $1a, (byte) $ab, (byte) $fb, (byte) $ec, (byte) $cd, (byte) $be, (byte) $af, (byte) $ff, (byte) $b4, (byte) $85, (byte) $56, (byte) $47, (byte) $18, (byte) 9, (byte) $f9, (byte) $ea, (byte) $7b, (byte) $7c, (byte) $5d, (byte) $5e, (byte) $2f, (byte) $ef, (byte) $ff, (byte) $ff, (byte) 6, (byte) $d6, (byte) $a7, (byte) $98, (byte) $59, (byte) $4a, (byte) $2b, (byte) $2c, (byte) $bc, (byte) $ad, (byte) $8e, (byte) $8f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff }
(const nomodify byte*) PROCPORT = (byte*)(number) 1
(const nomodify byte*) PROCPORT_DDR = (byte*)(number) 0
(const nomodify byte) PROCPORT_DDR_MEMORY_MASK = (byte) 7
(const nomodify byte) PROCPORT_RAM_IO = (byte) 5
(const nomodify byte) RASTER_LINES = (byte) $d8
(const nomodify byte*) SCREEN = (const nomodify byte*) DEFAULT_SCREEN
(const nomodify byte) SCROLL_BLACKBARS = (byte) $13
(const nomodify byte) SCROLL_ROW = (byte) $d
(const byte*) SCROLL_TEXT[]  = (byte*) "    THIS SMALL MEGA65 RASTER INTRO ... WAS MADE BY DEFT IN 2015 ... AND BROUGHT BACK TO LIFE 5 YEARS LATER IN 2020 ... BECAUSE THE MEGA65 HARDWARE CHANGED SO MUCH IN THE PAST 5 YEARS ... UNFORTUNATELY MY ASSEMBLER SKILLS DID NOT SO THIS IS THE FIRST APPROACH TO GET BETTER ... HOPEFULLY DR.MUTTI WILL HAVE TO SCOLD ME LESS ... THE PAST 5 YEARS HAVE BEEN AN UNFORGETTABLE & UNIQUE RIDE ... IF YOU DO WATCH THIS DEMO ON YOUR VERY OWN MEGA65 THERE IS ENOUGH EVIDENCE OF WHAT WE ACTUALLY ACHIEVED ... BELOW ARE THE GREETINGS TO DEAR AND VERY SPECIAL PEOPLE WHO HELPED TO GET THERE ... THANK YOU SO MUCH FOR YOUR SUPPORT AND FOR NOT GIVING UP ... DUAL SID TUNE BY RAYDEN OF ALPHA FLIGHT ... THIS SCROLLY WILL NOW RESTART           *WRAP*                    "
(const nomodify byte) SCROLL_Y = (byte) $66
(const byte*) SINUS[(number) $100]  = kickasm {{ .fill 256, 91.5 + 91.5*sin(i*2*PI/256)
 }}
(const byte*) SONG[]  = kickasm {{ .import c64 "DiscoZak_2SID_patched.prg"
 }}
(const nomodify struct MOS6569_VICII*) VICII = (struct MOS6569_VICII*)(number) $d000
(const nomodify struct MOS4569_VICIII*) VICIII = (struct MOS4569_VICIII*)(number) $d000
(const nomodify struct MEGA65_VICIV*) VICIV = (struct MEGA65_VICIV*)(number) $d000
(void()) __start()
(label) __start::@1
(label) __start::@2
(label) __start::@return
(label) __start::__init1
(volatile byte) greet_idx loadstore
(volatile byte) greet_zoomx loadstore
interrupt(HARDWARE_STACK)(void()) irq()
(number~) irq::$1
(number~) irq::$10
(bool~) irq::$11
(bool~) irq::$12
(bool~) irq::$13
(bool~) irq::$14
(bool~) irq::$15
(bool~) irq::$16
(number~) irq::$17
(bool~) irq::$18
(bool~) irq::$19
(bool~) irq::$2
(number~) irq::$20
(bool~) irq::$21
(bool~) irq::$22
(bool~) irq::$23
(byte~) irq::$24
(byte~) irq::$25
(number~) irq::$26
(number~) irq::$27
(bool~) irq::$28
(number~) irq::$29
(bool~) irq::$3
(bool~) irq::$30
(bool~) irq::$31
(bool~) irq::$32
(number~) irq::$33
(bool~) irq::$4
(bool~) irq::$5
(bool~) irq::$6
(bool~) irq::$7
(bool~) irq::$8
(bool~) irq::$9
(label) irq::@1
(label) irq::@10
(label) irq::@11
(label) irq::@12
(label) irq::@13
(label) irq::@14
(label) irq::@15
(label) irq::@16
(label) irq::@17
(label) irq::@18
(label) irq::@19
(label) irq::@2
(label) irq::@20
(label) irq::@21
(label) irq::@22
(label) irq::@23
(label) irq::@24
(label) irq::@25
(label) irq::@26
(label) irq::@27
(label) irq::@28
(label) irq::@29
(label) irq::@3
(label) irq::@30
(label) irq::@31
(label) irq::@32
(label) irq::@33
(label) irq::@34
(label) irq::@35
(label) irq::@36
(label) irq::@37
(label) irq::@38
(label) irq::@39
(label) irq::@4
(label) irq::@40
(label) irq::@41
(label) irq::@42
(label) irq::@5
(label) irq::@6
(label) irq::@7
(label) irq::@8
(label) irq::@9
(label) irq::@return
(byte) irq::barcnt
(byte) irq::barcnt#0
(byte) irq::barcnt#1
(byte) irq::barcnt#2
(byte) irq::barcnt#3
(byte) irq::barcnt#4
(byte) irq::barcnt#5
(byte) irq::barcnt#6
(byte) irq::barcnt#7
(byte) irq::barcnt#8
(byte) irq::barcnt#9
(byte) irq::barcol
(byte) irq::barcol#0
(byte) irq::barcol#1
(byte) irq::barcol#2
(byte) irq::barcol#3
(byte) irq::barcol#4
(byte) irq::barcol#5
(byte) irq::barcol#6
(byte) irq::barcol#7
(byte) irq::col
(byte) irq::col#0
(byte) irq::col1
(byte) irq::col1#0
(byte) irq::col1#1
(byte) irq::greet_offset
(byte) irq::greet_offset#0
(byte) irq::greet_offset#1
(byte) irq::greet_offset#2
(byte) irq::greet_offset#3
(byte) irq::i
(byte) irq::i#0
(byte) irq::i#1
(byte) irq::i#2
(byte) irq::i#3
(byte) irq::i1
(byte) irq::i1#0
(byte) irq::i1#1
(byte) irq::i1#2
(byte) irq::i1#3
(byte) irq::i2
(byte) irq::i2#0
(byte) irq::i2#1
(byte) irq::i2#2
(byte) irq::i2#3
(byte) irq::i3
(byte) irq::i3#0
(byte) irq::i3#1
(byte) irq::i3#2
(byte) irq::i3#3
(byte) irq::i4
(byte) irq::i4#0
(byte) irq::i4#1
(byte) irq::i4#2
(byte) irq::i4#3
(byte) irq::i5
(byte) irq::i5#0
(byte) irq::i5#1
(byte) irq::i5#2
(byte) irq::i5#3
(byte) irq::idx
(byte) irq::idx#0
(byte) irq::idx#1
(byte) irq::idx#2
(byte) irq::idx#3
(byte) irq::idx#4
(byte) irq::idx#5
(byte) irq::idx#6
(byte) irq::idx#7
(byte) irq::l
(byte) irq::l#0
(byte) irq::l#1
(byte) irq::l#2
(byte) irq::l#3
(byte) irq::line
(byte) irq::line#0
(byte) irq::line#1
(byte) irq::line#10
(byte) irq::line#11
(byte) irq::line#12
(byte) irq::line#13
(byte) irq::line#14
(byte) irq::line#15
(byte) irq::line#2
(byte) irq::line#3
(byte) irq::line#4
(byte) irq::line#5
(byte) irq::line#6
(byte) irq::line#7
(byte) irq::line#8
(byte) irq::line#9
(byte) irq::nxt
(byte) irq::nxt#0
(byte) irq::nxt#1
(byte) irq::nxt#2
(byte) irq::raster
(byte) irq::raster#0
(byte) irq::raster#1
(byte) irq::sin_bar
(byte) irq::sin_bar#0
(byte) irq::sin_bar#1
(byte) irq::sin_bar#2
(byte) irq::sin_bar#3
(byte) irq::sin_bar#4
(byte) irq::sin_bar#5
(byte) irq::sin_bar#6
(byte) irq::sin_bar#7
(byte) irq::sin_bar#8
(byte) irq::sin_bar#9
(byte) irq::sin_col
(byte) irq::sin_col#0
(byte) irq::sin_col#1
(byte) irq::sin_col#2
(byte) irq::sin_col#3
(byte) irq::wobble_idx
(byte) irq::wobble_idx#0
(byte) irq::wobble_idx#1
(byte) irq::wobble_idx#10
(byte) irq::wobble_idx#11
(byte) irq::wobble_idx#12
(byte) irq::wobble_idx#13
(byte) irq::wobble_idx#14
(byte) irq::wobble_idx#15
(byte) irq::wobble_idx#2
(byte) irq::wobble_idx#3
(byte) irq::wobble_idx#4
(byte) irq::wobble_idx#5
(byte) irq::wobble_idx#6
(byte) irq::wobble_idx#7
(byte) irq::wobble_idx#8
(byte) irq::wobble_idx#9
(byte) irq::zoomval
(byte) irq::zoomval#0
(void()) main()
(byte~) main::$2
(bool~) main::$3
(bool~) main::$4
(bool~) main::$5
(label) main::@1
(label) main::@10
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i1
(byte) main::i1#0
(byte) main::i1#1
(byte) main::i1#2
(byte) main::i1#3
(byte) main::i2
(byte) main::i2#0
(byte) main::i2#1
(byte) main::i2#2
(byte) main::i2#3
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(bool~) memset::$3
(byte*~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@4
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(const byte*) rasters[(const nomodify byte) RASTER_LINES]  = { fill( RASTER_LINES, 0) }
(volatile byte*) scroll_ptr loadstore
(volatile byte) scroll_soft loadstore
(volatile byte) sin_idx loadstore
(const void()*) songInit = (void()*)(const byte*) SONG
(const void()*) songPlay = (void()*)(const byte*) SONG+(number) 3

Adding number conversion cast (unumber) 3 in 
Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#1 > (number) 0
Adding number conversion cast (unumber) $47 in *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (number) $47
Adding number conversion cast (unumber) $53 in *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (number) $53
Adding number conversion cast (unumber) $40 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (number) $40
Adding number conversion cast (unumber) $40 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (number) $40
Adding number conversion cast (unumber) $28*$19 in (word) memset::num#0 ← (number) $28*(number) $19
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) SCREEN+(const nomodify byte) LOGO_ROW*(number) $28 + (byte) main::i1#3) ← *((const byte*) MEGA_LOGO + (byte) main::i1#3)
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) LOGO_ROW*(number) $28 + (byte) main::i1#3) ← *((const byte*) MEGA_LOGO + (byte) main::i1#3)
Adding number conversion cast (unumber) $28 in (bool~) main::$4 ← (byte) main::i2#2 < (number) $28
Adding number conversion cast (unumber) GREET_ROW*$28 in *((const nomodify byte*) SCREEN+(const nomodify byte) GREET_ROW*(number) $28 + (byte) main::i2#3) ← (byte) '*'
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) GREET_ROW*(number) $28 + (byte) main::i2#3) ← (byte) '*'
Adding number conversion cast (unumber) 0 in (bool~) main::$5 ← (byte) main::i#1 != (number) 0
Adding number conversion cast (unumber) $7f in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (number) $7f
Adding number conversion cast (unumber) 1 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (number) 1
Adding number conversion cast (unumber) $80 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (number) $80
Adding number conversion cast (unumber) 0 in *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (number) 0
Adding number conversion cast (unumber) $66 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (number) $66
Adding number conversion cast (unumber) $50 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (number) $50
Adding number conversion cast (unumber) $50 in *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (number) $50
Adding number conversion cast (unumber) SCROLL_Y+SCROLL_BLACKBARS+1 in (bool~) irq::$8 ← (byte) irq::line#6 == (const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(number) 1
Adding number conversion cast (unumber) 1 in (bool~) irq::$8 ← (byte) irq::line#6 == (unumber)(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(number) 1
Adding number conversion cast (unumber) 1 in (number~) irq::$10 ← (byte) irq::zoomval#0 + (number) 1
Adding number conversion cast (unumber) irq::$10 in (number~) irq::$10 ← (byte) irq::zoomval#0 + (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) irq::$11 ← (volatile byte) greet_zoomx == (number) 0
Adding number conversion cast (unumber) 0 in (volatile byte) greet_idx ← (number) 0
Adding number conversion cast (unumber) $28 in (bool~) irq::$16 ← (byte) irq::i#2 < (number) $28
Adding number conversion cast (unumber) 4 in (number~) irq::$17 ← *((const byte*) SINUS + (byte) irq::sin_col#2) / (number) 4
Adding number conversion cast (unumber) irq::$17 in (number~) irq::$17 ← *((const byte*) SINUS + (byte) irq::sin_col#2) / (unumber)(number) 4
Adding number conversion cast (unumber) GREET_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) GREET_ROW*(number) $28 + (byte) irq::i#3) ← (byte) irq::col1#0
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) GREET_ROW*(number) $28 + (byte) irq::i#3) ← (byte) irq::col1#0
Adding number conversion cast (unumber) 2 in (byte) irq::col1#1 ← (byte) irq::col1#0 / (number) 2
Adding number conversion cast (unumber) 1 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 0*(number) $28-(number) 1 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 0*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 0*(number) $28-(unumber)(number) 1 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 0*(number) $28-(unumber)(number) 1 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 0*(number) $28-(unumber)(number) 1 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 2 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 1*(number) $28-(number) 2 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 1*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 1*(number) $28-(unumber)(number) 2 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 1*(number) $28-(unumber)(number) 2 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 1*(number) $28-(unumber)(number) 2 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 3 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 2*(number) $28-(number) 3 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 2*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 2*(number) $28-(unumber)(number) 3 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 2*(number) $28-(unumber)(number) 3 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 2*(number) $28-(unumber)(number) 3 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 4 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 3*(number) $28-(number) 4 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 3*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 3*(number) $28-(unumber)(number) 4 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 3*(number) $28-(unumber)(number) 4 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 3*(number) $28-(unumber)(number) 4 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 5 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 4*(number) $28-(number) 5 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 4*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 4*(number) $28-(unumber)(number) 5 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 4*(number) $28-(unumber)(number) 5 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 4*(number) $28-(unumber)(number) 5 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 6 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 5*(number) $28-(number) 6 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) 5*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(number) 5*(number) $28-(unumber)(number) 6 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) LOGO_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 5*(number) $28-(unumber)(number) 6 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) LOGO_ROW*(number) $28+(unumber)(number) 5*(number) $28-(unumber)(number) 6 + (byte) irq::i#3) ← (byte) irq::col1#1
Adding number conversion cast (unumber) SCROLL_ROW*$28 in *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i#3) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2)
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) COLORRAM+(unumber)(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i#3) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2)
Adding number conversion cast (unumber) 0 in *((const byte*) rasters + (byte) irq::l#3) ← (number) 0
Adding number conversion cast (unumber) $10 in (bool~) irq::$19 ← (byte) irq::barcnt#2 < (number) $10
Adding number conversion cast (unumber) $10 in (number~) irq::$20 ← (byte) irq::barcnt#3 * (number) $10
Adding number conversion cast (unumber) irq::$20 in (number~) irq::$20 ← (byte) irq::barcnt#3 * (unumber)(number) $10
Adding number conversion cast (unumber) $10 in (bool~) irq::$21 ← (byte) irq::i1#2 < (number) $10
Adding number conversion cast (unumber) $f in (bool~) irq::$22 ← (byte) irq::i2#2 < (number) $f
Adding number conversion cast (unumber) $a in (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#3 + (number) $a
Adding number conversion cast (unumber) $13 in (bool~) irq::$23 ← (byte) irq::i3#2 < (number) $13
Adding number conversion cast (unumber) 2 in (number~) irq::$26 ← *((const byte*) rasters + (byte~) irq::$25) / (number) 2
Adding number conversion cast (unumber) irq::$26 in (number~) irq::$26 ← *((const byte*) rasters + (byte~) irq::$25) / (unumber)(number) 2
Adding number conversion cast (unumber) 7 in (number~) irq::$27 ← (unumber~) irq::$26 & (number) 7
Adding number conversion cast (unumber) irq::$27 in (number~) irq::$27 ← (unumber~) irq::$26 & (unumber)(number) 7
Adding number conversion cast (unumber) $10 in (number~) irq::$1 ← (volatile byte) greet_idx * (number) $10
Adding number conversion cast (unumber) irq::$1 in (number~) irq::$1 ← (volatile byte) greet_idx * (unumber)(number) $10
Adding number conversion cast (unumber) $10 in (bool~) irq::$28 ← (byte) irq::i4#2 < (number) $10
Adding number conversion cast (unumber) $bf in (number~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (number) $bf
Adding number conversion cast (unumber) irq::$29 in (number~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (unumber)(number) $bf
Adding number conversion cast (unumber) $d in *((const nomodify byte*) SCREEN+(const nomodify byte) GREET_ROW*(number) $28+(number) $d + (byte) irq::i4#3) ← (unumber~) irq::$29
Adding number conversion cast (unumber) GREET_ROW*$28 in *((const nomodify byte*) SCREEN+(const nomodify byte) GREET_ROW*(number) $28+(unumber)(number) $d + (byte) irq::i4#3) ← (unumber~) irq::$29
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) GREET_ROW*(number) $28+(unumber)(number) $d + (byte) irq::i4#3) ← (unumber~) irq::$29
Adding number conversion cast (unumber) $ff in (bool~) irq::$2 ← (volatile byte) scroll_soft == (number) $ff
Adding number conversion cast (unumber) 7 in (volatile byte) scroll_soft ← (number) 7
Adding number conversion cast (unumber) $27 in (bool~) irq::$30 ← (byte) irq::i5#2 < (number) $27
Adding number conversion cast (unumber) 1 in *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i5#3) ← *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28+(number) 1 + (byte) irq::i5#3)
Adding number conversion cast (unumber) SCROLL_ROW*$28 in *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i5#3) ← *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28+(unumber)(number) 1 + (byte) irq::i5#3)
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i5#3) ← *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) SCROLL_ROW*(number) $28+(unumber)(number) 1 + (byte) irq::i5#3)
Adding number conversion cast (unumber) SCROLL_ROW*$28 in *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i5#3) ← *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) SCROLL_ROW*(unumber)(number) $28+(unumber)(number) 1 + (byte) irq::i5#3)
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) SCROLL_ROW*(number) $28 + (byte) irq::i5#3) ← *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) SCROLL_ROW*(unumber)(number) $28+(unumber)(number) 1 + (byte) irq::i5#3)
Adding number conversion cast (unumber) 0 in (bool~) irq::$31 ← (byte) irq::nxt#0 == (number) 0
Adding number conversion cast (unumber) $bf in (number~) irq::$33 ← (byte) irq::nxt#2 & (number) $bf
Adding number conversion cast (unumber) irq::$33 in (number~) irq::$33 ← (byte) irq::nxt#2 & (unumber)(number) $bf
Adding number conversion cast (unumber) $27 in *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28+(number) $27) ← (unumber~) irq::$33
Adding number conversion cast (unumber) SCROLL_ROW*$28 in *((const nomodify byte*) SCREEN+(const nomodify byte) SCROLL_ROW*(number) $28+(unumber)(number) $27) ← (unumber~) irq::$33
Adding number conversion cast (unumber) $28 in *((const nomodify byte*) SCREEN+(unumber)(const nomodify byte) SCROLL_ROW*(number) $28+(unumber)(number) $27) ← (unumber~) irq::$33
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#2
Inlining cast *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (unumber)(number) $47
Inlining cast *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (unumber)(number) $53
Inlining cast (word) memset::num#0 ← (unumber)(number) $28*(number) $19
Inlining cast *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (unumber)(number) 1
Inlining cast *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (unumber)(number) 0
Inlining cast *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (unumber)(number) $66
Inlining cast *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (unumber)(number) $50
Inlining cast *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (unumber)(number) $50
Inlining cast (volatile byte) greet_idx ← (unumber)(number) 0
Inlining cast *((const byte*) rasters + (byte) irq::l#3) ← (unumber)(number) 0
Inlining cast (volatile byte) scroll_soft ← (unumber)(number) 7
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 0
Simplifying constant pointer cast (byte*) 1
Simplifying constant pointer cast (struct MOS6569_VICII*) 53248
Simplifying constant pointer cast (struct MOS4569_VICIII*) 53248
Simplifying constant pointer cast (struct MEGA65_VICIV*) 53248
Simplifying constant pointer cast (byte*) 53504
Simplifying constant pointer cast (byte*) 53760
Simplifying constant pointer cast (byte*) 54016
Simplifying constant pointer cast (byte*) 55296
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (struct MOS6526_CIA*) 56320
Simplifying constant pointer cast (void()**) 65534
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant integer cast $47
Simplifying constant integer cast $53
Simplifying constant integer cast $40
Simplifying constant integer cast $40
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast $28
Simplifying constant integer cast (const nomodify byte) GREET_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $7f
Simplifying constant integer cast 1
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $66
Simplifying constant integer cast $50
Simplifying constant integer cast $50
Simplifying constant integer cast (const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast 4
Simplifying constant integer cast (const nomodify byte) GREET_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 2
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 1
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 2
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 3
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 4
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 5
Simplifying constant integer cast (const nomodify byte) LOGO_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 6
Simplifying constant integer cast (const nomodify byte) SCROLL_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast $10
Simplifying constant integer cast $10
Simplifying constant integer cast $f
Simplifying constant integer cast $a
Simplifying constant integer cast $13
Simplifying constant integer cast 2
Simplifying constant integer cast 7
Simplifying constant integer cast $10
Simplifying constant integer cast $10
Simplifying constant integer cast $bf
Simplifying constant integer cast (const nomodify byte) GREET_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast $d
Simplifying constant integer cast $ff
Simplifying constant integer cast 7
Simplifying constant integer cast $27
Simplifying constant integer cast (const nomodify byte) SCROLL_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 1
Simplifying constant integer cast (const nomodify byte) SCROLL_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Simplifying constant integer cast $bf
Simplifying constant integer cast (const nomodify byte) SCROLL_ROW*(unumber)(number) $28
Simplifying constant integer cast $28
Simplifying constant integer cast $27
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $47
Finalized unsigned number type (byte) $53
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $7f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $66
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) $50
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 6
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $a
Finalized unsigned number type (byte) $13
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) $bf
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $d
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $bf
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $27
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) irq::$10 ← (byte) irq::zoomval#0 + (byte) 1
Inferred type updated to byte in (unumber~) irq::$17 ← *((const byte*) SINUS + (byte) irq::sin_col#2) / (byte) 4
Inferred type updated to byte in (unumber~) irq::$20 ← (byte) irq::barcnt#3 * (byte) $10
Inferred type updated to byte in (unumber~) irq::$26 ← *((const byte*) rasters + (byte~) irq::$25) / (byte) 2
Inferred type updated to byte in (unumber~) irq::$27 ← (byte~) irq::$26 & (byte) 7
Inferred type updated to byte in (unumber~) irq::$1 ← (volatile byte) greet_idx * (byte) $10
Inferred type updated to byte in (unumber~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf
Inferred type updated to byte in (unumber~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf
Inversing boolean not [2] (bool~) memset::$1 ← (word) memset::num#1 <= (byte) 0 from [1] (bool~) memset::$0 ← (word) memset::num#1 > (byte) 0
Inversing boolean not [100] (bool~) irq::$9 ← (byte) irq::line#6 != (const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1 from [99] (bool~) irq::$8 ← (byte) irq::line#6 == (const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1
Inversing boolean not [109] (bool~) irq::$12 ← (volatile byte) greet_zoomx != (byte) 0 from [108] (bool~) irq::$11 ← (volatile byte) greet_zoomx == (byte) 0
Inversing boolean not [114] (bool~) irq::$14 ← (volatile byte) greet_idx != (const nomodify byte) GREET_COUNT from [113] (bool~) irq::$13 ← (volatile byte) greet_idx == (const nomodify byte) GREET_COUNT
Inversing boolean not [204] (bool~) irq::$3 ← (volatile byte) scroll_soft != (byte) $ff from [203] (bool~) irq::$2 ← (volatile byte) scroll_soft == (byte) $ff
Inversing boolean not [217] (bool~) irq::$32 ← (byte) irq::nxt#0 != (byte) 0 from [216] (bool~) irq::$31 ← (byte) irq::nxt#0 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#1 memset::return#3 memset::return#1 
Alias memset::str#2 = memset::str#3 
Alias memset::num#1 = memset::num#2 
Alias memset::c#3 = memset::c#4 
Alias memset::end#0 = memset::$2 
Alias memset::c#1 = memset::c#2 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#4 = memset::str#5 
Alias main::i1#2 = main::i1#3 
Alias main::i2#2 = main::i2#3 
Alias irq::line#10 = irq::line#3 irq::line#2 irq::line#13 irq::line#4 irq::line#14 irq::line#5 irq::line#15 irq::line#6 irq::line#11 irq::line#12 
Alias irq::wobble_idx#10 = irq::wobble_idx#3 irq::wobble_idx#4 irq::wobble_idx#2 irq::wobble_idx#14 irq::wobble_idx#12 irq::wobble_idx#15 irq::wobble_idx#13 irq::wobble_idx#8 irq::wobble_idx#9 irq::wobble_idx#11 
Alias irq::line#7 = irq::line#8 
Alias irq::wobble_idx#5 = irq::wobble_idx#6 
Alias irq::sin_col#2 = irq::sin_col#3 
Alias irq::i#2 = irq::i#3 
Alias irq::col1#0 = irq::$17 
Alias irq::l#2 = irq::l#3 
Alias irq::sin_bar#2 = irq::sin_bar#4 
Alias irq::barcnt#2 = irq::barcnt#3 
Alias irq::barcol#0 = irq::$20 
Alias irq::barcol#3 = irq::barcol#5 irq::barcol#7 
Alias irq::idx#3 = irq::idx#5 irq::idx#7 
Alias irq::i1#2 = irq::i1#3 
Alias irq::sin_bar#6 = irq::sin_bar#9 irq::sin_bar#8 
Alias irq::barcnt#6 = irq::barcnt#9 irq::barcnt#8 
Alias irq::barcol#4 = irq::barcol#6 
Alias irq::idx#4 = irq::idx#6 
Alias irq::i2#2 = irq::i2#3 
Alias irq::sin_bar#3 = irq::sin_bar#7 irq::sin_bar#5 
Alias irq::barcnt#4 = irq::barcnt#7 irq::barcnt#5 
Alias irq::i3#2 = irq::i3#3 
Alias irq::greet_offset#0 = irq::$1 
Alias irq::greet_offset#2 = irq::greet_offset#3 
Alias irq::i4#2 = irq::i4#3 
Alias irq::i5#2 = irq::i5#3 
Successful SSA optimization Pass2AliasElimination
Alias irq::line#10 = irq::line#9 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) memset::num#1 (word) memset::num#0
Identical Phi Values (void*) memset::str#2 (void*) memset::str#0
Identical Phi Values (byte) memset::c#3 (byte) memset::c#0
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#4 (void*) memset::str#2
Identical Phi Values (byte) memset::c#1 (byte) memset::c#3
Identical Phi Values (byte) irq::raster#1 (byte) irq::raster#0
Identical Phi Values (byte) irq::line#7 (byte) irq::line#10
Identical Phi Values (byte) irq::wobble_idx#5 (byte) irq::wobble_idx#7
Identical Phi Values (byte) irq::sin_bar#6 (byte) irq::sin_bar#2
Identical Phi Values (byte) irq::barcnt#6 (byte) irq::barcnt#2
Identical Phi Values (byte) irq::sin_bar#3 (byte) irq::sin_bar#6
Identical Phi Values (byte) irq::barcnt#4 (byte) irq::barcnt#6
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) memset::$1 [2] if((word) memset::num#0<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$3 [9] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@4
Simple Condition (bool~) main::$3 [28] if((byte) main::i1#2<(byte~) main::$2) goto main::@2
Simple Condition (bool~) main::$4 [34] if((byte) main::i2#2<(byte) $28) goto main::@5
Simple Condition (bool~) main::$5 [44] if((byte) main::i#1!=(byte) 0) goto main::@7
Simple Condition (bool~) irq::$4 [64] if((byte) irq::line#10!=(const nomodify byte) RASTER_LINES) goto irq::@2
Simple Condition (bool~) irq::$5 [69] if((byte) irq::line#10<(const nomodify byte) SCROLL_Y) goto irq::@4
Simple Condition (bool~) irq::$6 [77] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y) goto irq::@5
Simple Condition (bool~) irq::$7 [81] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS) goto irq::@6
Simple Condition (bool~) irq::$9 [84] if((byte) irq::line#10!=(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1) goto irq::@7
Simple Condition (bool~) irq::$12 [91] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7
Simple Condition (bool~) irq::$14 [94] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7
Simple Condition (bool~) irq::$15 [100] if((byte) irq::raster#0==*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)) goto irq::@8
Simple Condition (bool~) irq::$16 [104] if((byte) irq::i#2<(byte) $28) goto irq::@17
Simple Condition (bool~) irq::$18 [120] if((byte) irq::l#2!=(const nomodify byte) RASTER_LINES) goto irq::@20
Simple Condition (bool~) irq::$19 [127] if((byte) irq::barcnt#2<(byte) $10) goto irq::@23
Simple Condition (bool~) irq::$21 [134] if((byte) irq::i1#2<(byte) $10) goto irq::@26
Simple Condition (bool~) irq::$22 [142] if((byte) irq::i2#2<(byte) $f) goto irq::@29
Simple Condition (bool~) irq::$23 [151] if((byte) irq::i3#2<(byte) $13) goto irq::@32
Simple Condition (bool~) irq::$28 [162] if((byte) irq::i4#2<(byte) $10) goto irq::@35
Simple Condition (bool~) irq::$3 [169] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return
Simple Condition (bool~) irq::$30 [174] if((byte) irq::i5#2<(byte) $27) goto irq::@39
Simple Condition (bool~) irq::$32 [180] if((byte) irq::nxt#0!=(byte) 0) goto irq::@42
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [21] (word) memset::num#0 ← (unumber)(number) $28*(number) $19
Constant right-side identified [26] (byte~) main::$2 ← sizeof  (const byte*) MEGA_LOGO
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const void*) memset::str#0 = (void*)SCREEN
Constant (const byte) memset::c#0 = ' '
Constant (const word) memset::num#0 = (unumber)$28*$19
Constant (const byte) main::i1#0 = 0
Constant (const byte) main::$2 = sizeof MEGA_LOGO
Constant (const byte) main::i2#0 = 0
Constant (const byte) main::i#0 = 0
Constant (const byte) irq::line#0 = 0
Constant (const byte) irq::i#0 = 0
Constant (const byte) irq::l#0 = 0
Constant (const byte) irq::barcnt#0 = 0
Constant (const byte) irq::i1#0 = 0
Constant (const byte) irq::i3#0 = 0
Constant (const byte) irq::i2#0 = 0
Constant (const byte) irq::i4#0 = 0
Constant (const byte) irq::i5#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) memset::$4 = (byte*)memset::str#0
Constant (const byte*) memset::dst#0 = (byte*)memset::str#0
Constant (const void*) memset::return#2 = memset::str#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [2] if((const word) memset::num#0<=(byte) 0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Simplifying constant evaluating to zero (byte)(number) 0*(number) $28 in [108] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 0*(number) $28-(byte) 1 + (byte) irq::i#2) ← (byte) irq::col1#1
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero COLORRAM+LOGO_ROW*$28 in [108] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte) 0-(byte) 1 + (byte) irq::i#2) ← (byte) irq::col1#1
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const void*) memset::return#2
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Resolving array sizeof() sizeof (const byte*) MEGA_LOGO
Successful SSA optimization PassNSizeOfSimplification
Constant right-side identified [0] (byte*) memset::end#0 ← (const byte*) memset::$4 + (const word) memset::num#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) memset::end#0 = memset::$4+memset::num#0
Successful SSA optimization Pass2ConstantIdentification
Adding number conversion cast (unumber) $bc in 
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast $bc
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $bc
Successful SSA optimization PassNFinalizeNumberTypeConversions
Rewriting division to use shift [73] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) / (byte) 4
Rewriting division to use shift [75] (byte) irq::col1#1 ← (byte) irq::col1#0 / (byte) 2
Rewriting multiplication to use shift [93] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 * (byte) $10
Rewriting division to use shift [112] (byte~) irq::$26 ← *((const byte*) rasters + (byte~) irq::$25) / (byte) 2
Rewriting multiplication to use shift [116] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx * (byte) $10
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte*) memset::dst#0
Inlining constant with var siblings (const byte) main::i1#0
Inlining constant with var siblings (const byte) main::i2#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) irq::line#0
Inlining constant with var siblings (const byte) irq::i#0
Inlining constant with var siblings (const byte) irq::l#0
Inlining constant with var siblings (const byte) irq::barcnt#0
Inlining constant with var siblings (const byte) irq::i1#0
Inlining constant with var siblings (const byte) irq::i3#0
Inlining constant with var siblings (const byte) irq::i2#0
Inlining constant with var siblings (const byte) irq::i4#0
Inlining constant with var siblings (const byte) irq::i5#0
Constant inlined irq::line#0 = (byte) 0
Constant inlined irq::barcnt#0 = (byte) 0
Constant inlined irq::i#0 = (byte) 0
Constant inlined irq::i2#0 = (byte) 0
Constant inlined irq::i3#0 = (byte) 0
Constant inlined irq::i1#0 = (byte) 0
Constant inlined irq::i4#0 = (byte) 0
Constant inlined irq::l#0 = (byte) 0
Constant inlined irq::i5#0 = (byte) 0
Constant inlined SCREEN = (const nomodify byte*) DEFAULT_SCREEN
Constant inlined memset::$4 = (byte*)(const void*) memset::str#0
Constant inlined main::$2 = (byte) $bc*(const byte) SIZEOF_BYTE
Constant inlined main::i1#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined main::i2#0 = (byte) 0
Constant inlined memset::dst#0 = (byte*)(const void*) memset::str#0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(rasters+SCROLL_Y + irq::$25)
Consolidated array index constant in assignment *(rasters+SCROLL_Y + irq::$24)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias irq::i3#2 = irq::$24 irq::$25 
Successful SSA optimization Pass2AliasElimination
Added new block during phi lifting main::@11(between main::@7 and main::@7)
Added new block during phi lifting irq::@43(between irq::@12 and irq::@7)
Added new block during phi lifting irq::@44(between irq::@13 and irq::@7)
Added new block during phi lifting irq::@45(between irq::@14 and irq::@7)
Added new block during phi lifting irq::@46(between irq::@40 and irq::@42)
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of __start::@2
Adding NOP phi() at start of irq::@18
Adding NOP phi() at start of irq::@24
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@3
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@9
Adding NOP phi() at start of memset
Adding NOP phi() at start of memset::@2
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [__start] to main:7 
Calls in [main] to memset:153 

Created 23 initial phi equivalence classes
Coalesced [15] irq::wobble_idx#16 ← irq::wobble_idx#0
Coalesced [20] irq::sin_col#5 ← irq::sin_col#0
Coalesced [27] irq::sin_bar#10 ← irq::sin_bar#0
Coalesced [34] irq::greet_offset#4 ← irq::greet_offset#0
Coalesced [47] irq::nxt#4 ← irq::nxt#1
Coalesced [52] irq::nxt#3 ← irq::nxt#0
Coalesced [55] irq::i5#4 ← irq::i5#1
Coalesced [60] irq::i4#4 ← irq::i4#1
Coalesced [61] irq::greet_offset#5 ← irq::greet_offset#1
Coalesced [66] irq::i3#4 ← irq::i3#1
Coalesced [69] irq::barcol#8 ← irq::barcol#0
Coalesced [70] irq::idx#8 ← irq::idx#0
Coalesced [73] irq::barcol#10 ← irq::barcol#3
Coalesced [74] irq::idx#10 ← irq::idx#3
Coalesced [79] irq::barcnt#10 ← irq::barcnt#1
Coalesced [80] irq::sin_bar#11 ← irq::sin_bar#1
Coalesced [85] irq::i2#4 ← irq::i2#1
Coalesced [86] irq::barcol#11 ← irq::barcol#2
Coalesced [87] irq::idx#11 ← irq::idx#2
Coalesced [92] irq::i1#4 ← irq::i1#1
Coalesced [93] irq::barcol#9 ← irq::barcol#1
Coalesced [94] irq::idx#9 ← irq::idx#1
Coalesced [97] irq::l#4 ← irq::l#1
Coalesced [110] irq::i#4 ← irq::i#1
Coalesced [111] irq::sin_col#4 ← irq::sin_col#1
Coalesced [128] irq::wobble_idx#21 ← irq::wobble_idx#10
Coalesced [133] irq::line#16 ← irq::line#1
Coalesced (already) [134] irq::wobble_idx#17 ← irq::wobble_idx#7
Coalesced (already) [135] irq::wobble_idx#20 ← irq::wobble_idx#10
Coalesced (already) [136] irq::wobble_idx#19 ← irq::wobble_idx#10
Coalesced (already) [137] irq::wobble_idx#18 ← irq::wobble_idx#10
Coalesced (already) [139] irq::wobble_idx#24 ← irq::wobble_idx#10
Coalesced (already) [142] irq::wobble_idx#23 ← irq::wobble_idx#10
Coalesced [146] irq::wobble_idx#22 ← irq::wobble_idx#1
Coalesced [178] main::i#3 ← main::i#1
Coalesced [181] main::i2#4 ← main::i2#1
Coalesced [184] main::i1#4 ← main::i1#1
Coalesced [193] memset::dst#4 ← memset::dst#1
Coalesced down to 20 phi equivalence classes
Culled Empty Block (label) __start::@2
Culled Empty Block (label) irq::@18
Culled Empty Block (label) irq::@24
Culled Empty Block (label) irq::@46
Culled Empty Block (label) irq::@27
Culled Empty Block (label) irq::@45
Culled Empty Block (label) irq::@44
Culled Empty Block (label) irq::@43
Culled Empty Block (label) main::@10
Culled Empty Block (label) main::@3
Culled Empty Block (label) main::@6
Culled Empty Block (label) main::@11
Culled Empty Block (label) memset::@2
Culled Empty Block (label) memset::@1
Renumbering block memset::@3 to memset::@1
Renumbering block memset::@4 to memset::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@7 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block irq::@19 to irq::@18
Renumbering block irq::@20 to irq::@19
Renumbering block irq::@21 to irq::@20
Renumbering block irq::@22 to irq::@21
Renumbering block irq::@23 to irq::@22
Renumbering block irq::@25 to irq::@23
Renumbering block irq::@26 to irq::@24
Renumbering block irq::@28 to irq::@25
Renumbering block irq::@29 to irq::@26
Renumbering block irq::@30 to irq::@27
Renumbering block irq::@31 to irq::@28
Renumbering block irq::@32 to irq::@29
Renumbering block irq::@33 to irq::@30
Renumbering block irq::@34 to irq::@31
Renumbering block irq::@35 to irq::@32
Renumbering block irq::@36 to irq::@33
Renumbering block irq::@37 to irq::@34
Renumbering block irq::@38 to irq::@35
Renumbering block irq::@39 to irq::@36
Renumbering block irq::@40 to irq::@37
Renumbering block irq::@41 to irq::@38
Renumbering block irq::@42 to irq::@39
Adding NOP phi() at start of __start
Adding NOP phi() at start of __start::@1
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of memset

FINAL CONTROL FLOW GRAPH

(void()) __start()
__start: scope:[__start]  from
  [0] phi()
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  [1] (volatile byte) sin_idx ← (byte) 0
  [2] (volatile byte) scroll_soft ← (byte) 7
  [3] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT
  [4] (volatile byte) greet_zoomx ← (byte) 0
  [5] (volatile byte) greet_idx ← (byte) 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  [6] phi()
  [7] call main 
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  [8] return 
  to:@return

interrupt(HARDWARE_STACK)(void()) irq()
irq: scope:[irq]  from
  [9] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80
  [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER
  [11] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0
  [12] (volatile byte) sin_idx ← ++ (volatile byte) sin_idx
  [13] (byte) irq::wobble_idx#0 ← (volatile byte) sin_idx
  to:irq::@1
irq::@1: scope:[irq]  from irq irq::@9
  [14] (byte) irq::wobble_idx#10 ← phi( irq/(byte) irq::wobble_idx#0 irq::@9/(byte) irq::wobble_idx#7 )
  [14] (byte) irq::line#10 ← phi( irq/(byte) 0 irq::@9/(byte) irq::line#1 )
  [15] if((byte) irq::line#10!=(const nomodify byte) RASTER_LINES) goto irq::@2
  to:irq::@3
irq::@3: scope:[irq]  from irq::@1
  [16] call *((const void()*) songPlay) 
  [17] (byte) irq::sin_col#0 ← (volatile byte) sin_idx
  to:irq::@16
irq::@16: scope:[irq]  from irq::@17 irq::@3
  [18] (byte) irq::sin_col#2 ← phi( irq::@17/(byte) irq::sin_col#1 irq::@3/(byte) irq::sin_col#0 )
  [18] (byte) irq::i#2 ← phi( irq::@17/(byte) irq::i#1 irq::@3/(byte) 0 )
  [19] if((byte) irq::i#2<(byte) $28) goto irq::@17
  to:irq::@18
irq::@18: scope:[irq]  from irq::@16 irq::@19
  [20] (byte) irq::l#2 ← phi( irq::@16/(byte) 0 irq::@19/(byte) irq::l#1 )
  [21] if((byte) irq::l#2!=(const nomodify byte) RASTER_LINES) goto irq::@19
  to:irq::@20
irq::@20: scope:[irq]  from irq::@18
  [22] (byte) irq::sin_bar#0 ← (volatile byte) sin_idx
  to:irq::@21
irq::@21: scope:[irq]  from irq::@20 irq::@27
  [23] (byte) irq::sin_bar#2 ← phi( irq::@20/(byte) irq::sin_bar#0 irq::@27/(byte) irq::sin_bar#1 )
  [23] (byte) irq::barcnt#2 ← phi( irq::@20/(byte) 0 irq::@27/(byte) irq::barcnt#1 )
  [24] if((byte) irq::barcnt#2<(byte) $10) goto irq::@22
  to:irq::@28
irq::@28: scope:[irq]  from irq::@21 irq::@29
  [25] (byte) irq::i3#2 ← phi( irq::@21/(byte) 0 irq::@29/(byte) irq::i3#1 )
  [26] if((byte) irq::i3#2<(byte) $13) goto irq::@29
  to:irq::@30
irq::@30: scope:[irq]  from irq::@28
  [27] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx << (byte) 4
  to:irq::@31
irq::@31: scope:[irq]  from irq::@30 irq::@32
  [28] (byte) irq::greet_offset#2 ← phi( irq::@30/(byte) irq::greet_offset#0 irq::@32/(byte) irq::greet_offset#1 )
  [28] (byte) irq::i4#2 ← phi( irq::@30/(byte) 0 irq::@32/(byte) irq::i4#1 )
  [29] if((byte) irq::i4#2<(byte) $10) goto irq::@32
  to:irq::@33
irq::@33: scope:[irq]  from irq::@31
  [30] (volatile byte) scroll_soft ← -- (volatile byte) scroll_soft
  [31] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return
  to:irq::@34
irq::@34: scope:[irq]  from irq::@33
  [32] (volatile byte) scroll_soft ← (byte) 7
  to:irq::@35
irq::@35: scope:[irq]  from irq::@34 irq::@36
  [33] (byte) irq::i5#2 ← phi( irq::@34/(byte) 0 irq::@36/(byte) irq::i5#1 )
  [34] if((byte) irq::i5#2<(byte) $27) goto irq::@36
  to:irq::@37
irq::@37: scope:[irq]  from irq::@35
  [35] (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr)
  [36] (volatile byte*) scroll_ptr ← ++ (volatile byte*) scroll_ptr
  [37] if((byte) irq::nxt#0!=(byte) 0) goto irq::@39
  to:irq::@38
irq::@38: scope:[irq]  from irq::@37
  [38] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT
  [39] (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr)
  to:irq::@39
irq::@39: scope:[irq]  from irq::@37 irq::@38
  [40] (byte) irq::nxt#2 ← phi( irq::@37/(byte) irq::nxt#0 irq::@38/(byte) irq::nxt#1 )
  [41] (byte~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf
  [42] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) $27) ← (byte~) irq::$33
  to:irq::@return
irq::@return: scope:[irq]  from irq::@33 irq::@39
  [43] return 
  to:@return
irq::@36: scope:[irq]  from irq::@35
  [44] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i5#2) ← *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) 1 + (byte) irq::i5#2)
  [45] (byte) irq::i5#1 ← ++ (byte) irq::i5#2
  to:irq::@35
irq::@32: scope:[irq]  from irq::@31
  [46] (byte~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf
  [47] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28+(byte) $d + (byte) irq::i4#2) ← (byte~) irq::$29
  [48] (byte) irq::greet_offset#1 ← ++ (byte) irq::greet_offset#2
  [49] (byte) irq::i4#1 ← ++ (byte) irq::i4#2
  to:irq::@31
irq::@29: scope:[irq]  from irq::@28
  [50] (byte~) irq::$26 ← *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) >> (byte) 1
  [51] (byte~) irq::$27 ← (byte~) irq::$26 & (byte) 7
  [52] *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) ← (byte~) irq::$27
  [53] (byte) irq::i3#1 ← ++ (byte) irq::i3#2
  to:irq::@28
irq::@22: scope:[irq]  from irq::@21
  [54] (byte) irq::idx#0 ← *((const byte*) SINUS + (byte) irq::sin_bar#2)
  [55] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 << (byte) 4
  to:irq::@23
irq::@23: scope:[irq]  from irq::@22 irq::@24
  [56] (byte) irq::idx#3 ← phi( irq::@22/(byte) irq::idx#0 irq::@24/(byte) irq::idx#1 )
  [56] (byte) irq::barcol#3 ← phi( irq::@22/(byte) irq::barcol#0 irq::@24/(byte) irq::barcol#1 )
  [56] (byte) irq::i1#2 ← phi( irq::@22/(byte) 0 irq::@24/(byte) irq::i1#1 )
  [57] if((byte) irq::i1#2<(byte) $10) goto irq::@24
  to:irq::@25
irq::@25: scope:[irq]  from irq::@23 irq::@26
  [58] (byte) irq::idx#4 ← phi( irq::@23/(byte) irq::idx#3 irq::@26/(byte) irq::idx#2 )
  [58] (byte) irq::barcol#4 ← phi( irq::@23/(byte) irq::barcol#3 irq::@26/(byte) irq::barcol#2 )
  [58] (byte) irq::i2#2 ← phi( irq::@23/(byte) 0 irq::@26/(byte) irq::i2#1 )
  [59] if((byte) irq::i2#2<(byte) $f) goto irq::@26
  to:irq::@27
irq::@27: scope:[irq]  from irq::@25
  [60] (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#2 + (byte) $a
  [61] (byte) irq::barcnt#1 ← ++ (byte) irq::barcnt#2
  to:irq::@21
irq::@26: scope:[irq]  from irq::@25
  [62] (byte) irq::barcol#2 ← -- (byte) irq::barcol#4
  [63] *((const byte*) rasters + (byte) irq::idx#4) ← (byte) irq::barcol#2
  [64] (byte) irq::idx#2 ← ++ (byte) irq::idx#4
  [65] (byte) irq::i2#1 ← ++ (byte) irq::i2#2
  to:irq::@25
irq::@24: scope:[irq]  from irq::@23
  [66] *((const byte*) rasters + (byte) irq::idx#3) ← (byte) irq::barcol#3
  [67] (byte) irq::idx#1 ← ++ (byte) irq::idx#3
  [68] (byte) irq::barcol#1 ← ++ (byte) irq::barcol#3
  [69] (byte) irq::i1#1 ← ++ (byte) irq::i1#2
  to:irq::@23
irq::@19: scope:[irq]  from irq::@18
  [70] *((const byte*) rasters + (byte) irq::l#2) ← (byte) 0
  [71] (byte) irq::l#1 ← ++ (byte) irq::l#2
  to:irq::@18
irq::@17: scope:[irq]  from irq::@16
  [72] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) >> (byte) 2
  [73] *((const nomodify byte*) COLORRAM+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) irq::i#2) ← (byte) irq::col1#0
  [74] (byte) irq::col1#1 ← (byte) irq::col1#0 >> (byte) 1
  [75] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28-(byte) 1 + (byte) irq::i#2) ← (byte) irq::col1#1
  [76] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 1*(number) $28-(byte) 2 + (byte) irq::i#2) ← (byte) irq::col1#1
  [77] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 2*(number) $28-(byte) 3 + (byte) irq::i#2) ← (byte) irq::col1#1
  [78] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 3*(number) $28-(byte) 4 + (byte) irq::i#2) ← (byte) irq::col1#1
  [79] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 4*(number) $28-(byte) 5 + (byte) irq::i#2) ← (byte) irq::col1#1
  [80] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 5*(number) $28-(byte) 6 + (byte) irq::i#2) ← (byte) irq::col1#1
  [81] *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i#2) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2)
  [82] (byte) irq::sin_col#1 ← ++ (byte) irq::sin_col#2
  [83] (byte) irq::i#1 ← ++ (byte) irq::i#2
  to:irq::@16
irq::@2: scope:[irq]  from irq::@1
  [84] (byte) irq::col#0 ← *((const byte*) rasters + (byte) irq::line#10)
  [85] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR) ← (byte) irq::col#0
  [86] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR) ← (byte) irq::col#0
  [87] if((byte) irq::line#10<(const nomodify byte) SCROLL_Y) goto irq::@4
  to:irq::@10
irq::@10: scope:[irq]  from irq::@2
  [88] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y) goto irq::@5
  to:irq::@11
irq::@11: scope:[irq]  from irq::@10
  [89] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS) goto irq::@6
  to:irq::@12
irq::@12: scope:[irq]  from irq::@11
  [90] if((byte) irq::line#10!=(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1) goto irq::@7
  to:irq::@13
irq::@13: scope:[irq]  from irq::@12
  [91] (byte) irq::zoomval#0 ← *((const byte*) SINUS + (volatile byte) greet_zoomx)
  [92] (volatile byte) greet_zoomx ← ++ (volatile byte) greet_zoomx
  [93] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) irq::zoomval#0
  [94] (byte~) irq::$10 ← (byte) irq::zoomval#0 + (byte) 1
  [95] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte~) irq::$10
  [96] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7
  to:irq::@14
irq::@14: scope:[irq]  from irq::@13
  [97] (volatile byte) greet_idx ← ++ (volatile byte) greet_idx
  [98] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7
  to:irq::@15
irq::@15: scope:[irq]  from irq::@14
  [99] (volatile byte) greet_idx ← (byte) 0
  to:irq::@7
irq::@7: scope:[irq]  from irq::@12 irq::@13 irq::@14 irq::@15 irq::@4 irq::@5 irq::@6
  [100] (byte) irq::wobble_idx#7 ← phi( irq::@12/(byte) irq::wobble_idx#10 irq::@13/(byte) irq::wobble_idx#10 irq::@14/(byte) irq::wobble_idx#10 irq::@15/(byte) irq::wobble_idx#10 irq::@4/(byte) irq::wobble_idx#1 irq::@5/(byte) irq::wobble_idx#10 irq::@6/(byte) irq::wobble_idx#10 )
  [101] (byte) irq::raster#0 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)
  to:irq::@8
irq::@8: scope:[irq]  from irq::@7 irq::@8
  [102] if((byte) irq::raster#0==*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)) goto irq::@8
  to:irq::@9
irq::@9: scope:[irq]  from irq::@8
  [103] (byte) irq::line#1 ← ++ (byte) irq::line#10
  to:irq::@1
irq::@6: scope:[irq]  from irq::@11
  [104] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50
  to:irq::@7
irq::@5: scope:[irq]  from irq::@10
  [105] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50
  [106] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft
  to:irq::@7
irq::@4: scope:[irq]  from irq::@2
  [107] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#10)
  [108] (byte) irq::wobble_idx#1 ← ++ (byte) irq::wobble_idx#10
  [109] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66
  to:irq::@7

(void()) main()
main: scope:[main]  from __start::@1
  [110] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47
  [111] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53
  [112] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (byte) $40
  [113] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (byte) $40
  asm { lda#0  }
  [115] call *((const void()*) songInit) 
  [116] call memset 
  to:main::@1
main::@1: scope:[main]  from main main::@2
  [117] (byte) main::i1#2 ← phi( main/(byte) 0 main::@2/(byte) main::i1#1 )
  [118] if((byte) main::i1#2<(byte) $bc*(const byte) SIZEOF_BYTE) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1 main::@4
  [119] (byte) main::i2#2 ← phi( main::@1/(byte) 0 main::@4/(byte) main::i2#1 )
  [120] if((byte) main::i2#2<(byte) $28) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3 main::@5
  [121] (byte) main::i#2 ← phi( main::@3/(byte) 0 main::@5/(byte) main::i#1 )
  [122] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2)
  [123] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2)
  [124] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2)
  [125] (byte) main::i#1 ← ++ (byte) main::i#2
  [126] if((byte) main::i#1!=(byte) 0) goto main::@5
  to:main::@6
main::@6: scope:[main]  from main::@5
  asm { sei  }
  [128] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR
  [129] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y
  [130] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f
  [131] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER
  [132] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq()
  [133] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK
  [134] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO
  [135] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1
  asm { cli  }
  to:main::@7
main::@7: scope:[main]  from main::@6 main::@7
  [137] phi()
  to:main::@7
main::@4: scope:[main]  from main::@3
  [138] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) main::i2#2) ← (byte) '*'
  [139] (byte) main::i2#1 ← ++ (byte) main::i2#2
  to:main::@3
main::@2: scope:[main]  from main::@1
  [140] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) LOGO_ROW*(byte) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2)
  [141] (byte) main::i1#1 ← ++ (byte) main::i1#2
  to:main::@1

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main
  [142] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [143] (byte*) memset::dst#2 ← phi( memset/(byte*)(const void*) memset::str#0 memset::@2/(byte*) memset::dst#1 )
  [144] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [145] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [146] *((byte*) memset::dst#2) ← (const byte) memset::c#0
  [147] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@1


VARIABLE REGISTER WEIGHTS
(byte) DMA_LIST_F018A::command
(word) DMA_LIST_F018A::count
(byte*) DMA_LIST_F018A::dest
(byte) DMA_LIST_F018A::dest_bank
(word) DMA_LIST_F018A::modulo
(byte*) DMA_LIST_F018A::src
(byte) DMA_LIST_F018A::src_bank
(byte) DMA_LIST_F018B::command
(word) DMA_LIST_F018B::count
(byte*) DMA_LIST_F018B::dest
(byte) DMA_LIST_F018B::dest_bank
(word) DMA_LIST_F018B::modulo
(byte*) DMA_LIST_F018B::src
(byte) DMA_LIST_F018B::src_bank
(byte) DMA_LIST_F018B::sub_command
(byte) F018_DMAGIC::ADDRBANK
(byte) F018_DMAGIC::ADDRLSB
(byte) F018_DMAGIC::ADDRLSBTRIG
(byte) F018_DMAGIC::ADDRMB
(byte) F018_DMAGIC::ADDRMSB
(byte) F018_DMAGIC::EN018B
(byte) F018_DMAGIC::ETRIG
(byte) F018_DMAGIC::MISC
(byte) F018_DMAGIC::UNUSED2
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(void()) __start()
(volatile byte) greet_idx loadstore 0.6153846153846154
(volatile byte) greet_zoomx loadstore 1.3939393939393938
interrupt(HARDWARE_STACK)(void()) irq()
(byte~) irq::$10 22.0
(byte~) irq::$26 22.0
(byte~) irq::$27 22.0
(byte~) irq::$29 22.0
(byte~) irq::$33 4.0
(byte) irq::barcnt
(byte) irq::barcnt#1 22.0
(byte) irq::barcnt#2 2.588235294117647
(byte) irq::barcol
(byte) irq::barcol#0 22.0
(byte) irq::barcol#1 101.0
(byte) irq::barcol#2 75.75
(byte) irq::barcol#3 103.75
(byte) irq::barcol#4 151.5
(byte) irq::col
(byte) irq::col#0 16.5
(byte) irq::col1
(byte) irq::col1#0 16.5
(byte) irq::col1#1 12.833333333333334
(byte) irq::greet_offset
(byte) irq::greet_offset#0 4.0
(byte) irq::greet_offset#1 11.0
(byte) irq::greet_offset#2 8.75
(byte) irq::i
(byte) irq::i#1 22.0
(byte) irq::i#2 9.307692307692307
(byte) irq::i1
(byte) irq::i1#1 202.0
(byte) irq::i1#2 60.599999999999994
(byte) irq::i2
(byte) irq::i2#1 202.0
(byte) irq::i2#2 60.599999999999994
(byte) irq::i3
(byte) irq::i3#1 22.0
(byte) irq::i3#2 11.0
(byte) irq::i4
(byte) irq::i4#1 22.0
(byte) irq::i4#2 8.8
(byte) irq::i5
(byte) irq::i5#1 22.0
(byte) irq::i5#2 18.333333333333332
(byte) irq::idx
(byte) irq::idx#0 11.0
(byte) irq::idx#1 67.33333333333333
(byte) irq::idx#2 101.0
(byte) irq::idx#3 138.33333333333331
(byte) irq::idx#4 101.0
(byte) irq::l
(byte) irq::l#1 22.0
(byte) irq::l#2 14.666666666666666
(byte) irq::line
(byte) irq::line#1 22.0
(byte) irq::line#10 3.259259259259259
(byte) irq::nxt
(byte) irq::nxt#0 2.0
(byte) irq::nxt#1 4.0
(byte) irq::nxt#2 6.0
(byte) irq::raster
(byte) irq::raster#0 56.0
(byte) irq::sin_bar
(byte) irq::sin_bar#0 4.0
(byte) irq::sin_bar#1 11.0
(byte) irq::sin_bar#2 2.1875
(byte) irq::sin_col
(byte) irq::sin_col#0 4.0
(byte) irq::sin_col#1 11.0
(byte) irq::sin_col#2 3.833333333333333
(byte) irq::wobble_idx
(byte) irq::wobble_idx#0 4.0
(byte) irq::wobble_idx#1 11.0
(byte) irq::wobble_idx#10 4.590909090909091
(byte) irq::wobble_idx#7 22.0
(byte) irq::zoomval
(byte) irq::zoomval#0 11.0
(void()) main()
(byte) main::i
(byte) main::i#1 151.5
(byte) main::i#2 202.0
(byte) main::i1
(byte) main::i1#1 202.0
(byte) main::i1#2 168.33333333333331
(byte) main::i2
(byte) main::i2#1 202.0
(byte) main::i2#2 134.66666666666666
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte*) memset::dst
(byte*) memset::dst#1 2002.0
(byte*) memset::dst#2 1334.6666666666667
(byte*) memset::end
(word) memset::num
(void*) memset::return
(void*) memset::str
(volatile byte*) scroll_ptr loadstore 0.1276595744680851
(volatile byte) scroll_soft loadstore 0.2441860465116279
(volatile byte) sin_idx loadstore 0.22641509433962262

Initial phi equivalence classes
[ irq::line#10 irq::line#1 ]
[ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ]
[ irq::i#2 irq::i#1 ]
[ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ]
[ irq::l#2 irq::l#1 ]
[ irq::barcnt#2 irq::barcnt#1 ]
[ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
[ irq::i3#2 irq::i3#1 ]
[ irq::i4#2 irq::i4#1 ]
[ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ]
[ irq::i5#2 irq::i5#1 ]
[ irq::nxt#2 irq::nxt#0 irq::nxt#1 ]
[ irq::i1#2 irq::i1#1 ]
[ irq::i2#2 irq::i2#1 ]
[ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ]
[ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ]
[ main::i1#2 main::i1#1 ]
[ main::i2#2 main::i2#1 ]
[ main::i#2 main::i#1 ]
[ memset::dst#2 memset::dst#1 ]
Added variable sin_idx to live range equivalence class [ sin_idx ]
Added variable scroll_soft to live range equivalence class [ scroll_soft ]
Added variable scroll_ptr to live range equivalence class [ scroll_ptr ]
Added variable greet_zoomx to live range equivalence class [ greet_zoomx ]
Added variable greet_idx to live range equivalence class [ greet_idx ]
Added variable irq::$33 to live range equivalence class [ irq::$33 ]
Added variable irq::$29 to live range equivalence class [ irq::$29 ]
Added variable irq::$26 to live range equivalence class [ irq::$26 ]
Added variable irq::$27 to live range equivalence class [ irq::$27 ]
Added variable irq::col1#0 to live range equivalence class [ irq::col1#0 ]
Added variable irq::col1#1 to live range equivalence class [ irq::col1#1 ]
Added variable irq::col#0 to live range equivalence class [ irq::col#0 ]
Added variable irq::zoomval#0 to live range equivalence class [ irq::zoomval#0 ]
Added variable irq::$10 to live range equivalence class [ irq::$10 ]
Added variable irq::raster#0 to live range equivalence class [ irq::raster#0 ]
Complete equivalence classes
[ irq::line#10 irq::line#1 ]
[ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ]
[ irq::i#2 irq::i#1 ]
[ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ]
[ irq::l#2 irq::l#1 ]
[ irq::barcnt#2 irq::barcnt#1 ]
[ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
[ irq::i3#2 irq::i3#1 ]
[ irq::i4#2 irq::i4#1 ]
[ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ]
[ irq::i5#2 irq::i5#1 ]
[ irq::nxt#2 irq::nxt#0 irq::nxt#1 ]
[ irq::i1#2 irq::i1#1 ]
[ irq::i2#2 irq::i2#1 ]
[ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ]
[ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ]
[ main::i1#2 main::i1#1 ]
[ main::i2#2 main::i2#1 ]
[ main::i#2 main::i#1 ]
[ memset::dst#2 memset::dst#1 ]
[ sin_idx ]
[ scroll_soft ]
[ scroll_ptr ]
[ greet_zoomx ]
[ greet_idx ]
[ irq::$33 ]
[ irq::$29 ]
[ irq::$26 ]
[ irq::$27 ]
[ irq::col1#0 ]
[ irq::col1#1 ]
[ irq::col#0 ]
[ irq::zoomval#0 ]
[ irq::$10 ]
[ irq::raster#0 ]
Allocated zp[1]:2 [ irq::line#10 irq::line#1 ]
Allocated zp[1]:3 [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ]
Allocated zp[1]:4 [ irq::i#2 irq::i#1 ]
Allocated zp[1]:5 [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ]
Allocated zp[1]:6 [ irq::l#2 irq::l#1 ]
Allocated zp[1]:7 [ irq::barcnt#2 irq::barcnt#1 ]
Allocated zp[1]:8 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
Allocated zp[1]:9 [ irq::i3#2 irq::i3#1 ]
Allocated zp[1]:10 [ irq::i4#2 irq::i4#1 ]
Allocated zp[1]:11 [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ]
Allocated zp[1]:12 [ irq::i5#2 irq::i5#1 ]
Allocated zp[1]:13 [ irq::nxt#2 irq::nxt#0 irq::nxt#1 ]
Allocated zp[1]:14 [ irq::i1#2 irq::i1#1 ]
Allocated zp[1]:15 [ irq::i2#2 irq::i2#1 ]
Allocated zp[1]:16 [ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ]
Allocated zp[1]:17 [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ]
Allocated zp[1]:18 [ main::i1#2 main::i1#1 ]
Allocated zp[1]:19 [ main::i2#2 main::i2#1 ]
Allocated zp[1]:20 [ main::i#2 main::i#1 ]
Allocated zp[2]:21 [ memset::dst#2 memset::dst#1 ]
Allocated zp[1]:23 [ sin_idx ]
Allocated zp[1]:24 [ scroll_soft ]
Allocated zp[2]:25 [ scroll_ptr ]
Allocated zp[1]:27 [ greet_zoomx ]
Allocated zp[1]:28 [ greet_idx ]
Allocated zp[1]:29 [ irq::$33 ]
Allocated zp[1]:30 [ irq::$29 ]
Allocated zp[1]:31 [ irq::$26 ]
Allocated zp[1]:32 [ irq::$27 ]
Allocated zp[1]:33 [ irq::col1#0 ]
Allocated zp[1]:34 [ irq::col1#1 ]
Allocated zp[1]:35 [ irq::col#0 ]
Allocated zp[1]:36 [ irq::zoomval#0 ]
Allocated zp[1]:37 [ irq::$10 ]
Allocated zp[1]:38 [ irq::raster#0 ]

INITIAL ASM
Target platform is mega65_c64 / MEGA45GS02
  // File Comments
// Raster65 Demo re-implementation in C by Jesper Gravgaard
// Based on RASTER65 assembler demo made in 2015 and updated in 2020 by DEFT 
// https://mega.scryptos.com/sharefolder/MEGA/MEGA65+filehost
// https://www.forum64.de/index.php?thread/104591-xemu-vic-iv-implementation-update/&postID=1560511#post1560511
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform executable starting in C64 mode.
.file [name="raster65.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$080d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
.segment Code


  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  // Logo start screen row 
  .const LOGO_ROW = 3
  // Scroll screen row
  .const SCROLL_ROW = $d
  // Greeting screen row
  .const GREET_ROW = $14
  // y rasterline where IRQ starts
  .const IRQ_Y = $16
  // y rasterline where scrolly starts
  .const SCROLL_Y = $66
  // size of raster behind scrolly
  .const SCROLL_BLACKBARS = $13
  // The number of raster lines
  .const RASTER_LINES = $d8
  // The number of greetings
  .const GREET_COUNT = $f
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MEGA65_VICIV_RASLINE0 = $6f
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = $16
  .const OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR = $20
  .const OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR = $21
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
  .const OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL = $5a
  .const SIZEOF_BYTE = 1
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC III MOS 4567/4569
  .label VICIII = $d000
  // The VIC IV
  .label VICIV = $d000
  // Palette RED
  .label PALETTE_RED = $d100
  // Palette GREEN
  .label PALETTE_GREEN = $d200
  // Palette BLUE
  .label PALETTE_BLUE = $d300
  // Color Ram
  .label COLORRAM = $d800
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $400
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Pointer to the song init routine
  .label songInit = SONG
  // Pointer to the song play routine
  .label songPlay = SONG+3
  // Sinus Position (used across effects)
  .label sin_idx = $17
  // scroll soft position of text scrolly (0-7)
  .label scroll_soft = $18
  // scroll text pointer to next char
  .label scroll_ptr = $19
  // Zoom Position
  .label greet_zoomx = $1b
  // The greeting currently being shown
  .label greet_idx = $1c
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] (volatile byte) sin_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // [2] (volatile byte) scroll_soft ← (byte) 7 -- vbuz1=vbuc1 
    lda #7
    sta.z scroll_soft
    // [3] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT -- pbuz1=pbuc1 
    lda #<SCROLL_TEXT
    sta.z scroll_ptr
    lda #>SCROLL_TEXT
    sta.z scroll_ptr+1
    // [4] (volatile byte) greet_zoomx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_zoomx
    // [5] (volatile byte) greet_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_idx
    // [6] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [7] call main 
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [8] return 
    rts
}
  // irq
// BIG INTERRUPT LOOP
irq: {
    .label __10 = $25
    .label __26 = $1f
    .label __27 = $20
    .label __29 = $1e
    .label __33 = $1d
    .label wobble_idx = 3
    .label col = $23
    .label sin_col = 5
    .label zoomval = $24
    .label raster = $26
    .label line = 2
    .label col1 = $21
    .label col1_1 = $22
    .label i = 4
    .label l = 6
    .label sin_bar = 8
    .label idx = $11
    .label barcol = $10
    .label i1 = $e
    .label i2 = $f
    .label barcnt = 7
    .label i3 = 9
    .label greet_offset = $b
    .label i4 = $a
    .label i5 = $c
    .label nxt = $d
    // entry interrupt(HARDWARE_STACK)
    pha
    txa
    pha
    tya
    pha
    // [9] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // force NTSC every frame (hehe)
    lda #$80
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_RASLINE0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_RASLINE0
    // [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [11] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // reset x scroll
    lda #0
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    // [12] (volatile byte) sin_idx ← ++ (volatile byte) sin_idx -- vbuz1=_inc_vbuz1 
    inc.z sin_idx
    // [13] (byte) irq::wobble_idx#0 ← (volatile byte) sin_idx -- vbuz1=vbuz2 
    // Generate Raster Bars and more
    lda.z sin_idx
    sta.z wobble_idx
    // [14] phi from irq to irq::@1 [phi:irq->irq::@1]
  __b1_from_irq:
    // [14] phi (byte) irq::wobble_idx#10 = (byte) irq::wobble_idx#0 [phi:irq->irq::@1#0] -- register_copy 
    // [14] phi (byte) irq::line#10 = (byte) 0 [phi:irq->irq::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z line
    jmp __b1
    // irq::@1
  __b1:
    // [15] if((byte) irq::line#10!=(const nomodify byte) RASTER_LINES) goto irq::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #RASTER_LINES
    cmp.z line
    bne __b2
    jmp __b3
    // irq::@3
  __b3:
    // [16] call *((const void()*) songPlay) 
    // play music
    jsr songPlay
    // [17] (byte) irq::sin_col#0 ← (volatile byte) sin_idx -- vbuz1=vbuz2 
    // Set up colors behind logo, scroll and greets
    lda.z sin_idx
    sta.z sin_col
    // [18] phi from irq::@3 to irq::@16 [phi:irq::@3->irq::@16]
  __b16_from___b3:
    // [18] phi (byte) irq::sin_col#2 = (byte) irq::sin_col#0 [phi:irq::@3->irq::@16#0] -- register_copy 
    // [18] phi (byte) irq::i#2 = (byte) 0 [phi:irq::@3->irq::@16#1] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b16
    // irq::@16
  __b16:
    // [19] if((byte) irq::i#2<(byte) $28) goto irq::@17 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$28
    bcc __b17
    // [20] phi from irq::@16 to irq::@18 [phi:irq::@16->irq::@18]
  __b18_from___b16:
    // [20] phi (byte) irq::l#2 = (byte) 0 [phi:irq::@16->irq::@18#0] -- vbuz1=vbuc1 
    lda #0
    sta.z l
    jmp __b18
  // Set all raster bars to black
    // irq::@18
  __b18:
    // [21] if((byte) irq::l#2!=(const nomodify byte) RASTER_LINES) goto irq::@19 -- vbuz1_neq_vbuc1_then_la1 
    lda #RASTER_LINES
    cmp.z l
    bne __b19
    jmp __b20
    // irq::@20
  __b20:
    // [22] (byte) irq::sin_bar#0 ← (volatile byte) sin_idx -- vbuz1=vbuz2 
    // Big block of bars (16)
    lda.z sin_idx
    sta.z sin_bar
    // [23] phi from irq::@20 to irq::@21 [phi:irq::@20->irq::@21]
  __b21_from___b20:
    // [23] phi (byte) irq::sin_bar#2 = (byte) irq::sin_bar#0 [phi:irq::@20->irq::@21#0] -- register_copy 
    // [23] phi (byte) irq::barcnt#2 = (byte) 0 [phi:irq::@20->irq::@21#1] -- vbuz1=vbuc1 
    lda #0
    sta.z barcnt
    jmp __b21
    // irq::@21
  __b21:
    // [24] if((byte) irq::barcnt#2<(byte) $10) goto irq::@22 -- vbuz1_lt_vbuc1_then_la1 
    lda.z barcnt
    cmp #$10
    bcc __b22
    // [25] phi from irq::@21 to irq::@28 [phi:irq::@21->irq::@28]
  __b28_from___b21:
    // [25] phi (byte) irq::i3#2 = (byte) 0 [phi:irq::@21->irq::@28#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i3
    jmp __b28
  // Produce dark area behind text
    // irq::@28
  __b28:
    // [26] if((byte) irq::i3#2<(byte) $13) goto irq::@29 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i3
    cmp #$13
    bcc __b29
    jmp __b30
    // irq::@30
  __b30:
    // [27] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx << (byte) 4 -- vbuz1=vbuz2_rol_4 
    lda.z greet_idx
    asl
    asl
    asl
    asl
    sta.z greet_offset
    // [28] phi from irq::@30 to irq::@31 [phi:irq::@30->irq::@31]
  __b31_from___b30:
    // [28] phi (byte) irq::greet_offset#2 = (byte) irq::greet_offset#0 [phi:irq::@30->irq::@31#0] -- register_copy 
    // [28] phi (byte) irq::i4#2 = (byte) 0 [phi:irq::@30->irq::@31#1] -- vbuz1=vbuc1 
    lda #0
    sta.z i4
    jmp __b31
    // irq::@31
  __b31:
    // [29] if((byte) irq::i4#2<(byte) $10) goto irq::@32 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i4
    cmp #$10
    bcc __b32
    jmp __b33
    // irq::@33
  __b33:
    // [30] (volatile byte) scroll_soft ← -- (volatile byte) scroll_soft -- vbuz1=_dec_vbuz1 
    dec.z scroll_soft
    // [31] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z scroll_soft
    bne __breturn
    jmp __b34
    // irq::@34
  __b34:
    // [32] (volatile byte) scroll_soft ← (byte) 7 -- vbuz1=vbuc1 
    lda #7
    sta.z scroll_soft
    // [33] phi from irq::@34 to irq::@35 [phi:irq::@34->irq::@35]
  __b35_from___b34:
    // [33] phi (byte) irq::i5#2 = (byte) 0 [phi:irq::@34->irq::@35#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i5
    jmp __b35
  // Move scroll on screen
    // irq::@35
  __b35:
    // [34] if((byte) irq::i5#2<(byte) $27) goto irq::@36 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i5
    cmp #$27
    bcc __b36
    jmp __b37
    // irq::@37
  __b37:
    // [35] (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr) -- vbuz1=_deref_pbuz2 
    // Show next char
    ldy #0
    lda (scroll_ptr),y
    sta.z nxt
    // [36] (volatile byte*) scroll_ptr ← ++ (volatile byte*) scroll_ptr -- pbuz1=_inc_pbuz1 
    inw.z scroll_ptr
    // [37] if((byte) irq::nxt#0!=(byte) 0) goto irq::@39 -- vbuz1_neq_0_then_la1 
    lda.z nxt
    cmp #0
    bne __b39_from___b37
    jmp __b38
    // irq::@38
  __b38:
    // [38] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT -- pbuz1=pbuc1 
    lda #<SCROLL_TEXT
    sta.z scroll_ptr
    lda #>SCROLL_TEXT
    sta.z scroll_ptr+1
    // [39] (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr) -- vbuz1=_deref_pbuz2 
    ldy #0
    lda (scroll_ptr),y
    sta.z nxt
    // [40] phi from irq::@37 irq::@38 to irq::@39 [phi:irq::@37/irq::@38->irq::@39]
  __b39_from___b37:
  __b39_from___b38:
    // [40] phi (byte) irq::nxt#2 = (byte) irq::nxt#0 [phi:irq::@37/irq::@38->irq::@39#0] -- register_copy 
    jmp __b39
    // irq::@39
  __b39:
    // [41] (byte~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf -- vbuz1=vbuz2_band_vbuc1 
    lda #$bf
    and.z nxt
    sta.z __33
    // [42] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) $27) ← (byte~) irq::$33 -- _deref_pbuc1=vbuz1 
    lda.z __33
    sta DEFAULT_SCREEN+SCROLL_ROW*$28+$27
    jmp __breturn
    // irq::@return
  __breturn:
    // [43] return  - exit interrupt(HARDWARE_STACK)
    pla
    tay
    pla
    tax
    pla
    rti
    // irq::@36
  __b36:
    // [44] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i5#2) ← *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) 1 + (byte) irq::i5#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i5
    lda DEFAULT_SCREEN+SCROLL_ROW*$28+1,y
    sta DEFAULT_SCREEN+SCROLL_ROW*$28,y
    // [45] (byte) irq::i5#1 ← ++ (byte) irq::i5#2 -- vbuz1=_inc_vbuz1 
    inc.z i5
    // [33] phi from irq::@36 to irq::@35 [phi:irq::@36->irq::@35]
  __b35_from___b36:
    // [33] phi (byte) irq::i5#2 = (byte) irq::i5#1 [phi:irq::@36->irq::@35#0] -- register_copy 
    jmp __b35
    // irq::@32
  __b32:
    // [46] (byte~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf -- vbuz1=pbuc1_derefidx_vbuz2_band_vbuc2 
    lda #$bf
    ldy.z greet_offset
    and GREETING,y
    sta.z __29
    // [47] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28+(byte) $d + (byte) irq::i4#2) ← (byte~) irq::$29 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __29
    ldy.z i4
    sta DEFAULT_SCREEN+GREET_ROW*$28+$d,y
    // [48] (byte) irq::greet_offset#1 ← ++ (byte) irq::greet_offset#2 -- vbuz1=_inc_vbuz1 
    inc.z greet_offset
    // [49] (byte) irq::i4#1 ← ++ (byte) irq::i4#2 -- vbuz1=_inc_vbuz1 
    inc.z i4
    // [28] phi from irq::@32 to irq::@31 [phi:irq::@32->irq::@31]
  __b31_from___b32:
    // [28] phi (byte) irq::greet_offset#2 = (byte) irq::greet_offset#1 [phi:irq::@32->irq::@31#0] -- register_copy 
    // [28] phi (byte) irq::i4#2 = (byte) irq::i4#1 [phi:irq::@32->irq::@31#1] -- register_copy 
    jmp __b31
    // irq::@29
  __b29:
    // [50] (byte~) irq::$26 ← *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) >> (byte) 1 -- vbuz1=pbuc1_derefidx_vbuz2_ror_1 
    ldy.z i3
    lda rasters+SCROLL_Y,y
    lsr
    sta.z __26
    // [51] (byte~) irq::$27 ← (byte~) irq::$26 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z __26
    sta.z __27
    // [52] *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) ← (byte~) irq::$27 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __27
    ldy.z i3
    sta rasters+SCROLL_Y,y
    // [53] (byte) irq::i3#1 ← ++ (byte) irq::i3#2 -- vbuz1=_inc_vbuz1 
    inc.z i3
    // [25] phi from irq::@29 to irq::@28 [phi:irq::@29->irq::@28]
  __b28_from___b29:
    // [25] phi (byte) irq::i3#2 = (byte) irq::i3#1 [phi:irq::@29->irq::@28#0] -- register_copy 
    jmp __b28
    // irq::@22
  __b22:
    // [54] (byte) irq::idx#0 ← *((const byte*) SINUS + (byte) irq::sin_bar#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z sin_bar
    lda SINUS,y
    sta.z idx
    // [55] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 << (byte) 4 -- vbuz1=vbuz2_rol_4 
    lda.z barcnt
    asl
    asl
    asl
    asl
    sta.z barcol
    // [56] phi from irq::@22 to irq::@23 [phi:irq::@22->irq::@23]
  __b23_from___b22:
    // [56] phi (byte) irq::idx#3 = (byte) irq::idx#0 [phi:irq::@22->irq::@23#0] -- register_copy 
    // [56] phi (byte) irq::barcol#3 = (byte) irq::barcol#0 [phi:irq::@22->irq::@23#1] -- register_copy 
    // [56] phi (byte) irq::i1#2 = (byte) 0 [phi:irq::@22->irq::@23#2] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    jmp __b23
    // irq::@23
  __b23:
    // [57] if((byte) irq::i1#2<(byte) $10) goto irq::@24 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i1
    cmp #$10
    bcc __b24
    // [58] phi from irq::@23 to irq::@25 [phi:irq::@23->irq::@25]
  __b25_from___b23:
    // [58] phi (byte) irq::idx#4 = (byte) irq::idx#3 [phi:irq::@23->irq::@25#0] -- register_copy 
    // [58] phi (byte) irq::barcol#4 = (byte) irq::barcol#3 [phi:irq::@23->irq::@25#1] -- register_copy 
    // [58] phi (byte) irq::i2#2 = (byte) 0 [phi:irq::@23->irq::@25#2] -- vbuz1=vbuc1 
    lda #0
    sta.z i2
    jmp __b25
    // irq::@25
  __b25:
    // [59] if((byte) irq::i2#2<(byte) $f) goto irq::@26 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i2
    cmp #$f
    bcc __b26
    jmp __b27
    // irq::@27
  __b27:
    // [60] (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#2 + (byte) $a -- vbuz1=vbuz1_plus_vbuc1 
    lda #$a
    clc
    adc.z sin_bar
    sta.z sin_bar
    // [61] (byte) irq::barcnt#1 ← ++ (byte) irq::barcnt#2 -- vbuz1=_inc_vbuz1 
    inc.z barcnt
    // [23] phi from irq::@27 to irq::@21 [phi:irq::@27->irq::@21]
  __b21_from___b27:
    // [23] phi (byte) irq::sin_bar#2 = (byte) irq::sin_bar#1 [phi:irq::@27->irq::@21#0] -- register_copy 
    // [23] phi (byte) irq::barcnt#2 = (byte) irq::barcnt#1 [phi:irq::@27->irq::@21#1] -- register_copy 
    jmp __b21
    // irq::@26
  __b26:
    // [62] (byte) irq::barcol#2 ← -- (byte) irq::barcol#4 -- vbuz1=_dec_vbuz1 
    dec.z barcol
    // [63] *((const byte*) rasters + (byte) irq::idx#4) ← (byte) irq::barcol#2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z barcol
    ldy.z idx
    sta rasters,y
    // [64] (byte) irq::idx#2 ← ++ (byte) irq::idx#4 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [65] (byte) irq::i2#1 ← ++ (byte) irq::i2#2 -- vbuz1=_inc_vbuz1 
    inc.z i2
    // [58] phi from irq::@26 to irq::@25 [phi:irq::@26->irq::@25]
  __b25_from___b26:
    // [58] phi (byte) irq::idx#4 = (byte) irq::idx#2 [phi:irq::@26->irq::@25#0] -- register_copy 
    // [58] phi (byte) irq::barcol#4 = (byte) irq::barcol#2 [phi:irq::@26->irq::@25#1] -- register_copy 
    // [58] phi (byte) irq::i2#2 = (byte) irq::i2#1 [phi:irq::@26->irq::@25#2] -- register_copy 
    jmp __b25
    // irq::@24
  __b24:
    // [66] *((const byte*) rasters + (byte) irq::idx#3) ← (byte) irq::barcol#3 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z barcol
    ldy.z idx
    sta rasters,y
    // [67] (byte) irq::idx#1 ← ++ (byte) irq::idx#3 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [68] (byte) irq::barcol#1 ← ++ (byte) irq::barcol#3 -- vbuz1=_inc_vbuz1 
    inc.z barcol
    // [69] (byte) irq::i1#1 ← ++ (byte) irq::i1#2 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [56] phi from irq::@24 to irq::@23 [phi:irq::@24->irq::@23]
  __b23_from___b24:
    // [56] phi (byte) irq::idx#3 = (byte) irq::idx#1 [phi:irq::@24->irq::@23#0] -- register_copy 
    // [56] phi (byte) irq::barcol#3 = (byte) irq::barcol#1 [phi:irq::@24->irq::@23#1] -- register_copy 
    // [56] phi (byte) irq::i1#2 = (byte) irq::i1#1 [phi:irq::@24->irq::@23#2] -- register_copy 
    jmp __b23
    // irq::@19
  __b19:
    // [70] *((const byte*) rasters + (byte) irq::l#2) ← (byte) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy.z l
    sta rasters,y
    // [71] (byte) irq::l#1 ← ++ (byte) irq::l#2 -- vbuz1=_inc_vbuz1 
    inc.z l
    // [20] phi from irq::@19 to irq::@18 [phi:irq::@19->irq::@18]
  __b18_from___b19:
    // [20] phi (byte) irq::l#2 = (byte) irq::l#1 [phi:irq::@19->irq::@18#0] -- register_copy 
    jmp __b18
    // irq::@17
  __b17:
    // [72] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) >> (byte) 2 -- vbuz1=pbuc1_derefidx_vbuz2_ror_2 
    ldy.z sin_col
    lda SINUS,y
    lsr
    lsr
    sta.z col1
    // [73] *((const nomodify byte*) COLORRAM+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) irq::i#2) ← (byte) irq::col1#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1
    ldy.z i
    sta COLORRAM+GREET_ROW*$28,y
    // [74] (byte) irq::col1#1 ← (byte) irq::col1#0 >> (byte) 1 -- vbuz1=vbuz2_ror_1 
    // Logo colors
    lda.z col1
    lsr
    sta.z col1_1
    // [75] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28-(byte) 1 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1_1
    ldy.z i
    sta COLORRAM+LOGO_ROW*$28-1,y
    // [76] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 1*(number) $28-(byte) 2 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1_1
    ldy.z i
    sta COLORRAM+LOGO_ROW*$28+1*$28-2,y
    // [77] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 2*(number) $28-(byte) 3 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1_1
    ldy.z i
    sta COLORRAM+LOGO_ROW*$28+2*$28-3,y
    // [78] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 3*(number) $28-(byte) 4 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1_1
    ldy.z i
    sta COLORRAM+LOGO_ROW*$28+3*$28-4,y
    // [79] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 4*(number) $28-(byte) 5 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1_1
    ldy.z i
    sta COLORRAM+LOGO_ROW*$28+4*$28-5,y
    // [80] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 5*(number) $28-(byte) 6 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z col1_1
    ldy.z i
    sta COLORRAM+LOGO_ROW*$28+5*$28-6,y
    // [81] *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i#2) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    // Scroll colors
    ldy.z sin_col
    lda PAL_GREEN,y
    ldy.z i
    sta COLORRAM+SCROLL_ROW*$28,y
    // [82] (byte) irq::sin_col#1 ← ++ (byte) irq::sin_col#2 -- vbuz1=_inc_vbuz1 
    inc.z sin_col
    // [83] (byte) irq::i#1 ← ++ (byte) irq::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [18] phi from irq::@17 to irq::@16 [phi:irq::@17->irq::@16]
  __b16_from___b17:
    // [18] phi (byte) irq::sin_col#2 = (byte) irq::sin_col#1 [phi:irq::@17->irq::@16#0] -- register_copy 
    // [18] phi (byte) irq::i#2 = (byte) irq::i#1 [phi:irq::@17->irq::@16#1] -- register_copy 
    jmp __b16
    // irq::@2
  __b2:
    // [84] (byte) irq::col#0 ← *((const byte*) rasters + (byte) irq::line#10) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z line
    lda rasters,y
    sta.z col
    // [85] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR) ← (byte) irq::col#0 -- _deref_pbuc1=vbuz1 
    lda.z col
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR
    // [86] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR) ← (byte) irq::col#0 -- _deref_pbuc1=vbuz1 
    lda.z col
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR
    // [87] if((byte) irq::line#10<(const nomodify byte) SCROLL_Y) goto irq::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #SCROLL_Y
    bcc __b4
    jmp __b10
    // irq::@10
  __b10:
    // [88] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y) goto irq::@5 -- vbuz1_eq_vbuc1_then_la1 
    lda #SCROLL_Y
    cmp.z line
    beq __b5
    jmp __b11
    // irq::@11
  __b11:
    // [89] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS) goto irq::@6 -- vbuz1_eq_vbuc1_then_la1 
    lda #SCROLL_Y+SCROLL_BLACKBARS
    cmp.z line
    beq __b6
    jmp __b12
    // irq::@12
  __b12:
    // [90] if((byte) irq::line#10!=(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1) goto irq::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #SCROLL_Y+SCROLL_BLACKBARS+1
    cmp.z line
    bne __b7_from___b12
    jmp __b13
    // irq::@13
  __b13:
    // [91] (byte) irq::zoomval#0 ← *((const byte*) SINUS + (volatile byte) greet_zoomx) -- vbuz1=pbuc1_derefidx_vbuz2 
    // if raster position > SCROLL_Y pos do zoom
    ldy.z greet_zoomx
    lda SINUS,y
    sta.z zoomval
    // [92] (volatile byte) greet_zoomx ← ++ (volatile byte) greet_zoomx -- vbuz1=_inc_vbuz1 
    inc.z greet_zoomx
    // [93] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) irq::zoomval#0 -- _deref_pbuc1=vbuz1 
    lda.z zoomval
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL
    // [94] (byte~) irq::$10 ← (byte) irq::zoomval#0 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    lda.z zoomval
    inc
    sta.z __10
    // [95] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte~) irq::$10 -- _deref_pbuc1=vbuz1 
    lda.z __10
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [96] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7 -- vbuz1_neq_0_then_la1 
    lda.z greet_zoomx
    cmp #0
    bne __b7_from___b13
    jmp __b14
    // irq::@14
  __b14:
    // [97] (volatile byte) greet_idx ← ++ (volatile byte) greet_idx -- vbuz1=_inc_vbuz1 
    inc.z greet_idx
    // [98] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #GREET_COUNT
    cmp.z greet_idx
    bne __b7_from___b14
    jmp __b15
    // irq::@15
  __b15:
    // [99] (volatile byte) greet_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_idx
    // [100] phi from irq::@12 irq::@13 irq::@14 irq::@15 irq::@4 irq::@5 irq::@6 to irq::@7 [phi:irq::@12/irq::@13/irq::@14/irq::@15/irq::@4/irq::@5/irq::@6->irq::@7]
  __b7_from___b12:
  __b7_from___b13:
  __b7_from___b14:
  __b7_from___b15:
  __b7_from___b4:
  __b7_from___b5:
  __b7_from___b6:
    // [100] phi (byte) irq::wobble_idx#7 = (byte) irq::wobble_idx#10 [phi:irq::@12/irq::@13/irq::@14/irq::@15/irq::@4/irq::@5/irq::@6->irq::@7#0] -- register_copy 
    jmp __b7
    // irq::@7
  __b7:
    // [101] (byte) irq::raster#0 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuz1=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    sta.z raster
    jmp __b8
    // irq::@8
  __b8:
    // [102] if((byte) irq::raster#0==*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)) goto irq::@8 -- vbuz1_eq__deref_pbuc1_then_la1 
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    cmp.z raster
    beq __b8
    jmp __b9
    // irq::@9
  __b9:
    // [103] (byte) irq::line#1 ← ++ (byte) irq::line#10 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [14] phi from irq::@9 to irq::@1 [phi:irq::@9->irq::@1]
  __b1_from___b9:
    // [14] phi (byte) irq::wobble_idx#10 = (byte) irq::wobble_idx#7 [phi:irq::@9->irq::@1#0] -- register_copy 
    // [14] phi (byte) irq::line#10 = (byte) irq::line#1 [phi:irq::@9->irq::@1#1] -- register_copy 
    jmp __b1
    // irq::@6
  __b6:
    // [104] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 -- _deref_pbuc1=vbuc2 
    // if raster position > SCROLL_Y pos do nozoom
    // default value
    lda #$50
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    jmp __b7_from___b6
    // irq::@5
  __b5:
    // [105] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 -- _deref_pbuc1=vbuc2 
    // if raster position = SCROLL_Y pos do scroll
    // no wobbling from this point
    lda #$50
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [106] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft -- _deref_pbuc1=vbuz1 
    // set softscroll
    lda.z scroll_soft
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    jmp __b7_from___b5
    // irq::@4
  __b4:
    // [107] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#10) -- _deref_pbuc1=pbuc2_derefidx_vbuz1 
    // if raster position < SCROLL_Y pos do wobble Logo!
    ldy.z wobble_idx
    lda SINUS,y
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [108] (byte) irq::wobble_idx#1 ← ++ (byte) irq::wobble_idx#10 -- vbuz1=_inc_vbuz1 
    inc.z wobble_idx
    // [109] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66 -- _deref_pbuc1=vbuc2 
    // No zooming
    lda #$66
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL
    jmp __b7_from___b4
}
  // main
main: {
    .label i1 = $12
    .label i2 = $13
    // Set up 256 color palette
    .label i = $14
    // [110] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [111] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [112] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (byte) $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // [113] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (byte) $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // asm { lda#0  }
    // Initialize music
    lda #0
    // [115] call *((const void()*) songInit) 
    jsr songInit
    // [116] call memset 
  // Clear screen 
    // [142] phi from main to memset [phi:main->memset]
  memset_from_main:
    jsr memset
    // [117] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [117] phi (byte) main::i1#2 = (byte) 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    jmp __b1
  // Put MEGA logo on screen
    // main::@1
  __b1:
    // [118] if((byte) main::i1#2<(byte) $bc*(const byte) SIZEOF_BYTE) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i1
    cmp #$bc*SIZEOF_BYTE
    bcc __b2
    // [119] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    // [119] phi (byte) main::i2#2 = (byte) 0 [phi:main::@1->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i2
    jmp __b3
  // Put '*' as default greeting
    // main::@3
  __b3:
    // [120] if((byte) main::i2#2<(byte) $28) goto main::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i2
    cmp #$28
    bcc __b4
    // [121] phi from main::@3 to main::@5 [phi:main::@3->main::@5]
  __b5_from___b3:
    // [121] phi (byte) main::i#2 = (byte) 0 [phi:main::@3->main::@5#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b5
    // [121] phi from main::@5 to main::@5 [phi:main::@5->main::@5]
  __b5_from___b5:
    // [121] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@5->main::@5#0] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [122] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda PAL_RED,y
    sta PALETTE_RED,y
    // [123] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda PAL_GREEN,y
    sta PALETTE_GREEN,y
    // [124] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i
    lda PAL_BLUE,y
    sta PALETTE_BLUE,y
    // [125] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [126] if((byte) main::i#1!=(byte) 0) goto main::@5 -- vbuz1_neq_0_then_la1 
    lda.z i
    cmp #0
    bne __b5_from___b5
    jmp __b6
    // main::@6
  __b6:
    // asm { sei  }
    // Set up raster interrupts C64 style
    sei
    // [128] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [129] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y -- _deref_pbuc1=vbuc2 
    // Set raster line to 0x16
    lda #IRQ_Y
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [130] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // [131] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // [132] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq() -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // [133] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [134] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [135] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // asm { cli  }
    // Enable IRQ
    cli
    // [137] phi from main::@6 main::@7 to main::@7 [phi:main::@6/main::@7->main::@7]
  __b7_from___b6:
  __b7_from___b7:
    jmp __b7
    // main::@7
  __b7:
    jmp __b7_from___b7
    // main::@4
  __b4:
    // [138] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) main::i2#2) ← (byte) '*' -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #'*'
    ldy.z i2
    sta DEFAULT_SCREEN+GREET_ROW*$28,y
    // [139] (byte) main::i2#1 ← ++ (byte) main::i2#2 -- vbuz1=_inc_vbuz1 
    inc.z i2
    // [119] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [119] phi (byte) main::i2#2 = (byte) main::i2#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
    // main::@2
  __b2:
    // [140] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) LOGO_ROW*(byte) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z i1
    lda MEGA_LOGO,y
    sta DEFAULT_SCREEN+LOGO_ROW*$28,y
    // [141] (byte) main::i1#1 ← ++ (byte) main::i1#2 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [117] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [117] phi (byte) main::i1#2 = (byte) main::i1#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $28*$19
    .label str = DEFAULT_SCREEN
    .label end = str+num
    .label dst = $15
    // [143] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [143] phi (byte*) memset::dst#2 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [144] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [145] return 
    rts
    // memset::@2
  __b2:
    // [146] *((byte*) memset::dst#2) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [147] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inw.z dst
    // [143] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [143] phi (byte*) memset::dst#2 = (byte*) memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  // A MEGA logo
  MEGA_LOGO: .byte $20, $20, $20, $20, $20, $cf, $cf, $cf, $20, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $20, $cf, $cf, $20, $cf, $20, $cf, $20, $20, $20, $cf, $cf, $20, $20, $20, $20, $cf, $cf, $20, $20, $20, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $20, $20, $cf, $20, $cf, $cf, $cf, $cf, $cf, $20, $cf, $cf, $20, $cf, $cf, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $20, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $cf, $cf, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $20, $20, $20, $20, $cf, $cf, $20, $cf, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $cf, $20, $20, $20, $cf
  // Greetings
  GREETING: .text "   DOUBLEFLASH        ADTBM          SY2002          TAYGER         SERIOUSLY   LIBI IN PARADIZE       LGB          BLUEWAYSW        SAUSAGE       BIT SHIFTER     INDIOCOLIFA     GRUMPYNINJA      0-LIMITS         CHEVERON     DR. COMMODORE "
  .byte 0
  // Scroll text
  SCROLL_TEXT: .text "    THIS SMALL MEGA65 RASTER INTRO ... WAS MADE BY DEFT IN 2015 ... AND BROUGHT BACK TO LIFE 5 YEARS LATER IN 2020 ... BECAUSE THE MEGA65 HARDWARE CHANGED SO MUCH IN THE PAST 5 YEARS ... UNFORTUNATELY MY ASSEMBLER SKILLS DID NOT SO THIS IS THE FIRST APPROACH TO GET BETTER ... HOPEFULLY DR.MUTTI WILL HAVE TO SCOLD ME LESS ... THE PAST 5 YEARS HAVE BEEN AN UNFORGETTABLE & UNIQUE RIDE ... IF YOU DO WATCH THIS DEMO ON YOUR VERY OWN MEGA65 THERE IS ENOUGH EVIDENCE OF WHAT WE ACTUALLY ACHIEVED ... BELOW ARE THE GREETINGS TO DEAR AND VERY SPECIAL PEOPLE WHO HELPED TO GET THERE ... THANK YOU SO MUCH FOR YOUR SUPPORT AND FOR NOT GIVING UP ... DUAL SID TUNE BY RAYDEN OF ALPHA FLIGHT ... THIS SCROLLY WILL NOW RESTART           *WRAP*                    "
  .byte 0
.pc = $fc0 "SONG"
  // Music at an absolute address
SONG:
.import c64 "DiscoZak_2SID_patched.prg"

.pc = $2c00 "SINUS"
  // Sinus Values 0-183
SINUS:
.fill 256, 91.5 + 91.5*sin(i*2*PI/256)

.pc = $3000 "rasters"
  // Moving Raster Bars
  rasters: .fill RASTER_LINES, 0
.pc = $2d00 "PAL_RED"
  PAL_RED: .byte 0, $f3, $d4, $b5, $a6, $97, $88, $79, $1a, $fa, $eb, $ec, $bd, $be, $af, $ff, $16, $c6, $a7, $88, $49, $5a, $2b, $1c, $ac, $ad, $8e, $8f, $ff, $ff, $ff, $ff, $c6, $77, $48, $29, $e9, $fa, $cb, $cc, $5d, $4e, $2f, $ff, $ff, $ff, $ff, $ff, $57, $18, $f8, $d9, $aa, $8b, $6c, $5d, $ed, $de, $cf, $ff, $ff, $ff, $ff, $ff, $26, $e6, $b7, $a8, $69, $5a, $3b, $3c, $dc, $cd, $ae, $9f, $ff, $ff, $ff, $ff, $65, $16, $17, $f7, $d8, $b9, $9a, $8b, $2c, $d, $fd, $ee, $cf, $ff, $ff, $ff, $64, $15, 6, $e6, $c7, $a8, $99, $8a, $1b, $c, $fc, $fd, $ee, $cf, $ff, $ff, $12, $d2, $d3, $b4, $95, $86, $77, $78, 9, $69, $ea, $fb, $dc, $ad, $ae, $af, $f0, $c1, $c2, $a3, $84, $85, $76, $67, 8, $f8, $e9, $da, $db, $bc, $bd, $ae, $40, $11, $12, $f2, $e3, $d4, $c5, $c6, $47, $38, $39, $2a, $1b, $c, $d, $ed, 0, 0, $f0, $d1, $c2, $b3, $a4, $95, $36, $27, $28, $29, $f9, $ea, $eb, $ec, $70, $41, $22, $23, $f3, $f4, $e5, $e6, $77, $78, $69, $7a, $3b, $3c, $3d, $3e, $a1, $82, $63, $54, $35, $26, 7, 8, $98, $99, $8a, $7b, $5c, $5d, $3e, $3f, $33, 4, $d4, $d5, $a6, $a7, $88, $89, $1a, $ab, $fb, $ec, $cd, $be, $af, $ff, $b4, $85, $56, $47, $18, 9, $f9, $ea, $7b, $7c, $5d, $5e, $2f, $ef, $ff, $ff, 6, $d6, $a7, $98, $59, $4a, $2b, $2c, $bc, $ad, $8e, $8f, $ff, $ff, $ff, $ff
.pc = $2e00 "PAL_GREEN"
  PAL_GREEN: .byte 0, $e3, $c4, $b5, $96, $87, $78, $79, $a, $fa, $eb, $dc, $bd, $ae, $af, $ff, $e2, $b3, $a4, $85, $76, $67, $48, $49, $d9, $da, $bb, $bc, $8d, $8e, $7f, $ff, $42, 3, 4, $e4, $d5, $c6, $b7, $a8, $39, $3a, $1b, $2c, $fc, $fd, $de, $df, $61, $32, $13, 4, $e4, $e5, $d6, $d7, $78, $59, $4a, $4b, $2c, $1d, $e, $fe, $e0, $b1, $a2, $93, $74, $75, $56, $57, $e7, $d8, $79, $ca, $ab, $9c, $9d, $8e, $f0, $d1, $c2, $a3, $84, $85, $76, $77, 8, 9, $f9, $fa, $db, $cc, $bd, $ae, $61, $22, $23, $14, $f4, $e5, $d6, $c7, $58, $59, $3a, $3b, $1c, $d, $fd, $fe, $92, $53, $44, $35, $16, $f6, $e7, $e8, $79, $6a, $5b, $4c, $2d, $3e, $1f, $ef, $53, $14, 5, $e5, $c6, $b7, $a8, $99, $2a, $2b, $c, $d, $dd, $ce, $cf, $ff, $f3, $b4, $95, $86, $57, $38, $29, $1a, $ba, $ab, $9c, $8d, $6e, $5f, $ff, $ff, $95, $56, $27, $18, $e8, $d9, $ca, $bb, $4c, $3d, $2e, $1f, $ef, $ff, $ff, $ff, $c5, $86, $57, $38, $19, $a, $ea, $db, $6c, $5d, $3e, $3f, $ef, $ff, $ff, $ff, $65, $26, 7, $e7, $c8, $b9, $9a, $9b, $2c, $1d, $fd, $fe, $cf, $ff, $ff, $ff, $b4, $75, $56, $37, $28, $19, $e9, $ea, $7b, $6c, $5d, $4e, $2f, $ff, $ff, $ff, $c3, $94, $75, $56, $47, $38, $19, $1a, $aa, $ab, $7c, $7d, $5e, $4f, $ff, $ff, $e2, $a3, $94, $85, $76, $67, $38, $49, $d9, $ca, $ab, $bc, $7d, $7e, $6f, $ff
.pc = $2f00 "PAL_BLUE"
  PAL_BLUE: .byte 0, $f3, $d4, $b5, $a6, $97, $88, $79, $1a, $fa, $eb, $ec, $bd, $be, $af, $ff, 0, 0, 0, 0, $c0, $b1, $a2, $a3, $34, $35, $26, $27, $f7, $f8, $f9, $ea, 0, 0, $30, $11, $22, $13, $14, 5, $b5, $96, $97, $98, $79, $6a, $5b, $4c, $81, $42, $43, $34, 5, 6, $f6, $f7, $78, $69, $5a, $5b, $4c, $3d, $1e, $f, $17, $c7, $a8, $89, $5a, $5b, $3c, $1d, $ad, $9e, $7f, $ff, $ff, $ff, $ff, $ff, $78, 9, $e9, $ca, $ab, $7c, $5d, $5e, $de, $cf, $ff, $ff, $ff, $ff, $ff, $ff, $59, $a, $ca, $bb, $8c, $6d, $3e, $2f, $bf, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $49, $f9, $da, $ab, $7c, $5d, $2e, $2f, $af, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $48, $d8, $b9, $aa, $7b, $5c, $2d, $2e, $be, $9f, $ff, $ff, $ff, $ff, $ff, $ff, 7, $97, $88, $69, $4a, $2b, $1c, $2d, $9d, $7e, $6f, $ff, $ff, $ff, $ff, $ff, $81, $62, $53, $44, 5, 6, $f6, $e7, $78, $69, $5a, $5b, $3c, $2d, $2e, $1f, 0, 0, 0, 0, $b0, $b1, $a2, $b3, $44, $35, $36, $37, 8, $f8, $a, $b, 0, 0, 0, 0, 0, $70, $61, $62, $f2, $e3, $d4, $c5, $b6, $b7, $b8, $99, 0, 0, 0, 0, 0, 0, $f0, $f1, $82, $83, $84, $85, $66, $57, $58, $59, 0, 0, 0, 0, 0, $70, $61, $62, $e2, $e3, $d4, $d5, $b6, $a7, $b8, $a9, 0, 0, 0, 0, $a0, $b1, $a2, $a3, $44, $35, $26, $37, $f7, $19, $f9, $fa

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] (volatile byte) sin_idx ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] (volatile byte) scroll_soft ← (byte) 7 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] (volatile byte) greet_zoomx ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] (volatile byte) greet_idx ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] { }  ) always clobbers reg byte a 
Statement [16] call *((const void()*) songPlay)  [ sin_idx scroll_soft scroll_ptr greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_idx ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [27] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx << (byte) 4 [ scroll_soft scroll_ptr irq::greet_offset#0 ] (  [ scroll_soft scroll_ptr irq::greet_offset#0 ] { }  ) always clobbers reg byte a 
Statement [31] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return [ scroll_ptr ] (  [ scroll_ptr ] { }  ) always clobbers reg byte a 
Statement [32] (volatile byte) scroll_soft ← (byte) 7 [ scroll_ptr ] (  [ scroll_ptr ] { }  ) always clobbers reg byte a 
Statement [35] (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr) [ scroll_ptr irq::nxt#0 ] (  [ scroll_ptr irq::nxt#0 ] { }  ) always clobbers reg byte a reg byte y 
Statement [38] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT [ scroll_ptr ] (  [ scroll_ptr ] { }  ) always clobbers reg byte a 
Statement [39] (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr) [ irq::nxt#1 ] (  [ irq::nxt#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [41] (byte~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf [ irq::$33 ] (  [ irq::$33 ] { }  ) always clobbers reg byte a 
Statement [43] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [44] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i5#2) ← *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) 1 + (byte) irq::i5#2) [ scroll_ptr irq::i5#2 ] (  [ scroll_ptr irq::i5#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:12 [ irq::i5#2 irq::i5#1 ]
Statement [46] (byte~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf [ scroll_soft scroll_ptr irq::i4#2 irq::greet_offset#2 irq::$29 ] (  [ scroll_soft scroll_ptr irq::i4#2 irq::greet_offset#2 irq::$29 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ irq::i4#2 irq::i4#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:11 [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ]
Statement [50] (byte~) irq::$26 ← *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) >> (byte) 1 [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$26 ] (  [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$26 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:9 [ irq::i3#2 irq::i3#1 ]
Statement [51] (byte~) irq::$27 ← (byte~) irq::$26 & (byte) 7 [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$27 ] (  [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$27 ] { }  ) always clobbers reg byte a 
Statement [55] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 << (byte) 4 [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#2 irq::idx#0 irq::barcol#0 ] (  [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#2 irq::idx#0 irq::barcol#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ irq::barcnt#2 irq::barcnt#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:17 [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ]
Statement [60] (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#2 + (byte) $a [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#1 ] (  [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#1 ] { }  ) always clobbers reg byte a 
Statement [70] *((const byte*) rasters + (byte) irq::l#2) ← (byte) 0 [ sin_idx scroll_soft scroll_ptr greet_idx irq::l#2 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::l#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ irq::l#2 irq::l#1 ]
Statement [72] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) >> (byte) 2 [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#0 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ irq::i#2 irq::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:5 [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ]
Statement [74] (byte) irq::col1#1 ← (byte) irq::col1#0 >> (byte) 1 [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#1 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#1 ] { }  ) always clobbers reg byte a 
Statement [81] *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i#2) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2) [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 ] { }  ) always clobbers reg byte a 
Statement [96] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ irq::line#10 irq::line#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ]
Statement [98] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [99] (volatile byte) greet_idx ← (byte) 0 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [104] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [105] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [106] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [107] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#10) [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [109] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#1 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#1 ] { }  ) always clobbers reg byte a 
Statement [110] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [111] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [112] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (byte) $40 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [113] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (byte) $40 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement asm { lda#0  } always clobbers reg byte a 
Statement [115] call *((const void()*) songInit)  [ ] ( main:7 [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [122] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2) [ main::i#2 ] ( main:7 [ main::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:20 [ main::i#2 main::i#1 ]
Statement [123] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2) [ main::i#2 ] ( main:7 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [124] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2) [ main::i#2 ] ( main:7 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [128] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [129] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [130] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [131] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [132] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq() [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [133] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [134] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [135] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [138] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) main::i2#2) ← (byte) '*' [ main::i2#2 ] ( main:7 [ main::i2#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:19 [ main::i2#2 main::i2#1 ]
Statement [140] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) LOGO_ROW*(byte) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2) [ main::i1#2 ] ( main:7 [ main::i1#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:18 [ main::i1#2 main::i1#1 ]
Statement [144] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:7::memset:116 [ memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [146] *((byte*) memset::dst#2) ← (const byte) memset::c#0 [ memset::dst#2 ] ( main:7::memset:116 [ memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [1] (volatile byte) sin_idx ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] (volatile byte) scroll_soft ← (byte) 7 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [4] (volatile byte) greet_zoomx ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] (volatile byte) greet_idx ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] { }  ) always clobbers reg byte a 
Statement [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] { }  ) always clobbers reg byte a 
Statement [11] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx ] { }  ) always clobbers reg byte a 
Statement [16] call *((const void()*) songPlay)  [ sin_idx scroll_soft scroll_ptr greet_idx ] (  [ sin_idx scroll_soft scroll_ptr greet_idx ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [27] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx << (byte) 4 [ scroll_soft scroll_ptr irq::greet_offset#0 ] (  [ scroll_soft scroll_ptr irq::greet_offset#0 ] { }  ) always clobbers reg byte a 
Statement [31] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return [ scroll_ptr ] (  [ scroll_ptr ] { }  ) always clobbers reg byte a 
Statement [32] (volatile byte) scroll_soft ← (byte) 7 [ scroll_ptr ] (  [ scroll_ptr ] { }  ) always clobbers reg byte a 
Statement [35] (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr) [ scroll_ptr irq::nxt#0 ] (  [ scroll_ptr irq::nxt#0 ] { }  ) always clobbers reg byte a reg byte y 
Statement [38] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT [ scroll_ptr ] (  [ scroll_ptr ] { }  ) always clobbers reg byte a 
Statement [39] (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr) [ irq::nxt#1 ] (  [ irq::nxt#1 ] { }  ) always clobbers reg byte a reg byte y 
Statement [41] (byte~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf [ irq::$33 ] (  [ irq::$33 ] { }  ) always clobbers reg byte a 
Statement [43] return  [ ] (  [ ] { }  ) always clobbers reg byte a reg byte x reg byte y 
Statement [44] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i5#2) ← *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) 1 + (byte) irq::i5#2) [ scroll_ptr irq::i5#2 ] (  [ scroll_ptr irq::i5#2 ] { }  ) always clobbers reg byte a 
Statement [46] (byte~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf [ scroll_soft scroll_ptr irq::i4#2 irq::greet_offset#2 irq::$29 ] (  [ scroll_soft scroll_ptr irq::i4#2 irq::greet_offset#2 irq::$29 ] { }  ) always clobbers reg byte a 
Statement [50] (byte~) irq::$26 ← *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) >> (byte) 1 [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$26 ] (  [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$26 ] { }  ) always clobbers reg byte a 
Statement [51] (byte~) irq::$27 ← (byte~) irq::$26 & (byte) 7 [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$27 ] (  [ scroll_soft scroll_ptr greet_idx irq::i3#2 irq::$27 ] { }  ) always clobbers reg byte a 
Statement [55] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 << (byte) 4 [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#2 irq::idx#0 irq::barcol#0 ] (  [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#2 irq::idx#0 irq::barcol#0 ] { }  ) always clobbers reg byte a 
Statement [60] (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#2 + (byte) $a [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#1 ] (  [ scroll_soft scroll_ptr greet_idx irq::barcnt#2 irq::sin_bar#1 ] { }  ) always clobbers reg byte a 
Statement [70] *((const byte*) rasters + (byte) irq::l#2) ← (byte) 0 [ sin_idx scroll_soft scroll_ptr greet_idx irq::l#2 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::l#2 ] { }  ) always clobbers reg byte a 
Statement [72] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) >> (byte) 2 [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#0 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#0 ] { }  ) always clobbers reg byte a 
Statement [74] (byte) irq::col1#1 ← (byte) irq::col1#0 >> (byte) 1 [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#1 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 irq::col1#1 ] { }  ) always clobbers reg byte a 
Statement [81] *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i#2) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2) [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 ] (  [ sin_idx scroll_soft scroll_ptr greet_idx irq::i#2 irq::sin_col#2 ] { }  ) always clobbers reg byte a 
Statement [96] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [98] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [99] (volatile byte) greet_idx ← (byte) 0 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [104] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [105] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [106] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [107] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#10) [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#10 ] { }  ) always clobbers reg byte a 
Statement [109] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66 [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#1 ] (  [ sin_idx scroll_soft scroll_ptr greet_zoomx greet_idx irq::line#10 irq::wobble_idx#1 ] { }  ) always clobbers reg byte a 
Statement [110] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [111] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [112] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (byte) $40 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [113] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (byte) $40 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement asm { lda#0  } always clobbers reg byte a 
Statement [115] call *((const void()*) songInit)  [ ] ( main:7 [ ] { }  ) always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [122] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2) [ main::i#2 ] ( main:7 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [123] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2) [ main::i#2 ] ( main:7 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [124] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2) [ main::i#2 ] ( main:7 [ main::i#2 ] { }  ) always clobbers reg byte a 
Statement [128] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [129] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [130] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [131] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [132] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq() [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [133] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [134] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [135] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1 [ ] ( main:7 [ ] { }  ) always clobbers reg byte a 
Statement [138] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) main::i2#2) ← (byte) '*' [ main::i2#2 ] ( main:7 [ main::i2#2 ] { }  ) always clobbers reg byte a 
Statement [140] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) LOGO_ROW*(byte) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2) [ main::i1#2 ] ( main:7 [ main::i1#2 ] { }  ) always clobbers reg byte a 
Statement [144] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:7::memset:116 [ memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [146] *((byte*) memset::dst#2) ← (const byte) memset::c#0 [ memset::dst#2 ] ( main:7::memset:116 [ memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Potential registers zp[1]:2 [ irq::line#10 irq::line#1 ] : zp[1]:2 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:3 [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ] : zp[1]:3 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:4 [ irq::i#2 irq::i#1 ] : zp[1]:4 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:5 [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ] : zp[1]:5 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:6 [ irq::l#2 irq::l#1 ] : zp[1]:6 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:7 [ irq::barcnt#2 irq::barcnt#1 ] : zp[1]:7 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:8 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ] : zp[1]:8 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:9 [ irq::i3#2 irq::i3#1 ] : zp[1]:9 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:10 [ irq::i4#2 irq::i4#1 ] : zp[1]:10 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:11 [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ] : zp[1]:11 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:12 [ irq::i5#2 irq::i5#1 ] : zp[1]:12 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:13 [ irq::nxt#2 irq::nxt#0 irq::nxt#1 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:14 [ irq::i1#2 irq::i1#1 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:15 [ irq::i2#2 irq::i2#1 ] : zp[1]:15 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:16 [ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ] : zp[1]:16 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:17 [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ] : zp[1]:17 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:18 [ main::i1#2 main::i1#1 ] : zp[1]:18 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:19 [ main::i2#2 main::i2#1 ] : zp[1]:19 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:20 [ main::i#2 main::i#1 ] : zp[1]:20 , reg byte x , reg byte y , reg byte z , 
Potential registers zp[2]:21 [ memset::dst#2 memset::dst#1 ] : zp[2]:21 , 
Potential registers zp[1]:23 [ sin_idx ] : zp[1]:23 , 
Potential registers zp[1]:24 [ scroll_soft ] : zp[1]:24 , 
Potential registers zp[2]:25 [ scroll_ptr ] : zp[2]:25 , 
Potential registers zp[1]:27 [ greet_zoomx ] : zp[1]:27 , 
Potential registers zp[1]:28 [ greet_idx ] : zp[1]:28 , 
Potential registers zp[1]:29 [ irq::$33 ] : zp[1]:29 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:30 [ irq::$29 ] : zp[1]:30 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:31 [ irq::$26 ] : zp[1]:31 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:32 [ irq::$27 ] : zp[1]:32 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:33 [ irq::col1#0 ] : zp[1]:33 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:34 [ irq::col1#1 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:35 [ irq::col#0 ] : zp[1]:35 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:36 [ irq::zoomval#0 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:37 [ irq::$10 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , reg byte z , 
Potential registers zp[1]:38 [ irq::raster#0 ] : zp[1]:38 , reg byte a , reg byte x , reg byte y , reg byte z , 

REGISTER UPLIFT SCOPES
Uplift Scope [memset] 3,336.67: zp[2]:21 [ memset::dst#2 memset::dst#1 ] 
Uplift Scope [irq] 454: zp[1]:16 [ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ] 418.67: zp[1]:17 [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ] 262.6: zp[1]:14 [ irq::i1#2 irq::i1#1 ] 262.6: zp[1]:15 [ irq::i2#2 irq::i2#1 ] 56: zp[1]:38 [ irq::raster#0 ] 41.59: zp[1]:3 [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ] 40.33: zp[1]:12 [ irq::i5#2 irq::i5#1 ] 36.67: zp[1]:6 [ irq::l#2 irq::l#1 ] 33: zp[1]:9 [ irq::i3#2 irq::i3#1 ] 31.31: zp[1]:4 [ irq::i#2 irq::i#1 ] 30.8: zp[1]:10 [ irq::i4#2 irq::i4#1 ] 25.26: zp[1]:2 [ irq::line#10 irq::line#1 ] 24.59: zp[1]:7 [ irq::barcnt#2 irq::barcnt#1 ] 23.75: zp[1]:11 [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ] 22: zp[1]:30 [ irq::$29 ] 22: zp[1]:31 [ irq::$26 ] 22: zp[1]:32 [ irq::$27 ] 22: zp[1]:37 [ irq::$10 ] 18.83: zp[1]:5 [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ] 17.19: zp[1]:8 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ] 16.5: zp[1]:33 [ irq::col1#0 ] 16.5: zp[1]:35 [ irq::col#0 ] 12.83: zp[1]:34 [ irq::col1#1 ] 12: zp[1]:13 [ irq::nxt#2 irq::nxt#0 irq::nxt#1 ] 11: zp[1]:36 [ irq::zoomval#0 ] 4: zp[1]:29 [ irq::$33 ] 
Uplift Scope [main] 370.33: zp[1]:18 [ main::i1#2 main::i1#1 ] 353.5: zp[1]:20 [ main::i#2 main::i#1 ] 336.67: zp[1]:19 [ main::i2#2 main::i2#1 ] 
Uplift Scope [] 1.39: zp[1]:27 [ greet_zoomx ] 0.62: zp[1]:28 [ greet_idx ] 0.24: zp[1]:24 [ scroll_soft ] 0.23: zp[1]:23 [ sin_idx ] 0.13: zp[2]:25 [ scroll_ptr ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [__start] 

Uplifting [memset] best 18980 combination zp[2]:21 [ memset::dst#2 memset::dst#1 ] 
Uplifting [main] best 18560 combination reg byte x [ main::i1#2 main::i1#1 ] reg byte x [ main::i#2 main::i#1 ] reg byte x [ main::i2#2 main::i2#1 ] 
Uplifting [] best 18560 combination zp[1]:27 [ greet_zoomx ] zp[1]:28 [ greet_idx ] zp[1]:24 [ scroll_soft ] zp[1]:23 [ sin_idx ] zp[2]:25 [ scroll_ptr ] 
Uplifting [MOS6526_CIA] best 18560 combination 
Uplifting [MOS6569_VICII] best 18560 combination 
Uplifting [MOS6581_SID] best 18560 combination 
Uplifting [MOS4569_VICIII] best 18560 combination 
Uplifting [MEGA65_VICIV] best 18560 combination 
Uplifting [F018_DMAGIC] best 18560 combination 
Uplifting [DMA_LIST_F018A] best 18560 combination 
Uplifting [DMA_LIST_F018B] best 18560 combination 
Uplifting [__start] best 18560 combination 
Attempting to uplift remaining variables inzp[1]:16 [ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ]
Uplifting [irq] best 17340 combination reg byte z [ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ] 
Attempting to uplift remaining variables inzp[1]:17 [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ]
Uplifting [irq] best 16110 combination reg byte x [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ] 
Attempting to uplift remaining variables inzp[1]:14 [ irq::i1#2 irq::i1#1 ]
Uplifting [irq] best 15210 combination reg byte y [ irq::i1#2 irq::i1#1 ] 
Attempting to uplift remaining variables inzp[1]:15 [ irq::i2#2 irq::i2#1 ]
Uplifting [irq] best 14310 combination reg byte y [ irq::i2#2 irq::i2#1 ] 
Attempting to uplift remaining variables inzp[1]:38 [ irq::raster#0 ]
Uplifting [irq] best 13980 combination reg byte a [ irq::raster#0 ] 
Attempting to uplift remaining variables inzp[1]:3 [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ]
Uplifting [irq] best 13917 combination reg byte x [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ] 
Attempting to uplift remaining variables inzp[1]:12 [ irq::i5#2 irq::i5#1 ]
Uplifting [irq] best 13797 combination reg byte x [ irq::i5#2 irq::i5#1 ] 
Attempting to uplift remaining variables inzp[1]:6 [ irq::l#2 irq::l#1 ]
Uplifting [irq] best 13677 combination reg byte x [ irq::l#2 irq::l#1 ] 
Attempting to uplift remaining variables inzp[1]:9 [ irq::i3#2 irq::i3#1 ]
Uplifting [irq] best 13527 combination reg byte x [ irq::i3#2 irq::i3#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ irq::i#2 irq::i#1 ]
Uplifting [irq] best 13197 combination reg byte x [ irq::i#2 irq::i#1 ] 
Attempting to uplift remaining variables inzp[1]:10 [ irq::i4#2 irq::i4#1 ]
Uplifting [irq] best 13077 combination reg byte x [ irq::i4#2 irq::i4#1 ] 
Attempting to uplift remaining variables inzp[1]:2 [ irq::line#10 irq::line#1 ]
Uplifting [irq] best 12857 combination reg byte z [ irq::line#10 irq::line#1 ] 
Attempting to uplift remaining variables inzp[1]:7 [ irq::barcnt#2 irq::barcnt#1 ]
Uplifting [irq] best 12857 combination zp[1]:7 [ irq::barcnt#2 irq::barcnt#1 ] 
Attempting to uplift remaining variables inzp[1]:11 [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ]
Uplifting [irq] best 12796 combination reg byte y [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ] 
Attempting to uplift remaining variables inzp[1]:30 [ irq::$29 ]
Uplifting [irq] best 12736 combination reg byte a [ irq::$29 ] 
Attempting to uplift remaining variables inzp[1]:31 [ irq::$26 ]
Uplifting [irq] best 12676 combination reg byte a [ irq::$26 ] 
Attempting to uplift remaining variables inzp[1]:32 [ irq::$27 ]
Uplifting [irq] best 12616 combination reg byte a [ irq::$27 ] 
Attempting to uplift remaining variables inzp[1]:37 [ irq::$10 ]
Uplifting [irq] best 12556 combination reg byte a [ irq::$10 ] 
Attempting to uplift remaining variables inzp[1]:5 [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ]
Uplifting [irq] best 12463 combination reg byte y [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ] 
Attempting to uplift remaining variables inzp[1]:8 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
Uplifting [irq] best 12463 combination zp[1]:8 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ] 
Attempting to uplift remaining variables inzp[1]:33 [ irq::col1#0 ]
Uplifting [irq] best 12373 combination reg byte a [ irq::col1#0 ] 
Attempting to uplift remaining variables inzp[1]:35 [ irq::col#0 ]
Uplifting [irq] best 12283 combination reg byte a [ irq::col#0 ] 
Attempting to uplift remaining variables inzp[1]:34 [ irq::col1#1 ]
Uplifting [irq] best 12073 combination reg byte a [ irq::col1#1 ] 
Attempting to uplift remaining variables inzp[1]:13 [ irq::nxt#2 irq::nxt#0 irq::nxt#1 ]
Uplifting [irq] best 12061 combination reg byte a [ irq::nxt#2 irq::nxt#0 irq::nxt#1 ] 
Attempting to uplift remaining variables inzp[1]:36 [ irq::zoomval#0 ]
Uplifting [irq] best 11971 combination reg byte a [ irq::zoomval#0 ] 
Attempting to uplift remaining variables inzp[1]:29 [ irq::$33 ]
Uplifting [irq] best 11965 combination reg byte a [ irq::$33 ] 
Attempting to uplift remaining variables inzp[1]:27 [ greet_zoomx ]
Uplifting [] best 11965 combination zp[1]:27 [ greet_zoomx ] 
Attempting to uplift remaining variables inzp[1]:28 [ greet_idx ]
Uplifting [] best 11965 combination zp[1]:28 [ greet_idx ] 
Attempting to uplift remaining variables inzp[1]:24 [ scroll_soft ]
Uplifting [] best 11965 combination zp[1]:24 [ scroll_soft ] 
Attempting to uplift remaining variables inzp[1]:23 [ sin_idx ]
Uplifting [] best 11965 combination zp[1]:23 [ sin_idx ] 
Allocated (was zp[1]:7) zp[1]:2 [ irq::barcnt#2 irq::barcnt#1 ]
Allocated (was zp[1]:8) zp[1]:3 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
Allocated (was zp[2]:21) zp[2]:4 [ memset::dst#2 memset::dst#1 ]
Allocated (was zp[1]:23) zp[1]:6 [ sin_idx ]
Allocated (was zp[1]:24) zp[1]:7 [ scroll_soft ]
Allocated (was zp[2]:25) zp[2]:8 [ scroll_ptr ]
Allocated (was zp[1]:27) zp[1]:10 [ greet_zoomx ]
Allocated (was zp[1]:28) zp[1]:11 [ greet_idx ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Raster65 Demo re-implementation in C by Jesper Gravgaard
// Based on RASTER65 assembler demo made in 2015 and updated in 2020 by DEFT 
// https://mega.scryptos.com/sharefolder/MEGA/MEGA65+filehost
// https://www.forum64.de/index.php?thread/104591-xemu-vic-iv-implementation-update/&postID=1560511#post1560511
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform executable starting in C64 mode.
.file [name="raster65.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$080d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
.segment Code


  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  // Logo start screen row 
  .const LOGO_ROW = 3
  // Scroll screen row
  .const SCROLL_ROW = $d
  // Greeting screen row
  .const GREET_ROW = $14
  // y rasterline where IRQ starts
  .const IRQ_Y = $16
  // y rasterline where scrolly starts
  .const SCROLL_Y = $66
  // size of raster behind scrolly
  .const SCROLL_BLACKBARS = $13
  // The number of raster lines
  .const RASTER_LINES = $d8
  // The number of greetings
  .const GREET_COUNT = $f
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MEGA65_VICIV_RASLINE0 = $6f
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = $16
  .const OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR = $20
  .const OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR = $21
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
  .const OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL = $5a
  .const SIZEOF_BYTE = 1
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC III MOS 4567/4569
  .label VICIII = $d000
  // The VIC IV
  .label VICIV = $d000
  // Palette RED
  .label PALETTE_RED = $d100
  // Palette GREEN
  .label PALETTE_GREEN = $d200
  // Palette BLUE
  .label PALETTE_BLUE = $d300
  // Color Ram
  .label COLORRAM = $d800
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $400
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Pointer to the song init routine
  .label songInit = SONG
  // Pointer to the song play routine
  .label songPlay = SONG+3
  // Sinus Position (used across effects)
  .label sin_idx = 6
  // scroll soft position of text scrolly (0-7)
  .label scroll_soft = 7
  // scroll text pointer to next char
  .label scroll_ptr = 8
  // Zoom Position
  .label greet_zoomx = $a
  // The greeting currently being shown
  .label greet_idx = $b
.segment Code
  // __start
__start: {
    jmp __init1
    // __start::__init1
  __init1:
    // [1] (volatile byte) sin_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // [2] (volatile byte) scroll_soft ← (byte) 7 -- vbuz1=vbuc1 
    lda #7
    sta.z scroll_soft
    // [3] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT -- pbuz1=pbuc1 
    lda #<SCROLL_TEXT
    sta.z scroll_ptr
    lda #>SCROLL_TEXT
    sta.z scroll_ptr+1
    // [4] (volatile byte) greet_zoomx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_zoomx
    // [5] (volatile byte) greet_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_idx
    // [6] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
  __b1_from___init1:
    jmp __b1
    // __start::@1
  __b1:
    // [7] call main 
    jsr main
    jmp __breturn
    // __start::@return
  __breturn:
    // [8] return 
    rts
}
  // irq
// BIG INTERRUPT LOOP
irq: {
    .label sin_bar = 3
    .label barcnt = 2
    // entry interrupt(HARDWARE_STACK)
    pha
    txa
    pha
    tya
    pha
    // [9] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // force NTSC every frame (hehe)
    lda #$80
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_RASLINE0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_RASLINE0
    // [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // [11] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // reset x scroll
    lda #0
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    // [12] (volatile byte) sin_idx ← ++ (volatile byte) sin_idx -- vbuz1=_inc_vbuz1 
    inc.z sin_idx
    // [13] (byte) irq::wobble_idx#0 ← (volatile byte) sin_idx -- vbuxx=vbuz1 
    // Generate Raster Bars and more
    ldx.z sin_idx
    // [14] phi from irq to irq::@1 [phi:irq->irq::@1]
  __b1_from_irq:
    // [14] phi (byte) irq::wobble_idx#10 = (byte) irq::wobble_idx#0 [phi:irq->irq::@1#0] -- register_copy 
    // [14] phi (byte) irq::line#10 = (byte) 0 [phi:irq->irq::@1#1] -- vbuzz=vbuc1 
    ldz #0
    jmp __b1
    // irq::@1
  __b1:
    // [15] if((byte) irq::line#10!=(const nomodify byte) RASTER_LINES) goto irq::@2 -- vbuzz_neq_vbuc1_then_la1 
    cpz #RASTER_LINES
    bne __b2
    jmp __b3
    // irq::@3
  __b3:
    // [16] call *((const void()*) songPlay) 
    // play music
    jsr songPlay
    // [17] (byte) irq::sin_col#0 ← (volatile byte) sin_idx -- vbuyy=vbuz1 
    // Set up colors behind logo, scroll and greets
    ldy.z sin_idx
    // [18] phi from irq::@3 to irq::@16 [phi:irq::@3->irq::@16]
  __b16_from___b3:
    // [18] phi (byte) irq::sin_col#2 = (byte) irq::sin_col#0 [phi:irq::@3->irq::@16#0] -- register_copy 
    // [18] phi (byte) irq::i#2 = (byte) 0 [phi:irq::@3->irq::@16#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b16
    // irq::@16
  __b16:
    // [19] if((byte) irq::i#2<(byte) $28) goto irq::@17 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$28
    bcc __b17
    // [20] phi from irq::@16 to irq::@18 [phi:irq::@16->irq::@18]
  __b18_from___b16:
    // [20] phi (byte) irq::l#2 = (byte) 0 [phi:irq::@16->irq::@18#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b18
  // Set all raster bars to black
    // irq::@18
  __b18:
    // [21] if((byte) irq::l#2!=(const nomodify byte) RASTER_LINES) goto irq::@19 -- vbuxx_neq_vbuc1_then_la1 
    cpx #RASTER_LINES
    bne __b19
    jmp __b20
    // irq::@20
  __b20:
    // [22] (byte) irq::sin_bar#0 ← (volatile byte) sin_idx -- vbuz1=vbuz2 
    // Big block of bars (16)
    lda.z sin_idx
    sta.z sin_bar
    // [23] phi from irq::@20 to irq::@21 [phi:irq::@20->irq::@21]
  __b21_from___b20:
    // [23] phi (byte) irq::sin_bar#2 = (byte) irq::sin_bar#0 [phi:irq::@20->irq::@21#0] -- register_copy 
    // [23] phi (byte) irq::barcnt#2 = (byte) 0 [phi:irq::@20->irq::@21#1] -- vbuz1=vbuc1 
    lda #0
    sta.z barcnt
    jmp __b21
    // irq::@21
  __b21:
    // [24] if((byte) irq::barcnt#2<(byte) $10) goto irq::@22 -- vbuz1_lt_vbuc1_then_la1 
    lda.z barcnt
    cmp #$10
    bcc __b22
    // [25] phi from irq::@21 to irq::@28 [phi:irq::@21->irq::@28]
  __b28_from___b21:
    // [25] phi (byte) irq::i3#2 = (byte) 0 [phi:irq::@21->irq::@28#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b28
  // Produce dark area behind text
    // irq::@28
  __b28:
    // [26] if((byte) irq::i3#2<(byte) $13) goto irq::@29 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$13
    bcc __b29
    jmp __b30
    // irq::@30
  __b30:
    // [27] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx << (byte) 4 -- vbuyy=vbuz1_rol_4 
    lda.z greet_idx
    asl
    asl
    asl
    asl
    tay
    // [28] phi from irq::@30 to irq::@31 [phi:irq::@30->irq::@31]
  __b31_from___b30:
    // [28] phi (byte) irq::greet_offset#2 = (byte) irq::greet_offset#0 [phi:irq::@30->irq::@31#0] -- register_copy 
    // [28] phi (byte) irq::i4#2 = (byte) 0 [phi:irq::@30->irq::@31#1] -- vbuxx=vbuc1 
    ldx #0
    jmp __b31
    // irq::@31
  __b31:
    // [29] if((byte) irq::i4#2<(byte) $10) goto irq::@32 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$10
    bcc __b32
    jmp __b33
    // irq::@33
  __b33:
    // [30] (volatile byte) scroll_soft ← -- (volatile byte) scroll_soft -- vbuz1=_dec_vbuz1 
    dec.z scroll_soft
    // [31] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z scroll_soft
    bne __breturn
    jmp __b34
    // irq::@34
  __b34:
    // [32] (volatile byte) scroll_soft ← (byte) 7 -- vbuz1=vbuc1 
    lda #7
    sta.z scroll_soft
    // [33] phi from irq::@34 to irq::@35 [phi:irq::@34->irq::@35]
  __b35_from___b34:
    // [33] phi (byte) irq::i5#2 = (byte) 0 [phi:irq::@34->irq::@35#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b35
  // Move scroll on screen
    // irq::@35
  __b35:
    // [34] if((byte) irq::i5#2<(byte) $27) goto irq::@36 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$27
    bcc __b36
    jmp __b37
    // irq::@37
  __b37:
    // [35] (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr) -- vbuaa=_deref_pbuz1 
    // Show next char
    ldy #0
    lda (scroll_ptr),y
    // [36] (volatile byte*) scroll_ptr ← ++ (volatile byte*) scroll_ptr -- pbuz1=_inc_pbuz1 
    inw.z scroll_ptr
    // [37] if((byte) irq::nxt#0!=(byte) 0) goto irq::@39 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b39_from___b37
    jmp __b38
    // irq::@38
  __b38:
    // [38] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT -- pbuz1=pbuc1 
    lda #<SCROLL_TEXT
    sta.z scroll_ptr
    lda #>SCROLL_TEXT
    sta.z scroll_ptr+1
    // [39] (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr) -- vbuaa=_deref_pbuz1 
    ldy #0
    lda (scroll_ptr),y
    // [40] phi from irq::@37 irq::@38 to irq::@39 [phi:irq::@37/irq::@38->irq::@39]
  __b39_from___b37:
  __b39_from___b38:
    // [40] phi (byte) irq::nxt#2 = (byte) irq::nxt#0 [phi:irq::@37/irq::@38->irq::@39#0] -- register_copy 
    jmp __b39
    // irq::@39
  __b39:
    // [41] (byte~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf -- vbuaa=vbuaa_band_vbuc1 
    and #$bf
    // [42] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) $27) ← (byte~) irq::$33 -- _deref_pbuc1=vbuaa 
    sta DEFAULT_SCREEN+SCROLL_ROW*$28+$27
    jmp __breturn
    // irq::@return
  __breturn:
    // [43] return  - exit interrupt(HARDWARE_STACK)
    pla
    tay
    pla
    tax
    pla
    rti
    // irq::@36
  __b36:
    // [44] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i5#2) ← *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) 1 + (byte) irq::i5#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda DEFAULT_SCREEN+SCROLL_ROW*$28+1,x
    sta DEFAULT_SCREEN+SCROLL_ROW*$28,x
    // [45] (byte) irq::i5#1 ← ++ (byte) irq::i5#2 -- vbuxx=_inc_vbuxx 
    inx
    // [33] phi from irq::@36 to irq::@35 [phi:irq::@36->irq::@35]
  __b35_from___b36:
    // [33] phi (byte) irq::i5#2 = (byte) irq::i5#1 [phi:irq::@36->irq::@35#0] -- register_copy 
    jmp __b35
    // irq::@32
  __b32:
    // [46] (byte~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf -- vbuaa=pbuc1_derefidx_vbuyy_band_vbuc2 
    lda #$bf
    and GREETING,y
    // [47] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28+(byte) $d + (byte) irq::i4#2) ← (byte~) irq::$29 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta DEFAULT_SCREEN+GREET_ROW*$28+$d,x
    // [48] (byte) irq::greet_offset#1 ← ++ (byte) irq::greet_offset#2 -- vbuyy=_inc_vbuyy 
    iny
    // [49] (byte) irq::i4#1 ← ++ (byte) irq::i4#2 -- vbuxx=_inc_vbuxx 
    inx
    // [28] phi from irq::@32 to irq::@31 [phi:irq::@32->irq::@31]
  __b31_from___b32:
    // [28] phi (byte) irq::greet_offset#2 = (byte) irq::greet_offset#1 [phi:irq::@32->irq::@31#0] -- register_copy 
    // [28] phi (byte) irq::i4#2 = (byte) irq::i4#1 [phi:irq::@32->irq::@31#1] -- register_copy 
    jmp __b31
    // irq::@29
  __b29:
    // [50] (byte~) irq::$26 ← *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) >> (byte) 1 -- vbuaa=pbuc1_derefidx_vbuxx_ror_1 
    lda rasters+SCROLL_Y,x
    lsr
    // [51] (byte~) irq::$27 ← (byte~) irq::$26 & (byte) 7 -- vbuaa=vbuaa_band_vbuc1 
    and #7
    // [52] *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) ← (byte~) irq::$27 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta rasters+SCROLL_Y,x
    // [53] (byte) irq::i3#1 ← ++ (byte) irq::i3#2 -- vbuxx=_inc_vbuxx 
    inx
    // [25] phi from irq::@29 to irq::@28 [phi:irq::@29->irq::@28]
  __b28_from___b29:
    // [25] phi (byte) irq::i3#2 = (byte) irq::i3#1 [phi:irq::@29->irq::@28#0] -- register_copy 
    jmp __b28
    // irq::@22
  __b22:
    // [54] (byte) irq::idx#0 ← *((const byte*) SINUS + (byte) irq::sin_bar#2) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z sin_bar
    ldx SINUS,y
    // [55] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 << (byte) 4 -- vbuzz=vbuz1_rol_4 
    lda.z barcnt
    asl
    asl
    asl
    asl
    taz
    // [56] phi from irq::@22 to irq::@23 [phi:irq::@22->irq::@23]
  __b23_from___b22:
    // [56] phi (byte) irq::idx#3 = (byte) irq::idx#0 [phi:irq::@22->irq::@23#0] -- register_copy 
    // [56] phi (byte) irq::barcol#3 = (byte) irq::barcol#0 [phi:irq::@22->irq::@23#1] -- register_copy 
    // [56] phi (byte) irq::i1#2 = (byte) 0 [phi:irq::@22->irq::@23#2] -- vbuyy=vbuc1 
    ldy #0
    jmp __b23
    // irq::@23
  __b23:
    // [57] if((byte) irq::i1#2<(byte) $10) goto irq::@24 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10
    bcc __b24
    // [58] phi from irq::@23 to irq::@25 [phi:irq::@23->irq::@25]
  __b25_from___b23:
    // [58] phi (byte) irq::idx#4 = (byte) irq::idx#3 [phi:irq::@23->irq::@25#0] -- register_copy 
    // [58] phi (byte) irq::barcol#4 = (byte) irq::barcol#3 [phi:irq::@23->irq::@25#1] -- register_copy 
    // [58] phi (byte) irq::i2#2 = (byte) 0 [phi:irq::@23->irq::@25#2] -- vbuyy=vbuc1 
    ldy #0
    jmp __b25
    // irq::@25
  __b25:
    // [59] if((byte) irq::i2#2<(byte) $f) goto irq::@26 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$f
    bcc __b26
    jmp __b27
    // irq::@27
  __b27:
    // [60] (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#2 + (byte) $a -- vbuz1=vbuz1_plus_vbuc1 
    lda #$a
    clc
    adc.z sin_bar
    sta.z sin_bar
    // [61] (byte) irq::barcnt#1 ← ++ (byte) irq::barcnt#2 -- vbuz1=_inc_vbuz1 
    inc.z barcnt
    // [23] phi from irq::@27 to irq::@21 [phi:irq::@27->irq::@21]
  __b21_from___b27:
    // [23] phi (byte) irq::sin_bar#2 = (byte) irq::sin_bar#1 [phi:irq::@27->irq::@21#0] -- register_copy 
    // [23] phi (byte) irq::barcnt#2 = (byte) irq::barcnt#1 [phi:irq::@27->irq::@21#1] -- register_copy 
    jmp __b21
    // irq::@26
  __b26:
    // [62] (byte) irq::barcol#2 ← -- (byte) irq::barcol#4 -- vbuzz=_dec_vbuzz 
    dez
    // [63] *((const byte*) rasters + (byte) irq::idx#4) ← (byte) irq::barcol#2 -- pbuc1_derefidx_vbuxx=vbuzz 
    tza
    sta rasters,x
    // [64] (byte) irq::idx#2 ← ++ (byte) irq::idx#4 -- vbuxx=_inc_vbuxx 
    inx
    // [65] (byte) irq::i2#1 ← ++ (byte) irq::i2#2 -- vbuyy=_inc_vbuyy 
    iny
    // [58] phi from irq::@26 to irq::@25 [phi:irq::@26->irq::@25]
  __b25_from___b26:
    // [58] phi (byte) irq::idx#4 = (byte) irq::idx#2 [phi:irq::@26->irq::@25#0] -- register_copy 
    // [58] phi (byte) irq::barcol#4 = (byte) irq::barcol#2 [phi:irq::@26->irq::@25#1] -- register_copy 
    // [58] phi (byte) irq::i2#2 = (byte) irq::i2#1 [phi:irq::@26->irq::@25#2] -- register_copy 
    jmp __b25
    // irq::@24
  __b24:
    // [66] *((const byte*) rasters + (byte) irq::idx#3) ← (byte) irq::barcol#3 -- pbuc1_derefidx_vbuxx=vbuzz 
    tza
    sta rasters,x
    // [67] (byte) irq::idx#1 ← ++ (byte) irq::idx#3 -- vbuxx=_inc_vbuxx 
    inx
    // [68] (byte) irq::barcol#1 ← ++ (byte) irq::barcol#3 -- vbuzz=_inc_vbuzz 
    inz
    // [69] (byte) irq::i1#1 ← ++ (byte) irq::i1#2 -- vbuyy=_inc_vbuyy 
    iny
    // [56] phi from irq::@24 to irq::@23 [phi:irq::@24->irq::@23]
  __b23_from___b24:
    // [56] phi (byte) irq::idx#3 = (byte) irq::idx#1 [phi:irq::@24->irq::@23#0] -- register_copy 
    // [56] phi (byte) irq::barcol#3 = (byte) irq::barcol#1 [phi:irq::@24->irq::@23#1] -- register_copy 
    // [56] phi (byte) irq::i1#2 = (byte) irq::i1#1 [phi:irq::@24->irq::@23#2] -- register_copy 
    jmp __b23
    // irq::@19
  __b19:
    // [70] *((const byte*) rasters + (byte) irq::l#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta rasters,x
    // [71] (byte) irq::l#1 ← ++ (byte) irq::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [20] phi from irq::@19 to irq::@18 [phi:irq::@19->irq::@18]
  __b18_from___b19:
    // [20] phi (byte) irq::l#2 = (byte) irq::l#1 [phi:irq::@19->irq::@18#0] -- register_copy 
    jmp __b18
    // irq::@17
  __b17:
    // [72] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) >> (byte) 2 -- vbuaa=pbuc1_derefidx_vbuyy_ror_2 
    lda SINUS,y
    lsr
    lsr
    // [73] *((const nomodify byte*) COLORRAM+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) irq::i#2) ← (byte) irq::col1#0 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+GREET_ROW*$28,x
    // [74] (byte) irq::col1#1 ← (byte) irq::col1#0 >> (byte) 1 -- vbuaa=vbuaa_ror_1 
    // Logo colors
    lsr
    // [75] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28-(byte) 1 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28-1,x
    // [76] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 1*(number) $28-(byte) 2 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+1*$28-2,x
    // [77] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 2*(number) $28-(byte) 3 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+2*$28-3,x
    // [78] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 3*(number) $28-(byte) 4 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+3*$28-4,x
    // [79] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 4*(number) $28-(byte) 5 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+4*$28-5,x
    // [80] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 5*(number) $28-(byte) 6 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+5*$28-6,x
    // [81] *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i#2) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuyy 
    // Scroll colors
    lda PAL_GREEN,y
    sta COLORRAM+SCROLL_ROW*$28,x
    // [82] (byte) irq::sin_col#1 ← ++ (byte) irq::sin_col#2 -- vbuyy=_inc_vbuyy 
    iny
    // [83] (byte) irq::i#1 ← ++ (byte) irq::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [18] phi from irq::@17 to irq::@16 [phi:irq::@17->irq::@16]
  __b16_from___b17:
    // [18] phi (byte) irq::sin_col#2 = (byte) irq::sin_col#1 [phi:irq::@17->irq::@16#0] -- register_copy 
    // [18] phi (byte) irq::i#2 = (byte) irq::i#1 [phi:irq::@17->irq::@16#1] -- register_copy 
    jmp __b16
    // irq::@2
  __b2:
    // [84] (byte) irq::col#0 ← *((const byte*) rasters + (byte) irq::line#10) -- vbuaa=pbuc1_derefidx_vbuzz 
    tza
    tay
    lda rasters,y
    // [85] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR) ← (byte) irq::col#0 -- _deref_pbuc1=vbuaa 
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR
    // [86] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR) ← (byte) irq::col#0 -- _deref_pbuc1=vbuaa 
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR
    // [87] if((byte) irq::line#10<(const nomodify byte) SCROLL_Y) goto irq::@4 -- vbuzz_lt_vbuc1_then_la1 
    cpz #SCROLL_Y
    bcc __b4
    jmp __b10
    // irq::@10
  __b10:
    // [88] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y) goto irq::@5 -- vbuzz_eq_vbuc1_then_la1 
    cpz #SCROLL_Y
    beq __b5
    jmp __b11
    // irq::@11
  __b11:
    // [89] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS) goto irq::@6 -- vbuzz_eq_vbuc1_then_la1 
    cpz #SCROLL_Y+SCROLL_BLACKBARS
    beq __b6
    jmp __b12
    // irq::@12
  __b12:
    // [90] if((byte) irq::line#10!=(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1) goto irq::@7 -- vbuzz_neq_vbuc1_then_la1 
    cpz #SCROLL_Y+SCROLL_BLACKBARS+1
    bne __b7_from___b12
    jmp __b13
    // irq::@13
  __b13:
    // [91] (byte) irq::zoomval#0 ← *((const byte*) SINUS + (volatile byte) greet_zoomx) -- vbuaa=pbuc1_derefidx_vbuz1 
    // if raster position > SCROLL_Y pos do zoom
    ldy.z greet_zoomx
    lda SINUS,y
    // [92] (volatile byte) greet_zoomx ← ++ (volatile byte) greet_zoomx -- vbuz1=_inc_vbuz1 
    inc.z greet_zoomx
    // [93] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) irq::zoomval#0 -- _deref_pbuc1=vbuaa 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL
    // [94] (byte~) irq::$10 ← (byte) irq::zoomval#0 + (byte) 1 -- vbuaa=vbuaa_plus_1 
    inc
    // [95] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte~) irq::$10 -- _deref_pbuc1=vbuaa 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [96] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7 -- vbuz1_neq_0_then_la1 
    lda.z greet_zoomx
    cmp #0
    bne __b7_from___b13
    jmp __b14
    // irq::@14
  __b14:
    // [97] (volatile byte) greet_idx ← ++ (volatile byte) greet_idx -- vbuz1=_inc_vbuz1 
    inc.z greet_idx
    // [98] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #GREET_COUNT
    cmp.z greet_idx
    bne __b7_from___b14
    jmp __b15
    // irq::@15
  __b15:
    // [99] (volatile byte) greet_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_idx
    // [100] phi from irq::@12 irq::@13 irq::@14 irq::@15 irq::@4 irq::@5 irq::@6 to irq::@7 [phi:irq::@12/irq::@13/irq::@14/irq::@15/irq::@4/irq::@5/irq::@6->irq::@7]
  __b7_from___b12:
  __b7_from___b13:
  __b7_from___b14:
  __b7_from___b15:
  __b7_from___b4:
  __b7_from___b5:
  __b7_from___b6:
    // [100] phi (byte) irq::wobble_idx#7 = (byte) irq::wobble_idx#10 [phi:irq::@12/irq::@13/irq::@14/irq::@15/irq::@4/irq::@5/irq::@6->irq::@7#0] -- register_copy 
    jmp __b7
    // irq::@7
  __b7:
    // [101] (byte) irq::raster#0 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuaa=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    jmp __b8
    // irq::@8
  __b8:
    // [102] if((byte) irq::raster#0==*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)) goto irq::@8 -- vbuaa_eq__deref_pbuc1_then_la1 
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    beq __b8
    jmp __b9
    // irq::@9
  __b9:
    // [103] (byte) irq::line#1 ← ++ (byte) irq::line#10 -- vbuzz=_inc_vbuzz 
    inz
    // [14] phi from irq::@9 to irq::@1 [phi:irq::@9->irq::@1]
  __b1_from___b9:
    // [14] phi (byte) irq::wobble_idx#10 = (byte) irq::wobble_idx#7 [phi:irq::@9->irq::@1#0] -- register_copy 
    // [14] phi (byte) irq::line#10 = (byte) irq::line#1 [phi:irq::@9->irq::@1#1] -- register_copy 
    jmp __b1
    // irq::@6
  __b6:
    // [104] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 -- _deref_pbuc1=vbuc2 
    // if raster position > SCROLL_Y pos do nozoom
    // default value
    lda #$50
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    jmp __b7_from___b6
    // irq::@5
  __b5:
    // [105] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 -- _deref_pbuc1=vbuc2 
    // if raster position = SCROLL_Y pos do scroll
    // no wobbling from this point
    lda #$50
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [106] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft -- _deref_pbuc1=vbuz1 
    // set softscroll
    lda.z scroll_soft
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    jmp __b7_from___b5
    // irq::@4
  __b4:
    // [107] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#10) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    // if raster position < SCROLL_Y pos do wobble Logo!
    lda SINUS,x
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // [108] (byte) irq::wobble_idx#1 ← ++ (byte) irq::wobble_idx#10 -- vbuxx=_inc_vbuxx 
    inx
    // [109] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66 -- _deref_pbuc1=vbuc2 
    // No zooming
    lda #$66
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL
    jmp __b7_from___b4
}
  // main
main: {
    // [110] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [111] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // [112] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (byte) $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // [113] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (byte) $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // asm { lda#0  }
    // Initialize music
    lda #0
    // [115] call *((const void()*) songInit) 
    jsr songInit
    // [116] call memset 
  // Clear screen 
    // [142] phi from main to memset [phi:main->memset]
  memset_from_main:
    jsr memset
    // [117] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [117] phi (byte) main::i1#2 = (byte) 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
  // Put MEGA logo on screen
    // main::@1
  __b1:
    // [118] if((byte) main::i1#2<(byte) $bc*(const byte) SIZEOF_BYTE) goto main::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$bc*SIZEOF_BYTE
    bcc __b2
    // [119] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
  __b3_from___b1:
    // [119] phi (byte) main::i2#2 = (byte) 0 [phi:main::@1->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
  // Put '*' as default greeting
    // main::@3
  __b3:
    // [120] if((byte) main::i2#2<(byte) $28) goto main::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$28
    bcc __b4
    // [121] phi from main::@3 to main::@5 [phi:main::@3->main::@5]
  __b5_from___b3:
    // [121] phi (byte) main::i#2 = (byte) 0 [phi:main::@3->main::@5#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b5
    // [121] phi from main::@5 to main::@5 [phi:main::@5->main::@5]
  __b5_from___b5:
    // [121] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@5->main::@5#0] -- register_copy 
    jmp __b5
    // main::@5
  __b5:
    // [122] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PAL_RED,x
    sta PALETTE_RED,x
    // [123] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PAL_GREEN,x
    sta PALETTE_GREEN,x
    // [124] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PAL_BLUE,x
    sta PALETTE_BLUE,x
    // [125] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [126] if((byte) main::i#1!=(byte) 0) goto main::@5 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b5_from___b5
    jmp __b6
    // main::@6
  __b6:
    // asm { sei  }
    // Set up raster interrupts C64 style
    sei
    // [128] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // [129] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y -- _deref_pbuc1=vbuc2 
    // Set raster line to 0x16
    lda #IRQ_Y
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // [130] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // [131] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // [132] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq() -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // [133] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // [134] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // [135] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // asm { cli  }
    // Enable IRQ
    cli
    // [137] phi from main::@6 main::@7 to main::@7 [phi:main::@6/main::@7->main::@7]
  __b7_from___b6:
  __b7_from___b7:
    jmp __b7
    // main::@7
  __b7:
    jmp __b7_from___b7
    // main::@4
  __b4:
    // [138] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) main::i2#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta DEFAULT_SCREEN+GREET_ROW*$28,x
    // [139] (byte) main::i2#1 ← ++ (byte) main::i2#2 -- vbuxx=_inc_vbuxx 
    inx
    // [119] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [119] phi (byte) main::i2#2 = (byte) main::i2#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
    // main::@2
  __b2:
    // [140] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) LOGO_ROW*(byte) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MEGA_LOGO,x
    sta DEFAULT_SCREEN+LOGO_ROW*$28,x
    // [141] (byte) main::i1#1 ← ++ (byte) main::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [117] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
  __b1_from___b2:
    // [117] phi (byte) main::i1#2 = (byte) main::i1#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $28*$19
    .label str = DEFAULT_SCREEN
    .label end = str+num
    .label dst = 4
    // [143] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [143] phi (byte*) memset::dst#2 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [144] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [145] return 
    rts
    // memset::@2
  __b2:
    // [146] *((byte*) memset::dst#2) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [147] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inw.z dst
    // [143] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [143] phi (byte*) memset::dst#2 = (byte*) memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  // A MEGA logo
  MEGA_LOGO: .byte $20, $20, $20, $20, $20, $cf, $cf, $cf, $20, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $20, $cf, $cf, $20, $cf, $20, $cf, $20, $20, $20, $cf, $cf, $20, $20, $20, $20, $cf, $cf, $20, $20, $20, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $20, $20, $cf, $20, $cf, $cf, $cf, $cf, $cf, $20, $cf, $cf, $20, $cf, $cf, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $20, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $cf, $cf, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $20, $20, $20, $20, $cf, $cf, $20, $cf, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $cf, $20, $20, $20, $cf
  // Greetings
  GREETING: .text "   DOUBLEFLASH        ADTBM          SY2002          TAYGER         SERIOUSLY   LIBI IN PARADIZE       LGB          BLUEWAYSW        SAUSAGE       BIT SHIFTER     INDIOCOLIFA     GRUMPYNINJA      0-LIMITS         CHEVERON     DR. COMMODORE "
  .byte 0
  // Scroll text
  SCROLL_TEXT: .text "    THIS SMALL MEGA65 RASTER INTRO ... WAS MADE BY DEFT IN 2015 ... AND BROUGHT BACK TO LIFE 5 YEARS LATER IN 2020 ... BECAUSE THE MEGA65 HARDWARE CHANGED SO MUCH IN THE PAST 5 YEARS ... UNFORTUNATELY MY ASSEMBLER SKILLS DID NOT SO THIS IS THE FIRST APPROACH TO GET BETTER ... HOPEFULLY DR.MUTTI WILL HAVE TO SCOLD ME LESS ... THE PAST 5 YEARS HAVE BEEN AN UNFORGETTABLE & UNIQUE RIDE ... IF YOU DO WATCH THIS DEMO ON YOUR VERY OWN MEGA65 THERE IS ENOUGH EVIDENCE OF WHAT WE ACTUALLY ACHIEVED ... BELOW ARE THE GREETINGS TO DEAR AND VERY SPECIAL PEOPLE WHO HELPED TO GET THERE ... THANK YOU SO MUCH FOR YOUR SUPPORT AND FOR NOT GIVING UP ... DUAL SID TUNE BY RAYDEN OF ALPHA FLIGHT ... THIS SCROLLY WILL NOW RESTART           *WRAP*                    "
  .byte 0
.pc = $fc0 "SONG"
  // Music at an absolute address
SONG:
.import c64 "DiscoZak_2SID_patched.prg"

.pc = $2c00 "SINUS"
  // Sinus Values 0-183
SINUS:
.fill 256, 91.5 + 91.5*sin(i*2*PI/256)

.pc = $3000 "rasters"
  // Moving Raster Bars
  rasters: .fill RASTER_LINES, 0
.pc = $2d00 "PAL_RED"
  PAL_RED: .byte 0, $f3, $d4, $b5, $a6, $97, $88, $79, $1a, $fa, $eb, $ec, $bd, $be, $af, $ff, $16, $c6, $a7, $88, $49, $5a, $2b, $1c, $ac, $ad, $8e, $8f, $ff, $ff, $ff, $ff, $c6, $77, $48, $29, $e9, $fa, $cb, $cc, $5d, $4e, $2f, $ff, $ff, $ff, $ff, $ff, $57, $18, $f8, $d9, $aa, $8b, $6c, $5d, $ed, $de, $cf, $ff, $ff, $ff, $ff, $ff, $26, $e6, $b7, $a8, $69, $5a, $3b, $3c, $dc, $cd, $ae, $9f, $ff, $ff, $ff, $ff, $65, $16, $17, $f7, $d8, $b9, $9a, $8b, $2c, $d, $fd, $ee, $cf, $ff, $ff, $ff, $64, $15, 6, $e6, $c7, $a8, $99, $8a, $1b, $c, $fc, $fd, $ee, $cf, $ff, $ff, $12, $d2, $d3, $b4, $95, $86, $77, $78, 9, $69, $ea, $fb, $dc, $ad, $ae, $af, $f0, $c1, $c2, $a3, $84, $85, $76, $67, 8, $f8, $e9, $da, $db, $bc, $bd, $ae, $40, $11, $12, $f2, $e3, $d4, $c5, $c6, $47, $38, $39, $2a, $1b, $c, $d, $ed, 0, 0, $f0, $d1, $c2, $b3, $a4, $95, $36, $27, $28, $29, $f9, $ea, $eb, $ec, $70, $41, $22, $23, $f3, $f4, $e5, $e6, $77, $78, $69, $7a, $3b, $3c, $3d, $3e, $a1, $82, $63, $54, $35, $26, 7, 8, $98, $99, $8a, $7b, $5c, $5d, $3e, $3f, $33, 4, $d4, $d5, $a6, $a7, $88, $89, $1a, $ab, $fb, $ec, $cd, $be, $af, $ff, $b4, $85, $56, $47, $18, 9, $f9, $ea, $7b, $7c, $5d, $5e, $2f, $ef, $ff, $ff, 6, $d6, $a7, $98, $59, $4a, $2b, $2c, $bc, $ad, $8e, $8f, $ff, $ff, $ff, $ff
.pc = $2e00 "PAL_GREEN"
  PAL_GREEN: .byte 0, $e3, $c4, $b5, $96, $87, $78, $79, $a, $fa, $eb, $dc, $bd, $ae, $af, $ff, $e2, $b3, $a4, $85, $76, $67, $48, $49, $d9, $da, $bb, $bc, $8d, $8e, $7f, $ff, $42, 3, 4, $e4, $d5, $c6, $b7, $a8, $39, $3a, $1b, $2c, $fc, $fd, $de, $df, $61, $32, $13, 4, $e4, $e5, $d6, $d7, $78, $59, $4a, $4b, $2c, $1d, $e, $fe, $e0, $b1, $a2, $93, $74, $75, $56, $57, $e7, $d8, $79, $ca, $ab, $9c, $9d, $8e, $f0, $d1, $c2, $a3, $84, $85, $76, $77, 8, 9, $f9, $fa, $db, $cc, $bd, $ae, $61, $22, $23, $14, $f4, $e5, $d6, $c7, $58, $59, $3a, $3b, $1c, $d, $fd, $fe, $92, $53, $44, $35, $16, $f6, $e7, $e8, $79, $6a, $5b, $4c, $2d, $3e, $1f, $ef, $53, $14, 5, $e5, $c6, $b7, $a8, $99, $2a, $2b, $c, $d, $dd, $ce, $cf, $ff, $f3, $b4, $95, $86, $57, $38, $29, $1a, $ba, $ab, $9c, $8d, $6e, $5f, $ff, $ff, $95, $56, $27, $18, $e8, $d9, $ca, $bb, $4c, $3d, $2e, $1f, $ef, $ff, $ff, $ff, $c5, $86, $57, $38, $19, $a, $ea, $db, $6c, $5d, $3e, $3f, $ef, $ff, $ff, $ff, $65, $26, 7, $e7, $c8, $b9, $9a, $9b, $2c, $1d, $fd, $fe, $cf, $ff, $ff, $ff, $b4, $75, $56, $37, $28, $19, $e9, $ea, $7b, $6c, $5d, $4e, $2f, $ff, $ff, $ff, $c3, $94, $75, $56, $47, $38, $19, $1a, $aa, $ab, $7c, $7d, $5e, $4f, $ff, $ff, $e2, $a3, $94, $85, $76, $67, $38, $49, $d9, $ca, $ab, $bc, $7d, $7e, $6f, $ff
.pc = $2f00 "PAL_BLUE"
  PAL_BLUE: .byte 0, $f3, $d4, $b5, $a6, $97, $88, $79, $1a, $fa, $eb, $ec, $bd, $be, $af, $ff, 0, 0, 0, 0, $c0, $b1, $a2, $a3, $34, $35, $26, $27, $f7, $f8, $f9, $ea, 0, 0, $30, $11, $22, $13, $14, 5, $b5, $96, $97, $98, $79, $6a, $5b, $4c, $81, $42, $43, $34, 5, 6, $f6, $f7, $78, $69, $5a, $5b, $4c, $3d, $1e, $f, $17, $c7, $a8, $89, $5a, $5b, $3c, $1d, $ad, $9e, $7f, $ff, $ff, $ff, $ff, $ff, $78, 9, $e9, $ca, $ab, $7c, $5d, $5e, $de, $cf, $ff, $ff, $ff, $ff, $ff, $ff, $59, $a, $ca, $bb, $8c, $6d, $3e, $2f, $bf, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $49, $f9, $da, $ab, $7c, $5d, $2e, $2f, $af, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $48, $d8, $b9, $aa, $7b, $5c, $2d, $2e, $be, $9f, $ff, $ff, $ff, $ff, $ff, $ff, 7, $97, $88, $69, $4a, $2b, $1c, $2d, $9d, $7e, $6f, $ff, $ff, $ff, $ff, $ff, $81, $62, $53, $44, 5, 6, $f6, $e7, $78, $69, $5a, $5b, $3c, $2d, $2e, $1f, 0, 0, 0, 0, $b0, $b1, $a2, $b3, $44, $35, $36, $37, 8, $f8, $a, $b, 0, 0, 0, 0, 0, $70, $61, $62, $f2, $e3, $d4, $c5, $b6, $b7, $b8, $99, 0, 0, 0, 0, 0, 0, $f0, $f1, $82, $83, $84, $85, $66, $57, $58, $59, 0, 0, 0, 0, 0, $70, $61, $62, $e2, $e3, $d4, $d5, $b6, $a7, $b8, $a9, 0, 0, 0, 0, $a0, $b1, $a2, $a3, $44, $35, $26, $37, $f7, $19, $f9, $fa

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __init1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b16
Removing instruction jmp __b18
Removing instruction jmp __b20
Removing instruction jmp __b21
Removing instruction jmp __b28
Removing instruction jmp __b30
Removing instruction jmp __b31
Removing instruction jmp __b33
Removing instruction jmp __b34
Removing instruction jmp __b35
Removing instruction jmp __b37
Removing instruction jmp __b38
Removing instruction jmp __b39
Removing instruction jmp __breturn
Removing instruction jmp __b23
Removing instruction jmp __b25
Removing instruction jmp __b27
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b13
Removing instruction jmp __b14
Removing instruction jmp __b15
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b39_from___b37 with __b39
Replacing label __b7_from___b12 with __b7
Replacing label __b7_from___b13 with __b7
Replacing label __b7_from___b14 with __b7
Replacing label __b7_from___b6 with __b7
Replacing label __b7_from___b5 with __b7
Replacing label __b7_from___b4 with __b7
Replacing label __b5_from___b5 with __b5
Replacing label __b7_from___b7 with __b7
Removing instruction __b1_from___init1:
Removing instruction __b39_from___b37:
Removing instruction __b39_from___b38:
Removing instruction __b7_from___b12:
Removing instruction __b7_from___b13:
Removing instruction __b7_from___b14:
Removing instruction __b7_from___b15:
Removing instruction __b7_from___b4:
Removing instruction __b7_from___b5:
Removing instruction __b7_from___b6:
Removing instruction __b5_from___b5:
Removing instruction __b7_from___b6:
Removing instruction __b7_from___b7:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __init1:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1_from_irq:
Removing instruction __b3:
Removing instruction __b16_from___b3:
Removing instruction __b18_from___b16:
Removing instruction __b20:
Removing instruction __b21_from___b20:
Removing instruction __b28_from___b21:
Removing instruction __b30:
Removing instruction __b31_from___b30:
Removing instruction __b33:
Removing instruction __b34:
Removing instruction __b35_from___b34:
Removing instruction __b37:
Removing instruction __b38:
Removing instruction __b35_from___b36:
Removing instruction __b31_from___b32:
Removing instruction __b28_from___b29:
Removing instruction __b23_from___b22:
Removing instruction __b25_from___b23:
Removing instruction __b27:
Removing instruction __b21_from___b27:
Removing instruction __b25_from___b26:
Removing instruction __b23_from___b24:
Removing instruction __b18_from___b19:
Removing instruction __b16_from___b17:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b13:
Removing instruction __b14:
Removing instruction __b15:
Removing instruction __b9:
Removing instruction __b1_from___b9:
Removing instruction memset_from_main:
Removing instruction __b1_from_main:
Removing instruction __b3_from___b1:
Removing instruction __b5_from___b3:
Removing instruction __b6:
Removing instruction __b3_from___b4:
Removing instruction __b1_from___b2:
Removing instruction __b1_from_memset:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b5
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldy #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Fixing long branch [138] bne __b2 to beq
Fixing long branch [148] bcc __b17 to bcs
Fixing long branch [155] bne __b19 to beq

FINAL SYMBOL TABLE
(const nomodify struct MOS6526_CIA*) CIA1 = (struct MOS6526_CIA*) 56320
(const nomodify byte) CIA_INTERRUPT_CLEAR = (byte) $7f
(const nomodify byte*) COLORRAM = (byte*) 55296
(const nomodify byte*) DEFAULT_SCREEN = (byte*) 1024
(byte) DMA_LIST_F018A::command
(word) DMA_LIST_F018A::count
(byte*) DMA_LIST_F018A::dest
(byte) DMA_LIST_F018A::dest_bank
(word) DMA_LIST_F018A::modulo
(byte*) DMA_LIST_F018A::src
(byte) DMA_LIST_F018A::src_bank
(byte) DMA_LIST_F018B::command
(word) DMA_LIST_F018B::count
(byte*) DMA_LIST_F018B::dest
(byte) DMA_LIST_F018B::dest_bank
(word) DMA_LIST_F018B::modulo
(byte*) DMA_LIST_F018B::src
(byte) DMA_LIST_F018B::src_bank
(byte) DMA_LIST_F018B::sub_command
(byte) F018_DMAGIC::ADDRBANK
(byte) F018_DMAGIC::ADDRLSB
(byte) F018_DMAGIC::ADDRLSBTRIG
(byte) F018_DMAGIC::ADDRMB
(byte) F018_DMAGIC::ADDRMSB
(byte) F018_DMAGIC::EN018B
(byte) F018_DMAGIC::ETRIG
(byte) F018_DMAGIC::MISC
(const byte*) F018_DMAGIC::UNUSED1[(number) 8]  = { fill( 8, 0) }
(byte) F018_DMAGIC::UNUSED2
(const byte*) GREETING[]  = (byte*) "   DOUBLEFLASH        ADTBM          SY2002          TAYGER         SERIOUSLY   LIBI IN PARADIZE       LGB          BLUEWAYSW        SAUSAGE       BIT SHIFTER     INDIOCOLIFA     GRUMPYNINJA      0-LIMITS         CHEVERON     DR. COMMODORE "
(const nomodify byte) GREET_COUNT = (byte) $f
(const nomodify byte) GREET_ROW = (byte) $14
(const nomodify void()**) HARDWARE_IRQ = (void()**) 65534
(const nomodify byte) IRQ_RASTER = (byte) 1
(const nomodify byte) IRQ_Y = (byte) $16
(const nomodify byte) LOGO_ROW = (byte) 3
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(const byte*) MEGA_LOGO[]  = { (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $cf, (byte) $cf, (byte) $20, (byte) $20, (byte) $cf, (byte) $20, (byte) $20, (byte) $20, (byte) $cf }
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL = (byte) $5a
(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = (byte) $31
(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = (byte) $54
(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0 = (byte) $6f
(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = (byte) $5c
(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = (byte) $4c
(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR = (byte) $21
(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR = (byte) $20
(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY = (byte) $2f
(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = (byte) $d
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = (byte) $11
(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = (byte) $16
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = (byte) $1a
(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = (byte) $19
(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER = (byte) $12
(const nomodify byte*) PALETTE_BLUE = (byte*) 54016
(const nomodify byte*) PALETTE_GREEN = (byte*) 53760
(const nomodify byte*) PALETTE_RED = (byte*) 53504
(const byte*) PAL_BLUE[]  = { (byte) 0, (byte) $f3, (byte) $d4, (byte) $b5, (byte) $a6, (byte) $97, (byte) $88, (byte) $79, (byte) $1a, (byte) $fa, (byte) $eb, (byte) $ec, (byte) $bd, (byte) $be, (byte) $af, (byte) $ff, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $c0, (byte) $b1, (byte) $a2, (byte) $a3, (byte) $34, (byte) $35, (byte) $26, (byte) $27, (byte) $f7, (byte) $f8, (byte) $f9, (byte) $ea, (byte) 0, (byte) 0, (byte) $30, (byte) $11, (byte) $22, (byte) $13, (byte) $14, (byte) 5, (byte) $b5, (byte) $96, (byte) $97, (byte) $98, (byte) $79, (byte) $6a, (byte) $5b, (byte) $4c, (byte) $81, (byte) $42, (byte) $43, (byte) $34, (byte) 5, (byte) 6, (byte) $f6, (byte) $f7, (byte) $78, (byte) $69, (byte) $5a, (byte) $5b, (byte) $4c, (byte) $3d, (byte) $1e, (byte) $f, (byte) $17, (byte) $c7, (byte) $a8, (byte) $89, (byte) $5a, (byte) $5b, (byte) $3c, (byte) $1d, (byte) $ad, (byte) $9e, (byte) $7f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $78, (byte) 9, (byte) $e9, (byte) $ca, (byte) $ab, (byte) $7c, (byte) $5d, (byte) $5e, (byte) $de, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $59, (byte) $a, (byte) $ca, (byte) $bb, (byte) $8c, (byte) $6d, (byte) $3e, (byte) $2f, (byte) $bf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $49, (byte) $f9, (byte) $da, (byte) $ab, (byte) $7c, (byte) $5d, (byte) $2e, (byte) $2f, (byte) $af, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $48, (byte) $d8, (byte) $b9, (byte) $aa, (byte) $7b, (byte) $5c, (byte) $2d, (byte) $2e, (byte) $be, (byte) $9f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) 7, (byte) $97, (byte) $88, (byte) $69, (byte) $4a, (byte) $2b, (byte) $1c, (byte) $2d, (byte) $9d, (byte) $7e, (byte) $6f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $81, (byte) $62, (byte) $53, (byte) $44, (byte) 5, (byte) 6, (byte) $f6, (byte) $e7, (byte) $78, (byte) $69, (byte) $5a, (byte) $5b, (byte) $3c, (byte) $2d, (byte) $2e, (byte) $1f, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $b0, (byte) $b1, (byte) $a2, (byte) $b3, (byte) $44, (byte) $35, (byte) $36, (byte) $37, (byte) 8, (byte) $f8, (byte) $a, (byte) $b, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $70, (byte) $61, (byte) $62, (byte) $f2, (byte) $e3, (byte) $d4, (byte) $c5, (byte) $b6, (byte) $b7, (byte) $b8, (byte) $99, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $f0, (byte) $f1, (byte) $82, (byte) $83, (byte) $84, (byte) $85, (byte) $66, (byte) $57, (byte) $58, (byte) $59, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $70, (byte) $61, (byte) $62, (byte) $e2, (byte) $e3, (byte) $d4, (byte) $d5, (byte) $b6, (byte) $a7, (byte) $b8, (byte) $a9, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) $a0, (byte) $b1, (byte) $a2, (byte) $a3, (byte) $44, (byte) $35, (byte) $26, (byte) $37, (byte) $f7, (byte) $19, (byte) $f9, (byte) $fa }
(const byte*) PAL_GREEN[]  = { (byte) 0, (byte) $e3, (byte) $c4, (byte) $b5, (byte) $96, (byte) $87, (byte) $78, (byte) $79, (byte) $a, (byte) $fa, (byte) $eb, (byte) $dc, (byte) $bd, (byte) $ae, (byte) $af, (byte) $ff, (byte) $e2, (byte) $b3, (byte) $a4, (byte) $85, (byte) $76, (byte) $67, (byte) $48, (byte) $49, (byte) $d9, (byte) $da, (byte) $bb, (byte) $bc, (byte) $8d, (byte) $8e, (byte) $7f, (byte) $ff, (byte) $42, (byte) 3, (byte) 4, (byte) $e4, (byte) $d5, (byte) $c6, (byte) $b7, (byte) $a8, (byte) $39, (byte) $3a, (byte) $1b, (byte) $2c, (byte) $fc, (byte) $fd, (byte) $de, (byte) $df, (byte) $61, (byte) $32, (byte) $13, (byte) 4, (byte) $e4, (byte) $e5, (byte) $d6, (byte) $d7, (byte) $78, (byte) $59, (byte) $4a, (byte) $4b, (byte) $2c, (byte) $1d, (byte) $e, (byte) $fe, (byte) $e0, (byte) $b1, (byte) $a2, (byte) $93, (byte) $74, (byte) $75, (byte) $56, (byte) $57, (byte) $e7, (byte) $d8, (byte) $79, (byte) $ca, (byte) $ab, (byte) $9c, (byte) $9d, (byte) $8e, (byte) $f0, (byte) $d1, (byte) $c2, (byte) $a3, (byte) $84, (byte) $85, (byte) $76, (byte) $77, (byte) 8, (byte) 9, (byte) $f9, (byte) $fa, (byte) $db, (byte) $cc, (byte) $bd, (byte) $ae, (byte) $61, (byte) $22, (byte) $23, (byte) $14, (byte) $f4, (byte) $e5, (byte) $d6, (byte) $c7, (byte) $58, (byte) $59, (byte) $3a, (byte) $3b, (byte) $1c, (byte) $d, (byte) $fd, (byte) $fe, (byte) $92, (byte) $53, (byte) $44, (byte) $35, (byte) $16, (byte) $f6, (byte) $e7, (byte) $e8, (byte) $79, (byte) $6a, (byte) $5b, (byte) $4c, (byte) $2d, (byte) $3e, (byte) $1f, (byte) $ef, (byte) $53, (byte) $14, (byte) 5, (byte) $e5, (byte) $c6, (byte) $b7, (byte) $a8, (byte) $99, (byte) $2a, (byte) $2b, (byte) $c, (byte) $d, (byte) $dd, (byte) $ce, (byte) $cf, (byte) $ff, (byte) $f3, (byte) $b4, (byte) $95, (byte) $86, (byte) $57, (byte) $38, (byte) $29, (byte) $1a, (byte) $ba, (byte) $ab, (byte) $9c, (byte) $8d, (byte) $6e, (byte) $5f, (byte) $ff, (byte) $ff, (byte) $95, (byte) $56, (byte) $27, (byte) $18, (byte) $e8, (byte) $d9, (byte) $ca, (byte) $bb, (byte) $4c, (byte) $3d, (byte) $2e, (byte) $1f, (byte) $ef, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $c5, (byte) $86, (byte) $57, (byte) $38, (byte) $19, (byte) $a, (byte) $ea, (byte) $db, (byte) $6c, (byte) $5d, (byte) $3e, (byte) $3f, (byte) $ef, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $65, (byte) $26, (byte) 7, (byte) $e7, (byte) $c8, (byte) $b9, (byte) $9a, (byte) $9b, (byte) $2c, (byte) $1d, (byte) $fd, (byte) $fe, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $b4, (byte) $75, (byte) $56, (byte) $37, (byte) $28, (byte) $19, (byte) $e9, (byte) $ea, (byte) $7b, (byte) $6c, (byte) $5d, (byte) $4e, (byte) $2f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $c3, (byte) $94, (byte) $75, (byte) $56, (byte) $47, (byte) $38, (byte) $19, (byte) $1a, (byte) $aa, (byte) $ab, (byte) $7c, (byte) $7d, (byte) $5e, (byte) $4f, (byte) $ff, (byte) $ff, (byte) $e2, (byte) $a3, (byte) $94, (byte) $85, (byte) $76, (byte) $67, (byte) $38, (byte) $49, (byte) $d9, (byte) $ca, (byte) $ab, (byte) $bc, (byte) $7d, (byte) $7e, (byte) $6f, (byte) $ff }
(const byte*) PAL_RED[]  = { (byte) 0, (byte) $f3, (byte) $d4, (byte) $b5, (byte) $a6, (byte) $97, (byte) $88, (byte) $79, (byte) $1a, (byte) $fa, (byte) $eb, (byte) $ec, (byte) $bd, (byte) $be, (byte) $af, (byte) $ff, (byte) $16, (byte) $c6, (byte) $a7, (byte) $88, (byte) $49, (byte) $5a, (byte) $2b, (byte) $1c, (byte) $ac, (byte) $ad, (byte) $8e, (byte) $8f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $c6, (byte) $77, (byte) $48, (byte) $29, (byte) $e9, (byte) $fa, (byte) $cb, (byte) $cc, (byte) $5d, (byte) $4e, (byte) $2f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $57, (byte) $18, (byte) $f8, (byte) $d9, (byte) $aa, (byte) $8b, (byte) $6c, (byte) $5d, (byte) $ed, (byte) $de, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $26, (byte) $e6, (byte) $b7, (byte) $a8, (byte) $69, (byte) $5a, (byte) $3b, (byte) $3c, (byte) $dc, (byte) $cd, (byte) $ae, (byte) $9f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $65, (byte) $16, (byte) $17, (byte) $f7, (byte) $d8, (byte) $b9, (byte) $9a, (byte) $8b, (byte) $2c, (byte) $d, (byte) $fd, (byte) $ee, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $64, (byte) $15, (byte) 6, (byte) $e6, (byte) $c7, (byte) $a8, (byte) $99, (byte) $8a, (byte) $1b, (byte) $c, (byte) $fc, (byte) $fd, (byte) $ee, (byte) $cf, (byte) $ff, (byte) $ff, (byte) $12, (byte) $d2, (byte) $d3, (byte) $b4, (byte) $95, (byte) $86, (byte) $77, (byte) $78, (byte) 9, (byte) $69, (byte) $ea, (byte) $fb, (byte) $dc, (byte) $ad, (byte) $ae, (byte) $af, (byte) $f0, (byte) $c1, (byte) $c2, (byte) $a3, (byte) $84, (byte) $85, (byte) $76, (byte) $67, (byte) 8, (byte) $f8, (byte) $e9, (byte) $da, (byte) $db, (byte) $bc, (byte) $bd, (byte) $ae, (byte) $40, (byte) $11, (byte) $12, (byte) $f2, (byte) $e3, (byte) $d4, (byte) $c5, (byte) $c6, (byte) $47, (byte) $38, (byte) $39, (byte) $2a, (byte) $1b, (byte) $c, (byte) $d, (byte) $ed, (byte) 0, (byte) 0, (byte) $f0, (byte) $d1, (byte) $c2, (byte) $b3, (byte) $a4, (byte) $95, (byte) $36, (byte) $27, (byte) $28, (byte) $29, (byte) $f9, (byte) $ea, (byte) $eb, (byte) $ec, (byte) $70, (byte) $41, (byte) $22, (byte) $23, (byte) $f3, (byte) $f4, (byte) $e5, (byte) $e6, (byte) $77, (byte) $78, (byte) $69, (byte) $7a, (byte) $3b, (byte) $3c, (byte) $3d, (byte) $3e, (byte) $a1, (byte) $82, (byte) $63, (byte) $54, (byte) $35, (byte) $26, (byte) 7, (byte) 8, (byte) $98, (byte) $99, (byte) $8a, (byte) $7b, (byte) $5c, (byte) $5d, (byte) $3e, (byte) $3f, (byte) $33, (byte) 4, (byte) $d4, (byte) $d5, (byte) $a6, (byte) $a7, (byte) $88, (byte) $89, (byte) $1a, (byte) $ab, (byte) $fb, (byte) $ec, (byte) $cd, (byte) $be, (byte) $af, (byte) $ff, (byte) $b4, (byte) $85, (byte) $56, (byte) $47, (byte) $18, (byte) 9, (byte) $f9, (byte) $ea, (byte) $7b, (byte) $7c, (byte) $5d, (byte) $5e, (byte) $2f, (byte) $ef, (byte) $ff, (byte) $ff, (byte) 6, (byte) $d6, (byte) $a7, (byte) $98, (byte) $59, (byte) $4a, (byte) $2b, (byte) $2c, (byte) $bc, (byte) $ad, (byte) $8e, (byte) $8f, (byte) $ff, (byte) $ff, (byte) $ff, (byte) $ff }
(const nomodify byte*) PROCPORT = (byte*) 1
(const nomodify byte*) PROCPORT_DDR = (byte*) 0
(const nomodify byte) PROCPORT_DDR_MEMORY_MASK = (byte) 7
(const nomodify byte) PROCPORT_RAM_IO = (byte) 5
(const nomodify byte) RASTER_LINES = (byte) $d8
(const nomodify byte) SCROLL_BLACKBARS = (byte) $13
(const nomodify byte) SCROLL_ROW = (byte) $d
(const byte*) SCROLL_TEXT[]  = (byte*) "    THIS SMALL MEGA65 RASTER INTRO ... WAS MADE BY DEFT IN 2015 ... AND BROUGHT BACK TO LIFE 5 YEARS LATER IN 2020 ... BECAUSE THE MEGA65 HARDWARE CHANGED SO MUCH IN THE PAST 5 YEARS ... UNFORTUNATELY MY ASSEMBLER SKILLS DID NOT SO THIS IS THE FIRST APPROACH TO GET BETTER ... HOPEFULLY DR.MUTTI WILL HAVE TO SCOLD ME LESS ... THE PAST 5 YEARS HAVE BEEN AN UNFORGETTABLE & UNIQUE RIDE ... IF YOU DO WATCH THIS DEMO ON YOUR VERY OWN MEGA65 THERE IS ENOUGH EVIDENCE OF WHAT WE ACTUALLY ACHIEVED ... BELOW ARE THE GREETINGS TO DEAR AND VERY SPECIAL PEOPLE WHO HELPED TO GET THERE ... THANK YOU SO MUCH FOR YOUR SUPPORT AND FOR NOT GIVING UP ... DUAL SID TUNE BY RAYDEN OF ALPHA FLIGHT ... THIS SCROLLY WILL NOW RESTART           *WRAP*                    "
(const nomodify byte) SCROLL_Y = (byte) $66
(const byte*) SINUS[(number) $100]  = kickasm {{ .fill 256, 91.5 + 91.5*sin(i*2*PI/256)
 }}
(const byte) SIZEOF_BYTE = (byte) 1
(const byte*) SONG[]  = kickasm {{ .import c64 "DiscoZak_2SID_patched.prg"
 }}
(const nomodify struct MOS6569_VICII*) VICII = (struct MOS6569_VICII*) 53248
(const nomodify struct MOS4569_VICIII*) VICIII = (struct MOS4569_VICIII*) 53248
(const nomodify struct MEGA65_VICIV*) VICIV = (struct MEGA65_VICIV*) 53248
(void()) __start()
(label) __start::@1
(label) __start::@return
(label) __start::__init1
(volatile byte) greet_idx loadstore zp[1]:11 0.6153846153846154
(volatile byte) greet_zoomx loadstore zp[1]:10 1.3939393939393938
interrupt(HARDWARE_STACK)(void()) irq()
(byte~) irq::$10 reg byte a 22.0
(byte~) irq::$26 reg byte a 22.0
(byte~) irq::$27 reg byte a 22.0
(byte~) irq::$29 reg byte a 22.0
(byte~) irq::$33 reg byte a 4.0
(label) irq::@1
(label) irq::@10
(label) irq::@11
(label) irq::@12
(label) irq::@13
(label) irq::@14
(label) irq::@15
(label) irq::@16
(label) irq::@17
(label) irq::@18
(label) irq::@19
(label) irq::@2
(label) irq::@20
(label) irq::@21
(label) irq::@22
(label) irq::@23
(label) irq::@24
(label) irq::@25
(label) irq::@26
(label) irq::@27
(label) irq::@28
(label) irq::@29
(label) irq::@3
(label) irq::@30
(label) irq::@31
(label) irq::@32
(label) irq::@33
(label) irq::@34
(label) irq::@35
(label) irq::@36
(label) irq::@37
(label) irq::@38
(label) irq::@39
(label) irq::@4
(label) irq::@5
(label) irq::@6
(label) irq::@7
(label) irq::@8
(label) irq::@9
(label) irq::@return
(byte) irq::barcnt
(byte) irq::barcnt#1 barcnt zp[1]:2 22.0
(byte) irq::barcnt#2 barcnt zp[1]:2 2.588235294117647
(byte) irq::barcol
(byte) irq::barcol#0 reg byte z 22.0
(byte) irq::barcol#1 reg byte z 101.0
(byte) irq::barcol#2 reg byte z 75.75
(byte) irq::barcol#3 reg byte z 103.75
(byte) irq::barcol#4 reg byte z 151.5
(byte) irq::col
(byte) irq::col#0 reg byte a 16.5
(byte) irq::col1
(byte) irq::col1#0 reg byte a 16.5
(byte) irq::col1#1 reg byte a 12.833333333333334
(byte) irq::greet_offset
(byte) irq::greet_offset#0 reg byte y 4.0
(byte) irq::greet_offset#1 reg byte y 11.0
(byte) irq::greet_offset#2 reg byte y 8.75
(byte) irq::i
(byte) irq::i#1 reg byte x 22.0
(byte) irq::i#2 reg byte x 9.307692307692307
(byte) irq::i1
(byte) irq::i1#1 reg byte y 202.0
(byte) irq::i1#2 reg byte y 60.599999999999994
(byte) irq::i2
(byte) irq::i2#1 reg byte y 202.0
(byte) irq::i2#2 reg byte y 60.599999999999994
(byte) irq::i3
(byte) irq::i3#1 reg byte x 22.0
(byte) irq::i3#2 reg byte x 11.0
(byte) irq::i4
(byte) irq::i4#1 reg byte x 22.0
(byte) irq::i4#2 reg byte x 8.8
(byte) irq::i5
(byte) irq::i5#1 reg byte x 22.0
(byte) irq::i5#2 reg byte x 18.333333333333332
(byte) irq::idx
(byte) irq::idx#0 reg byte x 11.0
(byte) irq::idx#1 reg byte x 67.33333333333333
(byte) irq::idx#2 reg byte x 101.0
(byte) irq::idx#3 reg byte x 138.33333333333331
(byte) irq::idx#4 reg byte x 101.0
(byte) irq::l
(byte) irq::l#1 reg byte x 22.0
(byte) irq::l#2 reg byte x 14.666666666666666
(byte) irq::line
(byte) irq::line#1 reg byte z 22.0
(byte) irq::line#10 reg byte z 3.259259259259259
(byte) irq::nxt
(byte) irq::nxt#0 reg byte a 2.0
(byte) irq::nxt#1 reg byte a 4.0
(byte) irq::nxt#2 reg byte a 6.0
(byte) irq::raster
(byte) irq::raster#0 reg byte a 56.0
(byte) irq::sin_bar
(byte) irq::sin_bar#0 sin_bar zp[1]:3 4.0
(byte) irq::sin_bar#1 sin_bar zp[1]:3 11.0
(byte) irq::sin_bar#2 sin_bar zp[1]:3 2.1875
(byte) irq::sin_col
(byte) irq::sin_col#0 reg byte y 4.0
(byte) irq::sin_col#1 reg byte y 11.0
(byte) irq::sin_col#2 reg byte y 3.833333333333333
(byte) irq::wobble_idx
(byte) irq::wobble_idx#0 reg byte x 4.0
(byte) irq::wobble_idx#1 reg byte x 11.0
(byte) irq::wobble_idx#10 reg byte x 4.590909090909091
(byte) irq::wobble_idx#7 reg byte x 22.0
(byte) irq::zoomval
(byte) irq::zoomval#0 reg byte a 11.0
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(byte) main::i
(byte) main::i#1 reg byte x 151.5
(byte) main::i#2 reg byte x 202.0
(byte) main::i1
(byte) main::i1#1 reg byte x 202.0
(byte) main::i1#2 reg byte x 168.33333333333331
(byte) main::i2
(byte) main::i2#1 reg byte x 202.0
(byte) main::i2#2 reg byte x 134.66666666666666
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@return
(byte) memset::c
(const byte) memset::c#0 c = (byte) ' '
(byte*) memset::dst
(byte*) memset::dst#1 dst zp[2]:4 2002.0
(byte*) memset::dst#2 dst zp[2]:4 1334.6666666666667
(byte*) memset::end
(const byte*) memset::end#0 end = (byte*)(const void*) memset::str#0+(const word) memset::num#0
(word) memset::num
(const word) memset::num#0 num = (word)(number) $28*(number) $19
(void*) memset::return
(void*) memset::str
(const void*) memset::str#0 str = (void*)(const nomodify byte*) DEFAULT_SCREEN
(const byte*) rasters[(const nomodify byte) RASTER_LINES]  = { fill( RASTER_LINES, 0) }
(volatile byte*) scroll_ptr loadstore zp[2]:8 0.1276595744680851
(volatile byte) scroll_soft loadstore zp[1]:7 0.2441860465116279
(volatile byte) sin_idx loadstore zp[1]:6 0.22641509433962262
(const void()*) songInit = (void()*)(const byte*) SONG
(const void()*) songPlay = (void()*)(const byte*) SONG+(byte) 3

reg byte z [ irq::line#10 irq::line#1 ]
reg byte x [ irq::wobble_idx#10 irq::wobble_idx#0 irq::wobble_idx#7 irq::wobble_idx#1 ]
reg byte x [ irq::i#2 irq::i#1 ]
reg byte y [ irq::sin_col#2 irq::sin_col#1 irq::sin_col#0 ]
reg byte x [ irq::l#2 irq::l#1 ]
zp[1]:2 [ irq::barcnt#2 irq::barcnt#1 ]
zp[1]:3 [ irq::sin_bar#2 irq::sin_bar#0 irq::sin_bar#1 ]
reg byte x [ irq::i3#2 irq::i3#1 ]
reg byte x [ irq::i4#2 irq::i4#1 ]
reg byte y [ irq::greet_offset#2 irq::greet_offset#0 irq::greet_offset#1 ]
reg byte x [ irq::i5#2 irq::i5#1 ]
reg byte a [ irq::nxt#2 irq::nxt#0 irq::nxt#1 ]
reg byte y [ irq::i1#2 irq::i1#1 ]
reg byte y [ irq::i2#2 irq::i2#1 ]
reg byte z [ irq::barcol#4 irq::barcol#3 irq::barcol#0 irq::barcol#1 irq::barcol#2 ]
reg byte x [ irq::idx#4 irq::idx#3 irq::idx#0 irq::idx#1 irq::idx#2 ]
reg byte x [ main::i1#2 main::i1#1 ]
reg byte x [ main::i2#2 main::i2#1 ]
reg byte x [ main::i#2 main::i#1 ]
zp[2]:4 [ memset::dst#2 memset::dst#1 ]
zp[1]:6 [ sin_idx ]
zp[1]:7 [ scroll_soft ]
zp[2]:8 [ scroll_ptr ]
zp[1]:10 [ greet_zoomx ]
zp[1]:11 [ greet_idx ]
reg byte a [ irq::$33 ]
reg byte a [ irq::$29 ]
reg byte a [ irq::$26 ]
reg byte a [ irq::$27 ]
reg byte a [ irq::col1#0 ]
reg byte a [ irq::col1#1 ]
reg byte a [ irq::col#0 ]
reg byte a [ irq::zoomval#0 ]
reg byte a [ irq::$10 ]
reg byte a [ irq::raster#0 ]


FINAL ASSEMBLER
Score: 9963

  // File Comments
// Raster65 Demo re-implementation in C by Jesper Gravgaard
// Based on RASTER65 assembler demo made in 2015 and updated in 2020 by DEFT 
// https://mega.scryptos.com/sharefolder/MEGA/MEGA65+filehost
// https://www.forum64.de/index.php?thread/104591-xemu-vic-iv-implementation-update/&postID=1560511#post1560511
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform executable starting in C64 mode.
.file [name="raster65.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$080d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(__start)
.segment Code


  // Global Constants & labels
  // Value that disables all CIA interrupts when stored to the CIA Interrupt registers
  .const CIA_INTERRUPT_CLEAR = $7f
  // Bits for the VICII IRQ Status/Enable Registers
  .const IRQ_RASTER = 1
  // Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
  .const PROCPORT_DDR_MEMORY_MASK = 7
  // RAM in 0xA000, 0xE000 I/O in 0xD000
  .const PROCPORT_RAM_IO = 5
  // Logo start screen row 
  .const LOGO_ROW = 3
  // Scroll screen row
  .const SCROLL_ROW = $d
  // Greeting screen row
  .const GREET_ROW = $14
  // y rasterline where IRQ starts
  .const IRQ_Y = $16
  // y rasterline where scrolly starts
  .const SCROLL_Y = $66
  // size of raster behind scrolly
  .const SCROLL_BLACKBARS = $13
  // The number of raster lines
  .const RASTER_LINES = $d8
  // The number of greetings
  .const GREET_COUNT = $f
  .const OFFSET_STRUCT_MOS4569_VICIII_KEY = $2f
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLB = $31
  .const OFFSET_STRUCT_MEGA65_VICIV_CONTROLC = $54
  .const OFFSET_STRUCT_MOS6526_CIA_INTERRUPT = $d
  .const OFFSET_STRUCT_MOS6569_VICII_RASTER = $12
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL1 = $11
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE = $1a
  .const OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO = $5c
  .const OFFSET_STRUCT_MEGA65_VICIV_RASLINE0 = $6f
  .const OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS = $19
  .const OFFSET_STRUCT_MOS6569_VICII_CONTROL2 = $16
  .const OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR = $20
  .const OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR = $21
  .const OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO = $4c
  .const OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL = $5a
  .const SIZEOF_BYTE = 1
  // Processor port data direction register
  .label PROCPORT_DDR = 0
  // Processor Port Register controlling RAM/ROM configuration and the datasette
  .label PROCPORT = 1
  // The VIC-II MOS 6567/6569
  .label VICII = $d000
  // The VIC III MOS 4567/4569
  .label VICIII = $d000
  // The VIC IV
  .label VICIV = $d000
  // Palette RED
  .label PALETTE_RED = $d100
  // Palette GREEN
  .label PALETTE_GREEN = $d200
  // Palette BLUE
  .label PALETTE_BLUE = $d300
  // Color Ram
  .label COLORRAM = $d800
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $400
  // The CIA#1: keyboard matrix, joystick #1/#2
  .label CIA1 = $dc00
  // The vector used when the HARDWARE serves IRQ interrupts
  .label HARDWARE_IRQ = $fffe
  // Pointer to the song init routine
  .label songInit = SONG
  // Pointer to the song play routine
  .label songPlay = SONG+3
  // Sinus Position (used across effects)
  .label sin_idx = 6
  // scroll soft position of text scrolly (0-7)
  .label scroll_soft = 7
  // scroll text pointer to next char
  .label scroll_ptr = 8
  // Zoom Position
  .label greet_zoomx = $a
  // The greeting currently being shown
  .label greet_idx = $b
.segment Code
  // __start
__start: {
    // __start::__init1
    // sin_idx
    // [1] (volatile byte) sin_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // scroll_soft = 7
    // [2] (volatile byte) scroll_soft ← (byte) 7 -- vbuz1=vbuc1 
    lda #7
    sta.z scroll_soft
    // scroll_ptr = SCROLL_TEXT
    // [3] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT -- pbuz1=pbuc1 
    lda #<SCROLL_TEXT
    sta.z scroll_ptr
    lda #>SCROLL_TEXT
    sta.z scroll_ptr+1
    // greet_zoomx
    // [4] (volatile byte) greet_zoomx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_zoomx
    // greet_idx
    // [5] (volatile byte) greet_idx ← (byte) 0 -- vbuz1=vbuc1 
    sta.z greet_idx
    // [6] phi from __start::__init1 to __start::@1 [phi:__start::__init1->__start::@1]
    // __start::@1
    // [7] call main 
    jsr main
    // __start::@return
    // [8] return 
    rts
}
  // irq
// BIG INTERRUPT LOOP
irq: {
    .label sin_bar = 3
    .label barcnt = 2
    // entry interrupt(HARDWARE_STACK)
    pha
    txa
    pha
    tya
    pha
    // VICIV->RASLINE0 |= 0x80
    // [9] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_RASLINE0) | (byte) $80 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // force NTSC every frame (hehe)
    lda #$80
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_RASLINE0
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_RASLINE0
    // VICII->IRQ_STATUS = IRQ_RASTER
    // [10] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Acknowledge the IRQ
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_STATUS
    // VICII->CONTROL2 = 0
    // [11] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // reset x scroll
    lda #0
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    // wobble_idx = ++sin_idx
    // [12] (volatile byte) sin_idx ← ++ (volatile byte) sin_idx -- vbuz1=_inc_vbuz1 
    inc.z sin_idx
    // [13] (byte) irq::wobble_idx#0 ← (volatile byte) sin_idx -- vbuxx=vbuz1 
    // Generate Raster Bars and more
    ldx.z sin_idx
    // [14] phi from irq to irq::@1 [phi:irq->irq::@1]
    // [14] phi (byte) irq::wobble_idx#10 = (byte) irq::wobble_idx#0 [phi:irq->irq::@1#0] -- register_copy 
    // [14] phi (byte) irq::line#10 = (byte) 0 [phi:irq->irq::@1#1] -- vbuzz=vbuc1 
    ldz #0
    // irq::@1
  __b1:
    // for(char line=0;line!=RASTER_LINES;line++)
    // [15] if((byte) irq::line#10!=(const nomodify byte) RASTER_LINES) goto irq::@2 -- vbuzz_neq_vbuc1_then_la1 
    cpz #RASTER_LINES
    beq !__b2+
    jmp __b2
  !__b2:
    // irq::@3
    // (*songPlay)()
    // [16] call *((const void()*) songPlay) 
    // play music
    jsr songPlay
    // sin_col = sin_idx
    // [17] (byte) irq::sin_col#0 ← (volatile byte) sin_idx -- vbuyy=vbuz1 
    // Set up colors behind logo, scroll and greets
    ldy.z sin_idx
    // [18] phi from irq::@3 to irq::@16 [phi:irq::@3->irq::@16]
    // [18] phi (byte) irq::sin_col#2 = (byte) irq::sin_col#0 [phi:irq::@3->irq::@16#0] -- register_copy 
    // [18] phi (byte) irq::i#2 = (byte) 0 [phi:irq::@3->irq::@16#1] -- vbuxx=vbuc1 
    ldx #0
    // irq::@16
  __b16:
    // for(char i=0;i<40;i++)
    // [19] if((byte) irq::i#2<(byte) $28) goto irq::@17 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$28
    bcs !__b17+
    jmp __b17
  !__b17:
    // [20] phi from irq::@16 to irq::@18 [phi:irq::@16->irq::@18]
    // [20] phi (byte) irq::l#2 = (byte) 0 [phi:irq::@16->irq::@18#0] -- vbuxx=vbuc1 
    ldx #0
  // Set all raster bars to black
    // irq::@18
  __b18:
    // for(char l=0;l!=RASTER_LINES;l++)
    // [21] if((byte) irq::l#2!=(const nomodify byte) RASTER_LINES) goto irq::@19 -- vbuxx_neq_vbuc1_then_la1 
    cpx #RASTER_LINES
    beq !__b19+
    jmp __b19
  !__b19:
    // irq::@20
    // sin_bar = sin_idx
    // [22] (byte) irq::sin_bar#0 ← (volatile byte) sin_idx -- vbuz1=vbuz2 
    // Big block of bars (16)
    lda.z sin_idx
    sta.z sin_bar
    // [23] phi from irq::@20 to irq::@21 [phi:irq::@20->irq::@21]
    // [23] phi (byte) irq::sin_bar#2 = (byte) irq::sin_bar#0 [phi:irq::@20->irq::@21#0] -- register_copy 
    // [23] phi (byte) irq::barcnt#2 = (byte) 0 [phi:irq::@20->irq::@21#1] -- vbuz1=vbuc1 
    lda #0
    sta.z barcnt
    // irq::@21
  __b21:
    // for(char barcnt=0; barcnt<16; barcnt++)
    // [24] if((byte) irq::barcnt#2<(byte) $10) goto irq::@22 -- vbuz1_lt_vbuc1_then_la1 
    lda.z barcnt
    cmp #$10
    bcc __b22
    // [25] phi from irq::@21 to irq::@28 [phi:irq::@21->irq::@28]
    // [25] phi (byte) irq::i3#2 = (byte) 0 [phi:irq::@21->irq::@28#0] -- vbuxx=vbuc1 
    ldx #0
  // Produce dark area behind text
    // irq::@28
  __b28:
    // for(char i=0;i<19;i++)
    // [26] if((byte) irq::i3#2<(byte) $13) goto irq::@29 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$13
    bcc __b29
    // irq::@30
    // greet_offset = greet_idx*16
    // [27] (byte) irq::greet_offset#0 ← (volatile byte) greet_idx << (byte) 4 -- vbuyy=vbuz1_rol_4 
    lda.z greet_idx
    asl
    asl
    asl
    asl
    tay
    // [28] phi from irq::@30 to irq::@31 [phi:irq::@30->irq::@31]
    // [28] phi (byte) irq::greet_offset#2 = (byte) irq::greet_offset#0 [phi:irq::@30->irq::@31#0] -- register_copy 
    // [28] phi (byte) irq::i4#2 = (byte) 0 [phi:irq::@30->irq::@31#1] -- vbuxx=vbuc1 
    ldx #0
    // irq::@31
  __b31:
    // for(char i=0;i<16;i++)
    // [29] if((byte) irq::i4#2<(byte) $10) goto irq::@32 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$10
    bcc __b32
    // irq::@33
    // if(--scroll_soft == 0xff)
    // [30] (volatile byte) scroll_soft ← -- (volatile byte) scroll_soft -- vbuz1=_dec_vbuz1 
    dec.z scroll_soft
    // [31] if((volatile byte) scroll_soft!=(byte) $ff) goto irq::@return -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z scroll_soft
    bne __breturn
    // irq::@34
    // scroll_soft = 7
    // [32] (volatile byte) scroll_soft ← (byte) 7 -- vbuz1=vbuc1 
    lda #7
    sta.z scroll_soft
    // [33] phi from irq::@34 to irq::@35 [phi:irq::@34->irq::@35]
    // [33] phi (byte) irq::i5#2 = (byte) 0 [phi:irq::@34->irq::@35#0] -- vbuxx=vbuc1 
    ldx #0
  // Move scroll on screen
    // irq::@35
  __b35:
    // for(char i=0;i<39;i++)
    // [34] if((byte) irq::i5#2<(byte) $27) goto irq::@36 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$27
    bcc __b36
    // irq::@37
    // nxt = *(scroll_ptr++)
    // [35] (byte) irq::nxt#0 ← *((volatile byte*) scroll_ptr) -- vbuaa=_deref_pbuz1 
    // Show next char
    ldy #0
    lda (scroll_ptr),y
    // [36] (volatile byte*) scroll_ptr ← ++ (volatile byte*) scroll_ptr -- pbuz1=_inc_pbuz1 
    inw.z scroll_ptr
    // if(nxt == 0)
    // [37] if((byte) irq::nxt#0!=(byte) 0) goto irq::@39 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b39
    // irq::@38
    // scroll_ptr = SCROLL_TEXT
    // [38] (volatile byte*) scroll_ptr ← (const byte*) SCROLL_TEXT -- pbuz1=pbuc1 
    lda #<SCROLL_TEXT
    sta.z scroll_ptr
    lda #>SCROLL_TEXT
    sta.z scroll_ptr+1
    // nxt = *scroll_ptr
    // [39] (byte) irq::nxt#1 ← *((volatile byte*) scroll_ptr) -- vbuaa=_deref_pbuz1 
    lda (scroll_ptr),y
    // [40] phi from irq::@37 irq::@38 to irq::@39 [phi:irq::@37/irq::@38->irq::@39]
    // [40] phi (byte) irq::nxt#2 = (byte) irq::nxt#0 [phi:irq::@37/irq::@38->irq::@39#0] -- register_copy 
    // irq::@39
  __b39:
    // nxt & 0xbf
    // [41] (byte~) irq::$33 ← (byte) irq::nxt#2 & (byte) $bf -- vbuaa=vbuaa_band_vbuc1 
    and #$bf
    // *(SCREEN + SCROLL_ROW*40 + 39) = nxt & 0xbf
    // [42] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) $27) ← (byte~) irq::$33 -- _deref_pbuc1=vbuaa 
    sta DEFAULT_SCREEN+SCROLL_ROW*$28+$27
    // irq::@return
  __breturn:
    // }
    // [43] return  - exit interrupt(HARDWARE_STACK)
    pla
    tay
    pla
    tax
    pla
    rti
    // irq::@36
  __b36:
    // (SCREEN + SCROLL_ROW*40)[i] = (SCREEN + SCROLL_ROW*40 + 1)[i]
    // [44] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i5#2) ← *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) SCROLL_ROW*(byte) $28+(byte) 1 + (byte) irq::i5#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda DEFAULT_SCREEN+SCROLL_ROW*$28+1,x
    sta DEFAULT_SCREEN+SCROLL_ROW*$28,x
    // for(char i=0;i<39;i++)
    // [45] (byte) irq::i5#1 ← ++ (byte) irq::i5#2 -- vbuxx=_inc_vbuxx 
    inx
    // [33] phi from irq::@36 to irq::@35 [phi:irq::@36->irq::@35]
    // [33] phi (byte) irq::i5#2 = (byte) irq::i5#1 [phi:irq::@36->irq::@35#0] -- register_copy 
    jmp __b35
    // irq::@32
  __b32:
    // GREETING[greet_offset++] & 0xbf
    // [46] (byte~) irq::$29 ← *((const byte*) GREETING + (byte) irq::greet_offset#2) & (byte) $bf -- vbuaa=pbuc1_derefidx_vbuyy_band_vbuc2 
    lda #$bf
    and GREETING,y
    // (SCREEN + GREET_ROW*40 + 13)[i] = GREETING[greet_offset++] & 0xbf
    // [47] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28+(byte) $d + (byte) irq::i4#2) ← (byte~) irq::$29 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta DEFAULT_SCREEN+GREET_ROW*$28+$d,x
    // (SCREEN + GREET_ROW*40 + 13)[i] = GREETING[greet_offset++] & 0xbf;
    // [48] (byte) irq::greet_offset#1 ← ++ (byte) irq::greet_offset#2 -- vbuyy=_inc_vbuyy 
    iny
    // for(char i=0;i<16;i++)
    // [49] (byte) irq::i4#1 ← ++ (byte) irq::i4#2 -- vbuxx=_inc_vbuxx 
    inx
    // [28] phi from irq::@32 to irq::@31 [phi:irq::@32->irq::@31]
    // [28] phi (byte) irq::greet_offset#2 = (byte) irq::greet_offset#1 [phi:irq::@32->irq::@31#0] -- register_copy 
    // [28] phi (byte) irq::i4#2 = (byte) irq::i4#1 [phi:irq::@32->irq::@31#1] -- register_copy 
    jmp __b31
    // irq::@29
  __b29:
    // rasters[SCROLL_Y+i] /2
    // [50] (byte~) irq::$26 ← *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) >> (byte) 1 -- vbuaa=pbuc1_derefidx_vbuxx_ror_1 
    lda rasters+SCROLL_Y,x
    lsr
    // rasters[SCROLL_Y+i] /2 & 7
    // [51] (byte~) irq::$27 ← (byte~) irq::$26 & (byte) 7 -- vbuaa=vbuaa_band_vbuc1 
    and #7
    // rasters[SCROLL_Y+i] = rasters[SCROLL_Y+i] /2 & 7
    // [52] *((const byte*) rasters+(const nomodify byte) SCROLL_Y + (byte) irq::i3#2) ← (byte~) irq::$27 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta rasters+SCROLL_Y,x
    // for(char i=0;i<19;i++)
    // [53] (byte) irq::i3#1 ← ++ (byte) irq::i3#2 -- vbuxx=_inc_vbuxx 
    inx
    // [25] phi from irq::@29 to irq::@28 [phi:irq::@29->irq::@28]
    // [25] phi (byte) irq::i3#2 = (byte) irq::i3#1 [phi:irq::@29->irq::@28#0] -- register_copy 
    jmp __b28
    // irq::@22
  __b22:
    // idx = SINUS[sin_bar]
    // [54] (byte) irq::idx#0 ← *((const byte*) SINUS + (byte) irq::sin_bar#2) -- vbuxx=pbuc1_derefidx_vbuz1 
    ldy.z sin_bar
    ldx SINUS,y
    // barcol = barcnt*16
    // [55] (byte) irq::barcol#0 ← (byte) irq::barcnt#2 << (byte) 4 -- vbuzz=vbuz1_rol_4 
    lda.z barcnt
    asl
    asl
    asl
    asl
    taz
    // [56] phi from irq::@22 to irq::@23 [phi:irq::@22->irq::@23]
    // [56] phi (byte) irq::idx#3 = (byte) irq::idx#0 [phi:irq::@22->irq::@23#0] -- register_copy 
    // [56] phi (byte) irq::barcol#3 = (byte) irq::barcol#0 [phi:irq::@22->irq::@23#1] -- register_copy 
    // [56] phi (byte) irq::i1#2 = (byte) 0 [phi:irq::@22->irq::@23#2] -- vbuyy=vbuc1 
    ldy #0
    // irq::@23
  __b23:
    // for(char i=0;i<16;i++)
    // [57] if((byte) irq::i1#2<(byte) $10) goto irq::@24 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10
    bcc __b24
    // [58] phi from irq::@23 to irq::@25 [phi:irq::@23->irq::@25]
    // [58] phi (byte) irq::idx#4 = (byte) irq::idx#3 [phi:irq::@23->irq::@25#0] -- register_copy 
    // [58] phi (byte) irq::barcol#4 = (byte) irq::barcol#3 [phi:irq::@23->irq::@25#1] -- register_copy 
    // [58] phi (byte) irq::i2#2 = (byte) 0 [phi:irq::@23->irq::@25#2] -- vbuyy=vbuc1 
    ldy #0
    // irq::@25
  __b25:
    // for(char i=0;i<15;i++)
    // [59] if((byte) irq::i2#2<(byte) $f) goto irq::@26 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$f
    bcc __b26
    // irq::@27
    // sin_bar += 10
    // [60] (byte) irq::sin_bar#1 ← (byte) irq::sin_bar#2 + (byte) $a -- vbuz1=vbuz1_plus_vbuc1 
    lda #$a
    clc
    adc.z sin_bar
    sta.z sin_bar
    // for(char barcnt=0; barcnt<16; barcnt++)
    // [61] (byte) irq::barcnt#1 ← ++ (byte) irq::barcnt#2 -- vbuz1=_inc_vbuz1 
    inc.z barcnt
    // [23] phi from irq::@27 to irq::@21 [phi:irq::@27->irq::@21]
    // [23] phi (byte) irq::sin_bar#2 = (byte) irq::sin_bar#1 [phi:irq::@27->irq::@21#0] -- register_copy 
    // [23] phi (byte) irq::barcnt#2 = (byte) irq::barcnt#1 [phi:irq::@27->irq::@21#1] -- register_copy 
    jmp __b21
    // irq::@26
  __b26:
    // rasters[idx++] = --barcol;
    // [62] (byte) irq::barcol#2 ← -- (byte) irq::barcol#4 -- vbuzz=_dec_vbuzz 
    dez
    // rasters[idx++] = --barcol
    // [63] *((const byte*) rasters + (byte) irq::idx#4) ← (byte) irq::barcol#2 -- pbuc1_derefidx_vbuxx=vbuzz 
    tza
    sta rasters,x
    // rasters[idx++] = --barcol;
    // [64] (byte) irq::idx#2 ← ++ (byte) irq::idx#4 -- vbuxx=_inc_vbuxx 
    inx
    // for(char i=0;i<15;i++)
    // [65] (byte) irq::i2#1 ← ++ (byte) irq::i2#2 -- vbuyy=_inc_vbuyy 
    iny
    // [58] phi from irq::@26 to irq::@25 [phi:irq::@26->irq::@25]
    // [58] phi (byte) irq::idx#4 = (byte) irq::idx#2 [phi:irq::@26->irq::@25#0] -- register_copy 
    // [58] phi (byte) irq::barcol#4 = (byte) irq::barcol#2 [phi:irq::@26->irq::@25#1] -- register_copy 
    // [58] phi (byte) irq::i2#2 = (byte) irq::i2#1 [phi:irq::@26->irq::@25#2] -- register_copy 
    jmp __b25
    // irq::@24
  __b24:
    // rasters[idx++] = barcol++
    // [66] *((const byte*) rasters + (byte) irq::idx#3) ← (byte) irq::barcol#3 -- pbuc1_derefidx_vbuxx=vbuzz 
    tza
    sta rasters,x
    // rasters[idx++] = barcol++;
    // [67] (byte) irq::idx#1 ← ++ (byte) irq::idx#3 -- vbuxx=_inc_vbuxx 
    inx
    // [68] (byte) irq::barcol#1 ← ++ (byte) irq::barcol#3 -- vbuzz=_inc_vbuzz 
    inz
    // for(char i=0;i<16;i++)
    // [69] (byte) irq::i1#1 ← ++ (byte) irq::i1#2 -- vbuyy=_inc_vbuyy 
    iny
    // [56] phi from irq::@24 to irq::@23 [phi:irq::@24->irq::@23]
    // [56] phi (byte) irq::idx#3 = (byte) irq::idx#1 [phi:irq::@24->irq::@23#0] -- register_copy 
    // [56] phi (byte) irq::barcol#3 = (byte) irq::barcol#1 [phi:irq::@24->irq::@23#1] -- register_copy 
    // [56] phi (byte) irq::i1#2 = (byte) irq::i1#1 [phi:irq::@24->irq::@23#2] -- register_copy 
    jmp __b23
    // irq::@19
  __b19:
    // rasters[l] = 0
    // [70] *((const byte*) rasters + (byte) irq::l#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta rasters,x
    // for(char l=0;l!=RASTER_LINES;l++)
    // [71] (byte) irq::l#1 ← ++ (byte) irq::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [20] phi from irq::@19 to irq::@18 [phi:irq::@19->irq::@18]
    // [20] phi (byte) irq::l#2 = (byte) irq::l#1 [phi:irq::@19->irq::@18#0] -- register_copy 
    jmp __b18
    // irq::@17
  __b17:
    // col = SINUS[sin_col]/4
    // [72] (byte) irq::col1#0 ← *((const byte*) SINUS + (byte) irq::sin_col#2) >> (byte) 2 -- vbuaa=pbuc1_derefidx_vbuyy_ror_2 
    lda SINUS,y
    lsr
    lsr
    // (COLORRAM + GREET_ROW*40)[i] = col
    // [73] *((const nomodify byte*) COLORRAM+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) irq::i#2) ← (byte) irq::col1#0 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+GREET_ROW*$28,x
    // col /= 2
    // [74] (byte) irq::col1#1 ← (byte) irq::col1#0 >> (byte) 1 -- vbuaa=vbuaa_ror_1 
    // Logo colors
    lsr
    // (COLORRAM + LOGO_ROW*40 + 0*40 - 1)[i] = col
    // [75] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28-(byte) 1 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28-1,x
    // (COLORRAM + LOGO_ROW*40 + 1*40 - 2)[i] = col
    // [76] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 1*(number) $28-(byte) 2 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+1*$28-2,x
    // (COLORRAM + LOGO_ROW*40 + 2*40 - 3)[i] = col
    // [77] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 2*(number) $28-(byte) 3 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+2*$28-3,x
    // (COLORRAM + LOGO_ROW*40 + 3*40 - 4)[i] = col
    // [78] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 3*(number) $28-(byte) 4 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+3*$28-4,x
    // (COLORRAM + LOGO_ROW*40 + 4*40 - 5)[i] = col
    // [79] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 4*(number) $28-(byte) 5 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+4*$28-5,x
    // (COLORRAM + LOGO_ROW*40 + 5*40 - 6)[i] = col
    // [80] *((const nomodify byte*) COLORRAM+(const nomodify byte) LOGO_ROW*(byte) $28+(byte)(number) 5*(number) $28-(byte) 6 + (byte) irq::i#2) ← (byte) irq::col1#1 -- pbuc1_derefidx_vbuxx=vbuaa 
    sta COLORRAM+LOGO_ROW*$28+5*$28-6,x
    // (COLORRAM + SCROLL_ROW*40)[i] = PAL_GREEN[sin_col]
    // [81] *((const nomodify byte*) COLORRAM+(const nomodify byte) SCROLL_ROW*(byte) $28 + (byte) irq::i#2) ← *((const byte*) PAL_GREEN + (byte) irq::sin_col#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuyy 
    // Scroll colors
    lda PAL_GREEN,y
    sta COLORRAM+SCROLL_ROW*$28,x
    // sin_col++;
    // [82] (byte) irq::sin_col#1 ← ++ (byte) irq::sin_col#2 -- vbuyy=_inc_vbuyy 
    iny
    // for(char i=0;i<40;i++)
    // [83] (byte) irq::i#1 ← ++ (byte) irq::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [18] phi from irq::@17 to irq::@16 [phi:irq::@17->irq::@16]
    // [18] phi (byte) irq::sin_col#2 = (byte) irq::sin_col#1 [phi:irq::@17->irq::@16#0] -- register_copy 
    // [18] phi (byte) irq::i#2 = (byte) irq::i#1 [phi:irq::@17->irq::@16#1] -- register_copy 
    jmp __b16
    // irq::@2
  __b2:
    // col = rasters[line]
    // [84] (byte) irq::col#0 ← *((const byte*) rasters + (byte) irq::line#10) -- vbuaa=pbuc1_derefidx_vbuzz 
    tza
    tay
    lda rasters,y
    // VICIII->BORDER_COLOR = col
    // [85] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR) ← (byte) irq::col#0 -- _deref_pbuc1=vbuaa 
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_BORDER_COLOR
    // VICIII->BG_COLOR = col
    // [86] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR) ← (byte) irq::col#0 -- _deref_pbuc1=vbuaa 
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_BG_COLOR
    // if(line < SCROLL_Y)
    // [87] if((byte) irq::line#10<(const nomodify byte) SCROLL_Y) goto irq::@4 -- vbuzz_lt_vbuc1_then_la1 
    cpz #SCROLL_Y
    bcc __b4
    // irq::@10
    // if(line == SCROLL_Y)
    // [88] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y) goto irq::@5 -- vbuzz_eq_vbuc1_then_la1 
    cpz #SCROLL_Y
    beq __b5
    // irq::@11
    // if(line == SCROLL_Y+SCROLL_BLACKBARS)
    // [89] if((byte) irq::line#10==(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS) goto irq::@6 -- vbuzz_eq_vbuc1_then_la1 
    cpz #SCROLL_Y+SCROLL_BLACKBARS
    beq __b6
    // irq::@12
    // if(line == SCROLL_Y+SCROLL_BLACKBARS+1)
    // [90] if((byte) irq::line#10!=(const nomodify byte) SCROLL_Y+(const nomodify byte) SCROLL_BLACKBARS+(byte) 1) goto irq::@7 -- vbuzz_neq_vbuc1_then_la1 
    cpz #SCROLL_Y+SCROLL_BLACKBARS+1
    bne __b7
    // irq::@13
    // zoomval = SINUS[greet_zoomx++]
    // [91] (byte) irq::zoomval#0 ← *((const byte*) SINUS + (volatile byte) greet_zoomx) -- vbuaa=pbuc1_derefidx_vbuz1 
    // if raster position > SCROLL_Y pos do zoom
    ldy.z greet_zoomx
    lda SINUS,y
    // [92] (volatile byte) greet_zoomx ← ++ (volatile byte) greet_zoomx -- vbuz1=_inc_vbuz1 
    inc.z greet_zoomx
    // VICIV->CHRXSCL = zoomval
    // [93] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) irq::zoomval#0 -- _deref_pbuc1=vbuaa 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL
    // zoomval+1
    // [94] (byte~) irq::$10 ← (byte) irq::zoomval#0 + (byte) 1 -- vbuaa=vbuaa_plus_1 
    inc
    // VICIV->TEXTXPOS_LO = zoomval+1
    // [95] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte~) irq::$10 -- _deref_pbuc1=vbuaa 
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // if(greet_zoomx==0)
    // [96] if((volatile byte) greet_zoomx!=(byte) 0) goto irq::@7 -- vbuz1_neq_0_then_la1 
    lda.z greet_zoomx
    cmp #0
    bne __b7
    // irq::@14
    // if(++greet_idx == GREET_COUNT)
    // [97] (volatile byte) greet_idx ← ++ (volatile byte) greet_idx -- vbuz1=_inc_vbuz1 
    inc.z greet_idx
    // [98] if((volatile byte) greet_idx!=(const nomodify byte) GREET_COUNT) goto irq::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #GREET_COUNT
    cmp.z greet_idx
    bne __b7
    // irq::@15
    // greet_idx = 0
    // [99] (volatile byte) greet_idx ← (byte) 0 -- vbuz1=vbuc1 
    lda #0
    sta.z greet_idx
    // [100] phi from irq::@12 irq::@13 irq::@14 irq::@15 irq::@4 irq::@5 irq::@6 to irq::@7 [phi:irq::@12/irq::@13/irq::@14/irq::@15/irq::@4/irq::@5/irq::@6->irq::@7]
    // [100] phi (byte) irq::wobble_idx#7 = (byte) irq::wobble_idx#10 [phi:irq::@12/irq::@13/irq::@14/irq::@15/irq::@4/irq::@5/irq::@6->irq::@7#0] -- register_copy 
    // irq::@7
  __b7:
    // raster = VICII->RASTER
    // [101] (byte) irq::raster#0 ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) -- vbuaa=_deref_pbuc1 
    // Wait for the next raster line
    lda VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // irq::@8
  __b8:
    // while(raster == VICII->RASTER)
    // [102] if((byte) irq::raster#0==*((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER)) goto irq::@8 -- vbuaa_eq__deref_pbuc1_then_la1 
    cmp VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    beq __b8
    // irq::@9
    // for(char line=0;line!=RASTER_LINES;line++)
    // [103] (byte) irq::line#1 ← ++ (byte) irq::line#10 -- vbuzz=_inc_vbuzz 
    inz
    // [14] phi from irq::@9 to irq::@1 [phi:irq::@9->irq::@1]
    // [14] phi (byte) irq::wobble_idx#10 = (byte) irq::wobble_idx#7 [phi:irq::@9->irq::@1#0] -- register_copy 
    // [14] phi (byte) irq::line#10 = (byte) irq::line#1 [phi:irq::@9->irq::@1#1] -- register_copy 
    jmp __b1
    // irq::@6
  __b6:
    // VICIV->TEXTXPOS_LO = 0x50
    // [104] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 -- _deref_pbuc1=vbuc2 
    // if raster position > SCROLL_Y pos do nozoom
    // default value
    lda #$50
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    jmp __b7
    // irq::@5
  __b5:
    // [105] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← (byte) $50 -- _deref_pbuc1=vbuc2 
    // if raster position = SCROLL_Y pos do scroll
    // no wobbling from this point
    lda #$50
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // VICII->CONTROL2 = scroll_soft
    // [106] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL2) ← (volatile byte) scroll_soft -- _deref_pbuc1=vbuz1 
    // set softscroll
    lda.z scroll_soft
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL2
    jmp __b7
    // irq::@4
  __b4:
    // VICIV->TEXTXPOS_LO =  SINUS[wobble_idx++]
    // [107] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO) ← *((const byte*) SINUS + (byte) irq::wobble_idx#10) -- _deref_pbuc1=pbuc2_derefidx_vbuxx 
    // if raster position < SCROLL_Y pos do wobble Logo!
    lda SINUS,x
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_TEXTXPOS_LO
    // VICIV->TEXTXPOS_LO =  SINUS[wobble_idx++];
    // [108] (byte) irq::wobble_idx#1 ← ++ (byte) irq::wobble_idx#10 -- vbuxx=_inc_vbuxx 
    inx
    // VICIV->CHRXSCL = 0x66
    // [109] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL) ← (byte) $66 -- _deref_pbuc1=vbuc2 
    // No zooming
    lda #$66
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CHRXSCL
    jmp __b7
}
  // main
main: {
    // VICIII->KEY = 0x47
    // [110] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $47 -- _deref_pbuc1=vbuc2 
    // Enable MEGA65 features
    lda #$47
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // VICIII->KEY = 0x53
    // [111] *((byte*)(const nomodify struct MOS4569_VICIII*) VICIII+(const byte) OFFSET_STRUCT_MOS4569_VICIII_KEY) ← (byte) $53 -- _deref_pbuc1=vbuc2 
    lda #$53
    sta VICIII+OFFSET_STRUCT_MOS4569_VICIII_KEY
    // VICIV->CONTROLB |= 0x40
    // [112] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLB) | (byte) $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    // Enable 48MHz fast mode
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLB
    // VICIV->CONTROLC |= 0x40
    // [113] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) ← *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_CONTROLC) | (byte) $40 -- _deref_pbuc1=_deref_pbuc1_bor_vbuc2 
    lda #$40
    ora VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_CONTROLC
    // asm
    // asm { lda#0  }
    // Initialize music
    lda #0
    // (*songInit)()
    // [115] call *((const void()*) songInit) 
    jsr songInit
    // memset(SCREEN, ' ', 40*25)
    // [116] call memset 
  // Clear screen 
    // [142] phi from main to memset [phi:main->memset]
    jsr memset
    // [117] phi from main to main::@1 [phi:main->main::@1]
    // [117] phi (byte) main::i1#2 = (byte) 0 [phi:main->main::@1#0] -- vbuxx=vbuc1 
    ldx #0
  // Put MEGA logo on screen
    // main::@1
  __b1:
    // for( char i=0; i<sizeof(MEGA_LOGO); i++)
    // [118] if((byte) main::i1#2<(byte) $bc*(const byte) SIZEOF_BYTE) goto main::@2 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$bc*SIZEOF_BYTE
    bcc __b2
    // [119] phi from main::@1 to main::@3 [phi:main::@1->main::@3]
    // [119] phi (byte) main::i2#2 = (byte) 0 [phi:main::@1->main::@3#0] -- vbuxx=vbuc1 
    ldx #0
  // Put '*' as default greeting
    // main::@3
  __b3:
    // for( char i=0;i<40;i++)
    // [120] if((byte) main::i2#2<(byte) $28) goto main::@4 -- vbuxx_lt_vbuc1_then_la1 
    cpx #$28
    bcc __b4
    // [121] phi from main::@3 to main::@5 [phi:main::@3->main::@5]
    // [121] phi (byte) main::i#2 = (byte) 0 [phi:main::@3->main::@5#0] -- vbuxx=vbuc1 
    ldx #0
    // [121] phi from main::@5 to main::@5 [phi:main::@5->main::@5]
    // [121] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@5->main::@5#0] -- register_copy 
    // main::@5
  __b5:
    // PALETTE_RED[i] = PAL_RED[i]
    // [122] *((const nomodify byte*) PALETTE_RED + (byte) main::i#2) ← *((const byte*) PAL_RED + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PAL_RED,x
    sta PALETTE_RED,x
    // PALETTE_GREEN[i] = PAL_GREEN[i]
    // [123] *((const nomodify byte*) PALETTE_GREEN + (byte) main::i#2) ← *((const byte*) PAL_GREEN + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PAL_GREEN,x
    sta PALETTE_GREEN,x
    // PALETTE_BLUE[i] = PAL_BLUE[i]
    // [124] *((const nomodify byte*) PALETTE_BLUE + (byte) main::i#2) ← *((const byte*) PAL_BLUE + (byte) main::i#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PAL_BLUE,x
    sta PALETTE_BLUE,x
    // while(++i!=0)
    // [125] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [126] if((byte) main::i#1!=(byte) 0) goto main::@5 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b5
    // main::@6
    // asm
    // asm { sei  }
    // Set up raster interrupts C64 style
    sei
    // CIA1->INTERRUPT = CIA_INTERRUPT_CLEAR
    // [128] *((byte*)(const nomodify struct MOS6526_CIA*) CIA1+(const byte) OFFSET_STRUCT_MOS6526_CIA_INTERRUPT) ← (const nomodify byte) CIA_INTERRUPT_CLEAR -- _deref_pbuc1=vbuc2 
    // Disable CIA 1 Timer IRQ
    lda #CIA_INTERRUPT_CLEAR
    sta CIA1+OFFSET_STRUCT_MOS6526_CIA_INTERRUPT
    // VICII->RASTER = IRQ_Y
    // [129] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_RASTER) ← (const nomodify byte) IRQ_Y -- _deref_pbuc1=vbuc2 
    // Set raster line to 0x16
    lda #IRQ_Y
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_RASTER
    // VICII->CONTROL1 &= 0x7f
    // [130] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) ← *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_CONTROL1) & (byte) $7f -- _deref_pbuc1=_deref_pbuc1_band_vbuc2 
    lda #$7f
    and VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_CONTROL1
    // VICII->IRQ_ENABLE = IRQ_RASTER
    // [131] *((byte*)(const nomodify struct MOS6569_VICII*) VICII+(const byte) OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE) ← (const nomodify byte) IRQ_RASTER -- _deref_pbuc1=vbuc2 
    // Enable Raster Interrupt
    lda #IRQ_RASTER
    sta VICII+OFFSET_STRUCT_MOS6569_VICII_IRQ_ENABLE
    // *HARDWARE_IRQ = &irq
    // [132] *((const nomodify void()**) HARDWARE_IRQ) ← &interrupt(HARDWARE_STACK)(void()) irq() -- _deref_qprc1=pprc2 
    // Set the IRQ routine
    lda #<irq
    sta HARDWARE_IRQ
    lda #>irq
    sta HARDWARE_IRQ+1
    // *PROCPORT_DDR = PROCPORT_DDR_MEMORY_MASK
    // [133] *((const nomodify byte*) PROCPORT_DDR) ← (const nomodify byte) PROCPORT_DDR_MEMORY_MASK -- _deref_pbuc1=vbuc2 
    // no kernal or BASIC rom visible
    lda #PROCPORT_DDR_MEMORY_MASK
    sta PROCPORT_DDR
    // *PROCPORT = PROCPORT_RAM_IO
    // [134] *((const nomodify byte*) PROCPORT) ← (const nomodify byte) PROCPORT_RAM_IO -- _deref_pbuc1=vbuc2 
    lda #PROCPORT_RAM_IO
    sta PROCPORT
    // VICIV->SIDBDRWD_LO = 1
    // [135] *((byte*)(const nomodify struct MEGA65_VICIV*) VICIV+(const byte) OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // open sideborder
    lda #1
    sta VICIV+OFFSET_STRUCT_MEGA65_VICIV_SIDBDRWD_LO
    // asm
    // asm { cli  }
    // Enable IRQ
    cli
    // [137] phi from main::@6 main::@7 to main::@7 [phi:main::@6/main::@7->main::@7]
    // main::@7
  __b7:
    jmp __b7
    // main::@4
  __b4:
    // (SCREEN + GREET_ROW*40)[i] = '*'
    // [138] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) GREET_ROW*(byte) $28 + (byte) main::i2#2) ← (byte) '*' -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #'*'
    sta DEFAULT_SCREEN+GREET_ROW*$28,x
    // for( char i=0;i<40;i++)
    // [139] (byte) main::i2#1 ← ++ (byte) main::i2#2 -- vbuxx=_inc_vbuxx 
    inx
    // [119] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [119] phi (byte) main::i2#2 = (byte) main::i2#1 [phi:main::@4->main::@3#0] -- register_copy 
    jmp __b3
    // main::@2
  __b2:
    // (SCREEN + LOGO_ROW*40)[i] = MEGA_LOGO[i]
    // [140] *((const nomodify byte*) DEFAULT_SCREEN+(const nomodify byte) LOGO_ROW*(byte) $28 + (byte) main::i1#2) ← *((const byte*) MEGA_LOGO + (byte) main::i1#2) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda MEGA_LOGO,x
    sta DEFAULT_SCREEN+LOGO_ROW*$28,x
    // for( char i=0; i<sizeof(MEGA_LOGO); i++)
    // [141] (byte) main::i1#1 ← ++ (byte) main::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [117] phi from main::@2 to main::@1 [phi:main::@2->main::@1]
    // [117] phi (byte) main::i1#2 = (byte) main::i1#1 [phi:main::@2->main::@1#0] -- register_copy 
    jmp __b1
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $28*$19
    .label str = DEFAULT_SCREEN
    .label end = str+num
    .label dst = 4
    // [143] phi from memset to memset::@1 [phi:memset->memset::@1]
    // [143] phi (byte*) memset::dst#2 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    // memset::@1
  __b1:
    // for(char* dst = str; dst!=end; dst++)
    // [144] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    // memset::@return
    // }
    // [145] return 
    rts
    // memset::@2
  __b2:
    // *dst = c
    // [146] *((byte*) memset::dst#2) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [147] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inw.z dst
    // [143] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
    // [143] phi (byte*) memset::dst#2 = (byte*) memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // File Data
.segment Data
  // A MEGA logo
  MEGA_LOGO: .byte $20, $20, $20, $20, $20, $cf, $cf, $cf, $20, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $20, $cf, $cf, $20, $cf, $20, $cf, $20, $20, $20, $cf, $cf, $20, $20, $20, $20, $cf, $cf, $20, $20, $20, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $20, $20, $cf, $20, $cf, $cf, $cf, $cf, $cf, $20, $cf, $cf, $20, $cf, $cf, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $20, $20, $20, $cf, $20, $20, $20, $cf, $cf, $cf, $20, $cf, $cf, $cf, $cf, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $cf, $20, $20, $20, $20, $cf, $cf, $20, $cf, $cf, $cf, $20, $20, $cf, $cf, $cf, $20, $20, $cf, $20, $20, $20, $cf
  // Greetings
  GREETING: .text "   DOUBLEFLASH        ADTBM          SY2002          TAYGER         SERIOUSLY   LIBI IN PARADIZE       LGB          BLUEWAYSW        SAUSAGE       BIT SHIFTER     INDIOCOLIFA     GRUMPYNINJA      0-LIMITS         CHEVERON     DR. COMMODORE "
  .byte 0
  // Scroll text
  SCROLL_TEXT: .text "    THIS SMALL MEGA65 RASTER INTRO ... WAS MADE BY DEFT IN 2015 ... AND BROUGHT BACK TO LIFE 5 YEARS LATER IN 2020 ... BECAUSE THE MEGA65 HARDWARE CHANGED SO MUCH IN THE PAST 5 YEARS ... UNFORTUNATELY MY ASSEMBLER SKILLS DID NOT SO THIS IS THE FIRST APPROACH TO GET BETTER ... HOPEFULLY DR.MUTTI WILL HAVE TO SCOLD ME LESS ... THE PAST 5 YEARS HAVE BEEN AN UNFORGETTABLE & UNIQUE RIDE ... IF YOU DO WATCH THIS DEMO ON YOUR VERY OWN MEGA65 THERE IS ENOUGH EVIDENCE OF WHAT WE ACTUALLY ACHIEVED ... BELOW ARE THE GREETINGS TO DEAR AND VERY SPECIAL PEOPLE WHO HELPED TO GET THERE ... THANK YOU SO MUCH FOR YOUR SUPPORT AND FOR NOT GIVING UP ... DUAL SID TUNE BY RAYDEN OF ALPHA FLIGHT ... THIS SCROLLY WILL NOW RESTART           *WRAP*                    "
  .byte 0
.pc = $fc0 "SONG"
  // Music at an absolute address
SONG:
.import c64 "DiscoZak_2SID_patched.prg"

.pc = $2c00 "SINUS"
  // Sinus Values 0-183
SINUS:
.fill 256, 91.5 + 91.5*sin(i*2*PI/256)

.pc = $3000 "rasters"
  // Moving Raster Bars
  rasters: .fill RASTER_LINES, 0
.pc = $2d00 "PAL_RED"
  PAL_RED: .byte 0, $f3, $d4, $b5, $a6, $97, $88, $79, $1a, $fa, $eb, $ec, $bd, $be, $af, $ff, $16, $c6, $a7, $88, $49, $5a, $2b, $1c, $ac, $ad, $8e, $8f, $ff, $ff, $ff, $ff, $c6, $77, $48, $29, $e9, $fa, $cb, $cc, $5d, $4e, $2f, $ff, $ff, $ff, $ff, $ff, $57, $18, $f8, $d9, $aa, $8b, $6c, $5d, $ed, $de, $cf, $ff, $ff, $ff, $ff, $ff, $26, $e6, $b7, $a8, $69, $5a, $3b, $3c, $dc, $cd, $ae, $9f, $ff, $ff, $ff, $ff, $65, $16, $17, $f7, $d8, $b9, $9a, $8b, $2c, $d, $fd, $ee, $cf, $ff, $ff, $ff, $64, $15, 6, $e6, $c7, $a8, $99, $8a, $1b, $c, $fc, $fd, $ee, $cf, $ff, $ff, $12, $d2, $d3, $b4, $95, $86, $77, $78, 9, $69, $ea, $fb, $dc, $ad, $ae, $af, $f0, $c1, $c2, $a3, $84, $85, $76, $67, 8, $f8, $e9, $da, $db, $bc, $bd, $ae, $40, $11, $12, $f2, $e3, $d4, $c5, $c6, $47, $38, $39, $2a, $1b, $c, $d, $ed, 0, 0, $f0, $d1, $c2, $b3, $a4, $95, $36, $27, $28, $29, $f9, $ea, $eb, $ec, $70, $41, $22, $23, $f3, $f4, $e5, $e6, $77, $78, $69, $7a, $3b, $3c, $3d, $3e, $a1, $82, $63, $54, $35, $26, 7, 8, $98, $99, $8a, $7b, $5c, $5d, $3e, $3f, $33, 4, $d4, $d5, $a6, $a7, $88, $89, $1a, $ab, $fb, $ec, $cd, $be, $af, $ff, $b4, $85, $56, $47, $18, 9, $f9, $ea, $7b, $7c, $5d, $5e, $2f, $ef, $ff, $ff, 6, $d6, $a7, $98, $59, $4a, $2b, $2c, $bc, $ad, $8e, $8f, $ff, $ff, $ff, $ff
.pc = $2e00 "PAL_GREEN"
  PAL_GREEN: .byte 0, $e3, $c4, $b5, $96, $87, $78, $79, $a, $fa, $eb, $dc, $bd, $ae, $af, $ff, $e2, $b3, $a4, $85, $76, $67, $48, $49, $d9, $da, $bb, $bc, $8d, $8e, $7f, $ff, $42, 3, 4, $e4, $d5, $c6, $b7, $a8, $39, $3a, $1b, $2c, $fc, $fd, $de, $df, $61, $32, $13, 4, $e4, $e5, $d6, $d7, $78, $59, $4a, $4b, $2c, $1d, $e, $fe, $e0, $b1, $a2, $93, $74, $75, $56, $57, $e7, $d8, $79, $ca, $ab, $9c, $9d, $8e, $f0, $d1, $c2, $a3, $84, $85, $76, $77, 8, 9, $f9, $fa, $db, $cc, $bd, $ae, $61, $22, $23, $14, $f4, $e5, $d6, $c7, $58, $59, $3a, $3b, $1c, $d, $fd, $fe, $92, $53, $44, $35, $16, $f6, $e7, $e8, $79, $6a, $5b, $4c, $2d, $3e, $1f, $ef, $53, $14, 5, $e5, $c6, $b7, $a8, $99, $2a, $2b, $c, $d, $dd, $ce, $cf, $ff, $f3, $b4, $95, $86, $57, $38, $29, $1a, $ba, $ab, $9c, $8d, $6e, $5f, $ff, $ff, $95, $56, $27, $18, $e8, $d9, $ca, $bb, $4c, $3d, $2e, $1f, $ef, $ff, $ff, $ff, $c5, $86, $57, $38, $19, $a, $ea, $db, $6c, $5d, $3e, $3f, $ef, $ff, $ff, $ff, $65, $26, 7, $e7, $c8, $b9, $9a, $9b, $2c, $1d, $fd, $fe, $cf, $ff, $ff, $ff, $b4, $75, $56, $37, $28, $19, $e9, $ea, $7b, $6c, $5d, $4e, $2f, $ff, $ff, $ff, $c3, $94, $75, $56, $47, $38, $19, $1a, $aa, $ab, $7c, $7d, $5e, $4f, $ff, $ff, $e2, $a3, $94, $85, $76, $67, $38, $49, $d9, $ca, $ab, $bc, $7d, $7e, $6f, $ff
.pc = $2f00 "PAL_BLUE"
  PAL_BLUE: .byte 0, $f3, $d4, $b5, $a6, $97, $88, $79, $1a, $fa, $eb, $ec, $bd, $be, $af, $ff, 0, 0, 0, 0, $c0, $b1, $a2, $a3, $34, $35, $26, $27, $f7, $f8, $f9, $ea, 0, 0, $30, $11, $22, $13, $14, 5, $b5, $96, $97, $98, $79, $6a, $5b, $4c, $81, $42, $43, $34, 5, 6, $f6, $f7, $78, $69, $5a, $5b, $4c, $3d, $1e, $f, $17, $c7, $a8, $89, $5a, $5b, $3c, $1d, $ad, $9e, $7f, $ff, $ff, $ff, $ff, $ff, $78, 9, $e9, $ca, $ab, $7c, $5d, $5e, $de, $cf, $ff, $ff, $ff, $ff, $ff, $ff, $59, $a, $ca, $bb, $8c, $6d, $3e, $2f, $bf, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $49, $f9, $da, $ab, $7c, $5d, $2e, $2f, $af, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $48, $d8, $b9, $aa, $7b, $5c, $2d, $2e, $be, $9f, $ff, $ff, $ff, $ff, $ff, $ff, 7, $97, $88, $69, $4a, $2b, $1c, $2d, $9d, $7e, $6f, $ff, $ff, $ff, $ff, $ff, $81, $62, $53, $44, 5, 6, $f6, $e7, $78, $69, $5a, $5b, $3c, $2d, $2e, $1f, 0, 0, 0, 0, $b0, $b1, $a2, $b3, $44, $35, $36, $37, 8, $f8, $a, $b, 0, 0, 0, 0, 0, $70, $61, $62, $f2, $e3, $d4, $c5, $b6, $b7, $b8, $99, 0, 0, 0, 0, 0, 0, $f0, $f1, $82, $83, $84, $85, $66, $57, $58, $59, 0, 0, 0, 0, 0, $70, $61, $62, $e2, $e3, $d4, $d5, $b6, $a7, $b8, $a9, 0, 0, 0, 0, $a0, $b1, $a2, $a3, $44, $35, $26, $37, $f7, $19, $f9, $fa

