Inlined call call __init
Eliminating unused variable with no statement plot::$1

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  call prepare
  to:main::@6
main::@6: scope:[main]  from main
  to:main::@1
main::@1: scope:[main]  from main::@6 main::@8
  main::c#0 = $19
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@2 main::@4
  main::c#4 = phi( main::@1/main::c#0, main::@2/main::c#4, main::@4/main::c#1 )
  main::$1 = *RASTER != $fe
  if(main::$1) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@3
  main::c#3 = phi( main::@2/main::c#4, main::@3/main::c#3 )
  main::$2 = *RASTER != $ff
  if(main::$2) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@3
  main::c#2 = phi( main::@3/main::c#3 )
  main::c#1 = main::c#2 + rangenext($19,1)
  main::$3 = main::c#1 != rangelast($19,1)
  if(main::$3) goto main::@2
  to:main::@5
main::@5: scope:[main]  from main::@4
  call flip
  to:main::@7
main::@7: scope:[main]  from main::@5
  call plot
  to:main::@8
main::@8: scope:[main]  from main::@7
  if(true) goto main::@1
  to:main::@return
main::@return: scope:[main]  from main::@8
  return 
  to:@return

void prepare()
prepare: scope:[prepare]  from main
  prepare::i#0 = 0
  to:prepare::@1
prepare::@1: scope:[prepare]  from prepare prepare::@1
  prepare::i#2 = phi( prepare/prepare::i#0, prepare::@1/prepare::i#1 )
  buffer1[prepare::i#2] = prepare::i#2
  prepare::i#1 = prepare::i#2 + rangenext(0,$ff)
  prepare::$0 = prepare::i#1 != rangelast(0,$ff)
  if(prepare::$0) goto prepare::@1
  to:prepare::@return
prepare::@return: scope:[prepare]  from prepare::@1
  return 
  to:@return

void flip()
flip: scope:[flip]  from main::@5
  flip::srcIdx#0 = 0
  flip::dstIdx#0 = $f
  flip::r#0 = $10
  to:flip::@1
flip::@1: scope:[flip]  from flip flip::@3
  flip::r#4 = phi( flip/flip::r#0, flip::@3/flip::r#1 )
  flip::dstIdx#5 = phi( flip/flip::dstIdx#0, flip::@3/flip::dstIdx#2 )
  flip::srcIdx#3 = phi( flip/flip::srcIdx#0, flip::@3/flip::srcIdx#4 )
  flip::c#0 = $10
  to:flip::@2
flip::@2: scope:[flip]  from flip::@1 flip::@2
  flip::r#3 = phi( flip::@1/flip::r#4, flip::@2/flip::r#3 )
  flip::c#2 = phi( flip::@1/flip::c#0, flip::@2/flip::c#1 )
  flip::dstIdx#3 = phi( flip::@1/flip::dstIdx#5, flip::@2/flip::dstIdx#1 )
  flip::srcIdx#2 = phi( flip::@1/flip::srcIdx#3, flip::@2/flip::srcIdx#1 )
  buffer2[flip::dstIdx#3] = buffer1[flip::srcIdx#2]
  flip::srcIdx#1 = ++ flip::srcIdx#2
  flip::$0 = flip::dstIdx#3 + $10
  flip::dstIdx#1 = flip::$0
  flip::c#1 = flip::c#2 + rangenext($10,1)
  flip::$1 = flip::c#1 != rangelast($10,1)
  if(flip::$1) goto flip::@2
  to:flip::@3
flip::@3: scope:[flip]  from flip::@2
  flip::srcIdx#4 = phi( flip::@2/flip::srcIdx#1 )
  flip::r#2 = phi( flip::@2/flip::r#3 )
  flip::dstIdx#4 = phi( flip::@2/flip::dstIdx#1 )
  flip::dstIdx#2 = -- flip::dstIdx#4
  flip::r#1 = flip::r#2 + rangenext($10,1)
  flip::$2 = flip::r#1 != rangelast($10,1)
  if(flip::$2) goto flip::@1
  to:flip::@4
flip::@4: scope:[flip]  from flip::@3
  flip::i#0 = 0
  to:flip::@5
flip::@5: scope:[flip]  from flip::@4 flip::@5
  flip::i#2 = phi( flip::@4/flip::i#0, flip::@5/flip::i#1 )
  buffer1[flip::i#2] = buffer2[flip::i#2]
  flip::i#1 = flip::i#2 + rangenext(0,$ff)
  flip::$3 = flip::i#1 != rangelast(0,$ff)
  if(flip::$3) goto flip::@5
  to:flip::@return
flip::@return: scope:[flip]  from flip::@5
  return 
  to:@return

void plot()
plot: scope:[plot]  from main::@7
  plot::$0 = SCREEN + 5*$28
  plot::line#0 = plot::$0 + $c
  plot::i#0 = 0
  plot::y#0 = $10
  to:plot::@1
plot::@1: scope:[plot]  from plot plot::@4
  plot::y#4 = phi( plot/plot::y#0, plot::@4/plot::y#1 )
  plot::line#5 = phi( plot/plot::line#0, plot::@4/plot::line#1 )
  plot::i#4 = phi( plot/plot::i#0, plot::@4/plot::i#5 )
  plot::x#0 = 0
  to:plot::@2
plot::@2: scope:[plot]  from plot::@1 plot::@3
  plot::y#3 = phi( plot::@1/plot::y#4, plot::@3/plot::y#5 )
  plot::line#4 = phi( plot::@1/plot::line#5, plot::@3/plot::line#2 )
  plot::i#3 = phi( plot::@1/plot::i#4, plot::@3/plot::i#1 )
  plot::x#2 = phi( plot::@1/plot::x#0, plot::@3/plot::x#1 )
  plot::$2 = plot::x#2 < $10
  if(plot::$2) goto plot::@3
  to:plot::@4
plot::@3: scope:[plot]  from plot::@2
  plot::y#5 = phi( plot::@2/plot::y#3 )
  plot::x#3 = phi( plot::@2/plot::x#2 )
  plot::line#2 = phi( plot::@2/plot::line#4 )
  plot::i#2 = phi( plot::@2/plot::i#3 )
  plot::line#2[plot::x#3] = buffer1[plot::i#2]
  plot::i#1 = ++ plot::i#2
  plot::x#1 = ++ plot::x#3
  to:plot::@2
plot::@4: scope:[plot]  from plot::@2
  plot::i#5 = phi( plot::@2/plot::i#3 )
  plot::y#2 = phi( plot::@2/plot::y#3 )
  plot::line#3 = phi( plot::@2/plot::line#4 )
  plot::$3 = plot::line#3 + $28
  plot::line#1 = plot::$3
  plot::y#1 = plot::y#2 + rangenext($10,1)
  plot::$4 = plot::y#1 != rangelast($10,1)
  if(plot::$4) goto plot::@1
  to:plot::@return
plot::@return: scope:[plot]  from plot::@4
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
__constant char *RASTER = (char *)$d012
__constant char *SCREEN = (char *)$400
void __start()
__constant char buffer1[$10*$10] = { fill( $10*$10, 0) }
__constant char buffer2[$10*$10] = { fill( $10*$10, 0) }
void flip()
number flip::$0
bool flip::$1
bool flip::$2
bool flip::$3
char flip::c
char flip::c#0
char flip::c#1
char flip::c#2
char flip::dstIdx
char flip::dstIdx#0
char flip::dstIdx#1
char flip::dstIdx#2
char flip::dstIdx#3
char flip::dstIdx#4
char flip::dstIdx#5
char flip::i
char flip::i#0
char flip::i#1
char flip::i#2
char flip::r
char flip::r#0
char flip::r#1
char flip::r#2
char flip::r#3
char flip::r#4
char flip::srcIdx
char flip::srcIdx#0
char flip::srcIdx#1
char flip::srcIdx#2
char flip::srcIdx#3
char flip::srcIdx#4
void main()
bool main::$1
bool main::$2
bool main::$3
char main::c
char main::c#0
char main::c#1
char main::c#2
char main::c#3
char main::c#4
void plot()
char *plot::$0
bool plot::$2
char *plot::$3
bool plot::$4
char plot::i
char plot::i#0
char plot::i#1
char plot::i#2
char plot::i#3
char plot::i#4
char plot::i#5
char *plot::line
char *plot::line#0
char *plot::line#1
char *plot::line#2
char *plot::line#3
char *plot::line#4
char *plot::line#5
char plot::x
char plot::x#0
char plot::x#1
char plot::x#2
char plot::x#3
char plot::y
char plot::y#0
char plot::y#1
char plot::y#2
char plot::y#3
char plot::y#4
char plot::y#5
void prepare()
bool prepare::$0
char prepare::i
char prepare::i#0
char prepare::i#1
char prepare::i#2

Adding number conversion cast (unumber) $fe in main::$1 = *RASTER != $fe
Adding number conversion cast (unumber) $ff in main::$2 = *RASTER != $ff
Adding number conversion cast (unumber) $10 in flip::$0 = flip::dstIdx#3 + $10
Adding number conversion cast (unumber) flip::$0 in flip::$0 = flip::dstIdx#3 + (unumber)$10
Adding number conversion cast (unumber) 5*$28 in plot::$0 = SCREEN + 5*$28
Adding number conversion cast (unumber) $c in plot::line#0 = plot::$0 + $c
Adding number conversion cast (unumber) $10 in plot::$2 = plot::x#2 < $10
Adding number conversion cast (unumber) $28 in plot::$3 = plot::line#3 + $28
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (char *) 53266
Simplifying constant pointer cast (char *) 1024
Simplifying constant integer cast $fe
Simplifying constant integer cast $ff
Simplifying constant integer cast $10
Simplifying constant integer cast $c
Simplifying constant integer cast $10
Simplifying constant integer cast $28
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) $fe
Finalized unsigned number type (char) $ff
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) $c
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to char in flip::$0 = flip::dstIdx#3 + $10
Alias main::c#2 = main::c#3 
Alias flip::dstIdx#1 = flip::$0 flip::dstIdx#4 
Alias flip::r#2 = flip::r#3 
Alias flip::srcIdx#1 = flip::srcIdx#4 
Alias plot::i#2 = plot::i#3 plot::i#5 
Alias plot::line#2 = plot::line#4 plot::line#3 
Alias plot::x#2 = plot::x#3 
Alias plot::y#2 = plot::y#5 plot::y#3 
Alias plot::line#1 = plot::$3 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values main::c#2 main::c#4
Identical Phi Values flip::r#2 flip::r#4
Identical Phi Values plot::line#2 plot::line#5
Identical Phi Values plot::y#2 plot::y#4
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$1 [4] if(*RASTER!=$fe) goto main::@2
Simple Condition main::$2 [7] if(*RASTER!=$ff) goto main::@3
Simple Condition main::$3 [10] if(main::c#1!=rangelast($19,1)) goto main::@2
Simple Condition prepare::$0 [20] if(prepare::i#1!=rangelast(0,$ff)) goto prepare::@1
Simple Condition flip::$1 [33] if(flip::c#1!=rangelast($10,1)) goto flip::@2
Simple Condition flip::$2 [37] if(flip::r#1!=rangelast($10,1)) goto flip::@1
Simple Condition flip::$3 [43] if(flip::i#1!=rangelast(0,$ff)) goto flip::@5
Simple Condition plot::$2 [53] if(plot::x#2<$10) goto plot::@3
Simple Condition plot::$4 [60] if(plot::y#1!=rangelast($10,1)) goto plot::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [45] plot::$0 = SCREEN + (char)5*$28
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::c#0 = $19
Constant prepare::i#0 = 0
Constant flip::srcIdx#0 = 0
Constant flip::dstIdx#0 = $f
Constant flip::r#0 = $10
Constant flip::c#0 = $10
Constant flip::i#0 = 0
Constant plot::$0 = SCREEN+(char)5*$28
Constant plot::i#0 = 0
Constant plot::y#0 = $10
Constant plot::x#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [13] if(true) goto main::@1
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [8] main::c#1 = -- main::c#4 to --
Resolved ranged comparison value [10] if(main::c#1!=rangelast($19,1)) goto main::@2 to 0
Resolved ranged next value [18] prepare::i#1 = ++ prepare::i#2 to ++
Resolved ranged comparison value [20] if(prepare::i#1!=rangelast(0,$ff)) goto prepare::@1 to 0
Resolved ranged next value [31] flip::c#1 = -- flip::c#2 to --
Resolved ranged comparison value [33] if(flip::c#1!=rangelast($10,1)) goto flip::@2 to 0
Resolved ranged next value [35] flip::r#1 = -- flip::r#4 to --
Resolved ranged comparison value [37] if(flip::r#1!=rangelast($10,1)) goto flip::@1 to 0
Resolved ranged next value [41] flip::i#1 = ++ flip::i#2 to ++
Resolved ranged comparison value [43] if(flip::i#1!=rangelast(0,$ff)) goto flip::@5 to 0
Resolved ranged next value [58] plot::y#1 = -- plot::y#4 to --
Resolved ranged comparison value [60] if(plot::y#1!=rangelast($10,1)) goto plot::@1 to 0
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 0 in [5] if(main::c#1!=0) goto main::@2
Adding number conversion cast (unumber) 0 in [11] if(prepare::i#1!=0) goto prepare::@1
Adding number conversion cast (unumber) 0 in [19] if(flip::c#1!=0) goto flip::@2
Adding number conversion cast (unumber) 0 in [22] if(flip::r#1!=0) goto flip::@1
Adding number conversion cast (unumber) 0 in [26] if(flip::i#1!=0) goto flip::@5
Adding number conversion cast (unumber) 0 in [37] if(plot::y#1!=0) goto plot::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [28] plot::line#0 = plot::$0 + $c
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant plot::line#0 = plot::$0+$c
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings main::c#0
Inlining constant with var siblings prepare::i#0
Inlining constant with var siblings flip::srcIdx#0
Inlining constant with var siblings flip::dstIdx#0
Inlining constant with var siblings flip::r#0
Inlining constant with var siblings flip::c#0
Inlining constant with var siblings flip::i#0
Inlining constant with var siblings plot::i#0
Inlining constant with var siblings plot::y#0
Inlining constant with var siblings plot::x#0
Inlining constant with var siblings plot::line#0
Constant inlined plot::line#0 = SCREEN+(char)5*$28+$c
Constant inlined plot::$0 = SCREEN+(char)5*$28
Constant inlined main::c#0 = $19
Constant inlined flip::i#0 = 0
Constant inlined flip::srcIdx#0 = 0
Constant inlined prepare::i#0 = 0
Constant inlined plot::x#0 = 0
Constant inlined plot::i#0 = 0
Constant inlined plot::y#0 = $10
Constant inlined flip::c#0 = $10
Constant inlined flip::dstIdx#0 = $f
Constant inlined flip::r#0 = $10
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) $10
Finalized unsigned number type (char) 5
Finalized unsigned number type (char) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simplifying constant integer cast 5*$28
Successful SSA optimization PassNCastSimplification
Added new block during phi lifting main::@9(between main::@2 and main::@2)
Added new block during phi lifting main::@10(between main::@4 and main::@2)
Added new block during phi lifting prepare::@2(between prepare::@1 and prepare::@1)
Added new block during phi lifting flip::@6(between flip::@3 and flip::@1)
Added new block during phi lifting flip::@7(between flip::@2 and flip::@2)
Added new block during phi lifting flip::@8(between flip::@5 and flip::@5)
Added new block during phi lifting plot::@5(between plot::@4 and plot::@1)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@6
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@8
Adding NOP phi() at start of prepare
Adding NOP phi() at start of flip
Adding NOP phi() at start of flip::@4
Adding NOP phi() at start of plot
CALL GRAPH
Calls in [main] to prepare:1 flip:10 plot:12 

Created 14 initial phi equivalence classes
Coalesced [14] main::c#6 = main::c#1
Coalesced (already) [15] main::c#5 = main::c#4
Coalesced [22] prepare::i#3 = prepare::i#1
Coalesced [25] flip::srcIdx#6 = flip::srcIdx#3
Coalesced [26] flip::dstIdx#7 = flip::dstIdx#5
Coalesced [42] flip::i#3 = flip::i#1
Coalesced [43] flip::srcIdx#5 = flip::srcIdx#1
Coalesced [44] flip::dstIdx#6 = flip::dstIdx#2
Coalesced [45] flip::r#5 = flip::r#1
Coalesced (already) [46] flip::srcIdx#7 = flip::srcIdx#1
Coalesced [47] flip::dstIdx#8 = flip::dstIdx#1
Coalesced [48] flip::c#3 = flip::c#1
Coalesced [51] plot::i#7 = plot::i#4
Coalesced (already) [58] plot::i#6 = plot::i#2
Coalesced [59] plot::line#6 = plot::line#1
Coalesced [60] plot::y#6 = plot::y#1
Coalesced [64] plot::x#4 = plot::x#1
Coalesced [65] plot::i#8 = plot::i#1
Coalesced down to 11 phi equivalence classes
Culled Empty Block label main::@6
Culled Empty Block label main::@1
Culled Empty Block label main::@8
Culled Empty Block label main::@10
Culled Empty Block label main::@9
Culled Empty Block label prepare::@2
Culled Empty Block label flip::@4
Culled Empty Block label flip::@8
Culled Empty Block label flip::@6
Culled Empty Block label flip::@7
Culled Empty Block label plot::@5
Renumbering block main::@2 to main::@1
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@7 to main::@5
Renumbering block flip::@5 to flip::@4
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@4
Adding NOP phi() at start of main::@5
Adding NOP phi() at start of prepare
Adding NOP phi() at start of flip
Adding NOP phi() at start of plot

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  [1] call prepare
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@3 main::@5
  [2] main::c#4 = phi( main/$19, main::@1/main::c#4, main::@3/main::c#1, main::@5/$19 )
  [3] if(*RASTER!=$fe) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@2
  [4] if(*RASTER!=$ff) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  [5] main::c#1 = -- main::c#4
  [6] if(main::c#1!=0) goto main::@1
  to:main::@4
main::@4: scope:[main]  from main::@3
  [7] phi()
  [8] call flip
  to:main::@5
main::@5: scope:[main]  from main::@4
  [9] phi()
  [10] call plot
  to:main::@1

void prepare()
prepare: scope:[prepare]  from main
  [11] phi()
  to:prepare::@1
prepare::@1: scope:[prepare]  from prepare prepare::@1
  [12] prepare::i#2 = phi( prepare/0, prepare::@1/prepare::i#1 )
  [13] buffer1[prepare::i#2] = prepare::i#2
  [14] prepare::i#1 = ++ prepare::i#2
  [15] if(prepare::i#1!=0) goto prepare::@1
  to:prepare::@return
prepare::@return: scope:[prepare]  from prepare::@1
  [16] return 
  to:@return

void flip()
flip: scope:[flip]  from main::@4
  [17] phi()
  to:flip::@1
flip::@1: scope:[flip]  from flip flip::@3
  [18] flip::r#4 = phi( flip/$10, flip::@3/flip::r#1 )
  [18] flip::dstIdx#5 = phi( flip/$f, flip::@3/flip::dstIdx#2 )
  [18] flip::srcIdx#3 = phi( flip/0, flip::@3/flip::srcIdx#1 )
  to:flip::@2
flip::@2: scope:[flip]  from flip::@1 flip::@2
  [19] flip::c#2 = phi( flip::@1/$10, flip::@2/flip::c#1 )
  [19] flip::dstIdx#3 = phi( flip::@1/flip::dstIdx#5, flip::@2/flip::dstIdx#1 )
  [19] flip::srcIdx#2 = phi( flip::@1/flip::srcIdx#3, flip::@2/flip::srcIdx#1 )
  [20] buffer2[flip::dstIdx#3] = buffer1[flip::srcIdx#2]
  [21] flip::srcIdx#1 = ++ flip::srcIdx#2
  [22] flip::dstIdx#1 = flip::dstIdx#3 + $10
  [23] flip::c#1 = -- flip::c#2
  [24] if(flip::c#1!=0) goto flip::@2
  to:flip::@3
flip::@3: scope:[flip]  from flip::@2
  [25] flip::dstIdx#2 = -- flip::dstIdx#1
  [26] flip::r#1 = -- flip::r#4
  [27] if(flip::r#1!=0) goto flip::@1
  to:flip::@4
flip::@4: scope:[flip]  from flip::@3 flip::@4
  [28] flip::i#2 = phi( flip::@3/0, flip::@4/flip::i#1 )
  [29] buffer1[flip::i#2] = buffer2[flip::i#2]
  [30] flip::i#1 = ++ flip::i#2
  [31] if(flip::i#1!=0) goto flip::@4
  to:flip::@return
flip::@return: scope:[flip]  from flip::@4
  [32] return 
  to:@return

void plot()
plot: scope:[plot]  from main::@5
  [33] phi()
  to:plot::@1
plot::@1: scope:[plot]  from plot plot::@4
  [34] plot::y#4 = phi( plot/$10, plot::@4/plot::y#1 )
  [34] plot::line#5 = phi( plot/SCREEN+5*$28+$c, plot::@4/plot::line#1 )
  [34] plot::i#4 = phi( plot/0, plot::@4/plot::i#2 )
  to:plot::@2
plot::@2: scope:[plot]  from plot::@1 plot::@3
  [35] plot::i#2 = phi( plot::@1/plot::i#4, plot::@3/plot::i#1 )
  [35] plot::x#2 = phi( plot::@1/0, plot::@3/plot::x#1 )
  [36] if(plot::x#2<$10) goto plot::@3
  to:plot::@4
plot::@4: scope:[plot]  from plot::@2
  [37] plot::line#1 = plot::line#5 + $28
  [38] plot::y#1 = -- plot::y#4
  [39] if(plot::y#1!=0) goto plot::@1
  to:plot::@return
plot::@return: scope:[plot]  from plot::@4
  [40] return 
  to:@return
plot::@3: scope:[plot]  from plot::@2
  [41] plot::line#5[plot::x#2] = buffer1[plot::i#2]
  [42] plot::i#1 = ++ plot::i#2
  [43] plot::x#1 = ++ plot::x#2
  to:plot::@2


VARIABLE REGISTER WEIGHTS
void flip()
char flip::c
char flip::c#1 // 150001.5
char flip::c#2 // 50000.5
char flip::dstIdx
char flip::dstIdx#1 // 70001.0
char flip::dstIdx#2 // 6667.333333333333
char flip::dstIdx#3 // 103334.66666666666
char flip::dstIdx#5 // 20002.0
char flip::i
char flip::i#1 // 15001.5
char flip::i#2 // 20002.0
char flip::r
char flip::r#1 // 15001.5
char flip::r#4 // 2500.25
char flip::srcIdx
char flip::srcIdx#1 // 30000.428571428572
char flip::srcIdx#2 // 155002.0
char flip::srcIdx#3 // 20002.0
void main()
char main::c
char main::c#1 // 151.5
char main::c#4 // 734.6666666666666
void plot()
char plot::i
char plot::i#1 // 100001.0
char plot::i#2 // 53334.16666666666
char plot::i#4 // 20002.0
char *plot::line
char *plot::line#1 // 6667.333333333333
char *plot::line#5 // 20000.5
char plot::x
char plot::x#1 // 200002.0
char plot::x#2 // 100001.0
char plot::y
char plot::y#1 // 15001.5
char plot::y#4 // 2857.4285714285716
void prepare()
char prepare::i
char prepare::i#1 // 151.5
char prepare::i#2 // 202.0

Initial phi equivalence classes
[ main::c#4 main::c#1 ]
[ prepare::i#2 prepare::i#1 ]
[ flip::r#4 flip::r#1 ]
[ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ]
[ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ]
[ flip::c#2 flip::c#1 ]
[ flip::i#2 flip::i#1 ]
[ plot::i#4 plot::i#2 plot::i#1 ]
[ plot::line#5 plot::line#1 ]
[ plot::y#4 plot::y#1 ]
[ plot::x#2 plot::x#1 ]
Complete equivalence classes
[ main::c#4 main::c#1 ]
[ prepare::i#2 prepare::i#1 ]
[ flip::r#4 flip::r#1 ]
[ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ]
[ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ]
[ flip::c#2 flip::c#1 ]
[ flip::i#2 flip::i#1 ]
[ plot::i#4 plot::i#2 plot::i#1 ]
[ plot::line#5 plot::line#1 ]
[ plot::y#4 plot::y#1 ]
[ plot::x#2 plot::x#1 ]
Allocated zp[1]:2 [ main::c#4 main::c#1 ]
Allocated zp[1]:3 [ prepare::i#2 prepare::i#1 ]
Allocated zp[1]:4 [ flip::r#4 flip::r#1 ]
Allocated zp[1]:5 [ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ]
Allocated zp[1]:6 [ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ]
Allocated zp[1]:7 [ flip::c#2 flip::c#1 ]
Allocated zp[1]:8 [ flip::i#2 flip::i#1 ]
Allocated zp[1]:9 [ plot::i#4 plot::i#2 plot::i#1 ]
Allocated zp[2]:10 [ plot::line#5 plot::line#1 ]
Allocated zp[1]:12 [ plot::y#4 plot::y#1 ]
Allocated zp[1]:13 [ plot::x#2 plot::x#1 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [3] if(*RASTER!=$fe) goto main::@1 [ main::c#4 ] (  [ main::c#4 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::c#4 main::c#1 ]
Statement [4] if(*RASTER!=$ff) goto main::@2 [ main::c#4 ] (  [ main::c#4 ] { }  ) always clobbers reg byte a 
Statement [20] buffer2[flip::dstIdx#3] = buffer1[flip::srcIdx#2] [ flip::r#4 flip::srcIdx#2 flip::dstIdx#3 flip::c#2 ] ( flip:8 [ flip::r#4 flip::srcIdx#2 flip::dstIdx#3 flip::c#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:4 [ flip::r#4 flip::r#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:5 [ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ flip::c#2 flip::c#1 ]
Statement [22] flip::dstIdx#1 = flip::dstIdx#3 + $10 [ flip::r#4 flip::srcIdx#1 flip::c#2 flip::dstIdx#1 ] ( flip:8 [ flip::r#4 flip::srcIdx#1 flip::c#2 flip::dstIdx#1 ] { }  ) always clobbers reg byte a 
Statement [29] buffer1[flip::i#2] = buffer2[flip::i#2] [ flip::i#2 ] ( flip:8 [ flip::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ flip::i#2 flip::i#1 ]
Statement [37] plot::line#1 = plot::line#5 + $28 [ plot::y#4 plot::i#2 plot::line#1 ] ( plot:10 [ plot::y#4 plot::i#2 plot::line#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:12 [ plot::y#4 plot::y#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ plot::i#4 plot::i#2 plot::i#1 ]
Statement [41] plot::line#5[plot::x#2] = buffer1[plot::i#2] [ plot::line#5 plot::y#4 plot::i#2 plot::x#2 ] ( plot:10 [ plot::line#5 plot::y#4 plot::i#2 plot::x#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:13 [ plot::x#2 plot::x#1 ]
Statement [3] if(*RASTER!=$fe) goto main::@1 [ main::c#4 ] (  [ main::c#4 ] { }  ) always clobbers reg byte a 
Statement [4] if(*RASTER!=$ff) goto main::@2 [ main::c#4 ] (  [ main::c#4 ] { }  ) always clobbers reg byte a 
Statement [20] buffer2[flip::dstIdx#3] = buffer1[flip::srcIdx#2] [ flip::r#4 flip::srcIdx#2 flip::dstIdx#3 flip::c#2 ] ( flip:8 [ flip::r#4 flip::srcIdx#2 flip::dstIdx#3 flip::c#2 ] { }  ) always clobbers reg byte a 
Statement [22] flip::dstIdx#1 = flip::dstIdx#3 + $10 [ flip::r#4 flip::srcIdx#1 flip::c#2 flip::dstIdx#1 ] ( flip:8 [ flip::r#4 flip::srcIdx#1 flip::c#2 flip::dstIdx#1 ] { }  ) always clobbers reg byte a 
Statement [29] buffer1[flip::i#2] = buffer2[flip::i#2] [ flip::i#2 ] ( flip:8 [ flip::i#2 ] { }  ) always clobbers reg byte a 
Statement [37] plot::line#1 = plot::line#5 + $28 [ plot::y#4 plot::i#2 plot::line#1 ] ( plot:10 [ plot::y#4 plot::i#2 plot::line#1 ] { }  ) always clobbers reg byte a 
Statement [41] plot::line#5[plot::x#2] = buffer1[plot::i#2] [ plot::line#5 plot::y#4 plot::i#2 plot::x#2 ] ( plot:10 [ plot::line#5 plot::y#4 plot::i#2 plot::x#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::c#4 main::c#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ prepare::i#2 prepare::i#1 ] : zp[1]:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ flip::r#4 flip::r#1 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ flip::c#2 flip::c#1 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ flip::i#2 flip::i#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ plot::i#4 plot::i#2 plot::i#1 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[2]:10 [ plot::line#5 plot::line#1 ] : zp[2]:10 , 
Potential registers zp[1]:12 [ plot::y#4 plot::y#1 ] : zp[1]:12 , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ plot::x#2 plot::x#1 ] : zp[1]:13 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [flip] 205,004.43: zp[1]:5 [ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ] 200,005: zp[1]:6 [ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ] 200,002: zp[1]:7 [ flip::c#2 flip::c#1 ] 35,003.5: zp[1]:8 [ flip::i#2 flip::i#1 ] 17,501.75: zp[1]:4 [ flip::r#4 flip::r#1 ] 
Uplift Scope [plot] 300,003: zp[1]:13 [ plot::x#2 plot::x#1 ] 173,337.17: zp[1]:9 [ plot::i#4 plot::i#2 plot::i#1 ] 26,667.83: zp[2]:10 [ plot::line#5 plot::line#1 ] 17,858.93: zp[1]:12 [ plot::y#4 plot::y#1 ] 
Uplift Scope [main] 886.17: zp[1]:2 [ main::c#4 main::c#1 ] 
Uplift Scope [prepare] 353.5: zp[1]:3 [ prepare::i#2 prepare::i#1 ] 
Uplift Scope [] 

Uplifting [flip] best 134644 combination reg byte y [ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ] reg byte x [ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ] zp[1]:7 [ flip::c#2 flip::c#1 ] reg byte x [ flip::i#2 flip::i#1 ] zp[1]:4 [ flip::r#4 flip::r#1 ] 
Limited combination testing to 100 combinations of 243 possible.
Uplifting [plot] best 116344 combination reg byte y [ plot::x#2 plot::x#1 ] reg byte x [ plot::i#4 plot::i#2 plot::i#1 ] zp[2]:10 [ plot::line#5 plot::line#1 ] zp[1]:12 [ plot::y#4 plot::y#1 ] 
Uplifting [main] best 112944 combination reg byte x [ main::c#4 main::c#1 ] 
Uplifting [prepare] best 112844 combination reg byte x [ prepare::i#2 prepare::i#1 ] 
Uplifting [] best 112844 combination 
Attempting to uplift remaining variables inzp[1]:7 [ flip::c#2 flip::c#1 ]
Uplifting [flip] best 112844 combination zp[1]:7 [ flip::c#2 flip::c#1 ] 
Attempting to uplift remaining variables inzp[1]:12 [ plot::y#4 plot::y#1 ]
Uplifting [plot] best 112844 combination zp[1]:12 [ plot::y#4 plot::y#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ flip::r#4 flip::r#1 ]
Uplifting [flip] best 112844 combination zp[1]:4 [ flip::r#4 flip::r#1 ] 
Coalescing zero page register [ zp[1]:12 [ plot::y#4 plot::y#1 ] ] with [ zp[1]:4 [ flip::r#4 flip::r#1 ] ]
Allocated (was zp[1]:7) zp[1]:2 [ flip::c#2 flip::c#1 ]
Allocated (was zp[2]:10) zp[2]:3 [ plot::line#5 plot::line#1 ]
Allocated (was zp[1]:12) zp[1]:5 [ plot::y#4 plot::y#1 flip::r#4 flip::r#1 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
  // Commodore 64 PRG executable file
.file [name="flipper-rex2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label RASTER = $d012
  .label SCREEN = $400
.segment Code
  // main
main: {
    // [1] call prepare
    // [11] phi from main to prepare [phi:main->prepare]
  prepare_from_main:
    jsr prepare
    // [2] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  __b1_from_main:
  __b1_from___b5:
    // [2] phi main::c#4 = $19 [phi:main/main::@5->main::@1#0] -- vbuxx=vbuc1 
    ldx #$19
    jmp __b1
    // [2] phi from main::@1 main::@3 to main::@1 [phi:main::@1/main::@3->main::@1]
  __b1_from___b1:
  __b1_from___b3:
    // [2] phi main::c#4 = main::c#4 [phi:main::@1/main::@3->main::@1#0] -- register_copy 
    jmp __b1
    // main::@1
  __b1:
    // [3] if(*RASTER!=$fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp RASTER
    bne __b1_from___b1
    jmp __b2
    // main::@2
  __b2:
    // [4] if(*RASTER!=$ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [5] main::c#1 = -- main::c#4 -- vbuxx=_dec_vbuxx 
    dex
    // [6] if(main::c#1!=0) goto main::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1_from___b3
    // [7] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
  __b4_from___b3:
    jmp __b4
    // main::@4
  __b4:
    // [8] call flip
    // [17] phi from main::@4 to flip [phi:main::@4->flip]
  flip_from___b4:
    jsr flip
    // [9] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
  __b5_from___b4:
    jmp __b5
    // main::@5
  __b5:
    // [10] call plot
    // [33] phi from main::@5 to plot [phi:main::@5->plot]
  plot_from___b5:
    jsr plot
    jmp __b1_from___b5
}
  // prepare
// Prepare buffer
prepare: {
    // [12] phi from prepare to prepare::@1 [phi:prepare->prepare::@1]
  __b1_from_prepare:
    // [12] phi prepare::i#2 = 0 [phi:prepare->prepare::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [12] phi from prepare::@1 to prepare::@1 [phi:prepare::@1->prepare::@1]
  __b1_from___b1:
    // [12] phi prepare::i#2 = prepare::i#1 [phi:prepare::@1->prepare::@1#0] -- register_copy 
    jmp __b1
    // prepare::@1
  __b1:
    // [13] buffer1[prepare::i#2] = prepare::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta buffer1,x
    // [14] prepare::i#1 = ++ prepare::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [15] if(prepare::i#1!=0) goto prepare::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1_from___b1
    jmp __breturn
    // prepare::@return
  __breturn:
    // [16] return 
    rts
}
  // flip
// Flip buffer
flip: {
    .label c = 2
    .label r = 5
    // [18] phi from flip to flip::@1 [phi:flip->flip::@1]
  __b1_from_flip:
    // [18] phi flip::r#4 = $10 [phi:flip->flip::@1#0] -- vbuz1=vbuc1 
    lda #$10
    sta.z r
    // [18] phi flip::dstIdx#5 = $f [phi:flip->flip::@1#1] -- vbuxx=vbuc1 
    ldx #$f
    // [18] phi flip::srcIdx#3 = 0 [phi:flip->flip::@1#2] -- vbuyy=vbuc1 
    ldy #0
    jmp __b1
    // [18] phi from flip::@3 to flip::@1 [phi:flip::@3->flip::@1]
  __b1_from___b3:
    // [18] phi flip::r#4 = flip::r#1 [phi:flip::@3->flip::@1#0] -- register_copy 
    // [18] phi flip::dstIdx#5 = flip::dstIdx#2 [phi:flip::@3->flip::@1#1] -- register_copy 
    // [18] phi flip::srcIdx#3 = flip::srcIdx#1 [phi:flip::@3->flip::@1#2] -- register_copy 
    jmp __b1
    // flip::@1
  __b1:
    // [19] phi from flip::@1 to flip::@2 [phi:flip::@1->flip::@2]
  __b2_from___b1:
    // [19] phi flip::c#2 = $10 [phi:flip::@1->flip::@2#0] -- vbuz1=vbuc1 
    lda #$10
    sta.z c
    // [19] phi flip::dstIdx#3 = flip::dstIdx#5 [phi:flip::@1->flip::@2#1] -- register_copy 
    // [19] phi flip::srcIdx#2 = flip::srcIdx#3 [phi:flip::@1->flip::@2#2] -- register_copy 
    jmp __b2
    // [19] phi from flip::@2 to flip::@2 [phi:flip::@2->flip::@2]
  __b2_from___b2:
    // [19] phi flip::c#2 = flip::c#1 [phi:flip::@2->flip::@2#0] -- register_copy 
    // [19] phi flip::dstIdx#3 = flip::dstIdx#1 [phi:flip::@2->flip::@2#1] -- register_copy 
    // [19] phi flip::srcIdx#2 = flip::srcIdx#1 [phi:flip::@2->flip::@2#2] -- register_copy 
    jmp __b2
    // flip::@2
  __b2:
    // [20] buffer2[flip::dstIdx#3] = buffer1[flip::srcIdx#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuyy 
    lda buffer1,y
    sta buffer2,x
    // [21] flip::srcIdx#1 = ++ flip::srcIdx#2 -- vbuyy=_inc_vbuyy 
    iny
    // [22] flip::dstIdx#1 = flip::dstIdx#3 + $10 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[$10]
    // [23] flip::c#1 = -- flip::c#2 -- vbuz1=_dec_vbuz1 
    dec.z c
    // [24] if(flip::c#1!=0) goto flip::@2 -- vbuz1_neq_0_then_la1 
    lda.z c
    bne __b2_from___b2
    jmp __b3
    // flip::@3
  __b3:
    // [25] flip::dstIdx#2 = -- flip::dstIdx#1 -- vbuxx=_dec_vbuxx 
    dex
    // [26] flip::r#1 = -- flip::r#4 -- vbuz1=_dec_vbuz1 
    dec.z r
    // [27] if(flip::r#1!=0) goto flip::@1 -- vbuz1_neq_0_then_la1 
    lda.z r
    bne __b1_from___b3
    // [28] phi from flip::@3 to flip::@4 [phi:flip::@3->flip::@4]
  __b4_from___b3:
    // [28] phi flip::i#2 = 0 [phi:flip::@3->flip::@4#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b4
    // [28] phi from flip::@4 to flip::@4 [phi:flip::@4->flip::@4]
  __b4_from___b4:
    // [28] phi flip::i#2 = flip::i#1 [phi:flip::@4->flip::@4#0] -- register_copy 
    jmp __b4
    // flip::@4
  __b4:
    // [29] buffer1[flip::i#2] = buffer2[flip::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda buffer2,x
    sta buffer1,x
    // [30] flip::i#1 = ++ flip::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [31] if(flip::i#1!=0) goto flip::@4 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b4_from___b4
    jmp __breturn
    // flip::@return
  __breturn:
    // [32] return 
    rts
}
  // plot
// Plot buffer on screen
plot: {
    .label line = 3
    .label y = 5
    // [34] phi from plot to plot::@1 [phi:plot->plot::@1]
  __b1_from_plot:
    // [34] phi plot::y#4 = $10 [phi:plot->plot::@1#0] -- vbuz1=vbuc1 
    lda #$10
    sta.z y
    // [34] phi plot::line#5 = SCREEN+5*$28+$c [phi:plot->plot::@1#1] -- pbuz1=pbuc1 
    lda #<SCREEN+5*$28+$c
    sta.z line
    lda #>SCREEN+5*$28+$c
    sta.z line+1
    // [34] phi plot::i#4 = 0 [phi:plot->plot::@1#2] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [34] phi from plot::@4 to plot::@1 [phi:plot::@4->plot::@1]
  __b1_from___b4:
    // [34] phi plot::y#4 = plot::y#1 [phi:plot::@4->plot::@1#0] -- register_copy 
    // [34] phi plot::line#5 = plot::line#1 [phi:plot::@4->plot::@1#1] -- register_copy 
    // [34] phi plot::i#4 = plot::i#2 [phi:plot::@4->plot::@1#2] -- register_copy 
    jmp __b1
    // plot::@1
  __b1:
    // [35] phi from plot::@1 to plot::@2 [phi:plot::@1->plot::@2]
  __b2_from___b1:
    // [35] phi plot::i#2 = plot::i#4 [phi:plot::@1->plot::@2#0] -- register_copy 
    // [35] phi plot::x#2 = 0 [phi:plot::@1->plot::@2#1] -- vbuyy=vbuc1 
    ldy #0
    jmp __b2
    // plot::@2
  __b2:
    // [36] if(plot::x#2<$10) goto plot::@3 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10
    bcc __b3
    jmp __b4
    // plot::@4
  __b4:
    // [37] plot::line#1 = plot::line#5 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    // [38] plot::y#1 = -- plot::y#4 -- vbuz1=_dec_vbuz1 
    dec.z y
    // [39] if(plot::y#1!=0) goto plot::@1 -- vbuz1_neq_0_then_la1 
    lda.z y
    bne __b1_from___b4
    jmp __breturn
    // plot::@return
  __breturn:
    // [40] return 
    rts
    // plot::@3
  __b3:
    // [41] plot::line#5[plot::x#2] = buffer1[plot::i#2] -- pbuz1_derefidx_vbuyy=pbuc1_derefidx_vbuxx 
    lda buffer1,x
    sta (line),y
    // [42] plot::i#1 = ++ plot::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [43] plot::x#1 = ++ plot::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [35] phi from plot::@3 to plot::@2 [phi:plot::@3->plot::@2]
  __b2_from___b3:
    // [35] phi plot::i#2 = plot::i#1 [phi:plot::@3->plot::@2#0] -- register_copy 
    // [35] phi plot::x#2 = plot::x#1 [phi:plot::@3->plot::@2#1] -- register_copy 
    jmp __b2
}
  // File Data
.segment Data
  buffer1: .fill $10*$10, 0
  buffer2: .fill $10*$10, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b1_from___b1 with __b1
Replacing label __b1_from___b3 with __b1
Replacing label __b1_from___b1 with __b1
Replacing label __b2_from___b2 with __b2
Replacing label __b1_from___b3 with __b1
Replacing label __b4_from___b4 with __b4
Replacing label __b1_from___b4 with __b1
Removing instruction __b1_from_main:
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b3:
Removing instruction __b4_from___b3:
Removing instruction flip_from___b4:
Removing instruction __b5_from___b4:
Removing instruction plot_from___b5:
Removing instruction __b1_from___b1:
Removing instruction __b1_from___b3:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b2:
Removing instruction __b4_from___b4:
Removing instruction __b1_from___b4:
Removing instruction __b2_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction prepare_from_main:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __b1_from_prepare:
Removing instruction __breturn:
Removing instruction __b1_from_flip:
Removing instruction __b3:
Removing instruction __b4_from___b3:
Removing instruction __breturn:
Removing instruction __b1_from_plot:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __b2_from___b3:
Succesful ASM optimization Pass5UnusedLabelElimination
Relabelling long label __b1_from___b5 to __b3
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
__constant char *RASTER = (char *) 53266
__constant char *SCREEN = (char *) 1024
__constant char buffer1[$10*$10] = { fill( $10*$10, 0) }
__constant char buffer2[$10*$10] = { fill( $10*$10, 0) }
void flip()
char flip::c
char flip::c#1 // c zp[1]:2 150001.5
char flip::c#2 // c zp[1]:2 50000.5
char flip::dstIdx
char flip::dstIdx#1 // reg byte x 70001.0
char flip::dstIdx#2 // reg byte x 6667.333333333333
char flip::dstIdx#3 // reg byte x 103334.66666666666
char flip::dstIdx#5 // reg byte x 20002.0
char flip::i
char flip::i#1 // reg byte x 15001.5
char flip::i#2 // reg byte x 20002.0
char flip::r
char flip::r#1 // r zp[1]:5 15001.5
char flip::r#4 // r zp[1]:5 2500.25
char flip::srcIdx
char flip::srcIdx#1 // reg byte y 30000.428571428572
char flip::srcIdx#2 // reg byte y 155002.0
char flip::srcIdx#3 // reg byte y 20002.0
void main()
char main::c
char main::c#1 // reg byte x 151.5
char main::c#4 // reg byte x 734.6666666666666
void plot()
char plot::i
char plot::i#1 // reg byte x 100001.0
char plot::i#2 // reg byte x 53334.16666666666
char plot::i#4 // reg byte x 20002.0
char *plot::line
char *plot::line#1 // line zp[2]:3 6667.333333333333
char *plot::line#5 // line zp[2]:3 20000.5
char plot::x
char plot::x#1 // reg byte y 200002.0
char plot::x#2 // reg byte y 100001.0
char plot::y
char plot::y#1 // y zp[1]:5 15001.5
char plot::y#4 // y zp[1]:5 2857.4285714285716
void prepare()
char prepare::i
char prepare::i#1 // reg byte x 151.5
char prepare::i#2 // reg byte x 202.0

reg byte x [ main::c#4 main::c#1 ]
reg byte x [ prepare::i#2 prepare::i#1 ]
reg byte y [ flip::srcIdx#2 flip::srcIdx#3 flip::srcIdx#1 ]
reg byte x [ flip::dstIdx#3 flip::dstIdx#5 flip::dstIdx#2 flip::dstIdx#1 ]
zp[1]:2 [ flip::c#2 flip::c#1 ]
reg byte x [ flip::i#2 flip::i#1 ]
reg byte x [ plot::i#4 plot::i#2 plot::i#1 ]
zp[2]:3 [ plot::line#5 plot::line#1 ]
zp[1]:5 [ plot::y#4 plot::y#1 flip::r#4 flip::r#1 ]
reg byte y [ plot::x#2 plot::x#1 ]


FINAL ASSEMBLER
Score: 83294

  // File Comments
  // Upstart
  // Commodore 64 PRG executable file
.file [name="flipper-rex2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label RASTER = $d012
  .label SCREEN = $400
.segment Code
  // main
main: {
    // prepare()
    // [1] call prepare
    // [11] phi from main to prepare [phi:main->prepare]
    jsr prepare
    // [2] phi from main main::@5 to main::@1 [phi:main/main::@5->main::@1]
  __b3:
    // [2] phi main::c#4 = $19 [phi:main/main::@5->main::@1#0] -- vbuxx=vbuc1 
    ldx #$19
    // [2] phi from main::@1 main::@3 to main::@1 [phi:main::@1/main::@3->main::@1]
    // [2] phi main::c#4 = main::c#4 [phi:main::@1/main::@3->main::@1#0] -- register_copy 
    // main::@1
  __b1:
    // while(*RASTER!=254)
    // [3] if(*RASTER!=$fe) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$fe
    cmp RASTER
    bne __b1
    // main::@2
  __b2:
    // while(*RASTER!=255)
    // [4] if(*RASTER!=$ff) goto main::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne __b2
    // main::@3
    // for( byte c : 25..1)
    // [5] main::c#1 = -- main::c#4 -- vbuxx=_dec_vbuxx 
    dex
    // [6] if(main::c#1!=0) goto main::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1
    // [7] phi from main::@3 to main::@4 [phi:main::@3->main::@4]
    // main::@4
    // flip()
    // [8] call flip
    // [17] phi from main::@4 to flip [phi:main::@4->flip]
    jsr flip
    // [9] phi from main::@4 to main::@5 [phi:main::@4->main::@5]
    // main::@5
    // plot()
    // [10] call plot
    // [33] phi from main::@5 to plot [phi:main::@5->plot]
    jsr plot
    jmp __b3
}
  // prepare
// Prepare buffer
prepare: {
    // [12] phi from prepare to prepare::@1 [phi:prepare->prepare::@1]
    // [12] phi prepare::i#2 = 0 [phi:prepare->prepare::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [12] phi from prepare::@1 to prepare::@1 [phi:prepare::@1->prepare::@1]
    // [12] phi prepare::i#2 = prepare::i#1 [phi:prepare::@1->prepare::@1#0] -- register_copy 
    // prepare::@1
  __b1:
    // buffer1[i] = i
    // [13] buffer1[prepare::i#2] = prepare::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta buffer1,x
    // for( byte i : 0..255)
    // [14] prepare::i#1 = ++ prepare::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [15] if(prepare::i#1!=0) goto prepare::@1 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b1
    // prepare::@return
    // }
    // [16] return 
    rts
}
  // flip
// Flip buffer
flip: {
    .label c = 2
    .label r = 5
    // [18] phi from flip to flip::@1 [phi:flip->flip::@1]
    // [18] phi flip::r#4 = $10 [phi:flip->flip::@1#0] -- vbuz1=vbuc1 
    lda #$10
    sta.z r
    // [18] phi flip::dstIdx#5 = $f [phi:flip->flip::@1#1] -- vbuxx=vbuc1 
    ldx #$f
    // [18] phi flip::srcIdx#3 = 0 [phi:flip->flip::@1#2] -- vbuyy=vbuc1 
    ldy #0
    // [18] phi from flip::@3 to flip::@1 [phi:flip::@3->flip::@1]
    // [18] phi flip::r#4 = flip::r#1 [phi:flip::@3->flip::@1#0] -- register_copy 
    // [18] phi flip::dstIdx#5 = flip::dstIdx#2 [phi:flip::@3->flip::@1#1] -- register_copy 
    // [18] phi flip::srcIdx#3 = flip::srcIdx#1 [phi:flip::@3->flip::@1#2] -- register_copy 
    // flip::@1
  __b1:
    // [19] phi from flip::@1 to flip::@2 [phi:flip::@1->flip::@2]
    // [19] phi flip::c#2 = $10 [phi:flip::@1->flip::@2#0] -- vbuz1=vbuc1 
    lda #$10
    sta.z c
    // [19] phi flip::dstIdx#3 = flip::dstIdx#5 [phi:flip::@1->flip::@2#1] -- register_copy 
    // [19] phi flip::srcIdx#2 = flip::srcIdx#3 [phi:flip::@1->flip::@2#2] -- register_copy 
    // [19] phi from flip::@2 to flip::@2 [phi:flip::@2->flip::@2]
    // [19] phi flip::c#2 = flip::c#1 [phi:flip::@2->flip::@2#0] -- register_copy 
    // [19] phi flip::dstIdx#3 = flip::dstIdx#1 [phi:flip::@2->flip::@2#1] -- register_copy 
    // [19] phi flip::srcIdx#2 = flip::srcIdx#1 [phi:flip::@2->flip::@2#2] -- register_copy 
    // flip::@2
  __b2:
    // buffer2[dstIdx] = buffer1[srcIdx++]
    // [20] buffer2[flip::dstIdx#3] = buffer1[flip::srcIdx#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuyy 
    lda buffer1,y
    sta buffer2,x
    // buffer2[dstIdx] = buffer1[srcIdx++];
    // [21] flip::srcIdx#1 = ++ flip::srcIdx#2 -- vbuyy=_inc_vbuyy 
    iny
    // dstIdx = dstIdx+16
    // [22] flip::dstIdx#1 = flip::dstIdx#3 + $10 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[$10]
    // for( byte c : 16..1)
    // [23] flip::c#1 = -- flip::c#2 -- vbuz1=_dec_vbuz1 
    dec.z c
    // [24] if(flip::c#1!=0) goto flip::@2 -- vbuz1_neq_0_then_la1 
    lda.z c
    bne __b2
    // flip::@3
    // dstIdx--;
    // [25] flip::dstIdx#2 = -- flip::dstIdx#1 -- vbuxx=_dec_vbuxx 
    dex
    // for( byte r : 16..1)
    // [26] flip::r#1 = -- flip::r#4 -- vbuz1=_dec_vbuz1 
    dec.z r
    // [27] if(flip::r#1!=0) goto flip::@1 -- vbuz1_neq_0_then_la1 
    lda.z r
    bne __b1
    // [28] phi from flip::@3 to flip::@4 [phi:flip::@3->flip::@4]
    // [28] phi flip::i#2 = 0 [phi:flip::@3->flip::@4#0] -- vbuxx=vbuc1 
    ldx #0
    // [28] phi from flip::@4 to flip::@4 [phi:flip::@4->flip::@4]
    // [28] phi flip::i#2 = flip::i#1 [phi:flip::@4->flip::@4#0] -- register_copy 
    // flip::@4
  __b4:
    // buffer1[i] = buffer2[i]
    // [29] buffer1[flip::i#2] = buffer2[flip::i#2] -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda buffer2,x
    sta buffer1,x
    // for(byte i : 0..255)
    // [30] flip::i#1 = ++ flip::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [31] if(flip::i#1!=0) goto flip::@4 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b4
    // flip::@return
    // }
    // [32] return 
    rts
}
  // plot
// Plot buffer on screen
plot: {
    .label line = 3
    .label y = 5
    // [34] phi from plot to plot::@1 [phi:plot->plot::@1]
    // [34] phi plot::y#4 = $10 [phi:plot->plot::@1#0] -- vbuz1=vbuc1 
    lda #$10
    sta.z y
    // [34] phi plot::line#5 = SCREEN+5*$28+$c [phi:plot->plot::@1#1] -- pbuz1=pbuc1 
    lda #<SCREEN+5*$28+$c
    sta.z line
    lda #>SCREEN+5*$28+$c
    sta.z line+1
    // [34] phi plot::i#4 = 0 [phi:plot->plot::@1#2] -- vbuxx=vbuc1 
    ldx #0
    // [34] phi from plot::@4 to plot::@1 [phi:plot::@4->plot::@1]
    // [34] phi plot::y#4 = plot::y#1 [phi:plot::@4->plot::@1#0] -- register_copy 
    // [34] phi plot::line#5 = plot::line#1 [phi:plot::@4->plot::@1#1] -- register_copy 
    // [34] phi plot::i#4 = plot::i#2 [phi:plot::@4->plot::@1#2] -- register_copy 
    // plot::@1
  __b1:
    // [35] phi from plot::@1 to plot::@2 [phi:plot::@1->plot::@2]
    // [35] phi plot::i#2 = plot::i#4 [phi:plot::@1->plot::@2#0] -- register_copy 
    // [35] phi plot::x#2 = 0 [phi:plot::@1->plot::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // plot::@2
  __b2:
    // for(byte x=0; x<16; x++ )
    // [36] if(plot::x#2<$10) goto plot::@3 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$10
    bcc __b3
    // plot::@4
    // line = line+40
    // [37] plot::line#1 = plot::line#5 + $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    // for(byte y : 16..1)
    // [38] plot::y#1 = -- plot::y#4 -- vbuz1=_dec_vbuz1 
    dec.z y
    // [39] if(plot::y#1!=0) goto plot::@1 -- vbuz1_neq_0_then_la1 
    lda.z y
    bne __b1
    // plot::@return
    // }
    // [40] return 
    rts
    // plot::@3
  __b3:
    // line[x] = buffer1[i++]
    // [41] plot::line#5[plot::x#2] = buffer1[plot::i#2] -- pbuz1_derefidx_vbuyy=pbuc1_derefidx_vbuxx 
    lda buffer1,x
    sta (line),y
    // line[x] = buffer1[i++];
    // [42] plot::i#1 = ++ plot::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // for(byte x=0; x<16; x++ )
    // [43] plot::x#1 = ++ plot::x#2 -- vbuyy=_inc_vbuyy 
    iny
    // [35] phi from plot::@3 to plot::@2 [phi:plot::@3->plot::@2]
    // [35] phi plot::i#2 = plot::i#1 [phi:plot::@3->plot::@2#0] -- register_copy 
    // [35] phi plot::x#2 = plot::x#1 [phi:plot::@3->plot::@2#1] -- register_copy 
    jmp __b2
}
  // File Data
.segment Data
  buffer1: .fill $10*$10, 0
  buffer2: .fill $10*$10, 0

