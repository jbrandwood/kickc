byte cnt = 0;
byte[256] SCREEN=$0400;

main();

void main() {
  inccnt();
  SCREEN[0]=cnt++;
  inccnt();
  SCREEN[1]=++cnt;
}

void inccnt() {
    ++cnt;
}




Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
Adding pre/post-modifier (byte) cnt ← ++ (byte) cnt
PROGRAM
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  proc (void()) main()
  (void~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  (void~) main::$1 ← call inccnt 
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
main::@return:
  return 
  endproc // main()
  proc (void()) inccnt()
  (byte) cnt ← ++ (byte) cnt
inccnt::@return:
  return 
  endproc // inccnt()

SYMBOLS
(void~) $0
(byte[256]) SCREEN
(byte) cnt
(void()) inccnt()
(label) inccnt::@return
(void()) main()
(void~) main::$0
(void~) main::$1
(label) main::@return

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@1
main: scope:[main]  from
  (void~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  (void~) main::$1 ← call inccnt 
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
inccnt: scope:[inccnt]  from
  (byte) cnt ← ++ (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@2: scope:[]  from @1
  to:@end
@end: scope:[]  from @2

Removing empty block @1
Removing empty block @2
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  (void~) $0 ← call main 
  to:@end
main: scope:[main]  from
  (void~) main::$0 ← call inccnt 
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  (void~) main::$1 ← call inccnt 
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
inccnt: scope:[inccnt]  from
  (byte) cnt ← ++ (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS
main modifies cnt
inccnt modifies cnt

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  (byte) cnt ← (byte) 0
  (byte[256]) SCREEN ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt ← (byte) cnt
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte) cnt ← (byte) cnt
  *((byte[256]) SCREEN + (byte) 0) ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt ← (byte) cnt
  (byte) cnt ← ++ (byte) cnt
  *((byte[256]) SCREEN + (byte) 1) ← (byte) cnt
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt ← (byte) cnt
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt ← ++ (byte) cnt
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt ← (byte) cnt
  return 
  to:@return
@end: scope:[]  from @3

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt#9 ← phi( @begin/(byte) cnt#0 )
  (byte) cnt#1 ← (byte) cnt#9
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt#15 ← phi( @begin/(byte) cnt#0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt#10 ← phi( main/(byte) cnt#15 )
  (byte) cnt#2 ← (byte) cnt#10
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte) cnt#2
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt#11 ← phi( main::@1/(byte) cnt#3 )
  (byte) cnt#4 ← (byte) cnt#11
  (byte) cnt#5 ← ++ (byte) cnt#4
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte) cnt#5
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt#12 ← phi( main::@2/(byte) cnt#5 )
  (byte) cnt#6 ← (byte) cnt#12
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#15 main::@1/(byte) cnt#3 )
  (byte) cnt#7 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt#14 ← phi( inccnt/(byte) cnt#7 )
  (byte) cnt#8 ← (byte) cnt#14
  return 
  to:@return
@end: scope:[]  from @3

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  (byte) cnt#0 ← (byte) 0
  (byte[256]) SCREEN#0 ← (word) 1024
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt#9 ← phi( @begin/(byte) cnt#6 )
  (byte) cnt#1 ← (byte) cnt#9
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(byte[256]) SCREEN#0 )
  (byte) cnt#15 ← phi( @begin/(byte) cnt#0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt#10 ← phi( main/(byte) cnt#8 )
  (byte) cnt#2 ← (byte) cnt#10
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte) cnt#2
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt#11 ← phi( main::@1/(byte) cnt#8 )
  (byte) cnt#4 ← (byte) cnt#11
  (byte) cnt#5 ← ++ (byte) cnt#4
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte) cnt#5
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt#12 ← phi( main::@2/(byte) cnt#5 )
  (byte) cnt#6 ← (byte) cnt#12
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#15 main::@1/(byte) cnt#3 )
  (byte) cnt#7 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt#14 ← phi( inccnt/(byte) cnt#7 )
  (byte) cnt#8 ← (byte) cnt#14
  return 
  to:@return
@end: scope:[]  from @3

Constant (byte) cnt#0 (byte) 0
Constant (byte[256]) SCREEN#0 (word) 1024
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  (byte) cnt#9 ← phi( @begin/(byte) cnt#6 )
  (byte) cnt#1 ← (byte) cnt#9
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#3 ← phi( @begin/(word) 1024 )
  (byte) cnt#15 ← phi( @begin/(byte) 0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  (byte[256]) SCREEN#1 ← phi( main/(byte[256]) SCREEN#3 )
  (byte) cnt#10 ← phi( main/(byte) cnt#8 )
  (byte) cnt#2 ← (byte) cnt#10
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte) cnt#2
  (byte) cnt#3 ← ++ (byte) cnt#2
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte[256]) SCREEN#2 ← phi( main::@1/(byte[256]) SCREEN#1 )
  (byte) cnt#11 ← phi( main::@1/(byte) cnt#8 )
  (byte) cnt#4 ← (byte) cnt#11
  (byte) cnt#5 ← ++ (byte) cnt#4
  *((byte[256]) SCREEN#2 + (byte) 1) ← (byte) cnt#5
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) cnt#12 ← phi( main::@2/(byte) cnt#5 )
  (byte) cnt#6 ← (byte) cnt#12
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#15 main::@1/(byte) cnt#3 )
  (byte) cnt#7 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  (byte) cnt#14 ← phi( inccnt/(byte) cnt#7 )
  (byte) cnt#8 ← (byte) cnt#14
  return 
  to:@return
@end: scope:[]  from @3

Alias (byte) cnt#1 = (byte) cnt#9 (byte) cnt#6 (byte) cnt#12 (byte) cnt#5 
Alias (byte) cnt#10 = (byte) cnt#8 (byte) cnt#2 (byte) cnt#11 (byte) cnt#4 (byte) cnt#14 (byte) cnt#7 
Alias (byte[256]) SCREEN#1 = (byte[256]) SCREEN#3 (byte[256]) SCREEN#2 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  (byte[256]) SCREEN#1 ← phi( @begin/(word) 1024 )
  (byte) cnt#15 ← phi( @begin/(byte) 0 )
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((byte[256]) SCREEN#1 + (byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((byte[256]) SCREEN#1 + (byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) cnt#15 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Redundant Phi (byte) cnt#15 (byte) 0
Redundant Phi (byte[256]) SCREEN#1 (word) 1024
Succesful SSA optimization Pass2RedundantPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@3
@3: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((word) 1024 + (byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((word) 1024 + (byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @3

Culled Empty Block (label) @3
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((word) 1024 + (byte) 0) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((word) 1024 + (byte) 1) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

Consolidated assigned array index constant in assignment *(1024)
Consolidated assigned array index constant in assignment *(1025)
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((word) 1024) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((word) 1025) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return
@end: scope:[]  from @begin

Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  call main param-assignment
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  call inccnt param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  *((word) 1024) ← (byte) cnt#10
  (byte) cnt#3 ← ++ (byte) cnt#10
  (byte~) cnt#16 ← (byte) cnt#3
  call inccnt param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) cnt#1 ← ++ (byte) cnt#10
  *((word) 1025) ← (byte) cnt#1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte~) cnt#16 )
  (byte) cnt#10 ← ++ (byte) cnt#13
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  return 
  to:@return

Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] call inccnt param-assignment [ cnt#10 ]
  to:main::@1
main::@1: scope:[main]  from main
  [2] *((word) 1024) ← (byte) cnt#10 [ cnt#10 ]
  [3] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ]
  [4] (byte~) cnt#16 ← (byte) cnt#3 [ cnt#16 ]
  [5] call inccnt param-assignment [ cnt#10 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [6] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ]
  [7] *((word) 1025) ← (byte) cnt#1 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [8] return  [ ]
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  [9] (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte~) cnt#16 ) [ cnt#13 ]
  [10] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ]
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  [11] return  [ cnt#10 ]
  to:@return

Created 1 initial phi equivalence classes
Coalesced [4] cnt#16 ← cnt#3
Coalesced down to 1 phi equivalence classes
Block Sequence Planned @begin @end main main::@1 main::@2 main::@return inccnt inccnt::@return 
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] call inccnt param-assignment [ cnt#10 ]
  to:main::@1
main::@1: scope:[main]  from main
  [2] *((word) 1024) ← (byte) cnt#10 [ cnt#10 ]
  [3] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ]
  [4] call inccnt param-assignment [ cnt#10 ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [5] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ]
  [6] *((word) 1025) ← (byte) cnt#1 [ ]
  to:main::@return
main::@return: scope:[main]  from main::@2
  [7] return  [ ]
  to:@return
inccnt: scope:[inccnt]  from main main::@1
  [8] (byte) cnt#13 ← phi( main/(byte) 0 main::@1/(byte) cnt#3 ) [ cnt#13 ]
  [9] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ]
  to:inccnt::@return
inccnt::@return: scope:[inccnt]  from inccnt
  [10] return  [ cnt#10 ]
  to:@return

CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 1:inccnt 4:inccnt 

DOMINATORS
@begin dominated by  @begin 
@end dominated by  @end @begin 
main dominated by  @begin main 
main::@1 dominated by  @begin main::@1 main 
main::@2 dominated by  @begin main::@2 main::@1 main 
main::@return dominated by  main::@return @begin main::@2 main::@1 main 
inccnt dominated by  inccnt @begin main 
inccnt::@return dominated by  inccnt::@return inccnt @begin main 

NATURAL LOOPS

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 0 loops in scope [inccnt]
NATURAL LOOPS WITH DEPTH


VARIABLE REGISTER WEIGHTS
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 4.0
(byte) cnt#10 1.6
(byte) cnt#13 4.0
(byte) cnt#3 4.0
(void()) inccnt()
(void()) main()

Initial phi equivalence classes
[ cnt#13 cnt#3 ]
Added variable cnt#1 to zero page equivalence class [ cnt#1 ]
Added variable cnt#10 to zero page equivalence class [ cnt#10 ]
Complete equivalence classes
[ cnt#13 cnt#3 ]
[ cnt#1 ]
[ cnt#10 ]
Allocated zp byte:2 to zp byte:2 [ cnt#13 cnt#3 ]
Allocated zp byte:3 to zp byte:3 [ cnt#1 ]
Allocated zp byte:4 to zp byte:4 [ cnt#10 ]
INITIAL ASM
//SEG0 @begin
bbegin:
//SEG1 [0] call main param-assignment [ ]
  jsr main
  jmp bend
//SEG2 @end
bend:
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ cnt#10 ]
  //SEG5 [8] phi from main to inccnt
  inccnt_from_main:
  //SEG6 [8] phi (byte) cnt#13 = (byte) 0 -- zpby1=coby1 
    lda #$0
    sta $2
    jsr inccnt
    jmp b1
  //SEG7 main::@1
  b1:
  //SEG8 [2] *((word) 1024) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=zpby1 
    lda $4
    sta $400
  //SEG9 [3] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- zpby1=_inc_zpby2 
    lda $4
    sta $2
    inc $2
  //SEG10 [4] call inccnt param-assignment [ cnt#10 ]
  //SEG11 [8] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG12 [8] phi (byte) cnt#13 = (byte) cnt#3 -- register_copy 
    jsr inccnt
    jmp b2
  //SEG13 main::@2
  b2:
  //SEG14 [5] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- zpby1=_inc_zpby2 
    lda $4
    sta $3
    inc $3
  //SEG15 [6] *((word) 1025) ← (byte) cnt#1 [ ] -- _star_cowo1=zpby1 
    lda $3
    sta $401
    jmp breturn
  //SEG16 main::@return
  breturn:
  //SEG17 [7] return  [ ]
    rts
}
//SEG18 inccnt
inccnt: {
  //SEG19 [9] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- zpby1=_inc_zpby2 
    lda $2
    sta $4
    inc $4
    jmp breturn
  //SEG20 inccnt::@return
  breturn:
  //SEG21 [10] return  [ cnt#10 ]
    rts
}

REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp byte:2 [ cnt#13 cnt#3 ] : zp byte:2 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:3 [ cnt#1 ] : zp byte:3 , reg byte a , reg byte x , reg byte y , 
Potential registers zp byte:4 [ cnt#10 ] : zp byte:4 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 8: zp byte:2 [ cnt#13 cnt#3 ] 4: zp byte:3 [ cnt#1 ] 1.6: zp byte:4 [ cnt#10 ] 
Uplift Scope [main] 
Uplift Scope [inccnt] 

Uplifting [] best 61 combination reg byte x [ cnt#13 cnt#3 ] reg byte x [ cnt#1 ] reg byte x [ cnt#10 ] 
Uplifting [main] best 61 combination 
Uplifting [inccnt] best 61 combination 
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 @begin
bbegin:
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @end
bend:
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ cnt#10 ]
  //SEG5 [8] phi from main to inccnt
  inccnt_from_main:
  //SEG6 [8] phi (byte) cnt#13 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG7 main::@1
  b1:
  //SEG8 [2] *((word) 1024) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx $400
  //SEG9 [3] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG10 [4] call inccnt param-assignment [ cnt#10 ]
  //SEG11 [8] phi from main::@1 to inccnt
  inccnt_from_b1:
  //SEG12 [8] phi (byte) cnt#13 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG13 main::@2
  b2:
  //SEG14 [5] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG15 [6] *((word) 1025) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx $401
  //SEG16 main::@return
  breturn:
  //SEG17 [7] return  [ ]
    rts
}
//SEG18 inccnt
inccnt: {
  //SEG19 [9] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG20 inccnt::@return
  breturn:
  //SEG21 [10] return  [ cnt#10 ]
    rts
}

Removing instruction bbegin:
Removing instruction bend:
Removing instruction inccnt_from_main:
Removing instruction b1:
Removing instruction inccnt_from_b1:
Removing instruction b2:
Removing instruction breturn:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 @begin
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @end
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ cnt#10 ]
  //SEG5 [8] phi from main to inccnt
  //SEG6 [8] phi (byte) cnt#13 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG7 main::@1
  //SEG8 [2] *((word) 1024) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx $400
  //SEG9 [3] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG10 [4] call inccnt param-assignment [ cnt#10 ]
  //SEG11 [8] phi from main::@1 to inccnt
  //SEG12 [8] phi (byte) cnt#13 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG13 main::@2
  //SEG14 [5] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG15 [6] *((word) 1025) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx $401
  //SEG16 main::@return
  //SEG17 [7] return  [ ]
    rts
}
//SEG18 inccnt
inccnt: {
  //SEG19 [9] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG20 inccnt::@return
  //SEG21 [10] return  [ cnt#10 ]
    rts
}

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(byte[256]) SCREEN
(byte) cnt
(byte) cnt#1 reg byte x 4.0
(byte) cnt#10 reg byte x 1.6
(byte) cnt#13 reg byte x 4.0
(byte) cnt#3 reg byte x 4.0
(void()) inccnt()
(label) inccnt::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return

reg byte x [ cnt#13 cnt#3 ]
reg byte x [ cnt#1 ]
reg byte x [ cnt#10 ]

FINAL CODE
//SEG0 @begin
//SEG1 [0] call main param-assignment [ ]
  jsr main
//SEG2 @end
//SEG3 main
main: {
  //SEG4 [1] call inccnt param-assignment [ cnt#10 ]
  //SEG5 [8] phi from main to inccnt
  //SEG6 [8] phi (byte) cnt#13 = (byte) 0 -- xby=coby1 
    ldx #$0
    jsr inccnt
  //SEG7 main::@1
  //SEG8 [2] *((word) 1024) ← (byte) cnt#10 [ cnt#10 ] -- _star_cowo1=xby 
    stx $400
  //SEG9 [3] (byte) cnt#3 ← ++ (byte) cnt#10 [ cnt#3 ] -- xby=_inc_xby 
    inx
  //SEG10 [4] call inccnt param-assignment [ cnt#10 ]
  //SEG11 [8] phi from main::@1 to inccnt
  //SEG12 [8] phi (byte) cnt#13 = (byte) cnt#3 -- register_copy 
    jsr inccnt
  //SEG13 main::@2
  //SEG14 [5] (byte) cnt#1 ← ++ (byte) cnt#10 [ cnt#1 ] -- xby=_inc_xby 
    inx
  //SEG15 [6] *((word) 1025) ← (byte) cnt#1 [ ] -- _star_cowo1=xby 
    stx $401
  //SEG16 main::@return
  //SEG17 [7] return  [ ]
    rts
}
//SEG18 inccnt
inccnt: {
  //SEG19 [9] (byte) cnt#10 ← ++ (byte) cnt#13 [ cnt#10 ] -- xby=_inc_xby 
    inx
  //SEG20 inccnt::@return
  //SEG21 [10] return  [ cnt#10 ]
    rts
}

