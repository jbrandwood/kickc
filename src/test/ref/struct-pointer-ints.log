Setting struct to load/store in variable affected by address-of main::$0 = call update &main::s $3e8 

CONTROL FLOW GRAPH SSA

void update(struct myStruct* update::s , word update::size)
update: scope:[update]  from main
  update::size#1 = phi( main/update::size#0 )
  update::s#1 = phi( main/update::s#0 )
  update::$2 = (word*)update::s#1
  update::$0 = update::$2 + OFFSET_STRUCT_MYSTRUCT_A
  update::$3 = (word*)update::s#1
  update::$1 = update::$3 + OFFSET_STRUCT_MYSTRUCT_A
  *update::$1 = *update::$0 + update::size#1
  to:update::@return
update::@return: scope:[update]  from update
  return 
  to:@return

signed word main()
main: scope:[main]  from __start
  *(&main::s) = memset(struct myStruct, SIZEOF_STRUCT_MYSTRUCT)
  main::s = struct-unwound {*(&main::s)}
  update::s#0 = &main::s
  update::size#0 = $3e8
  call update 
  to:main::@1
main::@1: scope:[main]  from main
  main::return#0 = 0
  to:main::@return
main::@return: scope:[main]  from main::@1
  main::return#3 = phi( main::@1/main::return#0 )
  main::return#1 = main::return#3
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  call main 
  main::return#2 = main::return#1
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
constant byte OFFSET_STRUCT_MYSTRUCT_A = 0
constant byte SIZEOF_STRUCT_MYSTRUCT = 4
void __start()
signed word main()
signed word main::return
signed word main::return#0
signed word main::return#1
signed word main::return#2
signed word main::return#3
volatile struct myStruct main::s loadstore
void update(struct myStruct* update::s , word update::size)
word*~ update::$0
word*~ update::$1
word*~ update::$2
word*~ update::$3
struct myStruct* update::s
struct myStruct* update::s#0
struct myStruct* update::s#1
word update::size
word update::size#0
word update::size#1

Adding number conversion cast (unumber) $3e8 in update::size#0 = $3e8
Adding number conversion cast (snumber) 0 in main::return#0 = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast update::size#0 = (unumber)$3e8
Inlining cast main::return#0 = (snumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (word) $3e8
Finalized signed number type (signed byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias main::return#0 = main::return#3 main::return#1 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values update::s#1 update::s#0
Identical Phi Values update::size#1 update::size#0
Successful SSA optimization Pass2IdenticalPhiElimination
Removing C-classic struct-unwound assignment [8] main::s = struct-unwound {*(&main::s)}
Constant update::s#0 = &main::s
Constant update::size#0 = $3e8
Constant main::return#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant update::$2 = (word*)update::s#0
Constant update::$3 = (word*)update::s#0
Constant main::return#2 = main::return#0
Successful SSA optimization Pass2ConstantIdentification
Converting *(pointer+n) to pointer[n] [5] *update::$1 = *update::$0 + update::size#0  -- update::$2[OFFSET_STRUCT_MYSTRUCT_A]
Converting *(pointer+n) to pointer[n] [5] *update::$1 = update::$2[OFFSET_STRUCT_MYSTRUCT_A] + update::size#0  -- update::$3[OFFSET_STRUCT_MYSTRUCT_A]
Successful SSA optimization Pass2InlineDerefIdx
Simplifying expression containing zero update::$2 in [2] update::$0 = update::$2 + OFFSET_STRUCT_MYSTRUCT_A
Simplifying expression containing zero update::$3 in [4] update::$1 = update::$3 + OFFSET_STRUCT_MYSTRUCT_A
Simplifying expression containing zero update::$2 in [5] update::$3[OFFSET_STRUCT_MYSTRUCT_A] = update::$2[OFFSET_STRUCT_MYSTRUCT_A] + update::size#0
Simplifying expression containing zero update::$3 in [5] update::$3[OFFSET_STRUCT_MYSTRUCT_A] = *update::$2 + update::size#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable update::$0 and assignment [0] update::$0 = update::$2
Eliminating unused variable update::$1 and assignment [1] update::$1 = update::$3
Eliminating unused constant main::return#2
Eliminating unused constant OFFSET_STRUCT_MYSTRUCT_A
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant main::return#0
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant inlined update::$2 = (word*)update::s#0
Constant inlined update::$3 = (word*)update::s#0
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main::@1
CALL GRAPH
Calls in [main] to update:1 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block label main::@1

FINAL CONTROL FLOW GRAPH

signed word main()
main: scope:[main]  from
  [0] *(&main::s) = memset(struct myStruct, SIZEOF_STRUCT_MYSTRUCT)
  [1] call update 
  to:main::@return
main::@return: scope:[main]  from main
  [2] return 
  to:@return

void update(struct myStruct* update::s , word update::size)
update: scope:[update]  from main
  [3] *((word*)update::s#0) = *((word*)update::s#0) + update::size#0
  to:update::@return
update::@return: scope:[update]  from update
  [4] return 
  to:@return


VARIABLE REGISTER WEIGHTS
signed word main()
signed word main::return
volatile struct myStruct main::s loadstore
void update(struct myStruct* update::s , word update::size)
struct myStruct* update::s
word update::size

Initial phi equivalence classes
Added variable main::s to live range equivalence class [ main::s ]
Complete equivalence classes
[ main::s ]
Allocated zp[4]:2 [ main::s ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *(&main::s) = memset(struct myStruct, SIZEOF_STRUCT_MYSTRUCT) [ ] (  [ ] { }  ) always clobbers reg byte a reg byte y 
Statement [3] *((word*)update::s#0) = *((word*)update::s#0) + update::size#0 [ ] ( update:1 [ ] { }  ) always clobbers reg byte a 
Potential registers zp[4]:2 [ main::s ] : zp[4]:2 , 

REGISTER UPLIFT SCOPES
Uplift Scope [myStruct] 
Uplift Scope [update] 
Uplift Scope [main] 0: zp[4]:2 [ main::s ] 
Uplift Scope [] 

Uplifting [myStruct] best 55 combination 
Uplifting [update] best 55 combination 
Uplifting [main] best 55 combination zp[4]:2 [ main::s ] 
Uplifting [] best 55 combination 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Demonstrates missing fragment _deref_pwuc1=_deref_pwuc1_plus_vwuc2
// https://gitlab.com/camelot/kickc/-/issues/435 reported by G.B.
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-pointer-ints.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_STRUCT_MYSTRUCT = 4
.segment Code
  // main
main: {
    .label s = 2
    // [0] *(&main::s) = memset(struct myStruct, SIZEOF_STRUCT_MYSTRUCT) -- _deref_pssc1=_memset_vbuc2 
    ldy #SIZEOF_STRUCT_MYSTRUCT
    lda #0
  !:
    dey
    sta s,y
    bne !-
    // [1] call update 
    jsr update
    jmp __breturn
    // main::@return
  __breturn:
    // [2] return 
    rts
}
  // update
update: {
    .const size = $3e8
    .label s = main.s
    // [3] *((word*)update::s#0) = *((word*)update::s#0) + update::size#0 -- _deref_pwuc1=_deref_pwuc1_plus_vwuc2 
    lda #<size
    clc
    adc.z s
    sta.z s
    lda #>size
    adc.z s+1
    sta.z s+1
    jmp __breturn
    // update::@return
  __breturn:
    // [4] return 
    rts
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
constant byte SIZEOF_STRUCT_MYSTRUCT = 4
signed word main()
signed word main::return
volatile struct myStruct main::s loadstore zp[4]:2
void update(struct myStruct* update::s , word update::size)
struct myStruct* update::s
constant struct myStruct* update::s#0 s = &main::s
word update::size
constant word update::size#0 size = $3e8

zp[4]:2 [ main::s ]


FINAL ASSEMBLER
Score: 49

  // File Comments
// Demonstrates missing fragment _deref_pwuc1=_deref_pwuc1_plus_vwuc2
// https://gitlab.com/camelot/kickc/-/issues/435 reported by G.B.
  // Upstart
  // Commodore 64 PRG executable file
.file [name="struct-pointer-ints.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .const SIZEOF_STRUCT_MYSTRUCT = 4
.segment Code
  // main
main: {
    .label s = 2
    // myStruct s
    // [0] *(&main::s) = memset(struct myStruct, SIZEOF_STRUCT_MYSTRUCT) -- _deref_pssc1=_memset_vbuc2 
    ldy #SIZEOF_STRUCT_MYSTRUCT
    lda #0
  !:
    dey
    sta s,y
    bne !-
    // update(&s, 1000)
    // [1] call update 
    jsr update
    // main::@return
    // }
    // [2] return 
    rts
}
  // update
update: {
    .const size = $3e8
    .label s = main.s
    // s->a += size
    // [3] *((word*)update::s#0) = *((word*)update::s#0) + update::size#0 -- _deref_pwuc1=_deref_pwuc1_plus_vwuc2 
    lda #<size
    clc
    adc.z s
    sta.z s
    lda #>size
    adc.z s+1
    sta.z s+1
    // update::@return
    // }
    // [4] return 
    rts
}
  // File Data

