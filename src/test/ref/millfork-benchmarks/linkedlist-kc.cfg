@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] (word) last_time#0 ← (word) 0
  to:@2
@2: scope:[]  from @1
  [2] (word) rand_seed#20 ← (word) 0
  to:@3
@3: scope:[]  from @2
  [3] phi()
  [4] call main 
  to:@end
@end: scope:[]  from @3
  [5] phi()

(void()) main()
main: scope:[main]  from @3
  [6] phi()
  [7] call start 
  to:main::@1
main::@1: scope:[main]  from main main::@7
  [8] (byte) main::c#8 ← phi( main/(byte) 0 main::@7/(byte) main::c#2 )
  [8] (byte*) print_char_cursor#49 ← phi( main/(byte*) 1024 main::@7/(byte*) print_char_cursor#10 )
  [9] call init 
  to:main::@2
main::@2: scope:[main]  from main::@1 main::@5
  [10] (struct node*) root#20 ← phi( main::@1/(struct node*) 0 main::@5/(struct node*) root#11 )
  [10] (word) free_#22 ← phi( main::@1/(byte) 0 main::@5/(word) free_#13 )
  [10] (word) main::i#3 ← phi( main::@1/(byte) 0 main::@5/(word) main::i#2 )
  [11] (word) prepend::x#0 ← (word) main::i#3
  [12] call prepend 
  to:main::@5
main::@5: scope:[main]  from main::@2
  [13] (word) main::i#2 ← ++ (word) main::i#3
  [14] if((word) main::i#2!=(word) $bb8) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@5
  [15] phi()
  [16] call sum 
  [17] (word) sum::return#2 ← (word) sum::s#3
  to:main::@6
main::@6: scope:[main]  from main::@3
  [18] (word~) main::$5 ← (word) sum::return#2
  [19] (byte) print_char::ch#2 ← (byte)(word~) main::$5
  [20] call print_char 
  to:main::@7
main::@7: scope:[main]  from main::@6
  [21] (byte) main::c#2 ← ++ (byte) main::c#8
  [22] if((byte) main::c#2!=(byte) 5) goto main::@1
  to:main::@4
main::@4: scope:[main]  from main::@7
  [23] phi()
  [24] call end 
  to:main::@return
main::@return: scope:[main]  from main::@4
  [25] return 
  to:@return

(void()) end()
end: scope:[end]  from main::@4
  [26] (word) Ticks#1 ← (word) last_time#0
  [27] call start 
  to:end::@1
end::@1: scope:[end]  from end
  [28] (word) last_time#1 ← (word) last_time#0 - (word) Ticks#1
  [29] (word) Ticks#2 ← (word) last_time#1
  [30] (word) print_word::w#0 ← (word) Ticks#2
  [31] call print_word 
  to:end::@2
end::@2: scope:[end]  from end::@1
  [32] phi()
  [33] call print_ln 
  to:end::@return
end::@return: scope:[end]  from end::@2
  [34] (word) last_time#2 ← (word) last_time#1
  [35] return 
  to:@return

(void()) print_ln()
print_ln: scope:[print_ln]  from end::@2
  [36] phi()
  to:print_ln::@1
print_ln::@1: scope:[print_ln]  from print_ln print_ln::@1
  [37] (byte*) print_line_cursor#8 ← phi( print_ln/(byte*) 1024 print_ln::@1/(byte*) print_line_cursor#1 )
  [38] (byte*) print_line_cursor#1 ← (byte*) print_line_cursor#8 + (byte) $28
  [39] if((byte*) print_line_cursor#1<(byte*) print_char_cursor#10) goto print_ln::@1
  to:print_ln::@return
print_ln::@return: scope:[print_ln]  from print_ln::@1
  [40] return 
  to:@return

(void()) print_word((word) print_word::w)
print_word: scope:[print_word]  from end::@1
  [41] (byte) print_byte::b#0 ← > (word) print_word::w#0
  [42] call print_byte 
  to:print_word::@1
print_word::@1: scope:[print_word]  from print_word
  [43] (byte) print_byte::b#1 ← < (word) print_word::w#0
  [44] call print_byte 
  to:print_word::@return
print_word::@return: scope:[print_word]  from print_word::@1
  [45] return 
  to:@return

(void()) print_byte((byte) print_byte::b)
print_byte: scope:[print_byte]  from print_word print_word::@1
  [46] (byte) print_byte::b#2 ← phi( print_word/(byte) print_byte::b#0 print_word::@1/(byte) print_byte::b#1 )
  [47] (byte~) print_byte::$0 ← (byte) print_byte::b#2 >> (byte) 4
  [48] (byte) print_char::ch#0 ← *((const byte*) print_hextab + (byte~) print_byte::$0)
  [49] call print_char 
  to:print_byte::@1
print_byte::@1: scope:[print_byte]  from print_byte
  [50] (byte~) print_byte::$2 ← (byte) print_byte::b#2 & (byte) $f
  [51] (byte) print_char::ch#1 ← *((const byte*) print_hextab + (byte~) print_byte::$2)
  [52] call print_char 
  to:print_byte::@return
print_byte::@return: scope:[print_byte]  from print_byte::@1
  [53] return 
  to:@return

(void()) print_char((byte) print_char::ch)
print_char: scope:[print_char]  from main::@6 print_byte print_byte::@1
  [54] (byte*) print_char_cursor#26 ← phi( main::@6/(byte*) print_char_cursor#49 print_byte/(byte*) print_char_cursor#10 print_byte::@1/(byte*) print_char_cursor#10 )
  [54] (byte) print_char::ch#3 ← phi( main::@6/(byte) print_char::ch#2 print_byte/(byte) print_char::ch#0 print_byte::@1/(byte) print_char::ch#1 )
  [55] *((byte*) print_char_cursor#26) ← (byte) print_char::ch#3
  [56] (byte*) print_char_cursor#10 ← ++ (byte*) print_char_cursor#26
  to:print_char::@return
print_char::@return: scope:[print_char]  from print_char
  [57] return 
  to:@return

(void()) start()
start: scope:[start]  from end main
  asm { jsr$FFDE staLAST_TIME stxLAST_TIME+1  }
  [59] (word) rand_seed#0 ← (word) $194a
  to:start::@return
start::@return: scope:[start]  from start
  [60] return 
  to:@return

(word()) sum()
sum: scope:[sum]  from main::@3
  [61] (struct node*) sum::current#1 ← (struct node*) root#11
  to:sum::@1
sum::@1: scope:[sum]  from sum sum::@2
  [62] (word) sum::s#3 ← phi( sum/(byte) 0 sum::@2/(word) sum::s#2 )
  [62] (struct node*) sum::current#3 ← phi( sum/(struct node*) sum::current#1 sum::@2/(struct node*) sum::current#2 )
  [63] if((struct node*)(word) 0!=(struct node*) sum::current#3) goto sum::@2
  to:sum::@return
sum::@return: scope:[sum]  from sum::@1
  [64] return 
  to:@return
sum::@2: scope:[sum]  from sum::@1
  [65] (word) sum::s#2 ← (word) sum::s#3 + *((word*)(struct node*) sum::current#3 + (const byte) OFFSET_STRUCT_NODE_VALUE)
  [66] (struct node*) sum::current#2 ← *((struct node**)(struct node*) sum::current#3)
  to:sum::@1

(void()) prepend((word) prepend::x)
prepend: scope:[prepend]  from main::@2
  [67] phi()
  [68] call alloc 
  [69] (struct node*) alloc::return#2 ← (struct node*) alloc::return#0
  to:prepend::@1
prepend::@1: scope:[prepend]  from prepend
  [70] (struct node*) prepend::new#1 ← (struct node*) alloc::return#2
  [71] *((struct node**)(struct node*) prepend::new#1) ← (struct node*) root#20
  [72] *((word*)(struct node*) prepend::new#1 + (const byte) OFFSET_STRUCT_NODE_VALUE) ← (word) prepend::x#0
  [73] (struct node*) root#11 ← (struct node*) prepend::new#1
  to:prepend::@return
prepend::@return: scope:[prepend]  from prepend::@1
  [74] return 
  to:@return

(struct node*()) alloc()
alloc: scope:[alloc]  from prepend
  [75] (word~) alloc::$1 ← (word) free_#22 << (byte) 2
  [76] (struct node*) alloc::return#0 ← (const struct node*) heap + (word~) alloc::$1
  [77] (word) free_#13 ← ++ (word) free_#22
  to:alloc::@return
alloc::@return: scope:[alloc]  from alloc
  [78] return 
  to:@return

(void()) init()
init: scope:[init]  from main::@1
  [79] phi()
  to:init::@return
init::@return: scope:[init]  from init
  [80] return 
  to:@return
