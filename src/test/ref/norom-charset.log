Fixing pointer array-indexing *((word[]) charset_spec_row + (byte) main::c)
Identified constant variable (byte*) VIC_MEMORY
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) CHARSET
Culled Empty Block (label) main::@4
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@6
Culled Empty Block (label) @1
Culled Empty Block (label) gen_char3::@6

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) VIC_MEMORY ← ((byte*)) (number) $d018
  (byte*) SCREEN ← ((byte*)) (number) $400
  (byte*) CHARSET ← ((byte*)) (number) $3000
  (word[]) charset_spec_row ← { (number) $f7da, (number) $f7de, (number) $f24e, (number) $d6de }
  to:@2

(void()) main()
main: scope:[main]  from @2
  (byte*~) main::$0 ← (byte*) CHARSET + (number) 8
  (byte*) main::charset#0 ← (byte*~) main::$0
  (byte) main::c#0 ← (number) 0
  to:main::@1
main::@1: scope:[main]  from main main::@7
  (byte*) main::charset#4 ← phi( main/(byte*) main::charset#0 main::@7/(byte*) main::charset#1 )
  (byte) main::c#2 ← phi( main/(byte) main::c#0 main::@7/(byte) main::c#1 )
  (bool~) main::$7 ← (byte) main::c#2 != (number) 4
  if((bool~) main::$7) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  (byte*) main::charset#2 ← phi( main::@1/(byte*) main::charset#4 )
  (byte) main::c#3 ← phi( main::@1/(byte) main::c#2 )
  (byte~) main::$10 ← (byte) main::c#3 * (const byte) SIZEOF_WORD
  (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
  (word) gen_char3::spec#0 ← *((word[]) charset_spec_row + (byte~) main::$10)
  call gen_char3 
  to:main::@7
main::@7: scope:[main]  from main::@2
  (byte) main::c#4 ← phi( main::@2/(byte) main::c#3 )
  (byte*) main::charset#3 ← phi( main::@2/(byte*) main::charset#2 )
  (byte*~) main::$9 ← (byte*) main::charset#3 + (number) 8
  (byte*) main::charset#1 ← (byte*~) main::$9
  (byte) main::c#1 ← ++ (byte) main::c#4
  to:main::@1
main::@3: scope:[main]  from main::@1
  (word~) main::$1 ← ((word)) (byte*) SCREEN
  (number~) main::$2 ← (word~) main::$1 / (number) $40
  (word~) main::$3 ← ((word)) (byte*) CHARSET
  (number~) main::$4 ← (word~) main::$3 / (number) $400
  (number~) main::$5 ← (number~) main::$2 | (number~) main::$4
  (byte~) main::$6 ← ((byte)) (number~) main::$5
  *((byte*) VIC_MEMORY) ← (byte~) main::$6
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return

(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
gen_char3: scope:[gen_char3]  from main::@2
  (byte*) gen_char3::dst#6 ← phi( main::@2/(byte*) gen_char3::dst#0 )
  (word) gen_char3::spec#6 ← phi( main::@2/(word) gen_char3::spec#0 )
  (byte) gen_char3::r#0 ← (byte) 0
  to:gen_char3::@1
gen_char3::@1: scope:[gen_char3]  from gen_char3 gen_char3::@5
  (byte) gen_char3::r#6 ← phi( gen_char3/(byte) gen_char3::r#0 gen_char3::@5/(byte) gen_char3::r#1 )
  (byte*) gen_char3::dst#5 ← phi( gen_char3/(byte*) gen_char3::dst#6 gen_char3::@5/(byte*) gen_char3::dst#1 )
  (word) gen_char3::spec#4 ← phi( gen_char3/(word) gen_char3::spec#6 gen_char3::@5/(word) gen_char3::spec#7 )
  (byte) gen_char3::b#0 ← (number) 0
  (byte) gen_char3::c#0 ← (byte) 0
  to:gen_char3::@2
gen_char3::@2: scope:[gen_char3]  from gen_char3::@1 gen_char3::@3
  (byte) gen_char3::r#4 ← phi( gen_char3::@1/(byte) gen_char3::r#6 gen_char3::@3/(byte) gen_char3::r#3 )
  (byte*) gen_char3::dst#3 ← phi( gen_char3::@1/(byte*) gen_char3::dst#5 gen_char3::@3/(byte*) gen_char3::dst#2 )
  (byte) gen_char3::c#3 ← phi( gen_char3::@1/(byte) gen_char3::c#0 gen_char3::@3/(byte) gen_char3::c#1 )
  (byte) gen_char3::b#6 ← phi( gen_char3::@1/(byte) gen_char3::b#0 gen_char3::@3/(byte) gen_char3::b#1 )
  (word) gen_char3::spec#2 ← phi( gen_char3::@1/(word) gen_char3::spec#4 gen_char3::@3/(word) gen_char3::spec#1 )
  (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2
  (number~) gen_char3::$1 ← (byte~) gen_char3::$0 & (number) $80
  (bool~) gen_char3::$2 ← (number~) gen_char3::$1 != (number) 0
  (bool~) gen_char3::$3 ← ! (bool~) gen_char3::$2
  if((bool~) gen_char3::$3) goto gen_char3::@3
  to:gen_char3::@4
gen_char3::@3: scope:[gen_char3]  from gen_char3::@2 gen_char3::@4
  (byte) gen_char3::r#3 ← phi( gen_char3::@2/(byte) gen_char3::r#4 gen_char3::@4/(byte) gen_char3::r#5 )
  (byte*) gen_char3::dst#2 ← phi( gen_char3::@2/(byte*) gen_char3::dst#3 gen_char3::@4/(byte*) gen_char3::dst#4 )
  (byte) gen_char3::c#2 ← phi( gen_char3::@2/(byte) gen_char3::c#3 gen_char3::@4/(byte) gen_char3::c#4 )
  (word) gen_char3::spec#3 ← phi( gen_char3::@2/(word) gen_char3::spec#2 gen_char3::@4/(word) gen_char3::spec#5 )
  (byte) gen_char3::b#3 ← phi( gen_char3::@2/(byte) gen_char3::b#6 gen_char3::@4/(byte) gen_char3::b#2 )
  (number~) gen_char3::$5 ← (byte) gen_char3::b#3 * (number) 2
  (byte) gen_char3::b#1 ← (number~) gen_char3::$5
  (number~) gen_char3::$6 ← (word) gen_char3::spec#3 * (number) 2
  (word) gen_char3::spec#1 ← (number~) gen_char3::$6
  (byte) gen_char3::c#1 ← (byte) gen_char3::c#2 + rangenext(0,2)
  (bool~) gen_char3::$7 ← (byte) gen_char3::c#1 != rangelast(0,2)
  if((bool~) gen_char3::$7) goto gen_char3::@2
  to:gen_char3::@5
gen_char3::@4: scope:[gen_char3]  from gen_char3::@2
  (byte) gen_char3::r#5 ← phi( gen_char3::@2/(byte) gen_char3::r#4 )
  (byte*) gen_char3::dst#4 ← phi( gen_char3::@2/(byte*) gen_char3::dst#3 )
  (byte) gen_char3::c#4 ← phi( gen_char3::@2/(byte) gen_char3::c#3 )
  (word) gen_char3::spec#5 ← phi( gen_char3::@2/(word) gen_char3::spec#2 )
  (byte) gen_char3::b#4 ← phi( gen_char3::@2/(byte) gen_char3::b#6 )
  (number~) gen_char3::$4 ← (byte) gen_char3::b#4 | (number) 1
  (byte) gen_char3::b#2 ← (number~) gen_char3::$4
  to:gen_char3::@3
gen_char3::@5: scope:[gen_char3]  from gen_char3::@3
  (word) gen_char3::spec#7 ← phi( gen_char3::@3/(word) gen_char3::spec#1 )
  (byte) gen_char3::r#2 ← phi( gen_char3::@3/(byte) gen_char3::r#3 )
  (byte*) gen_char3::dst#1 ← phi( gen_char3::@3/(byte*) gen_char3::dst#2 )
  (byte) gen_char3::b#5 ← phi( gen_char3::@3/(byte) gen_char3::b#1 )
  *((byte*) gen_char3::dst#1 + (byte) gen_char3::r#2) ← (byte) gen_char3::b#5
  (byte) gen_char3::r#1 ← (byte) gen_char3::r#2 + rangenext(0,4)
  (bool~) gen_char3::$8 ← (byte) gen_char3::r#1 != rangelast(0,4)
  if((bool~) gen_char3::$8) goto gen_char3::@1
  to:gen_char3::@return
gen_char3::@return: scope:[gen_char3]  from gen_char3::@5
  return 
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @2
(label) @3
(label) @begin
(label) @end
(byte*) CHARSET
(byte*) SCREEN
(const byte) SIZEOF_WORD = (byte) 2
(byte*) VIC_MEMORY
(word[]) charset_spec_row
(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
(byte~) gen_char3::$0
(number~) gen_char3::$1
(bool~) gen_char3::$2
(bool~) gen_char3::$3
(number~) gen_char3::$4
(number~) gen_char3::$5
(number~) gen_char3::$6
(bool~) gen_char3::$7
(bool~) gen_char3::$8
(label) gen_char3::@1
(label) gen_char3::@2
(label) gen_char3::@3
(label) gen_char3::@4
(label) gen_char3::@5
(label) gen_char3::@return
(byte) gen_char3::b
(byte) gen_char3::b#0
(byte) gen_char3::b#1
(byte) gen_char3::b#2
(byte) gen_char3::b#3
(byte) gen_char3::b#4
(byte) gen_char3::b#5
(byte) gen_char3::b#6
(byte) gen_char3::c
(byte) gen_char3::c#0
(byte) gen_char3::c#1
(byte) gen_char3::c#2
(byte) gen_char3::c#3
(byte) gen_char3::c#4
(byte*) gen_char3::dst
(byte*) gen_char3::dst#0
(byte*) gen_char3::dst#1
(byte*) gen_char3::dst#2
(byte*) gen_char3::dst#3
(byte*) gen_char3::dst#4
(byte*) gen_char3::dst#5
(byte*) gen_char3::dst#6
(byte) gen_char3::r
(byte) gen_char3::r#0
(byte) gen_char3::r#1
(byte) gen_char3::r#2
(byte) gen_char3::r#3
(byte) gen_char3::r#4
(byte) gen_char3::r#5
(byte) gen_char3::r#6
(word) gen_char3::spec
(word) gen_char3::spec#0
(word) gen_char3::spec#1
(word) gen_char3::spec#2
(word) gen_char3::spec#3
(word) gen_char3::spec#4
(word) gen_char3::spec#5
(word) gen_char3::spec#6
(word) gen_char3::spec#7
(void()) main()
(byte*~) main::$0
(word~) main::$1
(byte~) main::$10
(number~) main::$2
(word~) main::$3
(number~) main::$4
(number~) main::$5
(byte~) main::$6
(bool~) main::$7
(byte*~) main::$9
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@7
(label) main::@return
(byte) main::c
(byte) main::c#0
(byte) main::c#1
(byte) main::c#2
(byte) main::c#3
(byte) main::c#4
(byte*) main::charset
(byte*) main::charset#0
(byte*) main::charset#1
(byte*) main::charset#2
(byte*) main::charset#3
(byte*) main::charset#4

Adding number conversion cast (unumber) 8 in (byte*~) main::$0 ← (byte*) CHARSET + (number) 8
Adding number conversion cast (unumber) 0 in (byte) main::c#0 ← (number) 0
Adding number conversion cast (unumber) 4 in (bool~) main::$7 ← (byte) main::c#2 != (number) 4
Adding number conversion cast (unumber) 8 in (byte*~) main::$9 ← (byte*) main::charset#3 + (number) 8
Adding number conversion cast (unumber) $40 in (number~) main::$2 ← (word~) main::$1 / (number) $40
Adding number conversion cast (unumber) main::$2 in (number~) main::$2 ← (word~) main::$1 / (unumber)(number) $40
Adding number conversion cast (unumber) $400 in (number~) main::$4 ← (word~) main::$3 / (number) $400
Adding number conversion cast (unumber) main::$4 in (number~) main::$4 ← (word~) main::$3 / (unumber)(number) $400
Adding number conversion cast (unumber) main::$5 in (number~) main::$5 ← (unumber~) main::$2 | (unumber~) main::$4
Adding number conversion cast (unumber) 0 in (byte) gen_char3::b#0 ← (number) 0
Adding number conversion cast (unumber) $80 in (number~) gen_char3::$1 ← (byte~) gen_char3::$0 & (number) $80
Adding number conversion cast (unumber) gen_char3::$1 in (number~) gen_char3::$1 ← (byte~) gen_char3::$0 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) gen_char3::$2 ← (unumber~) gen_char3::$1 != (number) 0
Adding number conversion cast (unumber) 2 in (number~) gen_char3::$5 ← (byte) gen_char3::b#3 * (number) 2
Adding number conversion cast (unumber) gen_char3::$5 in (number~) gen_char3::$5 ← (byte) gen_char3::b#3 * (unumber)(number) 2
Adding number conversion cast (unumber) 2 in (number~) gen_char3::$6 ← (word) gen_char3::spec#3 * (number) 2
Adding number conversion cast (unumber) gen_char3::$6 in (number~) gen_char3::$6 ← (word) gen_char3::spec#3 * (unumber)(number) 2
Adding number conversion cast (unumber) 1 in (number~) gen_char3::$4 ← (byte) gen_char3::b#4 | (number) 1
Adding number conversion cast (unumber) gen_char3::$4 in (number~) gen_char3::$4 ← (byte) gen_char3::b#4 | (unumber)(number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (word[]) charset_spec_row ← (word[]){ (word)(number) $f7da, (word)(number) $f7de, (word)(number) $f24e, (word)(number) $d6de }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Inlining cast (byte*) VIC_MEMORY ← (byte*)(number) $d018
Inlining cast (byte*) SCREEN ← (byte*)(number) $400
Inlining cast (byte*) CHARSET ← (byte*)(number) $3000
Inlining cast (byte) main::c#0 ← (unumber)(number) 0
Inlining cast (word~) main::$1 ← (word)(byte*) SCREEN
Inlining cast (word~) main::$3 ← (word)(byte*) CHARSET
Inlining cast (byte~) main::$6 ← (byte)(unumber~) main::$5
Inlining cast (byte) gen_char3::b#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 12288
Simplifying constant integer cast $f7da
Simplifying constant integer cast $f7de
Simplifying constant integer cast $f24e
Simplifying constant integer cast $d6de
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $40
Simplifying constant integer cast $400
Simplifying constant integer cast 0
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $400
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in (unumber~) main::$2 ← (word~) main::$1 / (byte) $40
Inferred type updated to word in (unumber~) main::$4 ← (word~) main::$3 / (word) $400
Inferred type updated to word in (unumber~) main::$5 ← (word~) main::$2 | (word~) main::$4
Inferred type updated to byte in (unumber~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80
Inferred type updated to byte in (unumber~) gen_char3::$5 ← (byte) gen_char3::b#3 * (byte) 2
Inferred type updated to word in (unumber~) gen_char3::$6 ← (word) gen_char3::spec#3 * (byte) 2
Inferred type updated to byte in (unumber~) gen_char3::$4 ← (byte) gen_char3::b#4 | (byte) 1
Inversing boolean not [36] (bool~) gen_char3::$3 ← (byte~) gen_char3::$1 == (byte) 0 from [35] (bool~) gen_char3::$2 ← (byte~) gen_char3::$1 != (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte*) main::charset#0 = (byte*~) main::$0 
Alias (byte) main::c#2 = (byte) main::c#3 (byte) main::c#4 
Alias (byte*) main::charset#2 = (byte*) main::charset#4 (byte*) main::charset#3 
Alias (byte*) main::charset#1 = (byte*~) main::$9 
Alias (byte) gen_char3::b#1 = (byte~) gen_char3::$5 (byte) gen_char3::b#5 
Alias (word) gen_char3::spec#1 = (word~) gen_char3::$6 (word) gen_char3::spec#7 
Alias (byte) gen_char3::b#4 = (byte) gen_char3::b#6 
Alias (word) gen_char3::spec#2 = (word) gen_char3::spec#5 
Alias (byte) gen_char3::c#3 = (byte) gen_char3::c#4 
Alias (byte*) gen_char3::dst#3 = (byte*) gen_char3::dst#4 
Alias (byte) gen_char3::r#4 = (byte) gen_char3::r#5 
Alias (byte) gen_char3::b#2 = (byte~) gen_char3::$4 
Alias (byte*) gen_char3::dst#1 = (byte*) gen_char3::dst#2 
Alias (byte) gen_char3::r#2 = (byte) gen_char3::r#3 
Successful SSA optimization Pass2AliasElimination
Alias (word) gen_char3::spec#2 = (word) gen_char3::spec#3 
Alias (byte) gen_char3::c#2 = (byte) gen_char3::c#3 
Alias (byte*) gen_char3::dst#1 = (byte*) gen_char3::dst#3 
Alias (byte) gen_char3::r#2 = (byte) gen_char3::r#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) gen_char3::spec#6 (word) gen_char3::spec#0
Identical Phi Values (byte*) gen_char3::dst#6 (byte*) gen_char3::dst#0
Identical Phi Values (byte*) gen_char3::dst#1 (byte*) gen_char3::dst#5
Identical Phi Values (byte) gen_char3::r#2 (byte) gen_char3::r#6
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte*) gen_char3::dst#5 (byte*) gen_char3::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) main::$7 [9] if((byte) main::c#2!=(byte) 4) goto main::@2
Simple Condition (bool~) gen_char3::$3 [37] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3
Simple Condition (bool~) gen_char3::$7 [45] if((byte) gen_char3::c#1!=rangelast(0,2)) goto gen_char3::@2
Simple Condition (bool~) gen_char3::$8 [53] if((byte) gen_char3::r#1!=rangelast(0,4)) goto gen_char3::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Identified constant from value list (word[]) { (word) $f7da, (word) $f7de, (word) $f24e, (word) $d6de }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte*) VIC_MEMORY = (byte*) 53272
Constant (const byte*) SCREEN = (byte*) 1024
Constant (const byte*) CHARSET = (byte*) 12288
Constant (const word[]) charset_spec_row = { $f7da, $f7de, $f24e, $d6de }
Constant (const byte) main::c#0 = 0
Constant (const byte) gen_char3::r#0 = 0
Constant (const byte) gen_char3::b#0 = 0
Constant (const byte) gen_char3::c#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (word)SCREEN in [19] (word~) main::$1 ← (word)(const byte*) SCREEN
Constant value identified (word)CHARSET in [21] (word~) main::$3 ← (word)(const byte*) CHARSET
Successful SSA optimization Pass2ConstantValues
Resolved ranged next value [43] gen_char3::c#1 ← ++ gen_char3::c#2 to ++
Resolved ranged comparison value [45] if(gen_char3::c#1!=rangelast(0,2)) goto gen_char3::@2 to (number) 3
Resolved ranged next value [51] gen_char3::r#1 ← ++ gen_char3::r#6 to ++
Resolved ranged comparison value [53] if(gen_char3::r#1!=rangelast(0,4)) goto gen_char3::@1 to (number) 5
Adding number conversion cast (unumber) 3 in if((byte) gen_char3::c#1!=(number) 3) goto gen_char3::@2
Adding number conversion cast (unumber) 5 in if((byte) gen_char3::r#1!=(number) 5) goto gen_char3::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 3
Simplifying constant integer cast 5
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 5
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [0] (byte*) main::charset#0 ← (const byte*) CHARSET + (byte) 8
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::charset#0 = CHARSET+8
Constant (const word) main::$1 = (word)SCREEN
Constant (const word) main::$3 = (word)CHARSET
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [8] (word~) main::$2 ← (const word) main::$1 / (byte) $40
Constant right-side identified [9] (word~) main::$4 ← (const word) main::$3 / (word) $400
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::$2 = main::$1/$40
Constant (const word) main::$4 = main::$3/$400
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [8] (word~) main::$5 ← (const word) main::$2 | (const word) main::$4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word) main::$5 = main::$2|main::$4
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)main::$5 in [9] (byte~) main::$6 ← (byte)(const word) main::$5
Successful SSA optimization Pass2ConstantValues
Constant (const byte) main::$6 = (byte)main::$5
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [2] (byte~) main::$10 ← (byte) main::c#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [16] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 * (byte) 2
Rewriting multiplication to use shift [17] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 * (byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) main::c#0
Inlining constant with var siblings (const byte*) main::charset#0
Inlining constant with var siblings (const byte) gen_char3::r#0
Inlining constant with var siblings (const byte) gen_char3::b#0
Inlining constant with var siblings (const byte) gen_char3::c#0
Constant inlined gen_char3::r#0 = (byte) 0
Constant inlined gen_char3::b#0 = (byte) 0
Constant inlined main::c#0 = (byte) 0
Constant inlined gen_char3::c#0 = (byte) 0
Constant inlined main::$1 = (word)(const byte*) SCREEN
Constant inlined main::$2 = (word)(const byte*) SCREEN/(byte) $40
Constant inlined main::charset#0 = (const byte*) CHARSET+(byte) 8
Constant inlined main::$5 = (word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400
Constant inlined main::$6 = (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400
Constant inlined main::$3 = (word)(const byte*) CHARSET
Constant inlined main::$4 = (word)(const byte*) CHARSET/(word) $400
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting gen_char3::@7(between gen_char3::@5 and gen_char3::@1)
Added new block during phi lifting gen_char3::@8(between gen_char3::@3 and gen_char3::@2)
Added new block during phi lifting gen_char3::@9(between gen_char3::@2 and gen_char3::@3)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to gen_char3:13 

Created 8 initial phi equivalence classes
Coalesced [16] main::c#5 ← main::c#1
Coalesced [17] main::charset#5 ← main::charset#1
Coalesced [18] gen_char3::spec#8 ← gen_char3::spec#0
Coalesced [20] gen_char3::spec#10 ← gen_char3::spec#4
Coalesced [26] gen_char3::b#9 ← gen_char3::b#2
Coalesced [36] gen_char3::spec#9 ← gen_char3::spec#1
Coalesced [37] gen_char3::r#7 ← gen_char3::r#1
Coalesced (already) [38] gen_char3::spec#11 ← gen_char3::spec#1
Coalesced [39] gen_char3::b#7 ← gen_char3::b#1
Coalesced [40] gen_char3::c#5 ← gen_char3::c#1
Coalesced [41] gen_char3::b#8 ← gen_char3::b#4
Coalesced down to 6 phi equivalence classes
Culled Empty Block (label) @3
Culled Empty Block (label) gen_char3::@7
Culled Empty Block (label) gen_char3::@8
Culled Empty Block (label) gen_char3::@9
Renumbering block @2 to @1
Renumbering block main::@7 to main::@4
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of gen_char3

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@4
  [5] (byte*) main::charset#2 ← phi( main/(const byte*) CHARSET+(byte) 8 main::@4/(byte*) main::charset#1 )
  [5] (byte) main::c#2 ← phi( main/(byte) 0 main::@4/(byte) main::c#1 )
  [6] if((byte) main::c#2!=(byte) 4) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [7] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400
  to:main::@return
main::@return: scope:[main]  from main::@3
  [8] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [9] (byte~) main::$10 ← (byte) main::c#2 << (byte) 1
  [10] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
  [11] (word) gen_char3::spec#0 ← *((const word[]) charset_spec_row + (byte~) main::$10)
  [12] call gen_char3 
  to:main::@4
main::@4: scope:[main]  from main::@2
  [13] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8
  [14] (byte) main::c#1 ← ++ (byte) main::c#2
  to:main::@1

(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
gen_char3: scope:[gen_char3]  from main::@2
  [15] phi()
  to:gen_char3::@1
gen_char3::@1: scope:[gen_char3]  from gen_char3 gen_char3::@5
  [16] (byte) gen_char3::r#6 ← phi( gen_char3/(byte) 0 gen_char3::@5/(byte) gen_char3::r#1 )
  [16] (word) gen_char3::spec#4 ← phi( gen_char3/(word) gen_char3::spec#0 gen_char3::@5/(word) gen_char3::spec#1 )
  to:gen_char3::@2
gen_char3::@2: scope:[gen_char3]  from gen_char3::@1 gen_char3::@3
  [17] (byte) gen_char3::c#2 ← phi( gen_char3::@1/(byte) 0 gen_char3::@3/(byte) gen_char3::c#1 )
  [17] (byte) gen_char3::b#4 ← phi( gen_char3::@1/(byte) 0 gen_char3::@3/(byte) gen_char3::b#1 )
  [17] (word) gen_char3::spec#2 ← phi( gen_char3::@1/(word) gen_char3::spec#4 gen_char3::@3/(word) gen_char3::spec#1 )
  [18] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2
  [19] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80
  [20] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3
  to:gen_char3::@4
gen_char3::@4: scope:[gen_char3]  from gen_char3::@2
  [21] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1
  to:gen_char3::@3
gen_char3::@3: scope:[gen_char3]  from gen_char3::@2 gen_char3::@4
  [22] (byte) gen_char3::b#3 ← phi( gen_char3::@2/(byte) gen_char3::b#4 gen_char3::@4/(byte) gen_char3::b#2 )
  [23] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1
  [24] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1
  [25] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2
  [26] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2
  to:gen_char3::@5
gen_char3::@5: scope:[gen_char3]  from gen_char3::@3
  [27] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1
  [28] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6
  [29] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1
  to:gen_char3::@return
gen_char3::@return: scope:[gen_char3]  from gen_char3::@5
  [30] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
(byte~) gen_char3::$0 2002.0
(byte~) gen_char3::$1 2002.0
(byte) gen_char3::b
(byte) gen_char3::b#1 525.75
(byte) gen_char3::b#2 2002.0
(byte) gen_char3::b#3 3003.0
(byte) gen_char3::b#4 750.75
(byte) gen_char3::c
(byte) gen_char3::c#1 1501.5
(byte) gen_char3::c#2 250.25
(byte*) gen_char3::dst
(byte*) gen_char3::dst#0 6.588235294117648
(byte) gen_char3::r
(byte) gen_char3::r#1 151.5
(byte) gen_char3::r#6 25.25
(word) gen_char3::spec
(word) gen_char3::spec#0 6.5
(word) gen_char3::spec#1 350.5
(word) gen_char3::spec#2 443.42857142857144
(word) gen_char3::spec#4 204.0
(void()) main()
(byte~) main::$10 11.0
(byte) main::c
(byte) main::c#1 22.0
(byte) main::c#2 6.285714285714286
(byte*) main::charset
(byte*) main::charset#1 11.0
(byte*) main::charset#2 5.5

Initial phi equivalence classes
[ main::c#2 main::c#1 ]
[ main::charset#2 main::charset#1 ]
[ gen_char3::r#6 gen_char3::r#1 ]
[ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
[ gen_char3::c#2 gen_char3::c#1 ]
[ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Added variable main::$10 to zero page equivalence class [ main::$10 ]
Added variable gen_char3::dst#0 to zero page equivalence class [ gen_char3::dst#0 ]
Added variable gen_char3::$0 to zero page equivalence class [ gen_char3::$0 ]
Added variable gen_char3::$1 to zero page equivalence class [ gen_char3::$1 ]
Complete equivalence classes
[ main::c#2 main::c#1 ]
[ main::charset#2 main::charset#1 ]
[ gen_char3::r#6 gen_char3::r#1 ]
[ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
[ gen_char3::c#2 gen_char3::c#1 ]
[ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
[ main::$10 ]
[ gen_char3::dst#0 ]
[ gen_char3::$0 ]
[ gen_char3::$1 ]
Allocated zp[1]:2 [ main::c#2 main::c#1 ]
Allocated zp[2]:3 [ main::charset#2 main::charset#1 ]
Allocated zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Allocated zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
Allocated zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ]
Allocated zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Allocated zp[1]:10 [ main::$10 ]
Allocated zp[2]:11 [ gen_char3::dst#0 ]
Allocated zp[1]:13 [ gen_char3::$0 ]
Allocated zp[1]:14 [ gen_char3::$1 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __10 = $a
    .label charset = 3
    .label c = 2
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::charset#2 = (const byte*) CHARSET+(byte) 8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [5] phi (byte) main::c#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    jmp __b1
    // main::@1
  __b1:
    // [6] if((byte) main::c#2!=(byte) 4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [7] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VIC_MEMORY
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
    // main::@2
  __b2:
    // [9] (byte~) main::$10 ← (byte) main::c#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z c
    asl
    sta.z __10
    // [10] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2 -- pbuz1=pbuz2 
    lda.z charset
    sta.z gen_char3.dst
    lda.z charset+1
    sta.z gen_char3.dst+1
    // [11] (word) gen_char3::spec#0 ← *((const word[]) charset_spec_row + (byte~) main::$10) -- vwuz1=pwuc1_derefidx_vbuz2 
    ldy.z __10
    lda charset_spec_row,y
    sta.z gen_char3.spec
    lda charset_spec_row+1,y
    sta.z gen_char3.spec+1
    // [12] call gen_char3 
    // [15] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
  gen_char3_from___b2:
    jsr gen_char3
    jmp __b4
    // main::@4
  __b4:
    // [13] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // [14] (byte) main::c#1 ← ++ (byte) main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [5] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [5] phi (byte*) main::charset#2 = (byte*) main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [5] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zeropage($b) dst, word zeropage(6) spec)
gen_char3: {
    .label __0 = $d
    .label __1 = $e
    .label dst = $b
    .label spec = 6
    .label b = 9
    .label c = 8
    .label r = 5
    // [16] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
  __b1_from_gen_char3:
    // [16] phi (byte) gen_char3::r#6 = (byte) 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [16] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // [16] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
  __b1_from___b5:
    // [16] phi (byte) gen_char3::r#6 = (byte) gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [16] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // gen_char3::@1
  __b1:
    // [17] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
  __b2_from___b1:
    // [17] phi (byte) gen_char3::c#2 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // [17] phi (byte) gen_char3::b#4 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuz1=vbuc1 
    lda #0
    sta.z b
    // [17] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // [17] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
  __b2_from___b3:
    // [17] phi (byte) gen_char3::c#2 = (byte) gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [17] phi (byte) gen_char3::b#4 = (byte) gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [17] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // gen_char3::@2
  __b2:
    // [18] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 -- vbuz1=_hi_vwuz2 
    lda.z spec+1
    sta.z __0
    // [19] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z __0
    sta.z __1
    // [20] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3 -- vbuz1_eq_0_then_la1 
    lda.z __1
    cmp #0
    beq __b3_from___b2
    jmp __b4
    // gen_char3::@4
  __b4:
    // [21] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 -- vbuz1=vbuz1_bor_vbuc1 
    lda #1
    ora.z b
    sta.z b
    // [22] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [22] phi (byte) gen_char3::b#3 = (byte) gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    jmp __b3
    // gen_char3::@3
  __b3:
    // [23] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z b
    // [24] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // [25] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [26] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #3
    cmp.z c
    bne __b2_from___b3
    jmp __b5
    // gen_char3::@5
  __b5:
    // [27] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuz3 
    lda.z b
    ldy.z r
    sta (dst),y
    // [28] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [29] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1_from___b5
    jmp __breturn
    // gen_char3::@return
  __breturn:
    // [30] return 
    rts
}
  // File Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] (byte~) main::$10 ← (byte) main::c#2 << (byte) 1 [ main::c#2 main::charset#2 main::$10 ] ( main:2 [ main::c#2 main::charset#2 main::$10 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::c#2 main::c#1 ]
Statement [10] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2 [ main::c#2 main::charset#2 main::$10 gen_char3::dst#0 ] ( main:2 [ main::c#2 main::charset#2 main::$10 gen_char3::dst#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ main::$10 ]
Statement [11] (word) gen_char3::spec#0 ← *((const word[]) charset_spec_row + (byte~) main::$10) [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] ( main:2 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] ) always clobbers reg byte a 
Statement [13] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 [ main::c#2 main::charset#1 ] ( main:2 [ main::c#2 main::charset#1 ] ) always clobbers reg byte a 
Statement [18] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::b#4 gen_char3::c#2 gen_char3::$0 ] ( main:2::gen_char3:12 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::b#4 gen_char3::c#2 gen_char3::$0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ]
Statement [21] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ( main:2::gen_char3:12 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ) always clobbers reg byte a 
Statement [27] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#1 ] ( main:2::gen_char3:12 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#1 ] ) always clobbers reg byte a 
Statement [7] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [9] (byte~) main::$10 ← (byte) main::c#2 << (byte) 1 [ main::c#2 main::charset#2 main::$10 ] ( main:2 [ main::c#2 main::charset#2 main::$10 ] ) always clobbers reg byte a 
Statement [10] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2 [ main::c#2 main::charset#2 main::$10 gen_char3::dst#0 ] ( main:2 [ main::c#2 main::charset#2 main::$10 gen_char3::dst#0 ] ) always clobbers reg byte a 
Statement [11] (word) gen_char3::spec#0 ← *((const word[]) charset_spec_row + (byte~) main::$10) [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] ( main:2 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] ) always clobbers reg byte a 
Statement [13] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 [ main::c#2 main::charset#1 ] ( main:2 [ main::c#2 main::charset#1 ] ) always clobbers reg byte a 
Statement [18] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::b#4 gen_char3::c#2 gen_char3::$0 ] ( main:2::gen_char3:12 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::b#4 gen_char3::c#2 gen_char3::$0 ] ) always clobbers reg byte a 
Statement [21] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ( main:2::gen_char3:12 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ) always clobbers reg byte a 
Statement [27] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#1 ] ( main:2::gen_char3:12 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#1 ] ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::c#2 main::c#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[2]:3 [ main::charset#2 main::charset#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] : zp[2]:6 , 
Potential registers zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ main::$10 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ gen_char3::dst#0 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ gen_char3::$0 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ gen_char3::$1 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [gen_char3] 6,281.5: zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] 2,002: zp[1]:13 [ gen_char3::$0 ] 2,002: zp[1]:14 [ gen_char3::$1 ] 1,751.75: zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ] 1,004.43: zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] 176.75: zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] 6.59: zp[2]:11 [ gen_char3::dst#0 ] 
Uplift Scope [main] 28.29: zp[1]:2 [ main::c#2 main::c#1 ] 16.5: zp[2]:3 [ main::charset#2 main::charset#1 ] 11: zp[1]:10 [ main::$10 ] 
Uplift Scope [] 

Uplifting [gen_char3] best 61712 combination reg byte y [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] reg byte a [ gen_char3::$0 ] reg byte a [ gen_char3::$1 ] reg byte x [ gen_char3::c#2 gen_char3::c#1 ] zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] zp[2]:11 [ gen_char3::dst#0 ] 
Limited combination testing to 100 combinations of 432 possible.
Uplifting [main] best 61672 combination zp[1]:2 [ main::c#2 main::c#1 ] zp[2]:3 [ main::charset#2 main::charset#1 ] reg byte x [ main::$10 ] 
Uplifting [] best 61672 combination 
Attempting to uplift remaining variables inzp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Uplifting [gen_char3] best 61672 combination zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] 
Attempting to uplift remaining variables inzp[1]:2 [ main::c#2 main::c#1 ]
Uplifting [main] best 61672 combination zp[1]:2 [ main::c#2 main::c#1 ] 
Coalescing zero page register [ zp[2]:3 [ main::charset#2 main::charset#1 ] ] with [ zp[2]:11 [ gen_char3::dst#0 ] ] - score: 1

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label charset = 3
    .label c = 2
    // [5] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [5] phi (byte*) main::charset#2 = (const byte*) CHARSET+(byte) 8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [5] phi (byte) main::c#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    jmp __b1
    // main::@1
  __b1:
    // [6] if((byte) main::c#2!=(byte) 4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [7] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VIC_MEMORY
    jmp __breturn
    // main::@return
  __breturn:
    // [8] return 
    rts
    // main::@2
  __b2:
    // [9] (byte~) main::$10 ← (byte) main::c#2 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z c
    asl
    tax
    // [10] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
    // [11] (word) gen_char3::spec#0 ← *((const word[]) charset_spec_row + (byte~) main::$10) -- vwuz1=pwuc1_derefidx_vbuxx 
    lda charset_spec_row,x
    sta.z gen_char3.spec
    lda charset_spec_row+1,x
    sta.z gen_char3.spec+1
    // [12] call gen_char3 
    // [15] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
  gen_char3_from___b2:
    jsr gen_char3
    jmp __b4
    // main::@4
  __b4:
    // [13] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // [14] (byte) main::c#1 ← ++ (byte) main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [5] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [5] phi (byte*) main::charset#2 = (byte*) main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [5] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zeropage(3) dst, word zeropage(6) spec)
gen_char3: {
    .label dst = 3
    .label spec = 6
    .label r = 5
    // [16] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
  __b1_from_gen_char3:
    // [16] phi (byte) gen_char3::r#6 = (byte) 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [16] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // [16] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
  __b1_from___b5:
    // [16] phi (byte) gen_char3::r#6 = (byte) gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [16] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // gen_char3::@1
  __b1:
    // [17] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
  __b2_from___b1:
    // [17] phi (byte) gen_char3::c#2 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [17] phi (byte) gen_char3::b#4 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // [17] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // [17] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
  __b2_from___b3:
    // [17] phi (byte) gen_char3::c#2 = (byte) gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [17] phi (byte) gen_char3::b#4 = (byte) gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [17] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // gen_char3::@2
  __b2:
    // [18] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 -- vbuaa=_hi_vwuz1 
    lda.z spec+1
    // [19] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [20] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from___b2
    jmp __b4
    // gen_char3::@4
  __b4:
    // [21] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 -- vbuyy=vbuyy_bor_vbuc1 
    tya
    ora #1
    tay
    // [22] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [22] phi (byte) gen_char3::b#3 = (byte) gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    jmp __b3
    // gen_char3::@3
  __b3:
    // [23] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1 -- vbuyy=vbuyy_rol_1 
    tya
    asl
    tay
    // [24] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // [25] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #3
    bne __b2_from___b3
    jmp __b5
    // gen_char3::@5
  __b5:
    // [27] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuyy 
    tya
    ldy.z r
    sta (dst),y
    // [28] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [29] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1_from___b5
    jmp __breturn
    // gen_char3::@return
  __breturn:
    // [30] return 
    rts
}
  // File Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __bbegin with __b1
Replacing label __b3_from___b2 with __b3
Replacing label __b2_from___b3 with __b2
Replacing label __b1_from___b5 with __b1
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction gen_char3_from___b2:
Removing instruction __b4:
Removing instruction __b1_from___b4:
Removing instruction __b1_from_gen_char3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp __b1
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b1:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte*) CHARSET = (byte*) 12288
(const byte*) SCREEN = (byte*) 1024
(const byte*) VIC_MEMORY = (byte*) 53272
(const word[]) charset_spec_row = { (word) $f7da, (word) $f7de, (word) $f24e, (word) $d6de }
(void()) gen_char3((byte*) gen_char3::dst , (word) gen_char3::spec)
(byte~) gen_char3::$0 reg byte a 2002.0
(byte~) gen_char3::$1 reg byte a 2002.0
(label) gen_char3::@1
(label) gen_char3::@2
(label) gen_char3::@3
(label) gen_char3::@4
(label) gen_char3::@5
(label) gen_char3::@return
(byte) gen_char3::b
(byte) gen_char3::b#1 reg byte y 525.75
(byte) gen_char3::b#2 reg byte y 2002.0
(byte) gen_char3::b#3 reg byte y 3003.0
(byte) gen_char3::b#4 reg byte y 750.75
(byte) gen_char3::c
(byte) gen_char3::c#1 reg byte x 1501.5
(byte) gen_char3::c#2 reg byte x 250.25
(byte*) gen_char3::dst
(byte*) gen_char3::dst#0 dst zp[2]:3 6.588235294117648
(byte) gen_char3::r
(byte) gen_char3::r#1 r zp[1]:5 151.5
(byte) gen_char3::r#6 r zp[1]:5 25.25
(word) gen_char3::spec
(word) gen_char3::spec#0 spec zp[2]:6 6.5
(word) gen_char3::spec#1 spec zp[2]:6 350.5
(word) gen_char3::spec#2 spec zp[2]:6 443.42857142857144
(word) gen_char3::spec#4 spec zp[2]:6 204.0
(void()) main()
(byte~) main::$10 reg byte x 11.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(byte) main::c
(byte) main::c#1 c zp[1]:2 22.0
(byte) main::c#2 c zp[1]:2 6.285714285714286
(byte*) main::charset
(byte*) main::charset#1 charset zp[2]:3 11.0
(byte*) main::charset#2 charset zp[2]:3 5.5

zp[1]:2 [ main::c#2 main::c#1 ]
zp[2]:3 [ main::charset#2 main::charset#1 gen_char3::dst#0 ]
zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
reg byte x [ gen_char3::c#2 gen_char3::c#1 ]
reg byte y [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
reg byte x [ main::$10 ]
reg byte a [ gen_char3::$0 ]
reg byte a [ gen_char3::$1 ]


FINAL ASSEMBLER
Score: 45574

  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label charset = 3
    .label c = 2
    // [5] phi from main to main::@1 [phi:main->main::@1]
    // [5] phi (byte*) main::charset#2 = (const byte*) CHARSET+(byte) 8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [5] phi (byte) main::c#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // main::@1
  __b1:
    // for(byte c=0;c!=4;c++)
    // [6] if((byte) main::c#2!=(byte) 4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    // main::@3
    // *VIC_MEMORY = (byte)(((word)SCREEN/$40)|((word)CHARSET/$400))
    // [7] *((const byte*) VIC_MEMORY) ← (byte)(word)(const byte*) SCREEN/(byte) $40|(word)(const byte*) CHARSET/(word) $400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VIC_MEMORY
    // main::@return
    // }
    // [8] return 
    rts
    // main::@2
  __b2:
    // gen_char3(charset, charset_spec_row[c])
    // [9] (byte~) main::$10 ← (byte) main::c#2 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z c
    asl
    tax
    // [10] (byte*) gen_char3::dst#0 ← (byte*) main::charset#2
    // [11] (word) gen_char3::spec#0 ← *((const word[]) charset_spec_row + (byte~) main::$10) -- vwuz1=pwuc1_derefidx_vbuxx 
    lda charset_spec_row,x
    sta.z gen_char3.spec
    lda charset_spec_row+1,x
    sta.z gen_char3.spec+1
    // [12] call gen_char3 
    // [15] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
    jsr gen_char3
    // main::@4
    // charset = charset+8
    // [13] (byte*) main::charset#1 ← (byte*) main::charset#2 + (byte) 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // for(byte c=0;c!=4;c++)
    // [14] (byte) main::c#1 ← ++ (byte) main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [5] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [5] phi (byte*) main::charset#2 = (byte*) main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [5] phi (byte) main::c#2 = (byte) main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zeropage(3) dst, word zeropage(6) spec)
gen_char3: {
    .label dst = 3
    .label spec = 6
    .label r = 5
    // [16] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
    // [16] phi (byte) gen_char3::r#6 = (byte) 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [16] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    // [16] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
    // [16] phi (byte) gen_char3::r#6 = (byte) gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [16] phi (word) gen_char3::spec#4 = (word) gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    // gen_char3::@1
  __b1:
    // [17] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
    // [17] phi (byte) gen_char3::c#2 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [17] phi (byte) gen_char3::b#4 = (byte) 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // [17] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    // [17] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
    // [17] phi (byte) gen_char3::c#2 = (byte) gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [17] phi (byte) gen_char3::b#4 = (byte) gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [17] phi (word) gen_char3::spec#2 = (word) gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    // gen_char3::@2
  __b2:
    // >spec
    // [18] (byte~) gen_char3::$0 ← > (word) gen_char3::spec#2 -- vbuaa=_hi_vwuz1 
    lda.z spec+1
    // >spec&$80
    // [19] (byte~) gen_char3::$1 ← (byte~) gen_char3::$0 & (byte) $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if((>spec&$80)!=0)
    // [20] if((byte~) gen_char3::$1==(byte) 0) goto gen_char3::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3
    // gen_char3::@4
    // b = b|1
    // [21] (byte) gen_char3::b#2 ← (byte) gen_char3::b#4 | (byte) 1 -- vbuyy=vbuyy_bor_vbuc1 
    tya
    ora #1
    tay
    // [22] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
    // [22] phi (byte) gen_char3::b#3 = (byte) gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    // gen_char3::@3
  __b3:
    // b = b*2
    // [23] (byte) gen_char3::b#1 ← (byte) gen_char3::b#3 << (byte) 1 -- vbuyy=vbuyy_rol_1 
    tya
    asl
    tay
    // spec = spec*2
    // [24] (word) gen_char3::spec#1 ← (word) gen_char3::spec#2 << (byte) 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // for(byte c: 0..2 )
    // [25] (byte) gen_char3::c#1 ← ++ (byte) gen_char3::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [26] if((byte) gen_char3::c#1!=(byte) 3) goto gen_char3::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #3
    bne __b2
    // gen_char3::@5
    // dst[r] = b
    // [27] *((byte*) gen_char3::dst#0 + (byte) gen_char3::r#6) ← (byte) gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuyy 
    tya
    ldy.z r
    sta (dst),y
    // for(byte r : 0..4 )
    // [28] (byte) gen_char3::r#1 ← ++ (byte) gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [29] if((byte) gen_char3::r#1!=(byte) 5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1
    // gen_char3::@return
    // }
    // [30] return 
    rts
}
  // File Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

