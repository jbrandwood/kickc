// Test all types of pointers

main();

void main() {
  lvalue();
  rvalue();
  rvaluevar();
  lvaluevar();
}

void lvalue() {

  // A constant pointer
  byte[1024] SCREEN = $0400;

  // LValue constant pointer dereference
  *SCREEN = 1;

  // LValue constant array constant indexing
  SCREEN[1] = 2;

  // LValue constant array variable indexing
  byte i=2;
  while(i<10) {
    SCREEN[i++] = 3;
  }
}

void rvalue() {

  // A constant pointer
  byte[1024] SCREEN = $0400;

  // RValue constant pointer
  byte b = *SCREEN;

  // RValue constant array pointer constant index
  b = SCREEN[1];

  // RValue constant array variable index
  byte i=2;
  while(i<10) {
    b = SCREEN[i++];
  }
}

void lvaluevar() {
  byte *screen = $0400;

  // LValue Variable pointer dereference
  byte b=4;
  byte i=2;
  while(i<10) {
    *screen = b;
    screen++;
    i++;
  }

}

void rvaluevar() {
  byte *screen = $0400;

  // RValue Variable pointer dereference
  byte b;
  byte i=2;
  while(i<10) {
    b = *screen;
    screen++;
    i++;
  }

}


Adding pre/post-modifier (byte) lvalue::i ← ++ (byte) lvalue::i
Adding pre/post-modifier (byte) rvalue::i ← ++ (byte) rvalue::i
Adding pre/post-modifier (byte*) lvaluevar::screen ← ++ (byte*) lvaluevar::screen
Adding pre/post-modifier (byte) lvaluevar::i ← ++ (byte) lvaluevar::i
Adding pre/post-modifier (byte*) rvaluevar::screen ← ++ (byte*) rvaluevar::screen
Adding pre/post-modifier (byte) rvaluevar::i ← ++ (byte) rvaluevar::i
PROGRAM
  (void~) $0 ← call main 
proc (void()) main()
  (void~) main::$0 ← call lvalue 
  (void~) main::$1 ← call rvalue 
  (void~) main::$2 ← call rvaluevar 
  (void~) main::$3 ← call lvaluevar 
main::@return:
  return 
endproc // main()
proc (void()) lvalue()
  (byte[1024]) lvalue::SCREEN ← (word) 1024
  *((byte[1024]) lvalue::SCREEN) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN + (byte) 1) ← (byte) 2
  (byte) lvalue::i ← (byte) 2
lvalue::@1:
  (boolean~) lvalue::$0 ← (byte) lvalue::i < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  goto lvalue::@3
lvalue::@2:
  *((byte[1024]) lvalue::SCREEN + (byte) lvalue::i) ← (byte) 3
  (byte) lvalue::i ← ++ (byte) lvalue::i
  goto lvalue::@1
lvalue::@3:
lvalue::@return:
  return 
endproc // lvalue()
proc (void()) rvalue()
  (byte[1024]) rvalue::SCREEN ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN
  (byte) rvalue::b ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN *idx (byte) 1
  (byte) rvalue::b ← (byte~) rvalue::$1
  (byte) rvalue::i ← (byte) 2
rvalue::@1:
  (boolean~) rvalue::$2 ← (byte) rvalue::i < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  goto rvalue::@3
rvalue::@2:
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN *idx (byte) rvalue::i
  (byte) rvalue::b ← (byte~) rvalue::$3
  (byte) rvalue::i ← ++ (byte) rvalue::i
  goto rvalue::@1
rvalue::@3:
rvalue::@return:
  return 
endproc // rvalue()
proc (void()) lvaluevar()
  (byte*) lvaluevar::screen ← (word) 1024
  (byte) lvaluevar::b ← (byte) 4
  (byte) lvaluevar::i ← (byte) 2
lvaluevar::@1:
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  goto lvaluevar::@3
lvaluevar::@2:
  *((byte*) lvaluevar::screen) ← (byte) lvaluevar::b
  (byte*) lvaluevar::screen ← ++ (byte*) lvaluevar::screen
  (byte) lvaluevar::i ← ++ (byte) lvaluevar::i
  goto lvaluevar::@1
lvaluevar::@3:
lvaluevar::@return:
  return 
endproc // lvaluevar()
proc (void()) rvaluevar()
  (byte*) rvaluevar::screen ← (word) 1024
  (byte) rvaluevar::i ← (byte) 2
rvaluevar::@1:
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  goto rvaluevar::@3
rvaluevar::@2:
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen
  (byte) rvaluevar::b ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen ← ++ (byte*) rvaluevar::screen
  (byte) rvaluevar::i ← ++ (byte) rvaluevar::i
  goto rvaluevar::@1
rvaluevar::@3:
rvaluevar::@return:
  return 
endproc // rvaluevar()

SYMBOLS
(void~) $0
(void()) lvalue()
(boolean~) lvalue::$0
(label) lvalue::@1
(label) lvalue::@2
(label) lvalue::@3
(label) lvalue::@return
(byte[1024]) lvalue::SCREEN
(byte) lvalue::i
(void()) lvaluevar()
(boolean~) lvaluevar::$0
(label) lvaluevar::@1
(label) lvaluevar::@2
(label) lvaluevar::@3
(label) lvaluevar::@return
(byte) lvaluevar::b
(byte) lvaluevar::i
(byte*) lvaluevar::screen
(void()) main()
(void~) main::$0
(void~) main::$1
(void~) main::$2
(void~) main::$3
(label) main::@return
(void()) rvalue()
(byte~) rvalue::$0
(byte~) rvalue::$1
(boolean~) rvalue::$2
(byte~) rvalue::$3
(label) rvalue::@1
(label) rvalue::@2
(label) rvalue::@3
(label) rvalue::@return
(byte[1024]) rvalue::SCREEN
(byte) rvalue::b
(byte) rvalue::i
(void()) rvaluevar()
(boolean~) rvaluevar::$0
(byte~) rvaluevar::$1
(label) rvaluevar::@1
(label) rvaluevar::@2
(label) rvaluevar::@3
(label) rvaluevar::@return
(byte) rvaluevar::b
(byte) rvaluevar::i
(byte*) rvaluevar::screen

INITIAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  (void~) $0 ← call main 
  to:@1
main: scope:[main]  from
  (void~) main::$0 ← call lvalue 
  (void~) main::$1 ← call rvalue 
  (void~) main::$2 ← call rvaluevar 
  (void~) main::$3 ← call lvaluevar 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
@1: scope:[]  from @begin
  to:@2
lvalue: scope:[lvalue]  from
  (byte[1024]) lvalue::SCREEN ← (word) 1024
  *((byte[1024]) lvalue::SCREEN) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN + (byte) 1) ← (byte) 2
  (byte) lvalue::i ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (boolean~) lvalue::$0 ← (byte) lvalue::i < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@4
lvalue::@2: scope:[lvalue]  from lvalue::@1 lvalue::@5
  *((byte[1024]) lvalue::SCREEN + (byte) lvalue::i) ← (byte) 3
  (byte) lvalue::i ← ++ (byte) lvalue::i
  to:lvalue::@1
lvalue::@4: scope:[lvalue]  from lvalue::@1
  to:lvalue::@3
lvalue::@3: scope:[lvalue]  from lvalue::@4 lvalue::@6
  to:lvalue::@return
lvalue::@5: scope:[lvalue]  from
  to:lvalue::@2
lvalue::@6: scope:[lvalue]  from
  to:lvalue::@3
lvalue::@return: scope:[lvalue]  from lvalue::@3
  return 
  to:@return
@2: scope:[]  from @1
  to:@3
rvalue: scope:[rvalue]  from
  (byte[1024]) rvalue::SCREEN ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN
  (byte) rvalue::b ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN *idx (byte) 1
  (byte) rvalue::b ← (byte~) rvalue::$1
  (byte) rvalue::i ← (byte) 2
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (boolean~) rvalue::$2 ← (byte) rvalue::i < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@4
rvalue::@2: scope:[rvalue]  from rvalue::@1 rvalue::@5
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN *idx (byte) rvalue::i
  (byte) rvalue::b ← (byte~) rvalue::$3
  (byte) rvalue::i ← ++ (byte) rvalue::i
  to:rvalue::@1
rvalue::@4: scope:[rvalue]  from rvalue::@1
  to:rvalue::@3
rvalue::@3: scope:[rvalue]  from rvalue::@4 rvalue::@6
  to:rvalue::@return
rvalue::@5: scope:[rvalue]  from
  to:rvalue::@2
rvalue::@6: scope:[rvalue]  from
  to:rvalue::@3
rvalue::@return: scope:[rvalue]  from rvalue::@3
  return 
  to:@return
@3: scope:[]  from @2
  to:@4
lvaluevar: scope:[lvaluevar]  from
  (byte*) lvaluevar::screen ← (word) 1024
  (byte) lvaluevar::b ← (byte) 4
  (byte) lvaluevar::i ← (byte) 2
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@4
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1 lvaluevar::@5
  *((byte*) lvaluevar::screen) ← (byte) lvaluevar::b
  (byte*) lvaluevar::screen ← ++ (byte*) lvaluevar::screen
  (byte) lvaluevar::i ← ++ (byte) lvaluevar::i
  to:lvaluevar::@1
lvaluevar::@4: scope:[lvaluevar]  from lvaluevar::@1
  to:lvaluevar::@3
lvaluevar::@3: scope:[lvaluevar]  from lvaluevar::@4 lvaluevar::@6
  to:lvaluevar::@return
lvaluevar::@5: scope:[lvaluevar]  from
  to:lvaluevar::@2
lvaluevar::@6: scope:[lvaluevar]  from
  to:lvaluevar::@3
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@3
  return 
  to:@return
@4: scope:[]  from @3
  to:@5
rvaluevar: scope:[rvaluevar]  from
  (byte*) rvaluevar::screen ← (word) 1024
  (byte) rvaluevar::i ← (byte) 2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@4
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1 rvaluevar::@5
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen
  (byte) rvaluevar::b ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen ← ++ (byte*) rvaluevar::screen
  (byte) rvaluevar::i ← ++ (byte) rvaluevar::i
  to:rvaluevar::@1
rvaluevar::@4: scope:[rvaluevar]  from rvaluevar::@1
  to:rvaluevar::@3
rvaluevar::@3: scope:[rvaluevar]  from rvaluevar::@4 rvaluevar::@6
  to:rvaluevar::@return
rvaluevar::@5: scope:[rvaluevar]  from
  to:rvaluevar::@2
rvaluevar::@6: scope:[rvaluevar]  from
  to:rvaluevar::@3
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@3
  return 
  to:@return
@5: scope:[]  from @4
  to:@end
@end: scope:[]  from @5

Removing empty block @1
Removing empty block lvalue::@4
Removing empty block lvalue::@3
Removing empty block lvalue::@5
Removing empty block lvalue::@6
Removing empty block @2
Removing empty block rvalue::@4
Removing empty block rvalue::@3
Removing empty block rvalue::@5
Removing empty block rvalue::@6
Removing empty block @3
Removing empty block lvaluevar::@4
Removing empty block lvaluevar::@3
Removing empty block lvaluevar::@5
Removing empty block lvaluevar::@6
Removing empty block @4
Removing empty block rvaluevar::@4
Removing empty block rvaluevar::@3
Removing empty block rvaluevar::@5
Removing empty block rvaluevar::@6
Removing empty block @5
CONTROL FLOW GRAPH
@begin: scope:[]  from
  (void~) $0 ← call main 
  to:@end
main: scope:[main]  from
  (void~) main::$0 ← call lvalue 
  (void~) main::$1 ← call rvalue 
  (void~) main::$2 ← call rvaluevar 
  (void~) main::$3 ← call lvaluevar 
  to:main::@return
main::@return: scope:[main]  from main
  return 
  to:@return
lvalue: scope:[lvalue]  from
  (byte[1024]) lvalue::SCREEN ← (word) 1024
  *((byte[1024]) lvalue::SCREEN) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN + (byte) 1) ← (byte) 2
  (byte) lvalue::i ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (boolean~) lvalue::$0 ← (byte) lvalue::i < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((byte[1024]) lvalue::SCREEN + (byte) lvalue::i) ← (byte) 3
  (byte) lvalue::i ← ++ (byte) lvalue::i
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from
  (byte[1024]) rvalue::SCREEN ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN
  (byte) rvalue::b ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN *idx (byte) 1
  (byte) rvalue::b ← (byte~) rvalue::$1
  (byte) rvalue::i ← (byte) 2
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (boolean~) rvalue::$2 ← (byte) rvalue::i < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN *idx (byte) rvalue::i
  (byte) rvalue::b ← (byte~) rvalue::$3
  (byte) rvalue::i ← ++ (byte) rvalue::i
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from
  (byte*) lvaluevar::screen ← (word) 1024
  (byte) lvaluevar::b ← (byte) 4
  (byte) lvaluevar::i ← (byte) 2
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen) ← (byte) lvaluevar::b
  (byte*) lvaluevar::screen ← ++ (byte*) lvaluevar::screen
  (byte) lvaluevar::i ← ++ (byte) lvaluevar::i
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from
  (byte*) rvaluevar::screen ← (word) 1024
  (byte) rvaluevar::i ← (byte) 2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen
  (byte) rvaluevar::b ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen ← ++ (byte*) rvaluevar::screen
  (byte) rvaluevar::i ← ++ (byte) rvaluevar::i
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

PROCEDURE MODIFY VARIABLE ANALYSIS

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL
@begin: scope:[]  from
  call main param-assignment
  to:@6
@6: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  (byte[1024]) lvalue::SCREEN ← (word) 1024
  *((byte[1024]) lvalue::SCREEN) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN + (byte) 1) ← (byte) 2
  (byte) lvalue::i ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (boolean~) lvalue::$0 ← (byte) lvalue::i < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((byte[1024]) lvalue::SCREEN + (byte) lvalue::i) ← (byte) 3
  (byte) lvalue::i ← ++ (byte) lvalue::i
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte[1024]) rvalue::SCREEN ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN
  (byte) rvalue::b ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN *idx (byte) 1
  (byte) rvalue::b ← (byte~) rvalue::$1
  (byte) rvalue::i ← (byte) 2
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (boolean~) rvalue::$2 ← (byte) rvalue::i < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN *idx (byte) rvalue::i
  (byte) rvalue::b ← (byte~) rvalue::$3
  (byte) rvalue::i ← ++ (byte) rvalue::i
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  (byte*) lvaluevar::screen ← (word) 1024
  (byte) lvaluevar::b ← (byte) 4
  (byte) lvaluevar::i ← (byte) 2
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen) ← (byte) lvaluevar::b
  (byte*) lvaluevar::screen ← ++ (byte*) lvaluevar::screen
  (byte) lvaluevar::i ← ++ (byte) lvaluevar::i
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  (byte*) rvaluevar::screen ← (word) 1024
  (byte) rvaluevar::i ← (byte) 2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen
  (byte) rvaluevar::b ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen ← ++ (byte*) rvaluevar::screen
  (byte) rvaluevar::i ← ++ (byte) rvaluevar::i
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @6

Completing Phi functions...
Completing Phi functions...
CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  call main param-assignment
  to:@6
@6: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  (byte[1024]) lvalue::SCREEN#0 ← (word) 1024
  *((byte[1024]) lvalue::SCREEN#0) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN#0 + (byte) 1) ← (byte) 2
  (byte) lvalue::i#0 ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#2 ← phi( lvalue/(byte[1024]) lvalue::SCREEN#0 lvalue::@2/(byte[1024]) lvalue::SCREEN#1 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) lvalue::i#0 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  (byte) lvalue::i#3 ← phi( lvalue::@1/(byte) lvalue::i#2 )
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue::@1/(byte[1024]) lvalue::SCREEN#2 )
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#3) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#3
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte[1024]) rvalue::SCREEN#0 ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN#0
  (byte) rvalue::b#0 ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN#0 *idx (byte) 1
  (byte) rvalue::b#1 ← (byte~) rvalue::$1
  (byte) rvalue::i#0 ← (byte) 2
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#2 ← phi( rvalue/(byte[1024]) rvalue::SCREEN#0 rvalue::@2/(byte[1024]) rvalue::SCREEN#1 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) rvalue::i#0 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::i#3 ← phi( rvalue::@1/(byte) rvalue::i#2 )
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue::@1/(byte[1024]) rvalue::SCREEN#2 )
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#3
  (byte) rvalue::b#2 ← (byte~) rvalue::$3
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#3
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  (byte*) lvaluevar::screen#0 ← (word) 1024
  (byte) lvaluevar::b#0 ← (byte) 4
  (byte) lvaluevar::i#0 ← (byte) 2
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#3 ← phi( lvaluevar/(byte*) lvaluevar::screen#0 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#2 ← phi( lvaluevar/(byte) lvaluevar::b#0 lvaluevar::@2/(byte) lvaluevar::b#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) lvaluevar::i#0 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  (byte) lvaluevar::i#3 ← phi( lvaluevar::@1/(byte) lvaluevar::i#2 )
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar::@1/(byte*) lvaluevar::screen#3 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar::@1/(byte) lvaluevar::b#2 )
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#3
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  (byte*) rvaluevar::screen#0 ← (word) 1024
  (byte) rvaluevar::i#0 ← (byte) 2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#3 ← phi( rvaluevar/(byte*) rvaluevar::screen#0 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) rvaluevar::i#0 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::i#3 ← phi( rvaluevar::@1/(byte) rvaluevar::i#2 )
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar::@1/(byte*) rvaluevar::screen#3 )
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen#2
  (byte) rvaluevar::b#0 ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#3
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @6

CONTROL FLOW GRAPH WITH ASSIGNMENT CALL & RETURN
@begin: scope:[]  from
  call main param-assignment
  to:@6
@6: scope:[]  from @begin
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@4
main::@4: scope:[main]  from main::@3
  to:main::@return
main::@return: scope:[main]  from main::@4
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  (byte[1024]) lvalue::SCREEN#0 ← (word) 1024
  *((byte[1024]) lvalue::SCREEN#0) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN#0 + (byte) 1) ← (byte) 2
  (byte) lvalue::i#0 ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#2 ← phi( lvalue/(byte[1024]) lvalue::SCREEN#0 lvalue::@2/(byte[1024]) lvalue::SCREEN#1 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) lvalue::i#0 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  (byte) lvalue::i#3 ← phi( lvalue::@1/(byte) lvalue::i#2 )
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue::@1/(byte[1024]) lvalue::SCREEN#2 )
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#3) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#3
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte[1024]) rvalue::SCREEN#0 ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN#0
  (byte) rvalue::b#0 ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN#0 *idx (byte) 1
  (byte) rvalue::b#1 ← (byte~) rvalue::$1
  (byte) rvalue::i#0 ← (byte) 2
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#2 ← phi( rvalue/(byte[1024]) rvalue::SCREEN#0 rvalue::@2/(byte[1024]) rvalue::SCREEN#1 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) rvalue::i#0 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::i#3 ← phi( rvalue::@1/(byte) rvalue::i#2 )
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue::@1/(byte[1024]) rvalue::SCREEN#2 )
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#3
  (byte) rvalue::b#2 ← (byte~) rvalue::$3
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#3
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  (byte*) lvaluevar::screen#0 ← (word) 1024
  (byte) lvaluevar::b#0 ← (byte) 4
  (byte) lvaluevar::i#0 ← (byte) 2
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#3 ← phi( lvaluevar/(byte*) lvaluevar::screen#0 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#2 ← phi( lvaluevar/(byte) lvaluevar::b#0 lvaluevar::@2/(byte) lvaluevar::b#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) lvaluevar::i#0 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  (byte) lvaluevar::i#3 ← phi( lvaluevar::@1/(byte) lvaluevar::i#2 )
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar::@1/(byte*) lvaluevar::screen#3 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar::@1/(byte) lvaluevar::b#2 )
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#3
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  (byte*) rvaluevar::screen#0 ← (word) 1024
  (byte) rvaluevar::i#0 ← (byte) 2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#3 ← phi( rvaluevar/(byte*) rvaluevar::screen#0 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) rvaluevar::i#0 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::i#3 ← phi( rvaluevar::@1/(byte) rvaluevar::i#2 )
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar::@1/(byte*) rvaluevar::screen#3 )
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen#2
  (byte) rvaluevar::b#0 ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#3
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @6

INITIAL SSA SYMBOL TABLE
(label) @6
(label) @begin
(label) @end
(void()) lvalue()
(boolean~) lvalue::$0
(label) lvalue::@1
(label) lvalue::@2
(label) lvalue::@return
(byte[1024]) lvalue::SCREEN
(byte[1024]) lvalue::SCREEN#0
(byte[1024]) lvalue::SCREEN#1
(byte[1024]) lvalue::SCREEN#2
(byte) lvalue::i
(byte) lvalue::i#0
(byte) lvalue::i#1
(byte) lvalue::i#2
(byte) lvalue::i#3
(void()) lvaluevar()
(boolean~) lvaluevar::$0
(label) lvaluevar::@1
(label) lvaluevar::@2
(label) lvaluevar::@return
(byte) lvaluevar::b
(byte) lvaluevar::b#0
(byte) lvaluevar::b#1
(byte) lvaluevar::b#2
(byte) lvaluevar::i
(byte) lvaluevar::i#0
(byte) lvaluevar::i#1
(byte) lvaluevar::i#2
(byte) lvaluevar::i#3
(byte*) lvaluevar::screen
(byte*) lvaluevar::screen#0
(byte*) lvaluevar::screen#1
(byte*) lvaluevar::screen#2
(byte*) lvaluevar::screen#3
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@return
(void()) rvalue()
(byte~) rvalue::$0
(byte~) rvalue::$1
(boolean~) rvalue::$2
(byte~) rvalue::$3
(label) rvalue::@1
(label) rvalue::@2
(label) rvalue::@return
(byte[1024]) rvalue::SCREEN
(byte[1024]) rvalue::SCREEN#0
(byte[1024]) rvalue::SCREEN#1
(byte[1024]) rvalue::SCREEN#2
(byte) rvalue::b
(byte) rvalue::b#0
(byte) rvalue::b#1
(byte) rvalue::b#2
(byte) rvalue::i
(byte) rvalue::i#0
(byte) rvalue::i#1
(byte) rvalue::i#2
(byte) rvalue::i#3
(void()) rvaluevar()
(boolean~) rvaluevar::$0
(byte~) rvaluevar::$1
(label) rvaluevar::@1
(label) rvaluevar::@2
(label) rvaluevar::@return
(byte) rvaluevar::b
(byte) rvaluevar::b#0
(byte) rvaluevar::i
(byte) rvaluevar::i#0
(byte) rvaluevar::i#1
(byte) rvaluevar::i#2
(byte) rvaluevar::i#3
(byte*) rvaluevar::screen
(byte*) rvaluevar::screen#0
(byte*) rvaluevar::screen#1
(byte*) rvaluevar::screen#2
(byte*) rvaluevar::screen#3

Culled Empty Block (label) @6
Culled Empty Block (label) main::@4
Succesful SSA optimization Pass2CullEmptyBlocks
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  (byte[1024]) lvalue::SCREEN#0 ← (word) 1024
  *((byte[1024]) lvalue::SCREEN#0) ← (byte) 1
  *((byte[1024]) lvalue::SCREEN#0 + (byte) 1) ← (byte) 2
  (byte) lvalue::i#0 ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#2 ← phi( lvalue/(byte[1024]) lvalue::SCREEN#0 lvalue::@2/(byte[1024]) lvalue::SCREEN#1 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) lvalue::i#0 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  (byte) lvalue::i#3 ← phi( lvalue::@1/(byte) lvalue::i#2 )
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue::@1/(byte[1024]) lvalue::SCREEN#2 )
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#3) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#3
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte[1024]) rvalue::SCREEN#0 ← (word) 1024
  (byte~) rvalue::$0 ← * (byte[1024]) rvalue::SCREEN#0
  (byte) rvalue::b#0 ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (byte[1024]) rvalue::SCREEN#0 *idx (byte) 1
  (byte) rvalue::b#1 ← (byte~) rvalue::$1
  (byte) rvalue::i#0 ← (byte) 2
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#2 ← phi( rvalue/(byte[1024]) rvalue::SCREEN#0 rvalue::@2/(byte[1024]) rvalue::SCREEN#1 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) rvalue::i#0 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::i#3 ← phi( rvalue::@1/(byte) rvalue::i#2 )
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue::@1/(byte[1024]) rvalue::SCREEN#2 )
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#3
  (byte) rvalue::b#2 ← (byte~) rvalue::$3
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#3
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  (byte*) lvaluevar::screen#0 ← (word) 1024
  (byte) lvaluevar::b#0 ← (byte) 4
  (byte) lvaluevar::i#0 ← (byte) 2
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#3 ← phi( lvaluevar/(byte*) lvaluevar::screen#0 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#2 ← phi( lvaluevar/(byte) lvaluevar::b#0 lvaluevar::@2/(byte) lvaluevar::b#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) lvaluevar::i#0 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  (byte) lvaluevar::i#3 ← phi( lvaluevar::@1/(byte) lvaluevar::i#2 )
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar::@1/(byte*) lvaluevar::screen#3 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar::@1/(byte) lvaluevar::b#2 )
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#3
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  (byte*) rvaluevar::screen#0 ← (word) 1024
  (byte) rvaluevar::i#0 ← (byte) 2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#3 ← phi( rvaluevar/(byte*) rvaluevar::screen#0 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) rvaluevar::i#0 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::i#3 ← phi( rvaluevar::@1/(byte) rvaluevar::i#2 )
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar::@1/(byte*) rvaluevar::screen#3 )
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen#2
  (byte) rvaluevar::b#0 ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#3
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Constant (byte[1024]) lvalue::SCREEN#0 (word) 1024
Constant (byte) lvalue::i#0 (byte) 2
Constant (byte[1024]) rvalue::SCREEN#0 (word) 1024
Constant (byte) rvalue::i#0 (byte) 2
Constant (byte*) lvaluevar::screen#0 (word) 1024
Constant (byte) lvaluevar::b#0 (byte) 4
Constant (byte) lvaluevar::i#0 (byte) 2
Constant (byte*) rvaluevar::screen#0 (word) 1024
Constant (byte) rvaluevar::i#0 (byte) 2
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1024 + (byte) 1) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#2 ← phi( lvalue/(word) 1024 lvalue::@2/(byte[1024]) lvalue::SCREEN#1 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  (byte) lvalue::i#3 ← phi( lvalue::@1/(byte) lvalue::i#2 )
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue::@1/(byte[1024]) lvalue::SCREEN#2 )
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#3) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#3
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte~) rvalue::$0 ← * (word) 1024
  (byte) rvalue::b#0 ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← (word) 1024 *idx (byte) 1
  (byte) rvalue::b#1 ← (byte~) rvalue::$1
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#2 ← phi( rvalue/(word) 1024 rvalue::@2/(byte[1024]) rvalue::SCREEN#1 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::i#3 ← phi( rvalue::@1/(byte) rvalue::i#2 )
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue::@1/(byte[1024]) rvalue::SCREEN#2 )
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#3
  (byte) rvalue::b#2 ← (byte~) rvalue::$3
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#3
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#3 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#2 ← phi( lvaluevar/(byte) 4 lvaluevar::@2/(byte) lvaluevar::b#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  (byte) lvaluevar::i#3 ← phi( lvaluevar::@1/(byte) lvaluevar::i#2 )
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar::@1/(byte*) lvaluevar::screen#3 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar::@1/(byte) lvaluevar::b#2 )
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#3
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#3 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::i#3 ← phi( rvaluevar::@1/(byte) rvaluevar::i#2 )
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar::@1/(byte*) rvaluevar::screen#3 )
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen#2
  (byte) rvaluevar::b#0 ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#3
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Consolidated assigned array index constant in assignment *(1025)
Consolidated referenced array index constant in assignment rvalue::$1
Succesful SSA optimization Pass2ConstantAdditionElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1025) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#2 ← phi( lvalue/(word) 1024 lvalue::@2/(byte[1024]) lvalue::SCREEN#1 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  (byte) lvalue::i#3 ← phi( lvalue::@1/(byte) lvalue::i#2 )
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue::@1/(byte[1024]) lvalue::SCREEN#2 )
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#3) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#3
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte~) rvalue::$0 ← * (word) 1024
  (byte) rvalue::b#0 ← (byte~) rvalue::$0
  (byte~) rvalue::$1 ← * (word) 1025
  (byte) rvalue::b#1 ← (byte~) rvalue::$1
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#2 ← phi( rvalue/(word) 1024 rvalue::@2/(byte[1024]) rvalue::SCREEN#1 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::i#3 ← phi( rvalue::@1/(byte) rvalue::i#2 )
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue::@1/(byte[1024]) rvalue::SCREEN#2 )
  (byte~) rvalue::$3 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#3
  (byte) rvalue::b#2 ← (byte~) rvalue::$3
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#3
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#3 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#2 ← phi( lvaluevar/(byte) 4 lvaluevar::@2/(byte) lvaluevar::b#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  (byte) lvaluevar::i#3 ← phi( lvaluevar::@1/(byte) lvaluevar::i#2 )
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar::@1/(byte*) lvaluevar::screen#3 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar::@1/(byte) lvaluevar::b#2 )
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#3
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#3 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::i#3 ← phi( rvaluevar::@1/(byte) rvaluevar::i#2 )
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar::@1/(byte*) rvaluevar::screen#3 )
  (byte~) rvaluevar::$1 ← * (byte*) rvaluevar::screen#2
  (byte) rvaluevar::b#0 ← (byte~) rvaluevar::$1
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#3
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Alias (byte[1024]) lvalue::SCREEN#1 = (byte[1024]) lvalue::SCREEN#2 
Alias (byte) lvalue::i#2 = (byte) lvalue::i#3 
Alias (byte) rvalue::b#0 = (byte~) rvalue::$0 
Alias (byte) rvalue::b#1 = (byte~) rvalue::$1 
Alias (byte[1024]) rvalue::SCREEN#1 = (byte[1024]) rvalue::SCREEN#2 
Alias (byte) rvalue::i#2 = (byte) rvalue::i#3 
Alias (byte) rvalue::b#2 = (byte~) rvalue::$3 
Alias (byte) lvaluevar::b#1 = (byte) lvaluevar::b#2 
Alias (byte*) lvaluevar::screen#2 = (byte*) lvaluevar::screen#3 
Alias (byte) lvaluevar::i#2 = (byte) lvaluevar::i#3 
Alias (byte*) rvaluevar::screen#2 = (byte*) rvaluevar::screen#3 
Alias (byte) rvaluevar::i#2 = (byte) rvaluevar::i#3 
Alias (byte) rvaluevar::b#0 = (byte~) rvaluevar::$1 
Succesful SSA optimization Pass2AliasElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1025) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue/(word) 1024 lvalue::@2/(byte[1024]) lvalue::SCREEN#1 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#2) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte) rvalue::b#0 ← * (word) 1024
  (byte) rvalue::b#1 ← * (word) 1025
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue/(word) 1024 rvalue::@2/(byte[1024]) rvalue::SCREEN#1 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::b#2 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#2
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar/(byte) 4 lvaluevar::@2/(byte) lvaluevar::b#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Self Phi Eliminated (byte[1024]) lvalue::SCREEN#1
Self Phi Eliminated (byte[1024]) rvalue::SCREEN#1
Self Phi Eliminated (byte) lvaluevar::b#1
Succesful SSA optimization Pass2SelfPhiElimination
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1025) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue/(word) 1024 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 )
  (boolean~) lvalue::$0 ← (byte) lvalue::i#2 < (byte) 10
  if((boolean~) lvalue::$0) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#2) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte) rvalue::b#0 ← * (word) 1024
  (byte) rvalue::b#1 ← * (word) 1025
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue/(word) 1024 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 )
  (boolean~) rvalue::$2 ← (byte) rvalue::i#2 < (byte) 10
  if((boolean~) rvalue::$2) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::b#2 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#2
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar/(byte) 4 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 )
  (boolean~) lvaluevar::$0 ← (byte) lvaluevar::i#2 < (byte) 10
  if((boolean~) lvaluevar::$0) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 )
  (boolean~) rvaluevar::$0 ← (byte) rvaluevar::i#2 < (byte) 10
  if((boolean~) rvaluevar::$0) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Simple Condition (boolean~) lvalue::$0 if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2
Simple Condition (boolean~) rvalue::$2 if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2
Simple Condition (boolean~) lvaluevar::$0 if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2
Simple Condition (boolean~) rvaluevar::$0 if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2
Succesful SSA optimization Pass2ConditionalJumpSimplification
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1025) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte[1024]) lvalue::SCREEN#1 ← phi( lvalue/(word) 1024 )
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 )
  if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((byte[1024]) lvalue::SCREEN#1 + (byte) lvalue::i#2) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte) rvalue::b#0 ← * (word) 1024
  (byte) rvalue::b#1 ← * (word) 1025
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte[1024]) rvalue::SCREEN#1 ← phi( rvalue/(word) 1024 )
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 )
  if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::b#2 ← (byte[1024]) rvalue::SCREEN#1 *idx (byte) rvalue::i#2
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::b#1 ← phi( lvaluevar/(byte) 4 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 )
  if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen#2) ← (byte) lvaluevar::b#1
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 )
  if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Constant (byte[1024]) lvalue::SCREEN#1 (word) 1024
Constant (byte[1024]) rvalue::SCREEN#1 (word) 1024
Constant (byte) lvaluevar::b#1 (byte) 4
Succesful SSA optimization Pass2ConstantPropagation
CONTROL FLOW GRAPH
@begin: scope:[]  from
  call main param-assignment
  to:@end
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1025) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 )
  if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2
  to:lvalue::@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2
  to:lvalue::@1
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
rvalue: scope:[rvalue]  from main::@1
  (byte) rvalue::b#0 ← * (word) 1024
  (byte) rvalue::b#1 ← * (word) 1025
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 )
  if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2
  to:rvalue::@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2
  to:rvalue::@1
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 )
  if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen#2) ← (byte) 4
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2
  to:lvaluevar::@1
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 )
  if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2
  to:rvaluevar::@1
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
@end: scope:[]  from @begin

Multiple usages for variable. Not optimizing sub-constant (byte) rvalue::i#2
Multiple usages for variable. Not optimizing sub-constant (byte) rvalue::i#2
FINAL SYMBOL TABLE
(label) @begin
(label) @end
(void()) lvalue()
(label) lvalue::@1
(label) lvalue::@2
(label) lvalue::@return
(byte[1024]) lvalue::SCREEN
(byte) lvalue::i
(byte) lvalue::i#1
(byte) lvalue::i#2
(void()) lvaluevar()
(label) lvaluevar::@1
(label) lvaluevar::@2
(label) lvaluevar::@return
(byte) lvaluevar::b
(byte) lvaluevar::i
(byte) lvaluevar::i#1
(byte) lvaluevar::i#2
(byte*) lvaluevar::screen
(byte*) lvaluevar::screen#1
(byte*) lvaluevar::screen#2
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(void()) rvalue()
(label) rvalue::@1
(label) rvalue::@2
(label) rvalue::@return
(byte[1024]) rvalue::SCREEN
(byte) rvalue::b
(byte) rvalue::b#0
(byte) rvalue::b#1
(byte) rvalue::b#2
(byte) rvalue::i
(byte) rvalue::i#1
(byte) rvalue::i#2
(void()) rvaluevar()
(label) rvaluevar::@1
(label) rvaluevar::@2
(label) rvaluevar::@return
(byte) rvaluevar::b
(byte) rvaluevar::b#0
(byte) rvaluevar::i
(byte) rvaluevar::i#1
(byte) rvaluevar::i#2
(byte*) rvaluevar::screen
(byte*) rvaluevar::screen#1
(byte*) rvaluevar::screen#2

Block Sequence Planned @begin @end main main::@1 main::@2 main::@3 main::@return lvaluevar lvaluevar::@1 lvaluevar::@return lvaluevar::@2 rvaluevar rvaluevar::@1 rvaluevar::@return rvaluevar::@2 rvalue rvalue::@1 rvalue::@return rvalue::@2 lvalue lvalue::@1 lvalue::@return lvalue::@2 
Block Sequence Planned @begin @end main main::@1 main::@2 main::@3 main::@return lvaluevar lvaluevar::@1 lvaluevar::@return lvaluevar::@2 rvaluevar rvaluevar::@1 rvaluevar::@return rvaluevar::@2 rvalue rvalue::@1 rvalue::@return rvalue::@2 lvalue lvalue::@1 lvalue::@return lvalue::@2 
CONTROL FLOW GRAPH - PHI LIFTED
@begin: scope:[]  from
  call main param-assignment
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  call lvalue param-assignment
  to:main::@1
main::@1: scope:[main]  from main
  call rvalue param-assignment
  to:main::@2
main::@2: scope:[main]  from main::@1
  call rvaluevar param-assignment
  to:main::@3
main::@3: scope:[main]  from main::@2
  call lvaluevar param-assignment
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*~) lvaluevar::screen#4 )
  (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte~) lvaluevar::i#4 )
  if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2
  to:lvaluevar::@return
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  return 
  to:@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  *((byte*) lvaluevar::screen#2) ← (byte) 4
  (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2
  (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2
  (byte~) lvaluevar::i#4 ← (byte) lvaluevar::i#1
  (byte*~) lvaluevar::screen#4 ← (byte*) lvaluevar::screen#1
  to:lvaluevar::@1
rvaluevar: scope:[rvaluevar]  from main::@2
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*~) rvaluevar::screen#4 )
  (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte~) rvaluevar::i#4 )
  if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2
  to:rvaluevar::@return
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  return 
  to:@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2
  (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2
  (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2
  (byte~) rvaluevar::i#4 ← (byte) rvaluevar::i#1
  (byte*~) rvaluevar::screen#4 ← (byte*) rvaluevar::screen#1
  to:rvaluevar::@1
rvalue: scope:[rvalue]  from main::@1
  (byte) rvalue::b#0 ← * (word) 1024
  (byte) rvalue::b#1 ← * (word) 1025
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte~) rvalue::i#4 )
  if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2
  to:rvalue::@return
rvalue::@return: scope:[rvalue]  from rvalue::@1
  return 
  to:@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2
  (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2
  (byte~) rvalue::i#4 ← (byte) rvalue::i#1
  to:rvalue::@1
lvalue: scope:[lvalue]  from main
  *((word) 1024) ← (byte) 1
  *((word) 1025) ← (byte) 2
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte~) lvalue::i#4 )
  if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2
  to:lvalue::@return
lvalue::@return: scope:[lvalue]  from lvalue::@1
  return 
  to:@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3
  (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2
  (byte~) lvalue::i#4 ← (byte) lvalue::i#1
  to:lvalue::@1

Adding NOP phi() at start of main
Adding NOP phi() at start of lvaluevar
Adding NOP phi() at start of rvaluevar
CALL GRAPH
Calls in [] to 0:main 
Calls in [main] to 2:lvalue 3:rvalue 4:rvaluevar 5:lvaluevar 

Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - LIVE RANGES FOUND
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] phi() [ ]
  [2] call lvalue param-assignment [ ]
  to:main::@1
main::@1: scope:[main]  from main
  [3] call rvalue param-assignment [ ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] call rvaluevar param-assignment [ ]
  to:main::@3
main::@3: scope:[main]  from main::@2
  [5] call lvaluevar param-assignment [ ]
  to:main::@return
main::@return: scope:[main]  from main::@3
  [6] return  [ ]
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  [7] phi() [ ]
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  [8] (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*~) lvaluevar::screen#4 ) [ lvaluevar::i#2 lvaluevar::screen#2 ]
  [8] (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte~) lvaluevar::i#4 ) [ lvaluevar::i#2 lvaluevar::screen#2 ]
  [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ]
  to:lvaluevar::@return
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  [10] return  [ ]
  to:@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ]
  [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ]
  [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::screen#1 lvaluevar::i#1 ]
  [14] (byte~) lvaluevar::i#4 ← (byte) lvaluevar::i#1 [ lvaluevar::i#4 lvaluevar::screen#1 ]
  [15] (byte*~) lvaluevar::screen#4 ← (byte*) lvaluevar::screen#1 [ lvaluevar::i#4 lvaluevar::screen#4 ]
  to:lvaluevar::@1
rvaluevar: scope:[rvaluevar]  from main::@2
  [16] phi() [ ]
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  [17] (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*~) rvaluevar::screen#4 ) [ rvaluevar::i#2 rvaluevar::screen#2 ]
  [17] (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte~) rvaluevar::i#4 ) [ rvaluevar::i#2 rvaluevar::screen#2 ]
  [18] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ]
  to:rvaluevar::@return
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  [19] return  [ ]
  to:@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  [20] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ]
  [21] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ]
  [22] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::screen#1 rvaluevar::i#1 ]
  [23] (byte~) rvaluevar::i#4 ← (byte) rvaluevar::i#1 [ rvaluevar::i#4 rvaluevar::screen#1 ]
  [24] (byte*~) rvaluevar::screen#4 ← (byte*) rvaluevar::screen#1 [ rvaluevar::i#4 rvaluevar::screen#4 ]
  to:rvaluevar::@1
rvalue: scope:[rvalue]  from main::@1
  [25] (byte) rvalue::b#0 ← * (word) 1024 [ ]
  [26] (byte) rvalue::b#1 ← * (word) 1025 [ ]
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  [27] (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte~) rvalue::i#4 ) [ rvalue::i#2 ]
  [28] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ]
  to:rvalue::@return
rvalue::@return: scope:[rvalue]  from rvalue::@1
  [29] return  [ ]
  to:@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  [30] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ]
  [31] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ]
  [32] (byte~) rvalue::i#4 ← (byte) rvalue::i#1 [ rvalue::i#4 ]
  to:rvalue::@1
lvalue: scope:[lvalue]  from main
  [33] *((word) 1024) ← (byte) 1 [ ]
  [34] *((word) 1025) ← (byte) 2 [ ]
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  [35] (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte~) lvalue::i#4 ) [ lvalue::i#2 ]
  [36] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ]
  to:lvalue::@return
lvalue::@return: scope:[lvalue]  from lvalue::@1
  [37] return  [ ]
  to:@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  [38] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ]
  [39] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ]
  [40] (byte~) lvalue::i#4 ← (byte) lvalue::i#1 [ lvalue::i#4 ]
  to:lvalue::@1

Created 6 initial phi equivalence classes
Coalesced [14] lvaluevar::i#4 ← lvaluevar::i#1
Coalesced [15] lvaluevar::screen#4 ← lvaluevar::screen#1
Coalesced [23] rvaluevar::i#4 ← rvaluevar::i#1
Coalesced [24] rvaluevar::screen#4 ← rvaluevar::screen#1
Coalesced [32] rvalue::i#4 ← rvalue::i#1
Coalesced [40] lvalue::i#4 ← lvalue::i#1
Coalesced down to 6 phi equivalence classes
Block Sequence Planned @begin @end main main::@1 main::@2 main::@3 main::@return lvaluevar lvaluevar::@1 lvaluevar::@return lvaluevar::@2 rvaluevar rvaluevar::@1 rvaluevar::@return rvaluevar::@2 rvalue rvalue::@1 rvalue::@return rvalue::@2 lvalue lvalue::@1 lvalue::@return lvalue::@2 
Adding NOP phi() at start of main
Adding NOP phi() at start of lvaluevar
Adding NOP phi() at start of rvaluevar
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
Propagating live ranges...
CONTROL FLOW GRAPH - PHI MEM COALESCED
@begin: scope:[]  from
  [0] call main param-assignment [ ]
  to:@end
@end: scope:[]  from @begin
main: scope:[main]  from @begin
  [1] phi() [ ]
  [2] call lvalue param-assignment [ ]
  to:main::@1
main::@1: scope:[main]  from main
  [3] call rvalue param-assignment [ ]
  to:main::@2
main::@2: scope:[main]  from main::@1
  [4] call rvaluevar param-assignment [ ]
  to:main::@3
main::@3: scope:[main]  from main::@2
  [5] call lvaluevar param-assignment [ ]
  to:main::@return
main::@return: scope:[main]  from main::@3
  [6] return  [ ]
  to:@return
lvaluevar: scope:[lvaluevar]  from main::@3
  [7] phi() [ ]
  to:lvaluevar::@1
lvaluevar::@1: scope:[lvaluevar]  from lvaluevar lvaluevar::@2
  [8] (byte*) lvaluevar::screen#2 ← phi( lvaluevar/(word) 1024 lvaluevar::@2/(byte*) lvaluevar::screen#1 ) [ lvaluevar::i#2 lvaluevar::screen#2 ]
  [8] (byte) lvaluevar::i#2 ← phi( lvaluevar/(byte) 2 lvaluevar::@2/(byte) lvaluevar::i#1 ) [ lvaluevar::i#2 lvaluevar::screen#2 ]
  [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ]
  to:lvaluevar::@return
lvaluevar::@return: scope:[lvaluevar]  from lvaluevar::@1
  [10] return  [ ]
  to:@return
lvaluevar::@2: scope:[lvaluevar]  from lvaluevar::@1
  [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ]
  [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ]
  [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::i#1 lvaluevar::screen#1 ]
  to:lvaluevar::@1
rvaluevar: scope:[rvaluevar]  from main::@2
  [14] phi() [ ]
  to:rvaluevar::@1
rvaluevar::@1: scope:[rvaluevar]  from rvaluevar rvaluevar::@2
  [15] (byte*) rvaluevar::screen#2 ← phi( rvaluevar/(word) 1024 rvaluevar::@2/(byte*) rvaluevar::screen#1 ) [ rvaluevar::i#2 rvaluevar::screen#2 ]
  [15] (byte) rvaluevar::i#2 ← phi( rvaluevar/(byte) 2 rvaluevar::@2/(byte) rvaluevar::i#1 ) [ rvaluevar::i#2 rvaluevar::screen#2 ]
  [16] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ]
  to:rvaluevar::@return
rvaluevar::@return: scope:[rvaluevar]  from rvaluevar::@1
  [17] return  [ ]
  to:@return
rvaluevar::@2: scope:[rvaluevar]  from rvaluevar::@1
  [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ]
  [19] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ]
  [20] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::i#1 rvaluevar::screen#1 ]
  to:rvaluevar::@1
rvalue: scope:[rvalue]  from main::@1
  [21] (byte) rvalue::b#0 ← * (word) 1024 [ ]
  [22] (byte) rvalue::b#1 ← * (word) 1025 [ ]
  to:rvalue::@1
rvalue::@1: scope:[rvalue]  from rvalue rvalue::@2
  [23] (byte) rvalue::i#2 ← phi( rvalue/(byte) 2 rvalue::@2/(byte) rvalue::i#1 ) [ rvalue::i#2 ]
  [24] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ]
  to:rvalue::@return
rvalue::@return: scope:[rvalue]  from rvalue::@1
  [25] return  [ ]
  to:@return
rvalue::@2: scope:[rvalue]  from rvalue::@1
  [26] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ]
  [27] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ]
  to:rvalue::@1
lvalue: scope:[lvalue]  from main
  [28] *((word) 1024) ← (byte) 1 [ ]
  [29] *((word) 1025) ← (byte) 2 [ ]
  to:lvalue::@1
lvalue::@1: scope:[lvalue]  from lvalue lvalue::@2
  [30] (byte) lvalue::i#2 ← phi( lvalue/(byte) 2 lvalue::@2/(byte) lvalue::i#1 ) [ lvalue::i#2 ]
  [31] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ]
  to:lvalue::@return
lvalue::@return: scope:[lvalue]  from lvalue::@1
  [32] return  [ ]
  to:@return
lvalue::@2: scope:[lvalue]  from lvalue::@1
  [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ]
  [34] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ]
  to:lvalue::@1

DOMINATORS
@begin dominated by  @begin 
@end dominated by  @end @begin 
main dominated by  @begin main 
main::@1 dominated by  @begin main::@1 main 
main::@2 dominated by  @begin main::@2 main::@1 main 
main::@3 dominated by  @begin main::@2 main::@1 main::@3 main 
main::@return dominated by  @begin main::@2 main::@1 main::@3 main main::@return 
lvaluevar dominated by  @begin main::@2 main::@1 main::@3 main lvaluevar 
lvaluevar::@1 dominated by  @begin main::@2 main::@1 main::@3 main lvaluevar::@1 lvaluevar 
lvaluevar::@return dominated by  @begin main::@2 main::@1 main::@3 main lvaluevar::@1 lvaluevar::@return lvaluevar 
lvaluevar::@2 dominated by  @begin main::@2 main::@1 main::@3 main lvaluevar::@2 lvaluevar::@1 lvaluevar 
rvaluevar dominated by  rvaluevar @begin main::@2 main::@1 main 
rvaluevar::@1 dominated by  rvaluevar @begin main::@2 main::@1 main rvaluevar::@1 
rvaluevar::@return dominated by  rvaluevar @begin rvaluevar::@return main::@2 main::@1 main rvaluevar::@1 
rvaluevar::@2 dominated by  rvaluevar @begin main::@2 main::@1 main rvaluevar::@2 rvaluevar::@1 
rvalue dominated by  @begin main::@1 rvalue main 
rvalue::@1 dominated by  @begin main::@1 rvalue::@1 rvalue main 
rvalue::@return dominated by  @begin main::@1 rvalue::@1 rvalue main rvalue::@return 
rvalue::@2 dominated by  @begin main::@1 rvalue::@1 rvalue rvalue::@2 main 
lvalue dominated by  @begin main lvalue 
lvalue::@1 dominated by  @begin lvalue::@1 main lvalue 
lvalue::@return dominated by  lvalue::@return @begin lvalue::@1 main lvalue 
lvalue::@2 dominated by  @begin lvalue::@1 lvalue::@2 main lvalue 

Found back edge: Loop head: lvaluevar::@1 tails: lvaluevar::@2 blocks: null
Found back edge: Loop head: rvaluevar::@1 tails: rvaluevar::@2 blocks: null
Found back edge: Loop head: rvalue::@1 tails: rvalue::@2 blocks: null
Found back edge: Loop head: lvalue::@1 tails: lvalue::@2 blocks: null
Populated: Loop head: lvaluevar::@1 tails: lvaluevar::@2 blocks: lvaluevar::@2 lvaluevar::@1 
Populated: Loop head: rvaluevar::@1 tails: rvaluevar::@2 blocks: rvaluevar::@2 rvaluevar::@1 
Populated: Loop head: rvalue::@1 tails: rvalue::@2 blocks: rvalue::@2 rvalue::@1 
Populated: Loop head: lvalue::@1 tails: lvalue::@2 blocks: lvalue::@2 lvalue::@1 
NATURAL LOOPS
Loop head: lvaluevar::@1 tails: lvaluevar::@2 blocks: lvaluevar::@2 lvaluevar::@1 
Loop head: rvaluevar::@1 tails: rvaluevar::@2 blocks: rvaluevar::@2 rvaluevar::@1 
Loop head: rvalue::@1 tails: rvalue::@2 blocks: rvalue::@2 rvalue::@1 
Loop head: lvalue::@1 tails: lvalue::@2 blocks: lvalue::@2 lvalue::@1 

Found 0 loops in scope []
Found 0 loops in scope [main]
Found 1 loops in scope [lvalue]
  Loop head: lvalue::@1 tails: lvalue::@2 blocks: lvalue::@2 lvalue::@1 
Found 1 loops in scope [rvalue]
  Loop head: rvalue::@1 tails: rvalue::@2 blocks: rvalue::@2 rvalue::@1 
Found 1 loops in scope [rvaluevar]
  Loop head: rvaluevar::@1 tails: rvaluevar::@2 blocks: rvaluevar::@2 rvaluevar::@1 
Found 1 loops in scope [lvaluevar]
  Loop head: lvaluevar::@1 tails: lvaluevar::@2 blocks: lvaluevar::@2 lvaluevar::@1 
NATURAL LOOPS WITH DEPTH
Loop head: lvaluevar::@1 tails: lvaluevar::@2 blocks: lvaluevar::@2 lvaluevar::@1  depth: 1
Loop head: rvaluevar::@1 tails: rvaluevar::@2 blocks: rvaluevar::@2 rvaluevar::@1  depth: 1
Loop head: rvalue::@1 tails: rvalue::@2 blocks: rvalue::@2 rvalue::@1  depth: 1
Loop head: lvalue::@1 tails: lvalue::@2 blocks: lvalue::@2 lvalue::@1  depth: 1


VARIABLE REGISTER WEIGHTS
(void()) lvalue()
(byte[1024]) lvalue::SCREEN
(byte) lvalue::i
(byte) lvalue::i#1 22.0
(byte) lvalue::i#2 14.666666666666666
(void()) lvaluevar()
(byte) lvaluevar::b
(byte) lvaluevar::i
(byte) lvaluevar::i#1 22.0
(byte) lvaluevar::i#2 8.25
(byte*) lvaluevar::screen
(byte*) lvaluevar::screen#1 11.0
(byte*) lvaluevar::screen#2 11.0
(void()) main()
(void()) rvalue()
(byte[1024]) rvalue::SCREEN
(byte) rvalue::b
(byte) rvalue::b#0 20.0
(byte) rvalue::b#1 20.0
(byte) rvalue::b#2 110.0
(byte) rvalue::i
(byte) rvalue::i#1 22.0
(byte) rvalue::i#2 14.666666666666666
(void()) rvaluevar()
(byte) rvaluevar::b
(byte) rvaluevar::b#0 110.0
(byte) rvaluevar::i
(byte) rvaluevar::i#1 22.0
(byte) rvaluevar::i#2 8.25
(byte*) rvaluevar::screen
(byte*) rvaluevar::screen#1 11.0
(byte*) rvaluevar::screen#2 11.0

Initial phi equivalence classes
[ lvaluevar::i#2 lvaluevar::i#1 ]
[ lvaluevar::screen#2 lvaluevar::screen#1 ]
[ rvaluevar::i#2 rvaluevar::i#1 ]
[ rvaluevar::screen#2 rvaluevar::screen#1 ]
[ rvalue::i#2 rvalue::i#1 ]
[ lvalue::i#2 lvalue::i#1 ]
Added variable rvaluevar::b#0 to zero page equivalence class [ rvaluevar::b#0 ]
Added variable rvalue::b#0 to zero page equivalence class [ rvalue::b#0 ]
Added variable rvalue::b#1 to zero page equivalence class [ rvalue::b#1 ]
Added variable rvalue::b#2 to zero page equivalence class [ rvalue::b#2 ]
Complete equivalence classes
[ lvaluevar::i#2 lvaluevar::i#1 ]
[ lvaluevar::screen#2 lvaluevar::screen#1 ]
[ rvaluevar::i#2 rvaluevar::i#1 ]
[ rvaluevar::screen#2 rvaluevar::screen#1 ]
[ rvalue::i#2 rvalue::i#1 ]
[ lvalue::i#2 lvalue::i#1 ]
[ rvaluevar::b#0 ]
[ rvalue::b#0 ]
[ rvalue::b#1 ]
[ rvalue::b#2 ]
Allocated zp ZP_BYTE:2 [ lvaluevar::i#2 lvaluevar::i#1 ]
Allocated zp ZP_PTR_BYTE:3 [ lvaluevar::screen#2 lvaluevar::screen#1 ]
Allocated zp ZP_BYTE:5 [ rvaluevar::i#2 rvaluevar::i#1 ]
Allocated zp ZP_PTR_BYTE:6 [ rvaluevar::screen#2 rvaluevar::screen#1 ]
Allocated zp ZP_BYTE:8 [ rvalue::i#2 rvalue::i#1 ]
Allocated zp ZP_BYTE:9 [ lvalue::i#2 lvalue::i#1 ]
Allocated zp ZP_BYTE:10 [ rvaluevar::b#0 ]
Allocated zp ZP_BYTE:11 [ rvalue::b#0 ]
Allocated zp ZP_BYTE:12 [ rvalue::b#1 ]
Allocated zp ZP_BYTE:13 [ rvalue::b#2 ]
INITIAL ASM
//SEG0 Global ZP labels
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main
main_from_bbegin:
  jsr main
  jmp bend
//SEG4 @end
bend:
//SEG5 main
main: {
  //SEG6 [2] call lvalue param-assignment [ ]
    jsr lvalue
    jmp b1
  //SEG7 main::@1
  b1:
  //SEG8 [3] call rvalue param-assignment [ ]
    jsr rvalue
    jmp b2
  //SEG9 main::@2
  b2:
  //SEG10 [4] call rvaluevar param-assignment [ ]
  //SEG11 [14] phi from main::@2 to rvaluevar
  rvaluevar_from_b2:
    jsr rvaluevar
    jmp b3
  //SEG12 main::@3
  b3:
  //SEG13 [5] call lvaluevar param-assignment [ ]
  //SEG14 [7] phi from main::@3 to lvaluevar
  lvaluevar_from_b3:
    jsr lvaluevar
    jmp breturn
  //SEG15 main::@return
  breturn:
  //SEG16 [6] return  [ ]
    rts
}
//SEG17 lvaluevar
lvaluevar: {
    .label screen = 3
    .label i = 2
  //SEG18 [8] phi from lvaluevar to lvaluevar::@1
  b1_from_lvaluevar:
  //SEG19 [8] phi (byte*) lvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG20 [8] phi (byte) lvaluevar::i#2 = (byte) 2 -- zpby1=coby1 
    lda #$2
    sta i
    jmp b1
  //SEG21 lvaluevar::@1
  b1:
  //SEG22 [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- zpby1_lt_coby1_then_la1 
    lda i
    cmp #$a
    bcc b2
    jmp breturn
  //SEG23 lvaluevar::@return
  breturn:
  //SEG24 [10] return  [ ]
    rts
  //SEG25 lvaluevar::@2
  b2:
  //SEG26 [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$4
    sta (screen),y
  //SEG27 [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG28 [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::i#1 lvaluevar::screen#1 ] -- zpby1=_inc_zpby1 
    inc i
  //SEG29 [8] phi from lvaluevar::@2 to lvaluevar::@1
  b1_from_b2:
  //SEG30 [8] phi (byte*) lvaluevar::screen#2 = (byte*) lvaluevar::screen#1 -- register_copy 
  //SEG31 [8] phi (byte) lvaluevar::i#2 = (byte) lvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG32 rvaluevar
rvaluevar: {
    .label b = 10
    .label screen = 6
    .label i = 5
  //SEG33 [15] phi from rvaluevar to rvaluevar::@1
  b1_from_rvaluevar:
  //SEG34 [15] phi (byte*) rvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG35 [15] phi (byte) rvaluevar::i#2 = (byte) 2 -- zpby1=coby1 
    lda #$2
    sta i
    jmp b1
  //SEG36 rvaluevar::@1
  b1:
  //SEG37 [16] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- zpby1_lt_coby1_then_la1 
    lda i
    cmp #$a
    bcc b2
    jmp breturn
  //SEG38 rvaluevar::@return
  breturn:
  //SEG39 [17] return  [ ]
    rts
  //SEG40 rvaluevar::@2
  b2:
  //SEG41 [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- zpby1=_star_zpptrby1 
    ldy #$0
    lda (screen),y
    sta b
  //SEG42 [19] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG43 [20] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::i#1 rvaluevar::screen#1 ] -- zpby1=_inc_zpby1 
    inc i
  //SEG44 [15] phi from rvaluevar::@2 to rvaluevar::@1
  b1_from_b2:
  //SEG45 [15] phi (byte*) rvaluevar::screen#2 = (byte*) rvaluevar::screen#1 -- register_copy 
  //SEG46 [15] phi (byte) rvaluevar::i#2 = (byte) rvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG47 rvalue
rvalue: {
    .label b = 11
    .label b_1 = 12
    .label b_2 = 13
    .label i = 8
  //SEG48 [21] (byte) rvalue::b#0 ← * (word) 1024 [ ] -- zpby1=_star_cowo1 
    lda $400
    sta b
  //SEG49 [22] (byte) rvalue::b#1 ← * (word) 1025 [ ] -- zpby1=_star_cowo1 
    lda $401
    sta b_1
  //SEG50 [23] phi from rvalue to rvalue::@1
  b1_from_rvalue:
  //SEG51 [23] phi (byte) rvalue::i#2 = (byte) 2 -- zpby1=coby1 
    lda #$2
    sta i
    jmp b1
  //SEG52 rvalue::@1
  b1:
  //SEG53 [24] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ] -- zpby1_lt_coby1_then_la1 
    lda i
    cmp #$a
    bcc b2
    jmp breturn
  //SEG54 rvalue::@return
  breturn:
  //SEG55 [25] return  [ ]
    rts
  //SEG56 rvalue::@2
  b2:
  //SEG57 [26] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ] -- zpby1=cowo1_staridx_zpby2 
    ldx i
    lda $400,x
    sta b_2
  //SEG58 [27] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ] -- zpby1=_inc_zpby1 
    inc i
  //SEG59 [23] phi from rvalue::@2 to rvalue::@1
  b1_from_b2:
  //SEG60 [23] phi (byte) rvalue::i#2 = (byte) rvalue::i#1 -- register_copy 
    jmp b1
}
//SEG61 lvalue
lvalue: {
    .label i = 9
  //SEG62 [28] *((word) 1024) ← (byte) 1 [ ] -- _star_cowo1=coby2 
    lda #$1
    sta $400
  //SEG63 [29] *((word) 1025) ← (byte) 2 [ ] -- _star_cowo1=coby2 
    lda #$2
    sta $401
  //SEG64 [30] phi from lvalue to lvalue::@1
  b1_from_lvalue:
  //SEG65 [30] phi (byte) lvalue::i#2 = (byte) 2 -- zpby1=coby1 
    lda #$2
    sta i
    jmp b1
  //SEG66 lvalue::@1
  b1:
  //SEG67 [31] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ] -- zpby1_lt_coby1_then_la1 
    lda i
    cmp #$a
    bcc b2
    jmp breturn
  //SEG68 lvalue::@return
  breturn:
  //SEG69 [32] return  [ ]
    rts
  //SEG70 lvalue::@2
  b2:
  //SEG71 [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] -- cowo1_staridx_zpby1=coby2 
    lda #$3
    ldx i
    sta $400,x
  //SEG72 [34] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ] -- zpby1=_inc_zpby1 
    inc i
  //SEG73 [30] phi from lvalue::@2 to lvalue::@1
  b1_from_b2:
  //SEG74 [30] phi (byte) lvalue::i#2 = (byte) lvalue::i#1 -- register_copy 
    jmp b1
}

Statement [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ lvaluevar::i#2 lvaluevar::i#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ lvaluevar::i#2 lvaluevar::i#1 ]
Statement [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ rvaluevar::i#2 rvaluevar::i#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:5 [ rvaluevar::i#2 rvaluevar::i#1 ]
Statement [28] *((word) 1024) ← (byte) 1 [ ] always clobbers reg byte a 
Statement [29] *((word) 1025) ← (byte) 2 [ ] always clobbers reg byte a 
Statement [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ lvalue::i#2 lvalue::i#1 ]
Statement [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] always clobbers reg byte a reg byte y 
Statement [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] always clobbers reg byte a reg byte y 
Statement [28] *((word) 1024) ← (byte) 1 [ ] always clobbers reg byte a 
Statement [29] *((word) 1025) ← (byte) 2 [ ] always clobbers reg byte a 
Statement [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] always clobbers reg byte a 
REGISTER UPLIFT POTENTIAL REGISTERS
Potential registers zp ZP_BYTE:2 [ lvaluevar::i#2 lvaluevar::i#1 ] : zp ZP_BYTE:2 , reg byte x , 
Potential registers zp ZP_PTR_BYTE:3 [ lvaluevar::screen#2 lvaluevar::screen#1 ] : zp ZP_PTR_BYTE:3 , 
Potential registers zp ZP_BYTE:5 [ rvaluevar::i#2 rvaluevar::i#1 ] : zp ZP_BYTE:5 , reg byte x , 
Potential registers zp ZP_PTR_BYTE:6 [ rvaluevar::screen#2 rvaluevar::screen#1 ] : zp ZP_PTR_BYTE:6 , 
Potential registers zp ZP_BYTE:8 [ rvalue::i#2 rvalue::i#1 ] : zp ZP_BYTE:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ lvalue::i#2 lvalue::i#1 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ rvaluevar::b#0 ] : zp ZP_BYTE:10 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:11 [ rvalue::b#0 ] : zp ZP_BYTE:11 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ rvalue::b#1 ] : zp ZP_BYTE:12 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ rvalue::b#2 ] : zp ZP_BYTE:13 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [rvalue] 110: zp ZP_BYTE:13 [ rvalue::b#2 ] 36.67: zp ZP_BYTE:8 [ rvalue::i#2 rvalue::i#1 ] 20: zp ZP_BYTE:11 [ rvalue::b#0 ] 20: zp ZP_BYTE:12 [ rvalue::b#1 ] 
Uplift Scope [rvaluevar] 110: zp ZP_BYTE:10 [ rvaluevar::b#0 ] 30.25: zp ZP_BYTE:5 [ rvaluevar::i#2 rvaluevar::i#1 ] 22: zp ZP_PTR_BYTE:6 [ rvaluevar::screen#2 rvaluevar::screen#1 ] 
Uplift Scope [lvaluevar] 30.25: zp ZP_BYTE:2 [ lvaluevar::i#2 lvaluevar::i#1 ] 22: zp ZP_PTR_BYTE:3 [ lvaluevar::screen#2 lvaluevar::screen#1 ] 
Uplift Scope [lvalue] 36.67: zp ZP_BYTE:9 [ lvalue::i#2 lvalue::i#1 ] 
Uplift Scope [main] 
Uplift Scope [] 

Uplifting [rvalue] best 1865 combination reg byte a [ rvalue::b#2 ] reg byte x [ rvalue::i#2 rvalue::i#1 ] reg byte a [ rvalue::b#0 ] reg byte a [ rvalue::b#1 ] 
Uplifting [rvaluevar] best 1745 combination reg byte a [ rvaluevar::b#0 ] reg byte x [ rvaluevar::i#2 rvaluevar::i#1 ] zp ZP_PTR_BYTE:6 [ rvaluevar::screen#2 rvaluevar::screen#1 ] 
Uplifting [lvaluevar] best 1655 combination reg byte x [ lvaluevar::i#2 lvaluevar::i#1 ] zp ZP_PTR_BYTE:3 [ lvaluevar::screen#2 lvaluevar::screen#1 ] 
Uplifting [lvalue] best 1535 combination reg byte x [ lvalue::i#2 lvalue::i#1 ] 
Uplifting [main] best 1535 combination 
Uplifting [] best 1535 combination 
Coalescing zero page register [ zp ZP_PTR_BYTE:3 [ lvaluevar::screen#2 lvaluevar::screen#1 ] ] with [ zp ZP_PTR_BYTE:6 [ rvaluevar::screen#2 rvaluevar::screen#1 ] ]
Allocated (was zp ZP_PTR_BYTE:3) zp ZP_PTR_BYTE:2 [ lvaluevar::screen#2 lvaluevar::screen#1 rvaluevar::screen#2 rvaluevar::screen#1 ]
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main
main_from_bbegin:
  jsr main
//SEG4 @end
bend:
//SEG5 main
main: {
  //SEG6 [2] call lvalue param-assignment [ ]
    jsr lvalue
  //SEG7 main::@1
  b1:
  //SEG8 [3] call rvalue param-assignment [ ]
    jsr rvalue
  //SEG9 main::@2
  b2:
  //SEG10 [4] call rvaluevar param-assignment [ ]
  //SEG11 [14] phi from main::@2 to rvaluevar
  rvaluevar_from_b2:
    jsr rvaluevar
  //SEG12 main::@3
  b3:
  //SEG13 [5] call lvaluevar param-assignment [ ]
  //SEG14 [7] phi from main::@3 to lvaluevar
  lvaluevar_from_b3:
    jsr lvaluevar
  //SEG15 main::@return
  breturn:
  //SEG16 [6] return  [ ]
    rts
}
//SEG17 lvaluevar
lvaluevar: {
    .label screen = 2
  //SEG18 [8] phi from lvaluevar to lvaluevar::@1
  b1_from_lvaluevar:
  //SEG19 [8] phi (byte*) lvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG20 [8] phi (byte) lvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG21 lvaluevar::@1
  b1:
  //SEG22 [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG23 lvaluevar::@return
  breturn:
  //SEG24 [10] return  [ ]
    rts
  //SEG25 lvaluevar::@2
  b2:
  //SEG26 [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$4
    sta (screen),y
  //SEG27 [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG28 [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::i#1 lvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG29 [8] phi from lvaluevar::@2 to lvaluevar::@1
  b1_from_b2:
  //SEG30 [8] phi (byte*) lvaluevar::screen#2 = (byte*) lvaluevar::screen#1 -- register_copy 
  //SEG31 [8] phi (byte) lvaluevar::i#2 = (byte) lvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG32 rvaluevar
rvaluevar: {
    .label screen = 2
  //SEG33 [15] phi from rvaluevar to rvaluevar::@1
  b1_from_rvaluevar:
  //SEG34 [15] phi (byte*) rvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG35 [15] phi (byte) rvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG36 rvaluevar::@1
  b1:
  //SEG37 [16] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG38 rvaluevar::@return
  breturn:
  //SEG39 [17] return  [ ]
    rts
  //SEG40 rvaluevar::@2
  b2:
  //SEG41 [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- aby=_star_zpptrby1 
    ldy #$0
    lda (screen),y
  //SEG42 [19] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG43 [20] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::i#1 rvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG44 [15] phi from rvaluevar::@2 to rvaluevar::@1
  b1_from_b2:
  //SEG45 [15] phi (byte*) rvaluevar::screen#2 = (byte*) rvaluevar::screen#1 -- register_copy 
  //SEG46 [15] phi (byte) rvaluevar::i#2 = (byte) rvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG47 rvalue
rvalue: {
  //SEG48 [21] (byte) rvalue::b#0 ← * (word) 1024 [ ] -- aby=_star_cowo1 
    lda $400
  //SEG49 [22] (byte) rvalue::b#1 ← * (word) 1025 [ ] -- aby=_star_cowo1 
    lda $401
  //SEG50 [23] phi from rvalue to rvalue::@1
  b1_from_rvalue:
  //SEG51 [23] phi (byte) rvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG52 rvalue::@1
  b1:
  //SEG53 [24] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG54 rvalue::@return
  breturn:
  //SEG55 [25] return  [ ]
    rts
  //SEG56 rvalue::@2
  b2:
  //SEG57 [26] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ] -- aby=cowo1_staridx_xby 
    lda $400,x
  //SEG58 [27] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG59 [23] phi from rvalue::@2 to rvalue::@1
  b1_from_b2:
  //SEG60 [23] phi (byte) rvalue::i#2 = (byte) rvalue::i#1 -- register_copy 
    jmp b1
}
//SEG61 lvalue
lvalue: {
  //SEG62 [28] *((word) 1024) ← (byte) 1 [ ] -- _star_cowo1=coby2 
    lda #$1
    sta $400
  //SEG63 [29] *((word) 1025) ← (byte) 2 [ ] -- _star_cowo1=coby2 
    lda #$2
    sta $401
  //SEG64 [30] phi from lvalue to lvalue::@1
  b1_from_lvalue:
  //SEG65 [30] phi (byte) lvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG66 lvalue::@1
  b1:
  //SEG67 [31] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG68 lvalue::@return
  breturn:
  //SEG69 [32] return  [ ]
    rts
  //SEG70 lvalue::@2
  b2:
  //SEG71 [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] -- cowo1_staridx_xby=coby2 
    lda #$3
    sta $400,x
  //SEG72 [34] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG73 [30] phi from lvalue::@2 to lvalue::@1
  b1_from_b2:
  //SEG74 [30] phi (byte) lvalue::i#2 = (byte) lvalue::i#1 -- register_copy 
    jmp b1
}

Removing instruction main_from_bbegin:
Removing instruction rvaluevar_from_b2:
Removing instruction lvaluevar_from_b3:
Succesful ASM optimization Pass5RedundantLabelElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
bbegin:
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main
  jsr main
//SEG4 @end
bend:
//SEG5 main
main: {
  //SEG6 [2] call lvalue param-assignment [ ]
    jsr lvalue
  //SEG7 main::@1
  b1:
  //SEG8 [3] call rvalue param-assignment [ ]
    jsr rvalue
  //SEG9 main::@2
  b2:
  //SEG10 [4] call rvaluevar param-assignment [ ]
  //SEG11 [14] phi from main::@2 to rvaluevar
    jsr rvaluevar
  //SEG12 main::@3
  b3:
  //SEG13 [5] call lvaluevar param-assignment [ ]
  //SEG14 [7] phi from main::@3 to lvaluevar
    jsr lvaluevar
  //SEG15 main::@return
  breturn:
  //SEG16 [6] return  [ ]
    rts
}
//SEG17 lvaluevar
lvaluevar: {
    .label screen = 2
  //SEG18 [8] phi from lvaluevar to lvaluevar::@1
  b1_from_lvaluevar:
  //SEG19 [8] phi (byte*) lvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG20 [8] phi (byte) lvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG21 lvaluevar::@1
  b1:
  //SEG22 [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG23 lvaluevar::@return
  breturn:
  //SEG24 [10] return  [ ]
    rts
  //SEG25 lvaluevar::@2
  b2:
  //SEG26 [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$4
    sta (screen),y
  //SEG27 [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG28 [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::i#1 lvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG29 [8] phi from lvaluevar::@2 to lvaluevar::@1
  b1_from_b2:
  //SEG30 [8] phi (byte*) lvaluevar::screen#2 = (byte*) lvaluevar::screen#1 -- register_copy 
  //SEG31 [8] phi (byte) lvaluevar::i#2 = (byte) lvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG32 rvaluevar
rvaluevar: {
    .label screen = 2
  //SEG33 [15] phi from rvaluevar to rvaluevar::@1
  b1_from_rvaluevar:
  //SEG34 [15] phi (byte*) rvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG35 [15] phi (byte) rvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG36 rvaluevar::@1
  b1:
  //SEG37 [16] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG38 rvaluevar::@return
  breturn:
  //SEG39 [17] return  [ ]
    rts
  //SEG40 rvaluevar::@2
  b2:
  //SEG41 [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- aby=_star_zpptrby1 
    ldy #$0
    lda (screen),y
  //SEG42 [19] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG43 [20] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::i#1 rvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG44 [15] phi from rvaluevar::@2 to rvaluevar::@1
  b1_from_b2:
  //SEG45 [15] phi (byte*) rvaluevar::screen#2 = (byte*) rvaluevar::screen#1 -- register_copy 
  //SEG46 [15] phi (byte) rvaluevar::i#2 = (byte) rvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG47 rvalue
rvalue: {
  //SEG48 [21] (byte) rvalue::b#0 ← * (word) 1024 [ ] -- aby=_star_cowo1 
    lda $400
  //SEG49 [22] (byte) rvalue::b#1 ← * (word) 1025 [ ] -- aby=_star_cowo1 
    lda $401
  //SEG50 [23] phi from rvalue to rvalue::@1
  b1_from_rvalue:
  //SEG51 [23] phi (byte) rvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG52 rvalue::@1
  b1:
  //SEG53 [24] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG54 rvalue::@return
  breturn:
  //SEG55 [25] return  [ ]
    rts
  //SEG56 rvalue::@2
  b2:
  //SEG57 [26] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ] -- aby=cowo1_staridx_xby 
    lda $400,x
  //SEG58 [27] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG59 [23] phi from rvalue::@2 to rvalue::@1
  b1_from_b2:
  //SEG60 [23] phi (byte) rvalue::i#2 = (byte) rvalue::i#1 -- register_copy 
    jmp b1
}
//SEG61 lvalue
lvalue: {
  //SEG62 [28] *((word) 1024) ← (byte) 1 [ ] -- _star_cowo1=coby2 
    lda #$1
    sta $400
  //SEG63 [29] *((word) 1025) ← (byte) 2 [ ] -- _star_cowo1=coby2 
    lda #$2
    sta $401
  //SEG64 [30] phi from lvalue to lvalue::@1
  b1_from_lvalue:
  //SEG65 [30] phi (byte) lvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG66 lvalue::@1
  b1:
  //SEG67 [31] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG68 lvalue::@return
  breturn:
  //SEG69 [32] return  [ ]
    rts
  //SEG70 lvalue::@2
  b2:
  //SEG71 [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] -- cowo1_staridx_xby=coby2 
    lda #$3
    sta $400,x
  //SEG72 [34] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG73 [30] phi from lvalue::@2 to lvalue::@1
  b1_from_b2:
  //SEG74 [30] phi (byte) lvalue::i#2 = (byte) lvalue::i#1 -- register_copy 
    jmp b1
}

Removing instruction bbegin:
Removing instruction bend:
Removing instruction b1:
Removing instruction b2:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b1_from_lvaluevar:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction b1_from_rvaluevar:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction b1_from_rvalue:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction b1_from_lvalue:
Removing instruction breturn:
Removing instruction b1_from_b2:
Succesful ASM optimization Pass5UnusedLabelElimination
ASSEMBLER
//SEG0 Global ZP labels
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main
  jsr main
//SEG4 @end
//SEG5 main
main: {
  //SEG6 [2] call lvalue param-assignment [ ]
    jsr lvalue
  //SEG7 main::@1
  //SEG8 [3] call rvalue param-assignment [ ]
    jsr rvalue
  //SEG9 main::@2
  //SEG10 [4] call rvaluevar param-assignment [ ]
  //SEG11 [14] phi from main::@2 to rvaluevar
    jsr rvaluevar
  //SEG12 main::@3
  //SEG13 [5] call lvaluevar param-assignment [ ]
  //SEG14 [7] phi from main::@3 to lvaluevar
    jsr lvaluevar
  //SEG15 main::@return
  //SEG16 [6] return  [ ]
    rts
}
//SEG17 lvaluevar
lvaluevar: {
    .label screen = 2
  //SEG18 [8] phi from lvaluevar to lvaluevar::@1
  //SEG19 [8] phi (byte*) lvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG20 [8] phi (byte) lvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG21 lvaluevar::@1
  b1:
  //SEG22 [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG23 lvaluevar::@return
  //SEG24 [10] return  [ ]
    rts
  //SEG25 lvaluevar::@2
  b2:
  //SEG26 [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$4
    sta (screen),y
  //SEG27 [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG28 [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::i#1 lvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG29 [8] phi from lvaluevar::@2 to lvaluevar::@1
  //SEG30 [8] phi (byte*) lvaluevar::screen#2 = (byte*) lvaluevar::screen#1 -- register_copy 
  //SEG31 [8] phi (byte) lvaluevar::i#2 = (byte) lvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG32 rvaluevar
rvaluevar: {
    .label screen = 2
  //SEG33 [15] phi from rvaluevar to rvaluevar::@1
  //SEG34 [15] phi (byte*) rvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG35 [15] phi (byte) rvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG36 rvaluevar::@1
  b1:
  //SEG37 [16] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG38 rvaluevar::@return
  //SEG39 [17] return  [ ]
    rts
  //SEG40 rvaluevar::@2
  b2:
  //SEG41 [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- aby=_star_zpptrby1 
    ldy #$0
    lda (screen),y
  //SEG42 [19] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG43 [20] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::i#1 rvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG44 [15] phi from rvaluevar::@2 to rvaluevar::@1
  //SEG45 [15] phi (byte*) rvaluevar::screen#2 = (byte*) rvaluevar::screen#1 -- register_copy 
  //SEG46 [15] phi (byte) rvaluevar::i#2 = (byte) rvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG47 rvalue
rvalue: {
  //SEG48 [21] (byte) rvalue::b#0 ← * (word) 1024 [ ] -- aby=_star_cowo1 
    lda $400
  //SEG49 [22] (byte) rvalue::b#1 ← * (word) 1025 [ ] -- aby=_star_cowo1 
    lda $401
  //SEG50 [23] phi from rvalue to rvalue::@1
  //SEG51 [23] phi (byte) rvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG52 rvalue::@1
  b1:
  //SEG53 [24] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG54 rvalue::@return
  //SEG55 [25] return  [ ]
    rts
  //SEG56 rvalue::@2
  b2:
  //SEG57 [26] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ] -- aby=cowo1_staridx_xby 
    lda $400,x
  //SEG58 [27] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG59 [23] phi from rvalue::@2 to rvalue::@1
  //SEG60 [23] phi (byte) rvalue::i#2 = (byte) rvalue::i#1 -- register_copy 
    jmp b1
}
//SEG61 lvalue
lvalue: {
  //SEG62 [28] *((word) 1024) ← (byte) 1 [ ] -- _star_cowo1=coby2 
    lda #$1
    sta $400
  //SEG63 [29] *((word) 1025) ← (byte) 2 [ ] -- _star_cowo1=coby2 
    lda #$2
    sta $401
  //SEG64 [30] phi from lvalue to lvalue::@1
  //SEG65 [30] phi (byte) lvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG66 lvalue::@1
  b1:
  //SEG67 [31] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG68 lvalue::@return
  //SEG69 [32] return  [ ]
    rts
  //SEG70 lvalue::@2
  b2:
  //SEG71 [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] -- cowo1_staridx_xby=coby2 
    lda #$3
    sta $400,x
  //SEG72 [34] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG73 [30] phi from lvalue::@2 to lvalue::@1
  //SEG74 [30] phi (byte) lvalue::i#2 = (byte) lvalue::i#1 -- register_copy 
    jmp b1
}

FINAL SYMBOL TABLE
(label) @begin
(label) @end
(void()) lvalue()
(label) lvalue::@1
(label) lvalue::@2
(label) lvalue::@return
(byte[1024]) lvalue::SCREEN
(byte) lvalue::i
(byte) lvalue::i#1 reg byte x 22.0
(byte) lvalue::i#2 reg byte x 14.666666666666666
(void()) lvaluevar()
(label) lvaluevar::@1
(label) lvaluevar::@2
(label) lvaluevar::@return
(byte) lvaluevar::b
(byte) lvaluevar::i
(byte) lvaluevar::i#1 reg byte x 22.0
(byte) lvaluevar::i#2 reg byte x 8.25
(byte*) lvaluevar::screen
(byte*) lvaluevar::screen#1 screen zp ZP_PTR_BYTE:2 11.0
(byte*) lvaluevar::screen#2 screen zp ZP_PTR_BYTE:2 11.0
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(void()) rvalue()
(label) rvalue::@1
(label) rvalue::@2
(label) rvalue::@return
(byte[1024]) rvalue::SCREEN
(byte) rvalue::b
(byte) rvalue::b#0 reg byte a 20.0
(byte) rvalue::b#1 reg byte a 20.0
(byte) rvalue::b#2 reg byte a 110.0
(byte) rvalue::i
(byte) rvalue::i#1 reg byte x 22.0
(byte) rvalue::i#2 reg byte x 14.666666666666666
(void()) rvaluevar()
(label) rvaluevar::@1
(label) rvaluevar::@2
(label) rvaluevar::@return
(byte) rvaluevar::b
(byte) rvaluevar::b#0 reg byte a 110.0
(byte) rvaluevar::i
(byte) rvaluevar::i#1 reg byte x 22.0
(byte) rvaluevar::i#2 reg byte x 8.25
(byte*) rvaluevar::screen
(byte*) rvaluevar::screen#1 screen zp ZP_PTR_BYTE:2 11.0
(byte*) rvaluevar::screen#2 screen zp ZP_PTR_BYTE:2 11.0

reg byte x [ lvaluevar::i#2 lvaluevar::i#1 ]
zp ZP_PTR_BYTE:2 [ lvaluevar::screen#2 lvaluevar::screen#1 rvaluevar::screen#2 rvaluevar::screen#1 ]
reg byte x [ rvaluevar::i#2 rvaluevar::i#1 ]
reg byte x [ rvalue::i#2 rvalue::i#1 ]
reg byte x [ lvalue::i#2 lvalue::i#1 ]
reg byte a [ rvaluevar::b#0 ]
reg byte a [ rvalue::b#0 ]
reg byte a [ rvalue::b#1 ]
reg byte a [ rvalue::b#2 ]

FINAL CODE
//SEG0 Global ZP labels
//SEG1 @begin
//SEG2 [0] call main param-assignment [ ]
//SEG3 [1] phi from @begin to main
  jsr main
//SEG4 @end
//SEG5 main
main: {
  //SEG6 [2] call lvalue param-assignment [ ]
    jsr lvalue
  //SEG7 main::@1
  //SEG8 [3] call rvalue param-assignment [ ]
    jsr rvalue
  //SEG9 main::@2
  //SEG10 [4] call rvaluevar param-assignment [ ]
  //SEG11 [14] phi from main::@2 to rvaluevar
    jsr rvaluevar
  //SEG12 main::@3
  //SEG13 [5] call lvaluevar param-assignment [ ]
  //SEG14 [7] phi from main::@3 to lvaluevar
    jsr lvaluevar
  //SEG15 main::@return
  //SEG16 [6] return  [ ]
    rts
}
//SEG17 lvaluevar
lvaluevar: {
    .label screen = 2
  //SEG18 [8] phi from lvaluevar to lvaluevar::@1
  //SEG19 [8] phi (byte*) lvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG20 [8] phi (byte) lvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG21 lvaluevar::@1
  b1:
  //SEG22 [9] if((byte) lvaluevar::i#2<(byte) 10) goto lvaluevar::@2 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG23 lvaluevar::@return
  //SEG24 [10] return  [ ]
    rts
  //SEG25 lvaluevar::@2
  b2:
  //SEG26 [11] *((byte*) lvaluevar::screen#2) ← (byte) 4 [ lvaluevar::i#2 lvaluevar::screen#2 ] -- _star_zpptrby1=coby1 
    ldy #$0
    lda #$4
    sta (screen),y
  //SEG27 [12] (byte*) lvaluevar::screen#1 ← ++ (byte*) lvaluevar::screen#2 [ lvaluevar::i#2 lvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG28 [13] (byte) lvaluevar::i#1 ← ++ (byte) lvaluevar::i#2 [ lvaluevar::i#1 lvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG29 [8] phi from lvaluevar::@2 to lvaluevar::@1
  //SEG30 [8] phi (byte*) lvaluevar::screen#2 = (byte*) lvaluevar::screen#1 -- register_copy 
  //SEG31 [8] phi (byte) lvaluevar::i#2 = (byte) lvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG32 rvaluevar
rvaluevar: {
    .label screen = 2
  //SEG33 [15] phi from rvaluevar to rvaluevar::@1
  //SEG34 [15] phi (byte*) rvaluevar::screen#2 = (word) 1024 -- zpptrby1=cowo1 
    lda #<$400
    sta screen
    lda #>$400
    sta screen+$1
  //SEG35 [15] phi (byte) rvaluevar::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG36 rvaluevar::@1
  b1:
  //SEG37 [16] if((byte) rvaluevar::i#2<(byte) 10) goto rvaluevar::@2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG38 rvaluevar::@return
  //SEG39 [17] return  [ ]
    rts
  //SEG40 rvaluevar::@2
  b2:
  //SEG41 [18] (byte) rvaluevar::b#0 ← * (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#2 ] -- aby=_star_zpptrby1 
    ldy #$0
    lda (screen),y
  //SEG42 [19] (byte*) rvaluevar::screen#1 ← ++ (byte*) rvaluevar::screen#2 [ rvaluevar::i#2 rvaluevar::screen#1 ] -- zpptrby1=_inc_zpptrby1 
    inc screen
    bne !+
    inc screen+$1
  !:
  //SEG43 [20] (byte) rvaluevar::i#1 ← ++ (byte) rvaluevar::i#2 [ rvaluevar::i#1 rvaluevar::screen#1 ] -- xby=_inc_xby 
    inx
  //SEG44 [15] phi from rvaluevar::@2 to rvaluevar::@1
  //SEG45 [15] phi (byte*) rvaluevar::screen#2 = (byte*) rvaluevar::screen#1 -- register_copy 
  //SEG46 [15] phi (byte) rvaluevar::i#2 = (byte) rvaluevar::i#1 -- register_copy 
    jmp b1
}
//SEG47 rvalue
rvalue: {
  //SEG48 [21] (byte) rvalue::b#0 ← * (word) 1024 [ ] -- aby=_star_cowo1 
    lda $400
  //SEG49 [22] (byte) rvalue::b#1 ← * (word) 1025 [ ] -- aby=_star_cowo1 
    lda $401
  //SEG50 [23] phi from rvalue to rvalue::@1
  //SEG51 [23] phi (byte) rvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG52 rvalue::@1
  b1:
  //SEG53 [24] if((byte) rvalue::i#2<(byte) 10) goto rvalue::@2 [ rvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG54 rvalue::@return
  //SEG55 [25] return  [ ]
    rts
  //SEG56 rvalue::@2
  b2:
  //SEG57 [26] (byte) rvalue::b#2 ← (word) 1024 *idx (byte) rvalue::i#2 [ rvalue::i#2 ] -- aby=cowo1_staridx_xby 
    lda $400,x
  //SEG58 [27] (byte) rvalue::i#1 ← ++ (byte) rvalue::i#2 [ rvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG59 [23] phi from rvalue::@2 to rvalue::@1
  //SEG60 [23] phi (byte) rvalue::i#2 = (byte) rvalue::i#1 -- register_copy 
    jmp b1
}
//SEG61 lvalue
lvalue: {
  //SEG62 [28] *((word) 1024) ← (byte) 1 [ ] -- _star_cowo1=coby2 
    lda #$1
    sta $400
  //SEG63 [29] *((word) 1025) ← (byte) 2 [ ] -- _star_cowo1=coby2 
    lda #$2
    sta $401
  //SEG64 [30] phi from lvalue to lvalue::@1
  //SEG65 [30] phi (byte) lvalue::i#2 = (byte) 2 -- xby=coby1 
    ldx #$2
  //SEG66 lvalue::@1
  b1:
  //SEG67 [31] if((byte) lvalue::i#2<(byte) 10) goto lvalue::@2 [ lvalue::i#2 ] -- xby_lt_coby1_then_la1 
    cpx #$a
    bcc b2
  //SEG68 lvalue::@return
  //SEG69 [32] return  [ ]
    rts
  //SEG70 lvalue::@2
  b2:
  //SEG71 [33] *((word) 1024 + (byte) lvalue::i#2) ← (byte) 3 [ lvalue::i#2 ] -- cowo1_staridx_xby=coby2 
    lda #$3
    sta $400,x
  //SEG72 [34] (byte) lvalue::i#1 ← ++ (byte) lvalue::i#2 [ lvalue::i#1 ] -- xby=_inc_xby 
    inx
  //SEG73 [30] phi from lvalue::@2 to lvalue::@1
  //SEG74 [30] phi (byte) lvalue::i#2 = (byte) lvalue::i#1 -- register_copy 
    jmp b1
}

