// Commodore 64 Registers and Constants

// Processor port data direction register
const byte* PROCPORT_DDR = $00;
// Mask for PROCESSOR_PORT_DDR which allows only memory configuration to be written
const byte PROCPORT_DDR_MEMORY_MASK = %00000111;

// Processor Port Register controlling RAM/ROM configuration and the datasette
const byte* PROCPORT = $01;
// RAM in all three areas $A000, $D000, $E000
const byte PROCPORT_RAM_ALL         = %00110000;
// RAM in $A000, $E000 I/O in $D000
const byte PROCPORT_RAM_IO          = %00110101;
// RAM in $A000, $E000 CHAR ROM in $D000
const byte PROCPORT_RAM_CHARROM     = %00110001;
// RAM in $A000, I/O in $D000, KERNEL in $E000
const byte PROCPORT_KERNEL_IO       = %00110110;
// BASIC in $A000, I/O in $D000, KERNEL in $E000
const byte PROCPORT_BASIC_KERNEL_IO = %00110111;

// The address of the CHARGEN character set
const byte* CHARGEN = $d000;

// The offset of the sprite pointers from the screen start address
const word SPRITE_PTRS = $3f8;

const byte* SPRITES_XPOS = $d000;
const byte* SPRITES_YPOS = $d001;
const byte* SPRITES_XMSB = $d010;
const byte* RASTER = $d012;
const byte* SPRITES_ENABLE = $d015;
const byte* SPRITES_EXPAND_Y = $d017;
const byte* SPRITES_PRIORITY = $d01b;
const byte* SPRITES_MC = $d01c;
const byte* SPRITES_EXPAND_X = $d01d;
const byte* BORDERCOL = $d020;
const byte* BGCOL = $d021;
const byte* BGCOL1 = $d021;
const byte* BGCOL2 = $d022;
const byte* BGCOL3 = $d023;
const byte* BGCOL4 = $d024;
const byte* SPRITES_MC1 = $d025;
const byte* SPRITES_MC2 = $d026;
const byte* SPRITES_COLS = $d027;

const byte* VIC_CONTROL = $d011;
const byte* D011 = $d011;
const byte VIC_RST8 = %10000000;
const byte VIC_ECM =  %01000000;
const byte VIC_BMM =  %00100000;
const byte VIC_DEN =  %00010000;
const byte VIC_RSEL = %00001000;

const byte* VIC_CONTROL2 = $d016;
const byte* D016 = $d016;
const byte VIC_MCM =  %00010000;
const byte VIC_CSEL = %00001000;

const byte* D018 = $d018;
const byte* VIC_MEMORY = $d018;

const byte* LIGHTPEN_X = $d013;
const byte* LIGHTPEN_Y = $d014;

// VIC II IRQ Status Register
const byte* IRQ_STATUS = $d019;
// VIC II IRQ Enable Register
const byte* IRQ_ENABLE = $d01a;
// Bits for the IRQ Status/Enable Registers
const byte IRQ_RASTER = %00000001;
const byte IRQ_COLLISION_BG = %00000010;
const byte IRQ_COLLISION_SPRITE = %00000100;
const byte IRQ_LIGHTPEN = %00001000;

// Color Ram
const byte* COLS = $d800;

// CIA#1 Port A: keyboard matrix columns and joystick #2
const byte* CIA1_PORT_A = $dc00;
// CIA#1 Port B: keyboard matrix rows and joystick #1.
const byte* CIA1_PORT_B = $dc01;
// CIA #1 Port A data direction register.
const byte* CIA1_PORT_A_DDR = $dc02;
// CIA #1 Port B data direction register.
const byte* CIA1_PORT_B_DDR = $dc03;
// CIA#1 Interrupt Status & Control Register
const byte* CIA1_INTERRUPT = $dc0d;
// Value that disables all CIA interrupts when stored to the CIA Interrupt registers
const byte CIA_INTERRUPT_CLEAR = $7f;

// CIA#2 Port A: Serial bus, RS-232, VIC memory bank
const byte* CIA2_PORT_A = $dd00;
// CIA#2 Port B: RS-232
const byte* CIA2_PORT_B = $dd01;
// CIA #2 Port A data direction register.
const byte* CIA2_PORT_A_DDR = $dd02;
// CIA #2 Port B data direction register.
const byte* CIA2_PORT_B_DDR = $dd03;
// CIA#2 Interrupt Status & Control Register
const byte* CIA2_INTERRUPT = $dd0d;

// The vector used when the KERNAL serves IRQ interrupts
const void()** KERNEL_IRQ = $0314;

// The vector used when the HARDWARE serves IRQ interrupts
const void()** HARDWARE_IRQ = $fffe;

// The colors of the C64
const byte BLACK = $0;
const byte WHITE = $1;
const byte RED = $2;
const byte CYAN = $3;
const byte PURPLE = $4;
const byte GREEN = $5;
const byte BLUE = $6;
const byte YELLOW = $7;
const byte ORANGE = $8;
const byte BROWN = $9;
const byte PINK = $a;
const byte DARK_GREY= $b;
const byte GREY = $c;
const byte LIGHT_GREEN = $d;
const byte LIGHT_BLUE = $e;
const byte LIGHT_GREY = $f;

// Get the value to store into D018 to display a specific screen and charset/bitmap
// Optimized for ASM from (byte)((((word)screen&$3fff)/$40)|(((word)charset&$3fff)/$400));
inline byte toD018(byte* screen, byte* gfx) {
    return (>((((word)screen&$3fff)*4)))|(((>((word)gfx))/4)&$f);
}

// Get the value to store into DD00 (CIA 2 port A) to choose a specific VIC bank
// Optimized for ASM from %00000011 ^ (byte)((word)gfx/$4000)
inline byte toDd00(byte* gfx) {
    return %00000011 ^ (>((word)gfx))/$40;
}

// Get the sprite pointer for a sprite.
// The sprite pointer is the index of the sprite within the graphics bank and equal to the sprite (byte)(sprite_addr/64)
// The sprite pointers are stored SCREEN+$3f8+sprite_id to set the pointer of each sprite
inline byte toSpritePtr(byte* sprite) {
	return (byte)(((word)sprite)/$40);
}

// Select a specific VIC graphics bank by setting the CIA 2 port A ($dd00) as needed
inline void vicSelectGfxBank(byte* gfx) {
    *CIA2_PORT_A_DDR = %00000011;
    *CIA2_PORT_A = toDd00(gfx);
}
