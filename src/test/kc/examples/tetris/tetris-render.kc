import "tetris-data"

kickasm(pc PLAYFIELD_CHARSET, resource "nes-screen.imap") {{
    .fill 8,$00 // Place a filled char at the start of the charset
    .import binary "nes-screen.imap"
}}

const byte PLAYFIELD_SCREEN_ORIGINAL_WIDTH=32;
const byte* PLAYFIELD_SCREEN_ORIGINAL = $2c00;
// Address of the screen data original
kickasm(pc PLAYFIELD_SCREEN_ORIGINAL, resource "nes-screen.iscr") {{
  .import binary "nes-screen.iscr"
}}


// Pointers to the screen address for rendering each playfield line
byte*[PLAYFIELD_LINES] screen_lines;

// Initialize rendering
void render_init() {
	vicSelectGfxBank(PLAYFIELD_SCREEN);
	*D018 = toD018(PLAYFIELD_SCREEN, PLAYFIELD_CHARSET);
	// Enable Extended Background Color Mode
	*D011 = VIC_ECM | VIC_DEN | VIC_RSEL | 3;
	*BGCOL1 = BLACK;
	*BGCOL2 = BLUE;
	*BGCOL3 = CYAN;
	*BGCOL4 = GREY;
	fill(COLS,1000,DARK_GREY);
	render_screen_original(PLAYFIELD_SCREEN);

	// Initialize the screen line pointers;

	byte* li = PLAYFIELD_SCREEN + 2*40 + 16;
	for(byte i:0..PLAYFIELD_LINES-1) {
		screen_lines[i<<1] = li;
		li += 40;
	}
	// Fill the playfield frame with the white background color
	byte* line = COLS + 4*40 + 16;
	for(byte l:2..PLAYFIELD_LINES-1) {
		for(byte c:0..PLAYFIELD_COLS-1) {
			*(line+c) = WHITE;
		}
		line +=40;
	}

}

// Copy the original screen data to the passed screen
void render_screen_original(byte* screen) {
    byte SPACE = 0;
	byte* orig = PLAYFIELD_SCREEN_ORIGINAL+32*2;
	for(byte y:0..24) {
	    byte x=0;
	    do {
	        *screen++ = SPACE;
	    } while(++x!=4);
	    do {
	        *screen++ = (*orig++)+1; // +$c0 to get grey background, +1 because the charset is loaded to PLAYFIELD_CHARSET+8
	    } while(++x!=36);
	    do {
	        *screen++ = SPACE;
	    } while(++x!=40);
	}
}

// Render the static playfield on the screen
void render_playfield() {
	// Do not render the top 2 lines.
	byte i = PLAYFIELD_COLS*2;
	for(byte l:2..PLAYFIELD_LINES-1) {
		byte* screen_line = screen_lines[l<<1];
		for(byte c:0..PLAYFIELD_COLS-1) {
			*(screen_line++) = playfield[i++];
		}
	}
}

// Render the current moving piece at position (current_xpos, current_ypos)
void render_current() {
	byte i = 0;
	byte ypos2 = current_ypos<<1;
	for(byte l:0..3) {
		if(ypos2>2 && ypos2<2*PLAYFIELD_LINES) {
			byte* screen_line = screen_lines[ypos2];
			byte xpos = current_xpos;
			for(byte c:0..3) {
				byte current_cell = current_piece_gfx[i++];
				if(current_cell!=0) {
					if(xpos<PLAYFIELD_COLS) {
						screen_line[xpos] = current_piece_char;
					}
				}
				xpos++;
			}
		} else {
		    i += 4;
		}
		ypos2 += 2;
	}
}