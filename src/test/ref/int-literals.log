Resolving typeid() (byte~) testSimpleTypes::$0 ← typeid  (byte) $c
Resolving typeid() (byte~) testSimpleTypes::$2 ← typeid  (byte) $c
Resolving typeid() (byte~) testSimpleTypes::$4 ← typeid  (signed byte) $c
Resolving typeid() (byte~) testSimpleTypes::$6 ← typeid  (signed byte) $c
Resolving typeid() (byte~) testSimpleTypes::$8 ← typeid  (word) $c
Resolving typeid() (byte~) testSimpleTypes::$10 ← typeid  (word) $c
Resolving typeid() (byte~) testSimpleTypes::$12 ← typeid  (word) $c
Resolving typeid() (byte~) testSimpleTypes::$14 ← typeid  (signed word) $c
Resolving typeid() (byte~) testSimpleTypes::$16 ← typeid  (signed word) $c
Resolving typeid() (byte~) testSimpleTypes::$18 ← typeid  (signed word) $c
Resolving typeid() (byte~) testSimpleTypes::$20 ← typeid  (dword) $c
Resolving typeid() (byte~) testSimpleTypes::$22 ← typeid  (dword) $c
Resolving typeid() (byte~) testSimpleTypes::$24 ← typeid  (signed dword) $c
Resolving typeid() (byte~) testSimpleTypes::$26 ← typeid  (signed dword) $c
Resolving typeid() (byte~) testSimpleTypes::$28 ← typeid  (signed dword) $c
Adding pointer type conversion cast (byte*) SCREEN in (byte*) SCREEN ← (word) $400
Adding pointer type conversion cast (byte*) COLS in (byte*) COLS ← (word) $d800

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte) RED#0 ← (byte) 2
  (byte) GREEN#0 ← (byte) 5
  (word) $0 ← (word) $400
  (byte*) SCREEN#0 ← ((byte*)) (word) $0
  (word) $1 ← (word) $d800
  (byte*) COLS#0 ← ((byte*)) (word) $1
  (byte) idx#0 ← (byte) 0
  to:@3
main: scope:[main]  from @3
  (byte) idx#50 ← phi( @3/(byte) idx#48 )
  (byte*) main::s#0 ← (byte*) SCREEN#0
  to:main::@1
main::@1: scope:[main]  from main main::@1
  (byte) idx#49 ← phi( main/(byte) idx#50 main::@1/(byte) idx#49 )
  (byte*) main::s#2 ← phi( main/(byte*) main::s#0 main::@1/(byte*) main::s#1 )
  *((byte*) main::s#2) ← (byte) ' '
  (byte*) main::s#1 ← ++ (byte*) main::s#2
  (byte*~) main::$1 ← (byte*) SCREEN#0 + (word) $3e8
  (bool~) main::$2 ← (byte*) main::s#1 < (byte*~) main::$1
  if((bool~) main::$2) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte) idx#46 ← phi( main::@1/(byte) idx#49 )
  call testSimpleTypes 
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) idx#23 ← phi( main::@2/(byte) idx#19 )
  (byte) idx#1 ← (byte) idx#23
  to:main::@return
main::@return: scope:[main]  from main::@3
  (byte) idx#24 ← phi( main::@3/(byte) idx#1 )
  (byte) idx#2 ← (byte) idx#24
  return 
  to:@return
testSimpleTypes: scope:[testSimpleTypes]  from main::@2
  (byte) idx#3 ← (byte) 0
  (byte~) testSimpleTypes::$0 ← (const byte) TYPEID_BYTE
  (byte) assertType::t1#0 ← (byte~) testSimpleTypes::$0
  (byte) assertType::t2#0 ← (const byte) TYPEID_BYTE
  call assertType 
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  (byte) idx#25 ← phi( testSimpleTypes/(byte) idx#21 )
  (byte) idx#4 ← (byte) idx#25
  (byte~) testSimpleTypes::$2 ← (const byte) TYPEID_BYTE
  (byte) assertType::t1#1 ← (byte~) testSimpleTypes::$2
  (byte) assertType::t2#1 ← (const byte) TYPEID_BYTE
  call assertType 
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  (byte) idx#26 ← phi( testSimpleTypes::@1/(byte) idx#21 )
  (byte) idx#5 ← (byte) idx#26
  (byte~) testSimpleTypes::$4 ← (const byte) TYPEID_SIGNED_BYTE
  (byte) assertType::t1#2 ← (byte~) testSimpleTypes::$4
  (byte) assertType::t2#2 ← (const byte) TYPEID_SIGNED_BYTE
  call assertType 
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  (byte) idx#27 ← phi( testSimpleTypes::@2/(byte) idx#21 )
  (byte) idx#6 ← (byte) idx#27
  (byte~) testSimpleTypes::$6 ← (const byte) TYPEID_SIGNED_BYTE
  (byte) assertType::t1#3 ← (byte~) testSimpleTypes::$6
  (byte) assertType::t2#3 ← (const byte) TYPEID_SIGNED_BYTE
  call assertType 
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  (byte) idx#28 ← phi( testSimpleTypes::@3/(byte) idx#21 )
  (byte) idx#7 ← (byte) idx#28
  (byte~) testSimpleTypes::$8 ← (const byte) TYPEID_WORD
  (byte) assertType::t1#4 ← (byte~) testSimpleTypes::$8
  (byte) assertType::t2#4 ← (const byte) TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  (byte) idx#29 ← phi( testSimpleTypes::@4/(byte) idx#21 )
  (byte) idx#8 ← (byte) idx#29
  (byte~) testSimpleTypes::$10 ← (const byte) TYPEID_WORD
  (byte) assertType::t1#5 ← (byte~) testSimpleTypes::$10
  (byte) assertType::t2#5 ← (const byte) TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  (byte) idx#30 ← phi( testSimpleTypes::@5/(byte) idx#21 )
  (byte) idx#9 ← (byte) idx#30
  (byte~) testSimpleTypes::$12 ← (const byte) TYPEID_WORD
  (byte) assertType::t1#6 ← (byte~) testSimpleTypes::$12
  (byte) assertType::t2#6 ← (const byte) TYPEID_WORD
  call assertType 
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  (byte) idx#31 ← phi( testSimpleTypes::@6/(byte) idx#21 )
  (byte) idx#10 ← (byte) idx#31
  (byte~) testSimpleTypes::$14 ← (const byte) TYPEID_SIGNED_WORD
  (byte) assertType::t1#7 ← (byte~) testSimpleTypes::$14
  (byte) assertType::t2#7 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  (byte) idx#32 ← phi( testSimpleTypes::@7/(byte) idx#21 )
  (byte) idx#11 ← (byte) idx#32
  (byte~) testSimpleTypes::$16 ← (const byte) TYPEID_SIGNED_WORD
  (byte) assertType::t1#8 ← (byte~) testSimpleTypes::$16
  (byte) assertType::t2#8 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  (byte) idx#33 ← phi( testSimpleTypes::@8/(byte) idx#21 )
  (byte) idx#12 ← (byte) idx#33
  (byte~) testSimpleTypes::$18 ← (const byte) TYPEID_SIGNED_WORD
  (byte) assertType::t1#9 ← (byte~) testSimpleTypes::$18
  (byte) assertType::t2#9 ← (const byte) TYPEID_SIGNED_WORD
  call assertType 
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  (byte) idx#34 ← phi( testSimpleTypes::@9/(byte) idx#21 )
  (byte) idx#13 ← (byte) idx#34
  (byte~) testSimpleTypes::$20 ← (const byte) TYPEID_DWORD
  (byte) assertType::t1#10 ← (byte~) testSimpleTypes::$20
  (byte) assertType::t2#10 ← (const byte) TYPEID_DWORD
  call assertType 
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  (byte) idx#35 ← phi( testSimpleTypes::@10/(byte) idx#21 )
  (byte) idx#14 ← (byte) idx#35
  (byte~) testSimpleTypes::$22 ← (const byte) TYPEID_DWORD
  (byte) assertType::t1#11 ← (byte~) testSimpleTypes::$22
  (byte) assertType::t2#11 ← (const byte) TYPEID_DWORD
  call assertType 
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  (byte) idx#36 ← phi( testSimpleTypes::@11/(byte) idx#21 )
  (byte) idx#15 ← (byte) idx#36
  (byte~) testSimpleTypes::$24 ← (const byte) TYPEID_SIGNED_DWORD
  (byte) assertType::t1#12 ← (byte~) testSimpleTypes::$24
  (byte) assertType::t2#12 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  (byte) idx#37 ← phi( testSimpleTypes::@12/(byte) idx#21 )
  (byte) idx#16 ← (byte) idx#37
  (byte~) testSimpleTypes::$26 ← (const byte) TYPEID_SIGNED_DWORD
  (byte) assertType::t1#13 ← (byte~) testSimpleTypes::$26
  (byte) assertType::t2#13 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  (byte) idx#38 ← phi( testSimpleTypes::@13/(byte) idx#21 )
  (byte) idx#17 ← (byte) idx#38
  (byte~) testSimpleTypes::$28 ← (const byte) TYPEID_SIGNED_DWORD
  (byte) assertType::t1#14 ← (byte~) testSimpleTypes::$28
  (byte) assertType::t2#14 ← (const byte) TYPEID_SIGNED_DWORD
  call assertType 
  to:testSimpleTypes::@15
testSimpleTypes::@15: scope:[testSimpleTypes]  from testSimpleTypes::@14
  (byte) idx#39 ← phi( testSimpleTypes::@14/(byte) idx#21 )
  (byte) idx#18 ← (byte) idx#39
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@15
  (byte) idx#40 ← phi( testSimpleTypes::@15/(byte) idx#18 )
  (byte) idx#19 ← (byte) idx#40
  return 
  to:@return
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  (byte) idx#47 ← phi( testSimpleTypes/(byte) idx#3 testSimpleTypes::@1/(byte) idx#4 testSimpleTypes::@10/(byte) idx#13 testSimpleTypes::@11/(byte) idx#14 testSimpleTypes::@12/(byte) idx#15 testSimpleTypes::@13/(byte) idx#16 testSimpleTypes::@14/(byte) idx#17 testSimpleTypes::@2/(byte) idx#5 testSimpleTypes::@3/(byte) idx#6 testSimpleTypes::@4/(byte) idx#7 testSimpleTypes::@5/(byte) idx#8 testSimpleTypes::@6/(byte) idx#9 testSimpleTypes::@7/(byte) idx#10 testSimpleTypes::@8/(byte) idx#11 testSimpleTypes::@9/(byte) idx#12 )
  (byte) assertType::t2#15 ← phi( testSimpleTypes/(byte) assertType::t2#0 testSimpleTypes::@1/(byte) assertType::t2#1 testSimpleTypes::@10/(byte) assertType::t2#10 testSimpleTypes::@11/(byte) assertType::t2#11 testSimpleTypes::@12/(byte) assertType::t2#12 testSimpleTypes::@13/(byte) assertType::t2#13 testSimpleTypes::@14/(byte) assertType::t2#14 testSimpleTypes::@2/(byte) assertType::t2#2 testSimpleTypes::@3/(byte) assertType::t2#3 testSimpleTypes::@4/(byte) assertType::t2#4 testSimpleTypes::@5/(byte) assertType::t2#5 testSimpleTypes::@6/(byte) assertType::t2#6 testSimpleTypes::@7/(byte) assertType::t2#7 testSimpleTypes::@8/(byte) assertType::t2#8 testSimpleTypes::@9/(byte) assertType::t2#9 )
  (byte) assertType::t1#15 ← phi( testSimpleTypes/(byte) assertType::t1#0 testSimpleTypes::@1/(byte) assertType::t1#1 testSimpleTypes::@10/(byte) assertType::t1#10 testSimpleTypes::@11/(byte) assertType::t1#11 testSimpleTypes::@12/(byte) assertType::t1#12 testSimpleTypes::@13/(byte) assertType::t1#13 testSimpleTypes::@14/(byte) assertType::t1#14 testSimpleTypes::@2/(byte) assertType::t1#2 testSimpleTypes::@3/(byte) assertType::t1#3 testSimpleTypes::@4/(byte) assertType::t1#4 testSimpleTypes::@5/(byte) assertType::t1#5 testSimpleTypes::@6/(byte) assertType::t1#6 testSimpleTypes::@7/(byte) assertType::t1#7 testSimpleTypes::@8/(byte) assertType::t1#8 testSimpleTypes::@9/(byte) assertType::t1#9 )
  (bool~) assertType::$0 ← (byte) assertType::t1#15 == (byte) assertType::t2#15
  if((bool~) assertType::$0) goto assertType::@1
  to:assertType::@3
assertType::@1: scope:[assertType]  from assertType
  (byte) assertType::t1#17 ← phi( assertType/(byte) assertType::t1#15 )
  (byte) idx#41 ← phi( assertType/(byte) idx#47 )
  *((byte*) COLS#0 + (byte) idx#41) ← (byte) GREEN#0
  to:assertType::@2
assertType::@3: scope:[assertType]  from assertType
  (byte) assertType::t1#18 ← phi( assertType/(byte) assertType::t1#15 )
  (byte) idx#42 ← phi( assertType/(byte) idx#47 )
  *((byte*) COLS#0 + (byte) idx#42) ← (byte) RED#0
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  (byte) idx#43 ← phi( assertType::@1/(byte) idx#41 assertType::@3/(byte) idx#42 )
  (byte) assertType::t1#16 ← phi( assertType::@1/(byte) assertType::t1#17 assertType::@3/(byte) assertType::t1#18 )
  *((byte*) SCREEN#0 + (byte) idx#43) ← (byte) assertType::t1#16
  (byte) idx#20 ← ++ (byte) idx#43
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  (byte) idx#44 ← phi( assertType::@2/(byte) idx#20 )
  (byte) idx#21 ← (byte) idx#44
  return 
  to:@return
@3: scope:[]  from @begin
  (byte) idx#48 ← phi( @begin/(byte) idx#0 )
  call main 
  to:@4
@4: scope:[]  from @3
  (byte) idx#45 ← phi( @3/(byte) idx#2 )
  (byte) idx#22 ← (byte) idx#45
  to:@end
@end: scope:[]  from @4

SYMBOL TABLE SSA
(word) $0
(word) $1
(label) @3
(label) @4
(label) @begin
(label) @end
(byte*) COLS
(byte*) COLS#0
(byte) GREEN
(byte) GREEN#0
(byte) RED
(byte) RED#0
(byte*) SCREEN
(byte*) SCREEN#0
(const byte) TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(bool~) assertType::$0
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#0
(byte) assertType::t1#1
(byte) assertType::t1#10
(byte) assertType::t1#11
(byte) assertType::t1#12
(byte) assertType::t1#13
(byte) assertType::t1#14
(byte) assertType::t1#15
(byte) assertType::t1#16
(byte) assertType::t1#17
(byte) assertType::t1#18
(byte) assertType::t1#2
(byte) assertType::t1#3
(byte) assertType::t1#4
(byte) assertType::t1#5
(byte) assertType::t1#6
(byte) assertType::t1#7
(byte) assertType::t1#8
(byte) assertType::t1#9
(byte) assertType::t2
(byte) assertType::t2#0
(byte) assertType::t2#1
(byte) assertType::t2#10
(byte) assertType::t2#11
(byte) assertType::t2#12
(byte) assertType::t2#13
(byte) assertType::t2#14
(byte) assertType::t2#15
(byte) assertType::t2#2
(byte) assertType::t2#3
(byte) assertType::t2#4
(byte) assertType::t2#5
(byte) assertType::t2#6
(byte) assertType::t2#7
(byte) assertType::t2#8
(byte) assertType::t2#9
(byte) idx
(byte) idx#0
(byte) idx#1
(byte) idx#10
(byte) idx#11
(byte) idx#12
(byte) idx#13
(byte) idx#14
(byte) idx#15
(byte) idx#16
(byte) idx#17
(byte) idx#18
(byte) idx#19
(byte) idx#2
(byte) idx#20
(byte) idx#21
(byte) idx#22
(byte) idx#23
(byte) idx#24
(byte) idx#25
(byte) idx#26
(byte) idx#27
(byte) idx#28
(byte) idx#29
(byte) idx#3
(byte) idx#30
(byte) idx#31
(byte) idx#32
(byte) idx#33
(byte) idx#34
(byte) idx#35
(byte) idx#36
(byte) idx#37
(byte) idx#38
(byte) idx#39
(byte) idx#4
(byte) idx#40
(byte) idx#41
(byte) idx#42
(byte) idx#43
(byte) idx#44
(byte) idx#45
(byte) idx#46
(byte) idx#47
(byte) idx#48
(byte) idx#49
(byte) idx#5
(byte) idx#50
(byte) idx#6
(byte) idx#7
(byte) idx#8
(byte) idx#9
(void()) main()
(byte*~) main::$1
(bool~) main::$2
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(byte*) main::s
(byte*) main::s#0
(byte*) main::s#1
(byte*) main::s#2
(void()) testSimpleTypes()
(byte~) testSimpleTypes::$0
(byte~) testSimpleTypes::$10
(byte~) testSimpleTypes::$12
(byte~) testSimpleTypes::$14
(byte~) testSimpleTypes::$16
(byte~) testSimpleTypes::$18
(byte~) testSimpleTypes::$2
(byte~) testSimpleTypes::$20
(byte~) testSimpleTypes::$22
(byte~) testSimpleTypes::$24
(byte~) testSimpleTypes::$26
(byte~) testSimpleTypes::$28
(byte~) testSimpleTypes::$4
(byte~) testSimpleTypes::$6
(byte~) testSimpleTypes::$8
(label) testSimpleTypes::@1
(label) testSimpleTypes::@10
(label) testSimpleTypes::@11
(label) testSimpleTypes::@12
(label) testSimpleTypes::@13
(label) testSimpleTypes::@14
(label) testSimpleTypes::@15
(label) testSimpleTypes::@2
(label) testSimpleTypes::@3
(label) testSimpleTypes::@4
(label) testSimpleTypes::@5
(label) testSimpleTypes::@6
(label) testSimpleTypes::@7
(label) testSimpleTypes::@8
(label) testSimpleTypes::@9
(label) testSimpleTypes::@return

Alias (byte) idx#46 = (byte) idx#49 
Alias (byte) idx#1 = (byte) idx#23 (byte) idx#24 (byte) idx#2 
Alias (byte) assertType::t1#0 = (byte~) testSimpleTypes::$0 
Alias (byte) idx#25 = (byte) idx#4 
Alias (byte) assertType::t1#1 = (byte~) testSimpleTypes::$2 
Alias (byte) idx#26 = (byte) idx#5 
Alias (byte) assertType::t1#2 = (byte~) testSimpleTypes::$4 
Alias (byte) idx#27 = (byte) idx#6 
Alias (byte) assertType::t1#3 = (byte~) testSimpleTypes::$6 
Alias (byte) idx#28 = (byte) idx#7 
Alias (byte) assertType::t1#4 = (byte~) testSimpleTypes::$8 
Alias (byte) idx#29 = (byte) idx#8 
Alias (byte) assertType::t1#5 = (byte~) testSimpleTypes::$10 
Alias (byte) idx#30 = (byte) idx#9 
Alias (byte) assertType::t1#6 = (byte~) testSimpleTypes::$12 
Alias (byte) idx#10 = (byte) idx#31 
Alias (byte) assertType::t1#7 = (byte~) testSimpleTypes::$14 
Alias (byte) idx#11 = (byte) idx#32 
Alias (byte) assertType::t1#8 = (byte~) testSimpleTypes::$16 
Alias (byte) idx#12 = (byte) idx#33 
Alias (byte) assertType::t1#9 = (byte~) testSimpleTypes::$18 
Alias (byte) idx#13 = (byte) idx#34 
Alias (byte) assertType::t1#10 = (byte~) testSimpleTypes::$20 
Alias (byte) idx#14 = (byte) idx#35 
Alias (byte) assertType::t1#11 = (byte~) testSimpleTypes::$22 
Alias (byte) idx#15 = (byte) idx#36 
Alias (byte) assertType::t1#12 = (byte~) testSimpleTypes::$24 
Alias (byte) idx#16 = (byte) idx#37 
Alias (byte) assertType::t1#13 = (byte~) testSimpleTypes::$26 
Alias (byte) idx#17 = (byte) idx#38 
Alias (byte) assertType::t1#14 = (byte~) testSimpleTypes::$28 
Alias (byte) idx#18 = (byte) idx#39 (byte) idx#40 (byte) idx#19 
Alias (byte) idx#41 = (byte) idx#47 (byte) idx#42 
Alias (byte) assertType::t1#15 = (byte) assertType::t1#17 (byte) assertType::t1#18 
Alias (byte) idx#20 = (byte) idx#44 (byte) idx#21 
Alias (byte) idx#0 = (byte) idx#48 
Alias (byte) idx#22 = (byte) idx#45 
Successful SSA optimization Pass2AliasElimination
Alias (byte) assertType::t1#15 = (byte) assertType::t1#16 
Alias (byte) idx#41 = (byte) idx#43 
Successful SSA optimization Pass2AliasElimination
Self Phi Eliminated (byte) idx#46
Successful SSA optimization Pass2SelfPhiElimination
Redundant Phi (byte) idx#50 (byte) idx#0
Redundant Phi (byte) idx#46 (byte) idx#50
Redundant Phi (byte) idx#1 (byte) idx#18
Redundant Phi (byte) idx#25 (byte) idx#20
Redundant Phi (byte) idx#26 (byte) idx#20
Redundant Phi (byte) idx#27 (byte) idx#20
Redundant Phi (byte) idx#28 (byte) idx#20
Redundant Phi (byte) idx#29 (byte) idx#20
Redundant Phi (byte) idx#30 (byte) idx#20
Redundant Phi (byte) idx#10 (byte) idx#20
Redundant Phi (byte) idx#11 (byte) idx#20
Redundant Phi (byte) idx#12 (byte) idx#20
Redundant Phi (byte) idx#13 (byte) idx#20
Redundant Phi (byte) idx#14 (byte) idx#20
Redundant Phi (byte) idx#15 (byte) idx#20
Redundant Phi (byte) idx#16 (byte) idx#20
Redundant Phi (byte) idx#17 (byte) idx#20
Redundant Phi (byte) idx#18 (byte) idx#20
Redundant Phi (byte) idx#22 (byte) idx#1
Successful SSA optimization Pass2RedundantPhiElimination
Simple Condition (bool~) main::$2 [14] if((byte*) main::s#1<(byte*~) main::$1) goto main::@1
Simple Condition (bool~) assertType::$0 [118] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte) RED#0 = 2
Constant (const byte) GREEN#0 = 5
Constant (const word) $0 = $400
Constant (const word) $1 = $d800
Constant (const byte) idx#0 = 0
Constant (const byte) idx#3 = 0
Constant (const byte) assertType::t1#0 = TYPEID_BYTE
Constant (const byte) assertType::t2#0 = TYPEID_BYTE
Constant (const byte) assertType::t1#1 = TYPEID_BYTE
Constant (const byte) assertType::t2#1 = TYPEID_BYTE
Constant (const byte) assertType::t1#2 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t2#2 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t1#3 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t2#3 = TYPEID_SIGNED_BYTE
Constant (const byte) assertType::t1#4 = TYPEID_WORD
Constant (const byte) assertType::t2#4 = TYPEID_WORD
Constant (const byte) assertType::t1#5 = TYPEID_WORD
Constant (const byte) assertType::t2#5 = TYPEID_WORD
Constant (const byte) assertType::t1#6 = TYPEID_WORD
Constant (const byte) assertType::t2#6 = TYPEID_WORD
Constant (const byte) assertType::t1#7 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#7 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#8 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#8 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#9 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t2#9 = TYPEID_SIGNED_WORD
Constant (const byte) assertType::t1#10 = TYPEID_DWORD
Constant (const byte) assertType::t2#10 = TYPEID_DWORD
Constant (const byte) assertType::t1#11 = TYPEID_DWORD
Constant (const byte) assertType::t2#11 = TYPEID_DWORD
Constant (const byte) assertType::t1#12 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#12 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#13 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#13 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t1#14 = TYPEID_SIGNED_DWORD
Constant (const byte) assertType::t2#14 = TYPEID_SIGNED_DWORD
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const byte) idx#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating Noop Cast (byte*) SCREEN#0 ← ((byte*)) (const word) $0
Eliminating Noop Cast (byte*) COLS#0 ← ((byte*)) (const word) $1
Successful SSA optimization Pass2NopCastElimination
Culled Empty Block (label) main::@3
Culled Empty Block (label) testSimpleTypes::@15
Culled Empty Block (label) @4
Successful SSA optimization Pass2CullEmptyBlocks
Constant right-side identified [4] (byte*~) main::$1 ← (byte*)(const word) $0 + (word) $3e8
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) main::s#0 = (byte*)$0
Constant (const byte*) main::$1 = (byte*)$0+$3e8
Successful SSA optimization Pass2ConstantIdentification
Inlining constant with var siblings (const byte*) main::s#0
Inlining constant with var siblings (const byte) assertType::t1#0
Inlining constant with var siblings (const byte) assertType::t2#0
Inlining constant with var siblings (const byte) assertType::t1#1
Inlining constant with var siblings (const byte) assertType::t2#1
Inlining constant with var siblings (const byte) assertType::t1#2
Inlining constant with var siblings (const byte) assertType::t2#2
Inlining constant with var siblings (const byte) assertType::t1#3
Inlining constant with var siblings (const byte) assertType::t2#3
Inlining constant with var siblings (const byte) assertType::t1#4
Inlining constant with var siblings (const byte) assertType::t2#4
Inlining constant with var siblings (const byte) assertType::t1#5
Inlining constant with var siblings (const byte) assertType::t2#5
Inlining constant with var siblings (const byte) assertType::t1#6
Inlining constant with var siblings (const byte) assertType::t2#6
Inlining constant with var siblings (const byte) assertType::t1#7
Inlining constant with var siblings (const byte) assertType::t2#7
Inlining constant with var siblings (const byte) assertType::t1#8
Inlining constant with var siblings (const byte) assertType::t2#8
Inlining constant with var siblings (const byte) assertType::t1#9
Inlining constant with var siblings (const byte) assertType::t2#9
Inlining constant with var siblings (const byte) assertType::t1#10
Inlining constant with var siblings (const byte) assertType::t2#10
Inlining constant with var siblings (const byte) assertType::t1#11
Inlining constant with var siblings (const byte) assertType::t2#11
Inlining constant with var siblings (const byte) assertType::t1#12
Inlining constant with var siblings (const byte) assertType::t2#12
Inlining constant with var siblings (const byte) assertType::t1#13
Inlining constant with var siblings (const byte) assertType::t2#13
Inlining constant with var siblings (const byte) assertType::t1#14
Inlining constant with var siblings (const byte) assertType::t2#14
Inlining constant with var siblings (const byte) idx#3
Constant inlined assertType::t2#5 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#6 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#6 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#7 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#7 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#8 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#8 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t1#9 = (const byte) TYPEID_SIGNED_WORD
Constant inlined assertType::t2#9 = (const byte) TYPEID_SIGNED_WORD
Constant inlined $0 = (word) $400
Constant inlined $1 = (word) $d800
Constant inlined assertType::t2#11 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#10 = (const byte) TYPEID_DWORD
Constant inlined assertType::t2#13 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#12 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t2#14 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#0 = (const byte) TYPEID_BYTE
Constant inlined assertType::t2#0 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#1 = (const byte) TYPEID_BYTE
Constant inlined idx#3 = (byte) 0
Constant inlined assertType::t2#1 = (const byte) TYPEID_BYTE
Constant inlined assertType::t1#2 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#2 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#3 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t2#3 = (const byte) TYPEID_SIGNED_BYTE
Constant inlined assertType::t1#4 = (const byte) TYPEID_WORD
Constant inlined assertType::t2#4 = (const byte) TYPEID_WORD
Constant inlined assertType::t1#5 = (const byte) TYPEID_WORD
Constant inlined main::s#0 = (byte*)(word) $400
Constant inlined main::$1 = (byte*)(word) $400+(word) $3e8
Constant inlined assertType::t1#10 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#12 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#11 = (const byte) TYPEID_DWORD
Constant inlined assertType::t1#14 = (const byte) TYPEID_SIGNED_DWORD
Constant inlined assertType::t1#13 = (const byte) TYPEID_SIGNED_DWORD
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting main::@4(between main::@1 and main::@1)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of testSimpleTypes
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to testSimpleTypes:10 
Calls in [testSimpleTypes] to assertType:14 assertType:16 assertType:18 assertType:20 assertType:22 assertType:24 assertType:26 assertType:28 assertType:30 assertType:32 assertType:34 assertType:36 assertType:38 assertType:40 assertType:42 

Created 4 initial phi equivalence classes
Coalesced [12] main::s#3 ← main::s#1
Coalesced [15] idx#51 ← idx#20
Coalesced (already) [17] idx#57 ← idx#20
Coalesced (already) [19] idx#58 ← idx#20
Coalesced (already) [21] idx#59 ← idx#20
Coalesced (already) [23] idx#60 ← idx#20
Coalesced (already) [25] idx#61 ← idx#20
Coalesced (already) [27] idx#62 ← idx#20
Coalesced (already) [29] idx#63 ← idx#20
Coalesced (already) [31] idx#64 ← idx#20
Coalesced (already) [33] idx#52 ← idx#20
Coalesced (already) [35] idx#53 ← idx#20
Coalesced (already) [37] idx#54 ← idx#20
Coalesced (already) [39] idx#55 ← idx#20
Coalesced (already) [41] idx#56 ← idx#20
Coalesced down to 4 phi equivalence classes
Culled Empty Block (label) main::@4
Renumbering block @3 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of testSimpleTypes
Adding NOP phi() at start of testSimpleTypes::@1
Adding NOP phi() at start of testSimpleTypes::@2
Adding NOP phi() at start of testSimpleTypes::@3
Adding NOP phi() at start of testSimpleTypes::@4
Adding NOP phi() at start of testSimpleTypes::@5
Adding NOP phi() at start of testSimpleTypes::@6
Adding NOP phi() at start of testSimpleTypes::@7
Adding NOP phi() at start of testSimpleTypes::@8
Adding NOP phi() at start of testSimpleTypes::@9
Adding NOP phi() at start of testSimpleTypes::@10
Adding NOP phi() at start of testSimpleTypes::@11
Adding NOP phi() at start of testSimpleTypes::@12
Adding NOP phi() at start of testSimpleTypes::@13
Adding NOP phi() at start of testSimpleTypes::@14

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@1
  [5] (byte*) main::s#2 ← phi( main/(byte*)(word) $400 main::@1/(byte*) main::s#1 )
  [6] *((byte*) main::s#2) ← (byte) ' '
  [7] (byte*) main::s#1 ← ++ (byte*) main::s#2
  [8] if((byte*) main::s#1<(byte*)(word) $400+(word) $3e8) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [9] phi()
  [10] call testSimpleTypes 
  to:main::@return
main::@return: scope:[main]  from main::@2
  [11] return 
  to:@return
testSimpleTypes: scope:[testSimpleTypes]  from main::@2
  [12] phi()
  [13] call assertType 
  to:testSimpleTypes::@1
testSimpleTypes::@1: scope:[testSimpleTypes]  from testSimpleTypes
  [14] phi()
  [15] call assertType 
  to:testSimpleTypes::@2
testSimpleTypes::@2: scope:[testSimpleTypes]  from testSimpleTypes::@1
  [16] phi()
  [17] call assertType 
  to:testSimpleTypes::@3
testSimpleTypes::@3: scope:[testSimpleTypes]  from testSimpleTypes::@2
  [18] phi()
  [19] call assertType 
  to:testSimpleTypes::@4
testSimpleTypes::@4: scope:[testSimpleTypes]  from testSimpleTypes::@3
  [20] phi()
  [21] call assertType 
  to:testSimpleTypes::@5
testSimpleTypes::@5: scope:[testSimpleTypes]  from testSimpleTypes::@4
  [22] phi()
  [23] call assertType 
  to:testSimpleTypes::@6
testSimpleTypes::@6: scope:[testSimpleTypes]  from testSimpleTypes::@5
  [24] phi()
  [25] call assertType 
  to:testSimpleTypes::@7
testSimpleTypes::@7: scope:[testSimpleTypes]  from testSimpleTypes::@6
  [26] phi()
  [27] call assertType 
  to:testSimpleTypes::@8
testSimpleTypes::@8: scope:[testSimpleTypes]  from testSimpleTypes::@7
  [28] phi()
  [29] call assertType 
  to:testSimpleTypes::@9
testSimpleTypes::@9: scope:[testSimpleTypes]  from testSimpleTypes::@8
  [30] phi()
  [31] call assertType 
  to:testSimpleTypes::@10
testSimpleTypes::@10: scope:[testSimpleTypes]  from testSimpleTypes::@9
  [32] phi()
  [33] call assertType 
  to:testSimpleTypes::@11
testSimpleTypes::@11: scope:[testSimpleTypes]  from testSimpleTypes::@10
  [34] phi()
  [35] call assertType 
  to:testSimpleTypes::@12
testSimpleTypes::@12: scope:[testSimpleTypes]  from testSimpleTypes::@11
  [36] phi()
  [37] call assertType 
  to:testSimpleTypes::@13
testSimpleTypes::@13: scope:[testSimpleTypes]  from testSimpleTypes::@12
  [38] phi()
  [39] call assertType 
  to:testSimpleTypes::@14
testSimpleTypes::@14: scope:[testSimpleTypes]  from testSimpleTypes::@13
  [40] phi()
  [41] call assertType 
  to:testSimpleTypes::@return
testSimpleTypes::@return: scope:[testSimpleTypes]  from testSimpleTypes::@14
  [42] return 
  to:@return
assertType: scope:[assertType]  from testSimpleTypes testSimpleTypes::@1 testSimpleTypes::@10 testSimpleTypes::@11 testSimpleTypes::@12 testSimpleTypes::@13 testSimpleTypes::@14 testSimpleTypes::@2 testSimpleTypes::@3 testSimpleTypes::@4 testSimpleTypes::@5 testSimpleTypes::@6 testSimpleTypes::@7 testSimpleTypes::@8 testSimpleTypes::@9
  [43] (byte) idx#41 ← phi( testSimpleTypes/(byte) 0 testSimpleTypes::@1/(byte) idx#20 testSimpleTypes::@10/(byte) idx#20 testSimpleTypes::@11/(byte) idx#20 testSimpleTypes::@12/(byte) idx#20 testSimpleTypes::@13/(byte) idx#20 testSimpleTypes::@14/(byte) idx#20 testSimpleTypes::@2/(byte) idx#20 testSimpleTypes::@3/(byte) idx#20 testSimpleTypes::@4/(byte) idx#20 testSimpleTypes::@5/(byte) idx#20 testSimpleTypes::@6/(byte) idx#20 testSimpleTypes::@7/(byte) idx#20 testSimpleTypes::@8/(byte) idx#20 testSimpleTypes::@9/(byte) idx#20 )
  [43] (byte) assertType::t2#15 ← phi( testSimpleTypes/(const byte) TYPEID_BYTE testSimpleTypes::@1/(const byte) TYPEID_BYTE testSimpleTypes::@10/(const byte) TYPEID_DWORD testSimpleTypes::@11/(const byte) TYPEID_DWORD testSimpleTypes::@12/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@13/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@14/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@2/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@3/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@4/(const byte) TYPEID_WORD testSimpleTypes::@5/(const byte) TYPEID_WORD testSimpleTypes::@6/(const byte) TYPEID_WORD testSimpleTypes::@7/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@8/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@9/(const byte) TYPEID_SIGNED_WORD )
  [43] (byte) assertType::t1#15 ← phi( testSimpleTypes/(const byte) TYPEID_BYTE testSimpleTypes::@1/(const byte) TYPEID_BYTE testSimpleTypes::@10/(const byte) TYPEID_DWORD testSimpleTypes::@11/(const byte) TYPEID_DWORD testSimpleTypes::@12/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@13/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@14/(const byte) TYPEID_SIGNED_DWORD testSimpleTypes::@2/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@3/(const byte) TYPEID_SIGNED_BYTE testSimpleTypes::@4/(const byte) TYPEID_WORD testSimpleTypes::@5/(const byte) TYPEID_WORD testSimpleTypes::@6/(const byte) TYPEID_WORD testSimpleTypes::@7/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@8/(const byte) TYPEID_SIGNED_WORD testSimpleTypes::@9/(const byte) TYPEID_SIGNED_WORD )
  [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1
  to:assertType::@3
assertType::@3: scope:[assertType]  from assertType
  [45] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) RED#0
  to:assertType::@2
assertType::@2: scope:[assertType]  from assertType::@1 assertType::@3
  [46] *((byte*)(word) $400 + (byte) idx#41) ← (byte) assertType::t1#15
  [47] (byte) idx#20 ← ++ (byte) idx#41
  to:assertType::@return
assertType::@return: scope:[assertType]  from assertType::@2
  [48] return 
  to:@return
assertType::@1: scope:[assertType]  from assertType
  [49] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) GREEN#0
  to:assertType::@2


VARIABLE REGISTER WEIGHTS
(byte*) COLS
(byte) GREEN
(byte) RED
(byte*) SCREEN
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(byte) assertType::t1
(byte) assertType::t1#15 1.0
(byte) assertType::t2
(byte) assertType::t2#15 2.0
(byte) idx
(byte) idx#20 0.9999999999999999
(byte) idx#41 7.200000000000002
(void()) main()
(byte*) main::s
(byte*) main::s#1 16.5
(byte*) main::s#2 16.5
(void()) testSimpleTypes()

Initial phi equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#15 ]
[ assertType::t2#15 ]
[ idx#41 idx#20 ]
Complete equivalence classes
[ main::s#2 main::s#1 ]
[ assertType::t1#15 ]
[ assertType::t2#15 ]
[ idx#41 idx#20 ]
Allocated zp ZP_WORD:2 [ main::s#2 main::s#1 ]
Allocated zp ZP_BYTE:4 [ assertType::t1#15 ]
Allocated zp ZP_BYTE:5 [ assertType::t2#15 ]
Allocated zp ZP_BYTE:6 [ idx#41 idx#20 ]

INITIAL ASM
//SEG0 File Comments
// Tests different integer literal types
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  .const RED = 2
  .const GREEN = 5
  .label idx = 6
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label s = 2
  //SEG11 [5] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG12 [5] phi (byte*) main::s#2 = (byte*)(word) $400 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta s
    lda #>$400
    sta s+1
    jmp b1
  //SEG13 [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG14 [5] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((byte*) main::s#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
  //SEG17 [7] (byte*) main::s#1 ← ++ (byte*) main::s#2 -- pbuz1=_inc_pbuz1 
    inc s
    bne !+
    inc s+1
  !:
  //SEG18 [8] if((byte*) main::s#1<(byte*)(word) $400+(word) $3e8) goto main::@1 -- pbuz1_lt_pbuc1_then_la1 
    lda s+1
    cmp #>$400+$3e8
    bcc b1_from_b1
    bne !+
    lda s
    cmp #<$400+$3e8
    bcc b1_from_b1
  !:
  //SEG19 [9] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG20 main::@2
  b2:
  //SEG21 [10] call testSimpleTypes 
  //SEG22 [12] phi from main::@2 to testSimpleTypes [phi:main::@2->testSimpleTypes]
  testSimpleTypes_from_b2:
    jsr testSimpleTypes
    jmp breturn
  //SEG23 main::@return
  breturn:
  //SEG24 [11] return 
    rts
}
//SEG25 testSimpleTypes
testSimpleTypes: {
  //SEG26 [13] call assertType 
  //SEG27 [43] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  assertType_from_testSimpleTypes:
  //SEG28 [43] phi (byte) idx#41 = (byte) 0 [phi:testSimpleTypes->assertType#0] -- vbuz1=vbuc1 
    lda #0
    sta idx
  //SEG29 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG30 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG31 [14] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  b1_from_testSimpleTypes:
    jmp b1
  //SEG32 testSimpleTypes::@1
  b1:
  //SEG33 [15] call assertType 
  //SEG34 [43] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  assertType_from_b1:
  //SEG35 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
  //SEG36 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG37 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t1
    jsr assertType
  //SEG38 [16] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  b2_from_b1:
    jmp b2
  //SEG39 testSimpleTypes::@2
  b2:
  //SEG40 [17] call assertType 
  //SEG41 [43] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  assertType_from_b2:
  //SEG42 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
  //SEG43 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG44 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t1
    jsr assertType
  //SEG45 [18] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  b3_from_b2:
    jmp b3
  //SEG46 testSimpleTypes::@3
  b3:
  //SEG47 [19] call assertType 
  //SEG48 [43] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  assertType_from_b3:
  //SEG49 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
  //SEG50 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG51 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t1
    jsr assertType
  //SEG52 [20] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  b4_from_b3:
    jmp b4
  //SEG53 testSimpleTypes::@4
  b4:
  //SEG54 [21] call assertType 
  //SEG55 [43] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  assertType_from_b4:
  //SEG56 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
  //SEG57 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG58 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG59 [22] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  b5_from_b4:
    jmp b5
  //SEG60 testSimpleTypes::@5
  b5:
  //SEG61 [23] call assertType 
  //SEG62 [43] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  assertType_from_b5:
  //SEG63 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
  //SEG64 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG65 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG66 [24] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  b6_from_b5:
    jmp b6
  //SEG67 testSimpleTypes::@6
  b6:
  //SEG68 [25] call assertType 
  //SEG69 [43] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  assertType_from_b6:
  //SEG70 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
  //SEG71 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG72 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t1
    jsr assertType
  //SEG73 [26] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  b7_from_b6:
    jmp b7
  //SEG74 testSimpleTypes::@7
  b7:
  //SEG75 [27] call assertType 
  //SEG76 [43] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  assertType_from_b7:
  //SEG77 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
  //SEG78 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG79 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t1
    jsr assertType
  //SEG80 [28] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  b8_from_b7:
    jmp b8
  //SEG81 testSimpleTypes::@8
  b8:
  //SEG82 [29] call assertType 
  //SEG83 [43] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  assertType_from_b8:
  //SEG84 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
  //SEG85 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG86 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t1
    jsr assertType
  //SEG87 [30] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  b9_from_b8:
    jmp b9
  //SEG88 testSimpleTypes::@9
  b9:
  //SEG89 [31] call assertType 
  //SEG90 [43] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  assertType_from_b9:
  //SEG91 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
  //SEG92 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG93 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t1
    jsr assertType
  //SEG94 [32] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  b10_from_b9:
    jmp b10
  //SEG95 testSimpleTypes::@10
  b10:
  //SEG96 [33] call assertType 
  //SEG97 [43] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  assertType_from_b10:
  //SEG98 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
  //SEG99 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG100 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG101 [34] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  b11_from_b10:
    jmp b11
  //SEG102 testSimpleTypes::@11
  b11:
  //SEG103 [35] call assertType 
  //SEG104 [43] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  assertType_from_b11:
  //SEG105 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
  //SEG106 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG107 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t1
    jsr assertType
  //SEG108 [36] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  b12_from_b11:
    jmp b12
  //SEG109 testSimpleTypes::@12
  b12:
  //SEG110 [37] call assertType 
  //SEG111 [43] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  assertType_from_b12:
  //SEG112 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
  //SEG113 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG114 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG115 [38] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  b13_from_b12:
    jmp b13
  //SEG116 testSimpleTypes::@13
  b13:
  //SEG117 [39] call assertType 
  //SEG118 [43] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  assertType_from_b13:
  //SEG119 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
  //SEG120 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG121 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
  //SEG122 [40] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  b14_from_b13:
    jmp b14
  //SEG123 testSimpleTypes::@14
  b14:
  //SEG124 [41] call assertType 
  //SEG125 [43] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  assertType_from_b14:
  //SEG126 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
  //SEG127 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG128 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t1
    jsr assertType
    jmp breturn
  //SEG129 testSimpleTypes::@return
  breturn:
  //SEG130 [42] return 
    rts
}
//SEG131 assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte zeropage(4) t1, byte zeropage(5) t2)
assertType: {
    .label t1 = 4
    .label t2 = 5
  //SEG132 [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1 -- vbuz1_eq_vbuz2_then_la1 
    lda t1
    cmp t2
    beq b1
    jmp b3
  //SEG133 assertType::@3
  b3:
  //SEG134 [45] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) RED#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #RED
    ldy idx
    sta $d800,y
    jmp b2
  //SEG135 assertType::@2
  b2:
  //SEG136 [46] *((byte*)(word) $400 + (byte) idx#41) ← (byte) assertType::t1#15 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda t1
    ldy idx
    sta $400,y
  //SEG137 [47] (byte) idx#20 ← ++ (byte) idx#41 -- vbuz1=_inc_vbuz1 
    inc idx
    jmp breturn
  //SEG138 assertType::@return
  breturn:
  //SEG139 [48] return 
    rts
  //SEG140 assertType::@1
  b1:
  //SEG141 [49] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy idx
    sta $d800,y
    jmp b2
}

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((byte*) main::s#2) ← (byte) ' ' [ main::s#2 ] ( main:2 [ main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [8] if((byte*) main::s#1<(byte*)(word) $400+(word) $3e8) goto main::@1 [ main::s#1 ] ( main:2 [ main::s#1 ] ) always clobbers reg byte a 
Statement [45] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) RED#0 [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:10::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ assertType::t1#15 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ idx#41 idx#20 ]
Statement [46] *((byte*)(word) $400 + (byte) idx#41) ← (byte) assertType::t1#15 [ idx#41 ] ( main:2::testSimpleTypes:10::assertType:13 [ idx#41 ] main:2::testSimpleTypes:10::assertType:15 [ idx#41 ] main:2::testSimpleTypes:10::assertType:17 [ idx#41 ] main:2::testSimpleTypes:10::assertType:19 [ idx#41 ] main:2::testSimpleTypes:10::assertType:21 [ idx#41 ] main:2::testSimpleTypes:10::assertType:23 [ idx#41 ] main:2::testSimpleTypes:10::assertType:25 [ idx#41 ] main:2::testSimpleTypes:10::assertType:27 [ idx#41 ] main:2::testSimpleTypes:10::assertType:29 [ idx#41 ] main:2::testSimpleTypes:10::assertType:31 [ idx#41 ] main:2::testSimpleTypes:10::assertType:33 [ idx#41 ] main:2::testSimpleTypes:10::assertType:35 [ idx#41 ] main:2::testSimpleTypes:10::assertType:37 [ idx#41 ] main:2::testSimpleTypes:10::assertType:39 [ idx#41 ] main:2::testSimpleTypes:10::assertType:41 [ idx#41 ] ) always clobbers reg byte a 
Statement [49] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) GREEN#0 [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:10::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Statement [6] *((byte*) main::s#2) ← (byte) ' ' [ main::s#2 ] ( main:2 [ main::s#2 ] ) always clobbers reg byte a reg byte y 
Statement [8] if((byte*) main::s#1<(byte*)(word) $400+(word) $3e8) goto main::@1 [ main::s#1 ] ( main:2 [ main::s#1 ] ) always clobbers reg byte a 
Statement [45] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) RED#0 [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:10::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Statement [46] *((byte*)(word) $400 + (byte) idx#41) ← (byte) assertType::t1#15 [ idx#41 ] ( main:2::testSimpleTypes:10::assertType:13 [ idx#41 ] main:2::testSimpleTypes:10::assertType:15 [ idx#41 ] main:2::testSimpleTypes:10::assertType:17 [ idx#41 ] main:2::testSimpleTypes:10::assertType:19 [ idx#41 ] main:2::testSimpleTypes:10::assertType:21 [ idx#41 ] main:2::testSimpleTypes:10::assertType:23 [ idx#41 ] main:2::testSimpleTypes:10::assertType:25 [ idx#41 ] main:2::testSimpleTypes:10::assertType:27 [ idx#41 ] main:2::testSimpleTypes:10::assertType:29 [ idx#41 ] main:2::testSimpleTypes:10::assertType:31 [ idx#41 ] main:2::testSimpleTypes:10::assertType:33 [ idx#41 ] main:2::testSimpleTypes:10::assertType:35 [ idx#41 ] main:2::testSimpleTypes:10::assertType:37 [ idx#41 ] main:2::testSimpleTypes:10::assertType:39 [ idx#41 ] main:2::testSimpleTypes:10::assertType:41 [ idx#41 ] ) always clobbers reg byte a 
Statement [49] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) GREEN#0 [ assertType::t1#15 idx#41 ] ( main:2::testSimpleTypes:10::assertType:13 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:15 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:17 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:19 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:21 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:23 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:25 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:27 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:29 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:31 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:33 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:35 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:37 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:39 [ assertType::t1#15 idx#41 ] main:2::testSimpleTypes:10::assertType:41 [ assertType::t1#15 idx#41 ] ) always clobbers reg byte a 
Potential registers zp ZP_WORD:2 [ main::s#2 main::s#1 ] : zp ZP_WORD:2 , 
Potential registers zp ZP_BYTE:4 [ assertType::t1#15 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ assertType::t2#15 ] : zp ZP_BYTE:5 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ idx#41 idx#20 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 33: zp ZP_WORD:2 [ main::s#2 main::s#1 ] 
Uplift Scope [] 8.2: zp ZP_BYTE:6 [ idx#41 idx#20 ] 
Uplift Scope [assertType] 2: zp ZP_BYTE:5 [ assertType::t2#15 ] 1: zp ZP_BYTE:4 [ assertType::t1#15 ] 
Uplift Scope [testSimpleTypes] 

Uplifting [main] best 978 combination zp ZP_WORD:2 [ main::s#2 main::s#1 ] 
Uplifting [] best 963 combination reg byte x [ idx#41 idx#20 ] 
Uplifting [assertType] best 916 combination zp ZP_BYTE:5 [ assertType::t2#15 ] reg byte y [ assertType::t1#15 ] 
Uplifting [testSimpleTypes] best 916 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ assertType::t2#15 ]
Uplifting [assertType] best 916 combination zp ZP_BYTE:5 [ assertType::t2#15 ] 
Allocated (was zp ZP_BYTE:5) zp ZP_BYTE:4 [ assertType::t2#15 ]

ASSEMBLER BEFORE OPTIMIZATION
//SEG0 File Comments
// Tests different integer literal types
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  .const RED = 2
  .const GREEN = 5
//SEG3 @begin
bbegin:
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
//SEG5 @1
b1:
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
//SEG9 @end
bend:
//SEG10 main
main: {
    .label s = 2
  //SEG11 [5] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
  //SEG12 [5] phi (byte*) main::s#2 = (byte*)(word) $400 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta s
    lda #>$400
    sta s+1
    jmp b1
  //SEG13 [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  b1_from_b1:
  //SEG14 [5] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@1->main::@1#0] -- register_copy 
    jmp b1
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((byte*) main::s#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
  //SEG17 [7] (byte*) main::s#1 ← ++ (byte*) main::s#2 -- pbuz1=_inc_pbuz1 
    inc s
    bne !+
    inc s+1
  !:
  //SEG18 [8] if((byte*) main::s#1<(byte*)(word) $400+(word) $3e8) goto main::@1 -- pbuz1_lt_pbuc1_then_la1 
    lda s+1
    cmp #>$400+$3e8
    bcc b1_from_b1
    bne !+
    lda s
    cmp #<$400+$3e8
    bcc b1_from_b1
  !:
  //SEG19 [9] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  b2_from_b1:
    jmp b2
  //SEG20 main::@2
  b2:
  //SEG21 [10] call testSimpleTypes 
  //SEG22 [12] phi from main::@2 to testSimpleTypes [phi:main::@2->testSimpleTypes]
  testSimpleTypes_from_b2:
    jsr testSimpleTypes
    jmp breturn
  //SEG23 main::@return
  breturn:
  //SEG24 [11] return 
    rts
}
//SEG25 testSimpleTypes
testSimpleTypes: {
  //SEG26 [13] call assertType 
  //SEG27 [43] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  assertType_from_testSimpleTypes:
  //SEG28 [43] phi (byte) idx#41 = (byte) 0 [phi:testSimpleTypes->assertType#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG29 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG30 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG31 [14] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  b1_from_testSimpleTypes:
    jmp b1
  //SEG32 testSimpleTypes::@1
  b1:
  //SEG33 [15] call assertType 
  //SEG34 [43] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  assertType_from_b1:
  //SEG35 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
  //SEG36 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG37 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_BYTE
    jsr assertType
  //SEG38 [16] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  b2_from_b1:
    jmp b2
  //SEG39 testSimpleTypes::@2
  b2:
  //SEG40 [17] call assertType 
  //SEG41 [43] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  assertType_from_b2:
  //SEG42 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
  //SEG43 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG44 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    jsr assertType
  //SEG45 [18] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  b3_from_b2:
    jmp b3
  //SEG46 testSimpleTypes::@3
  b3:
  //SEG47 [19] call assertType 
  //SEG48 [43] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  assertType_from_b3:
  //SEG49 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
  //SEG50 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG51 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_BYTE
    jsr assertType
  //SEG52 [20] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  b4_from_b3:
    jmp b4
  //SEG53 testSimpleTypes::@4
  b4:
  //SEG54 [21] call assertType 
  //SEG55 [43] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  assertType_from_b4:
  //SEG56 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
  //SEG57 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG58 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG59 [22] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  b5_from_b4:
    jmp b5
  //SEG60 testSimpleTypes::@5
  b5:
  //SEG61 [23] call assertType 
  //SEG62 [43] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  assertType_from_b5:
  //SEG63 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
  //SEG64 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG65 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG66 [24] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  b6_from_b5:
    jmp b6
  //SEG67 testSimpleTypes::@6
  b6:
  //SEG68 [25] call assertType 
  //SEG69 [43] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  assertType_from_b6:
  //SEG70 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
  //SEG71 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG72 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_WORD
    jsr assertType
  //SEG73 [26] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  b7_from_b6:
    jmp b7
  //SEG74 testSimpleTypes::@7
  b7:
  //SEG75 [27] call assertType 
  //SEG76 [43] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  assertType_from_b7:
  //SEG77 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
  //SEG78 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG79 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
  //SEG80 [28] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  b8_from_b7:
    jmp b8
  //SEG81 testSimpleTypes::@8
  b8:
  //SEG82 [29] call assertType 
  //SEG83 [43] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  assertType_from_b8:
  //SEG84 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
  //SEG85 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG86 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
  //SEG87 [30] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  b9_from_b8:
    jmp b9
  //SEG88 testSimpleTypes::@9
  b9:
  //SEG89 [31] call assertType 
  //SEG90 [43] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  assertType_from_b9:
  //SEG91 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
  //SEG92 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG93 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_WORD
    jsr assertType
  //SEG94 [32] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  b10_from_b9:
    jmp b10
  //SEG95 testSimpleTypes::@10
  b10:
  //SEG96 [33] call assertType 
  //SEG97 [43] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  assertType_from_b10:
  //SEG98 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
  //SEG99 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG100 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG101 [34] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  b11_from_b10:
    jmp b11
  //SEG102 testSimpleTypes::@11
  b11:
  //SEG103 [35] call assertType 
  //SEG104 [43] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  assertType_from_b11:
  //SEG105 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
  //SEG106 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG107 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_DWORD
    jsr assertType
  //SEG108 [36] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  b12_from_b11:
    jmp b12
  //SEG109 testSimpleTypes::@12
  b12:
  //SEG110 [37] call assertType 
  //SEG111 [43] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  assertType_from_b12:
  //SEG112 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
  //SEG113 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG114 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG115 [38] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  b13_from_b12:
    jmp b13
  //SEG116 testSimpleTypes::@13
  b13:
  //SEG117 [39] call assertType 
  //SEG118 [43] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  assertType_from_b13:
  //SEG119 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
  //SEG120 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG121 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
  //SEG122 [40] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  b14_from_b13:
    jmp b14
  //SEG123 testSimpleTypes::@14
  b14:
  //SEG124 [41] call assertType 
  //SEG125 [43] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  assertType_from_b14:
  //SEG126 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
  //SEG127 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG128 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuyy=vbuc1 
    ldy #TYPEID_SIGNED_DWORD
    jsr assertType
    jmp breturn
  //SEG129 testSimpleTypes::@return
  breturn:
  //SEG130 [42] return 
    rts
}
//SEG131 assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zeropage(4) t2)
assertType: {
    .label t2 = 4
  //SEG132 [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp t2
    beq b1
    jmp b3
  //SEG133 assertType::@3
  b3:
  //SEG134 [45] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) RED#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta $d800,x
    jmp b2
  //SEG135 assertType::@2
  b2:
  //SEG136 [46] *((byte*)(word) $400 + (byte) idx#41) ← (byte) assertType::t1#15 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta $400,x
  //SEG137 [47] (byte) idx#20 ← ++ (byte) idx#41 -- vbuxx=_inc_vbuxx 
    inx
    jmp breturn
  //SEG138 assertType::@return
  breturn:
  //SEG139 [48] return 
    rts
  //SEG140 assertType::@1
  b1:
  //SEG141 [49] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta $d800,x
    jmp b2
}

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b6
Removing instruction jmp b7
Removing instruction jmp b8
Removing instruction jmp b9
Removing instruction jmp b10
Removing instruction jmp b11
Removing instruction jmp b12
Removing instruction jmp b13
Removing instruction jmp b14
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_BYTE with TAY
Replacing instruction ldy #TYPEID_SIGNED_BYTE with TAY
Replacing instruction ldy #TYPEID_SIGNED_BYTE with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_WORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing instruction ldy #TYPEID_SIGNED_DWORD with TAY
Replacing label b1_from_b1 with b1
Replacing label b1_from_b1 with b1
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b1:
Removing instruction b2_from_b1:
Removing instruction testSimpleTypes_from_b2:
Removing instruction b1_from_testSimpleTypes:
Removing instruction assertType_from_b1:
Removing instruction b2_from_b1:
Removing instruction assertType_from_b2:
Removing instruction b3_from_b2:
Removing instruction assertType_from_b3:
Removing instruction b4_from_b3:
Removing instruction assertType_from_b4:
Removing instruction b5_from_b4:
Removing instruction assertType_from_b5:
Removing instruction b6_from_b5:
Removing instruction assertType_from_b6:
Removing instruction b7_from_b6:
Removing instruction assertType_from_b7:
Removing instruction b8_from_b7:
Removing instruction assertType_from_b8:
Removing instruction b9_from_b8:
Removing instruction assertType_from_b9:
Removing instruction b10_from_b9:
Removing instruction assertType_from_b10:
Removing instruction b11_from_b10:
Removing instruction assertType_from_b11:
Removing instruction b12_from_b11:
Removing instruction assertType_from_b12:
Removing instruction b13_from_b12:
Removing instruction assertType_from_b13:
Removing instruction b14_from_b13:
Removing instruction assertType_from_b14:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b1_from_main:
Removing instruction b2:
Removing instruction breturn:
Removing instruction assertType_from_testSimpleTypes:
Removing instruction b1:
Removing instruction b2:
Removing instruction b3:
Removing instruction b4:
Removing instruction b5:
Removing instruction b6:
Removing instruction b7:
Removing instruction b8:
Removing instruction b9:
Removing instruction b10:
Removing instruction b11:
Removing instruction b12:
Removing instruction b13:
Removing instruction b14:
Removing instruction breturn:
Removing instruction b3:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(byte*) COLS
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) RED
(const byte) RED#0 RED = (byte) 2
(byte*) SCREEN
(const byte) TYPEID_BYTE TYPEID_BYTE = (number) 1
(const byte) TYPEID_DWORD TYPEID_DWORD = (number) 5
(const byte) TYPEID_SIGNED_BYTE TYPEID_SIGNED_BYTE = (number) 2
(const byte) TYPEID_SIGNED_DWORD TYPEID_SIGNED_DWORD = (number) 6
(const byte) TYPEID_SIGNED_WORD TYPEID_SIGNED_WORD = (number) 4
(const byte) TYPEID_WORD TYPEID_WORD = (number) 3
(void()) assertType((byte) assertType::t1 , (byte) assertType::t2)
(label) assertType::@1
(label) assertType::@2
(label) assertType::@3
(label) assertType::@return
(byte) assertType::t1
(byte) assertType::t1#15 reg byte y 1.0
(byte) assertType::t2
(byte) assertType::t2#15 t2 zp ZP_BYTE:4 2.0
(byte) idx
(byte) idx#20 reg byte x 0.9999999999999999
(byte) idx#41 reg byte x 7.200000000000002
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(byte*) main::s
(byte*) main::s#1 s zp ZP_WORD:2 16.5
(byte*) main::s#2 s zp ZP_WORD:2 16.5
(void()) testSimpleTypes()
(label) testSimpleTypes::@1
(label) testSimpleTypes::@10
(label) testSimpleTypes::@11
(label) testSimpleTypes::@12
(label) testSimpleTypes::@13
(label) testSimpleTypes::@14
(label) testSimpleTypes::@2
(label) testSimpleTypes::@3
(label) testSimpleTypes::@4
(label) testSimpleTypes::@5
(label) testSimpleTypes::@6
(label) testSimpleTypes::@7
(label) testSimpleTypes::@8
(label) testSimpleTypes::@9
(label) testSimpleTypes::@return

zp ZP_WORD:2 [ main::s#2 main::s#1 ]
reg byte y [ assertType::t1#15 ]
zp ZP_BYTE:4 [ assertType::t2#15 ]
reg byte x [ idx#41 idx#20 ]


FINAL ASSEMBLER
Score: 784

//SEG0 File Comments
// Tests different integer literal types
//SEG1 Basic Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
//SEG2 Global Constants & labels
  .const TYPEID_BYTE = 1
  .const TYPEID_SIGNED_BYTE = 2
  .const TYPEID_WORD = 3
  .const TYPEID_SIGNED_WORD = 4
  .const TYPEID_DWORD = 5
  .const TYPEID_SIGNED_DWORD = 6
  .const RED = 2
  .const GREEN = 5
//SEG3 @begin
//SEG4 [1] phi from @begin to @1 [phi:@begin->@1]
//SEG5 @1
//SEG6 [2] call main 
//SEG7 [4] phi from @1 to main [phi:@1->main]
//SEG8 [3] phi from @1 to @end [phi:@1->@end]
//SEG9 @end
//SEG10 main
main: {
    .label s = 2
  //SEG11 [5] phi from main to main::@1 [phi:main->main::@1]
  //SEG12 [5] phi (byte*) main::s#2 = (byte*)(word) $400 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400
    sta s
    lda #>$400
    sta s+1
  //SEG13 [5] phi from main::@1 to main::@1 [phi:main::@1->main::@1]
  //SEG14 [5] phi (byte*) main::s#2 = (byte*) main::s#1 [phi:main::@1->main::@1#0] -- register_copy 
  //SEG15 main::@1
  b1:
  //SEG16 [6] *((byte*) main::s#2) ← (byte) ' ' -- _deref_pbuz1=vbuc1 
    lda #' '
    ldy #0
    sta (s),y
  //SEG17 [7] (byte*) main::s#1 ← ++ (byte*) main::s#2 -- pbuz1=_inc_pbuz1 
    inc s
    bne !+
    inc s+1
  !:
  //SEG18 [8] if((byte*) main::s#1<(byte*)(word) $400+(word) $3e8) goto main::@1 -- pbuz1_lt_pbuc1_then_la1 
    lda s+1
    cmp #>$400+$3e8
    bcc b1
    bne !+
    lda s
    cmp #<$400+$3e8
    bcc b1
  !:
  //SEG19 [9] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  //SEG20 main::@2
  //SEG21 [10] call testSimpleTypes 
  //SEG22 [12] phi from main::@2 to testSimpleTypes [phi:main::@2->testSimpleTypes]
    jsr testSimpleTypes
  //SEG23 main::@return
  //SEG24 [11] return 
    rts
}
//SEG25 testSimpleTypes
testSimpleTypes: {
  //SEG26 [13] call assertType 
  //SEG27 [43] phi from testSimpleTypes to assertType [phi:testSimpleTypes->assertType]
  //SEG28 [43] phi (byte) idx#41 = (byte) 0 [phi:testSimpleTypes->assertType#0] -- vbuxx=vbuc1 
    ldx #0
  //SEG29 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG30 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG31 [14] phi from testSimpleTypes to testSimpleTypes::@1 [phi:testSimpleTypes->testSimpleTypes::@1]
  //SEG32 testSimpleTypes::@1
  //SEG33 [15] call assertType 
  //SEG34 [43] phi from testSimpleTypes::@1 to assertType [phi:testSimpleTypes::@1->assertType]
  //SEG35 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@1->assertType#0] -- register_copy 
  //SEG36 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_BYTE
    sta assertType.t2
  //SEG37 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_BYTE [phi:testSimpleTypes::@1->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG38 [16] phi from testSimpleTypes::@1 to testSimpleTypes::@2 [phi:testSimpleTypes::@1->testSimpleTypes::@2]
  //SEG39 testSimpleTypes::@2
  //SEG40 [17] call assertType 
  //SEG41 [43] phi from testSimpleTypes::@2 to assertType [phi:testSimpleTypes::@2->assertType]
  //SEG42 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@2->assertType#0] -- register_copy 
  //SEG43 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG44 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@2->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG45 [18] phi from testSimpleTypes::@2 to testSimpleTypes::@3 [phi:testSimpleTypes::@2->testSimpleTypes::@3]
  //SEG46 testSimpleTypes::@3
  //SEG47 [19] call assertType 
  //SEG48 [43] phi from testSimpleTypes::@3 to assertType [phi:testSimpleTypes::@3->assertType]
  //SEG49 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@3->assertType#0] -- register_copy 
  //SEG50 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_BYTE
    sta assertType.t2
  //SEG51 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_BYTE [phi:testSimpleTypes::@3->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG52 [20] phi from testSimpleTypes::@3 to testSimpleTypes::@4 [phi:testSimpleTypes::@3->testSimpleTypes::@4]
  //SEG53 testSimpleTypes::@4
  //SEG54 [21] call assertType 
  //SEG55 [43] phi from testSimpleTypes::@4 to assertType [phi:testSimpleTypes::@4->assertType]
  //SEG56 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@4->assertType#0] -- register_copy 
  //SEG57 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG58 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@4->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG59 [22] phi from testSimpleTypes::@4 to testSimpleTypes::@5 [phi:testSimpleTypes::@4->testSimpleTypes::@5]
  //SEG60 testSimpleTypes::@5
  //SEG61 [23] call assertType 
  //SEG62 [43] phi from testSimpleTypes::@5 to assertType [phi:testSimpleTypes::@5->assertType]
  //SEG63 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@5->assertType#0] -- register_copy 
  //SEG64 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG65 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@5->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG66 [24] phi from testSimpleTypes::@5 to testSimpleTypes::@6 [phi:testSimpleTypes::@5->testSimpleTypes::@6]
  //SEG67 testSimpleTypes::@6
  //SEG68 [25] call assertType 
  //SEG69 [43] phi from testSimpleTypes::@6 to assertType [phi:testSimpleTypes::@6->assertType]
  //SEG70 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@6->assertType#0] -- register_copy 
  //SEG71 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_WORD
    sta assertType.t2
  //SEG72 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_WORD [phi:testSimpleTypes::@6->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG73 [26] phi from testSimpleTypes::@6 to testSimpleTypes::@7 [phi:testSimpleTypes::@6->testSimpleTypes::@7]
  //SEG74 testSimpleTypes::@7
  //SEG75 [27] call assertType 
  //SEG76 [43] phi from testSimpleTypes::@7 to assertType [phi:testSimpleTypes::@7->assertType]
  //SEG77 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@7->assertType#0] -- register_copy 
  //SEG78 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG79 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@7->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG80 [28] phi from testSimpleTypes::@7 to testSimpleTypes::@8 [phi:testSimpleTypes::@7->testSimpleTypes::@8]
  //SEG81 testSimpleTypes::@8
  //SEG82 [29] call assertType 
  //SEG83 [43] phi from testSimpleTypes::@8 to assertType [phi:testSimpleTypes::@8->assertType]
  //SEG84 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@8->assertType#0] -- register_copy 
  //SEG85 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG86 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@8->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG87 [30] phi from testSimpleTypes::@8 to testSimpleTypes::@9 [phi:testSimpleTypes::@8->testSimpleTypes::@9]
  //SEG88 testSimpleTypes::@9
  //SEG89 [31] call assertType 
  //SEG90 [43] phi from testSimpleTypes::@9 to assertType [phi:testSimpleTypes::@9->assertType]
  //SEG91 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@9->assertType#0] -- register_copy 
  //SEG92 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_WORD
    sta assertType.t2
  //SEG93 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_WORD [phi:testSimpleTypes::@9->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG94 [32] phi from testSimpleTypes::@9 to testSimpleTypes::@10 [phi:testSimpleTypes::@9->testSimpleTypes::@10]
  //SEG95 testSimpleTypes::@10
  //SEG96 [33] call assertType 
  //SEG97 [43] phi from testSimpleTypes::@10 to assertType [phi:testSimpleTypes::@10->assertType]
  //SEG98 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@10->assertType#0] -- register_copy 
  //SEG99 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG100 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@10->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG101 [34] phi from testSimpleTypes::@10 to testSimpleTypes::@11 [phi:testSimpleTypes::@10->testSimpleTypes::@11]
  //SEG102 testSimpleTypes::@11
  //SEG103 [35] call assertType 
  //SEG104 [43] phi from testSimpleTypes::@11 to assertType [phi:testSimpleTypes::@11->assertType]
  //SEG105 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@11->assertType#0] -- register_copy 
  //SEG106 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_DWORD
    sta assertType.t2
  //SEG107 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_DWORD [phi:testSimpleTypes::@11->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG108 [36] phi from testSimpleTypes::@11 to testSimpleTypes::@12 [phi:testSimpleTypes::@11->testSimpleTypes::@12]
  //SEG109 testSimpleTypes::@12
  //SEG110 [37] call assertType 
  //SEG111 [43] phi from testSimpleTypes::@12 to assertType [phi:testSimpleTypes::@12->assertType]
  //SEG112 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@12->assertType#0] -- register_copy 
  //SEG113 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG114 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@12->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG115 [38] phi from testSimpleTypes::@12 to testSimpleTypes::@13 [phi:testSimpleTypes::@12->testSimpleTypes::@13]
  //SEG116 testSimpleTypes::@13
  //SEG117 [39] call assertType 
  //SEG118 [43] phi from testSimpleTypes::@13 to assertType [phi:testSimpleTypes::@13->assertType]
  //SEG119 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@13->assertType#0] -- register_copy 
  //SEG120 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG121 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@13->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG122 [40] phi from testSimpleTypes::@13 to testSimpleTypes::@14 [phi:testSimpleTypes::@13->testSimpleTypes::@14]
  //SEG123 testSimpleTypes::@14
  //SEG124 [41] call assertType 
  //SEG125 [43] phi from testSimpleTypes::@14 to assertType [phi:testSimpleTypes::@14->assertType]
  //SEG126 [43] phi (byte) idx#41 = (byte) idx#20 [phi:testSimpleTypes::@14->assertType#0] -- register_copy 
  //SEG127 [43] phi (byte) assertType::t2#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#1] -- vbuz1=vbuc1 
    lda #TYPEID_SIGNED_DWORD
    sta assertType.t2
  //SEG128 [43] phi (byte) assertType::t1#15 = (const byte) TYPEID_SIGNED_DWORD [phi:testSimpleTypes::@14->assertType#2] -- vbuyy=vbuc1 
    tay
    jsr assertType
  //SEG129 testSimpleTypes::@return
  //SEG130 [42] return 
    rts
}
//SEG131 assertType
// Check that the two passed type IDs are equal.
// Shows a letter symbolizing t1
// If they are equal the letter is green - if not it is red.
// assertType(byte register(Y) t1, byte zeropage(4) t2)
assertType: {
    .label t2 = 4
  //SEG132 [44] if((byte) assertType::t1#15==(byte) assertType::t2#15) goto assertType::@1 -- vbuyy_eq_vbuz1_then_la1 
    tya
    cmp t2
    beq b1
  //SEG133 assertType::@3
  //SEG134 [45] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) RED#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #RED
    sta $d800,x
  //SEG135 assertType::@2
  b2:
  //SEG136 [46] *((byte*)(word) $400 + (byte) idx#41) ← (byte) assertType::t1#15 -- pbuc1_derefidx_vbuxx=vbuyy 
    tya
    sta $400,x
  //SEG137 [47] (byte) idx#20 ← ++ (byte) idx#41 -- vbuxx=_inc_vbuxx 
    inx
  //SEG138 assertType::@return
  //SEG139 [48] return 
    rts
  //SEG140 assertType::@1
  b1:
  //SEG141 [49] *((byte*)(word) $d800 + (byte) idx#41) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta $d800,x
    jmp b2
}

