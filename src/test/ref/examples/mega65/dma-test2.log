Resolved forward reference memcpy_dma_command to (struct DMA_LIST_F018B) memcpy_dma_command
Resolved forward reference memcpy_dma_command to (struct DMA_LIST_F018B) memcpy_dma_command
Resolved forward reference memcpy_dma_command to (struct DMA_LIST_F018B) memcpy_dma_command
Resolved forward reference memcpy_dma_command to (struct DMA_LIST_F018B) memcpy_dma_command
Resolved forward reference memcpy_dma_command to (struct DMA_LIST_F018B) memcpy_dma_command
Fixing struct type size struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Fixing struct type SIZE_OF struct F018_DMAGIC to 17
Setting struct to load/store in variable affected by address-of *((const nomodify struct F018_DMAGIC*) DMA).ADDRMSB ← >&(struct DMA_LIST_F018B) memcpy_dma_command
Setting struct to load/store in variable affected by address-of *((const nomodify struct F018_DMAGIC*) DMA).ADDRLSBTRIG ← <&(struct DMA_LIST_F018B) memcpy_dma_command
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 

CONTROL FLOW GRAPH SSA

(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main
  (word) memoryRemap::upperPageOffset#1 ← phi( main/(word) memoryRemap::upperPageOffset#0 )
  (byte) memoryRemap::remapBlocks#1 ← phi( main/(byte) memoryRemap::remapBlocks#0 )
  (word) memoryRemap::lowerPageOffset#1 ← phi( main/(word) memoryRemap::lowerPageOffset#0 )
  (byte~) memoryRemap::$0 ← < (word) memoryRemap::lowerPageOffset#1
  *((const byte*) memoryRemap::aVal) ← (byte~) memoryRemap::$0
  (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#1 << (number) 4
  (byte~) memoryRemap::$2 ← > (word) memoryRemap::lowerPageOffset#1
  (number~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (number) $f
  (number~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (number~) memoryRemap::$3
  *((const byte*) memoryRemap::xVal) ← (number~) memoryRemap::$4
  (byte~) memoryRemap::$5 ← < (word) memoryRemap::upperPageOffset#1
  *((const byte*) memoryRemap::yVal) ← (byte~) memoryRemap::$5
  (number~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#1 & (number) $f0
  (byte~) memoryRemap::$7 ← > (word) memoryRemap::upperPageOffset#1
  (number~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (number) $f
  (number~) memoryRemap::$9 ← (number~) memoryRemap::$6 | (number~) memoryRemap::$8
  *((const byte*) memoryRemap::zVal) ← (number~) memoryRemap::$9
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  return 
  to:@return

(void()) memcpy_dma((void*) memcpy_dma::dest , (void*) memcpy_dma::src , (word) memcpy_dma::num)
memcpy_dma: scope:[memcpy_dma]  from main::@1
  (void*) memcpy_dma::dest#1 ← phi( main::@1/(void*) memcpy_dma::dest#0 )
  (void*) memcpy_dma::src#1 ← phi( main::@1/(void*) memcpy_dma::src#0 )
  (word) memcpy_dma::num#1 ← phi( main::@1/(word) memcpy_dma::num#0 )
  (byte) memcpy_dma::dmaMode#0 ← *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B)
  *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (word) memcpy_dma::num#1
  *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← ((byte*)) (void*) memcpy_dma::src#1
  *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← ((byte*)) (void*) memcpy_dma::dest#1
  *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (number) 1
  *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (number) 0
  *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (number) 0
  *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command
  *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) ← <&(struct DMA_LIST_F018B) memcpy_dma_command
  *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) memcpy_dma::dmaMode#0
  to:memcpy_dma::@return
memcpy_dma::@return: scope:[memcpy_dma]  from memcpy_dma
  return 
  to:@return

(void()) main()
main: scope:[main]  from __start
  (byte) memoryRemap::remapBlocks#0 ← (number) 0
  (word) memoryRemap::lowerPageOffset#0 ← (number) 0
  (word) memoryRemap::upperPageOffset#0 ← (number) 0
  call memoryRemap 
  to:main::@1
main::@1: scope:[main]  from main
  (void*) memcpy_dma::dest#0 ← (void*)(const nomodify byte*) DEFAULT_SCREEN
  (void*) memcpy_dma::src#0 ← (void*)(const nomodify byte*) DEFAULT_SCREEN+(number) $50
  (word) memcpy_dma::num#0 ← (number) $18*(number) $50
  call memcpy_dma 
  to:main::@2
main::@2: scope:[main]  from main::@1
  to:main::@return
main::@return: scope:[main]  from main::@2
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify byte*) DEFAULT_SCREEN = (byte*)(number) $800
(const nomodify struct F018_DMAGIC*) DMA = (struct F018_DMAGIC*)(number) $d700
(const nomodify byte) DMA_COMMAND_COPY = (byte) 0
(byte) DMA_LIST_F018A::command
(word) DMA_LIST_F018A::count
(byte*) DMA_LIST_F018A::dest
(byte) DMA_LIST_F018A::dest_bank
(word) DMA_LIST_F018A::modulo
(byte*) DMA_LIST_F018A::src
(byte) DMA_LIST_F018A::src_bank
(byte) DMA_LIST_F018B::command
(word) DMA_LIST_F018B::count
(byte*) DMA_LIST_F018B::dest
(byte) DMA_LIST_F018B::dest_bank
(word) DMA_LIST_F018B::modulo
(byte*) DMA_LIST_F018B::src
(byte) DMA_LIST_F018B::src_bank
(byte) DMA_LIST_F018B::sub_command
(byte) F018_DMAGIC::ADDRBANK
(byte) F018_DMAGIC::ADDRLSB
(byte) F018_DMAGIC::ADDRLSBTRIG
(byte) F018_DMAGIC::ADDRMB
(byte) F018_DMAGIC::ADDRMSB
(byte) F018_DMAGIC::EN018B
(byte) F018_DMAGIC::ETRIG
(byte) F018_DMAGIC::MISC
(const byte*) F018_DMAGIC::UNUSED1[(number) 8]  = { fill( 8, 0) }
(byte) F018_DMAGIC::UNUSED2
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT = (byte) 1
(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST = (byte) 6
(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC = (byte) 3
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = (byte) 2
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG = (byte) 0
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB = (byte) 4
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = (byte) 1
(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B = (byte) 3
(void()) __start()
(label) __start::@1
(label) __start::@return
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(void()) memcpy_dma((void*) memcpy_dma::dest , (void*) memcpy_dma::src , (word) memcpy_dma::num)
(label) memcpy_dma::@return
(void*) memcpy_dma::dest
(void*) memcpy_dma::dest#0
(void*) memcpy_dma::dest#1
(byte) memcpy_dma::dmaMode
(byte) memcpy_dma::dmaMode#0
(word) memcpy_dma::num
(word) memcpy_dma::num#0
(word) memcpy_dma::num#1
(void*) memcpy_dma::src
(void*) memcpy_dma::src#0
(void*) memcpy_dma::src#1
(struct DMA_LIST_F018B) memcpy_dma_command loadstore = { command: (const nomodify byte) DMA_COMMAND_COPY, count: (word) 0, src: (byte*)(number) 0, src_bank: (byte) 0, dest: (byte*)(number) 0, dest_bank: (byte) 0, sub_command: (byte) 0, modulo: (word) 0 }
(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
(byte~) memoryRemap::$0
(byte~) memoryRemap::$1
(byte~) memoryRemap::$2
(number~) memoryRemap::$3
(number~) memoryRemap::$4
(byte~) memoryRemap::$5
(number~) memoryRemap::$6
(byte~) memoryRemap::$7
(number~) memoryRemap::$8
(number~) memoryRemap::$9
(label) memoryRemap::@return
(const byte*) memoryRemap::aVal = (byte*)(number) $fc
(word) memoryRemap::lowerPageOffset
(word) memoryRemap::lowerPageOffset#0
(word) memoryRemap::lowerPageOffset#1
(byte) memoryRemap::remapBlocks
(byte) memoryRemap::remapBlocks#0
(byte) memoryRemap::remapBlocks#1
(word) memoryRemap::upperPageOffset
(word) memoryRemap::upperPageOffset#0
(word) memoryRemap::upperPageOffset#1
(const byte*) memoryRemap::xVal = (byte*)(number) $fd
(const byte*) memoryRemap::yVal = (byte*)(number) $fe
(const byte*) memoryRemap::zVal = (byte*)(number) $ff

Adding number conversion cast (unumber) 4 in (byte~) memoryRemap::$1 ← (byte) memoryRemap::remapBlocks#1 << (number) 4
Adding number conversion cast (unumber) $f in (number~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (number) $f
Adding number conversion cast (unumber) memoryRemap::$3 in (number~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (unumber)(number) $f
Adding number conversion cast (unumber) memoryRemap::$4 in (number~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (unumber~) memoryRemap::$3
Adding number conversion cast (unumber) $f0 in (number~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#1 & (number) $f0
Adding number conversion cast (unumber) memoryRemap::$6 in (number~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#1 & (unumber)(number) $f0
Adding number conversion cast (unumber) $f in (number~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (number) $f
Adding number conversion cast (unumber) memoryRemap::$8 in (number~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (unumber)(number) $f
Adding number conversion cast (unumber) memoryRemap::$9 in (number~) memoryRemap::$9 ← (unumber~) memoryRemap::$6 | (unumber~) memoryRemap::$8
Adding number conversion cast (unumber) 1 in *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) memoryRemap::remapBlocks#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (word) memoryRemap::lowerPageOffset#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (word) memoryRemap::upperPageOffset#0 ← (number) 0
Adding number conversion cast (unumber) $50 in (void*) memcpy_dma::src#0 ← (void*)(const nomodify byte*) DEFAULT_SCREEN+(number) $50
Adding number conversion cast (unumber) $18*$50 in (word) memcpy_dma::num#0 ← (number) $18*(number) $50
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(void*) memcpy_dma::src#1
Inlining cast *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(void*) memcpy_dma::dest#1
Inlining cast *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (unumber)(number) 1
Inlining cast *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (unumber)(number) 0
Inlining cast *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (unumber)(number) 0
Inlining cast (byte) memoryRemap::remapBlocks#0 ← (unumber)(number) 0
Inlining cast (word) memoryRemap::lowerPageOffset#0 ← (unumber)(number) 0
Inlining cast (word) memoryRemap::upperPageOffset#0 ← (unumber)(number) 0
Inlining cast (word) memcpy_dma::num#0 ← (unumber)(number) $18*(number) $50
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 252
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (struct F018_DMAGIC*) 55040
Simplifying constant pointer cast (byte*) 2048
Simplifying constant pointer cast (byte*) 0
Simplifying constant pointer cast (byte*) 0
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast $f0
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $50
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $f0
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $50
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) memoryRemap::$3 ← (byte~) memoryRemap::$2 & (byte) $f
Inferred type updated to byte in (unumber~) memoryRemap::$4 ← (byte~) memoryRemap::$1 | (byte~) memoryRemap::$3
Inferred type updated to byte in (unumber~) memoryRemap::$6 ← (byte) memoryRemap::remapBlocks#1 & (byte) $f0
Inferred type updated to byte in (unumber~) memoryRemap::$8 ← (byte~) memoryRemap::$7 & (byte) $f
Inferred type updated to byte in (unumber~) memoryRemap::$9 ← (byte~) memoryRemap::$6 | (byte~) memoryRemap::$8
Identical Phi Values (word) memoryRemap::lowerPageOffset#1 (word) memoryRemap::lowerPageOffset#0
Identical Phi Values (byte) memoryRemap::remapBlocks#1 (byte) memoryRemap::remapBlocks#0
Identical Phi Values (word) memoryRemap::upperPageOffset#1 (word) memoryRemap::upperPageOffset#0
Identical Phi Values (word) memcpy_dma::num#1 (word) memcpy_dma::num#0
Identical Phi Values (void*) memcpy_dma::src#1 (void*) memcpy_dma::src#0
Identical Phi Values (void*) memcpy_dma::dest#1 (void*) memcpy_dma::dest#0
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [35] (word) memcpy_dma::num#0 ← (unumber)(number) $18*(number) $50
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) memoryRemap::remapBlocks#0 = 0
Constant (const word) memoryRemap::lowerPageOffset#0 = 0
Constant (const word) memoryRemap::upperPageOffset#0 = 0
Constant (const void*) memcpy_dma::dest#0 = (void*)DEFAULT_SCREEN
Constant (const void*) memcpy_dma::src#0 = (void*)DEFAULT_SCREEN+$50
Constant (const word) memcpy_dma::num#0 = (unumber)$18*$50
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte*)memcpy_dma::src#0 in [20] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0
Constant value identified (byte*)memcpy_dma::dest#0 in [21] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0
Successful SSA optimization Pass2ConstantValues
Simplifying expression containing zero (byte*)DMA in [26] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG) ← <&(struct DMA_LIST_F018B) memcpy_dma_command
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRLSBTRIG
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Constant right-side identified [0] (byte~) memoryRemap::$0 ← < (const word) memoryRemap::lowerPageOffset#0
Constant right-side identified [2] (byte~) memoryRemap::$1 ← (const byte) memoryRemap::remapBlocks#0 << (byte) 4
Constant right-side identified [3] (byte~) memoryRemap::$2 ← > (const word) memoryRemap::lowerPageOffset#0
Constant right-side identified [7] (byte~) memoryRemap::$5 ← < (const word) memoryRemap::upperPageOffset#0
Constant right-side identified [9] (byte~) memoryRemap::$6 ← (const byte) memoryRemap::remapBlocks#0 & (byte) $f0
Constant right-side identified [10] (byte~) memoryRemap::$7 ← > (const word) memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) memoryRemap::$0 = <memoryRemap::lowerPageOffset#0
Constant (const byte) memoryRemap::$1 = memoryRemap::remapBlocks#0<<4
Constant (const byte) memoryRemap::$2 = >memoryRemap::lowerPageOffset#0
Constant (const byte) memoryRemap::$5 = <memoryRemap::upperPageOffset#0
Constant (const byte) memoryRemap::$6 = memoryRemap::remapBlocks#0&$f0
Constant (const byte) memoryRemap::$7 = >memoryRemap::upperPageOffset#0
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero <(const word) memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero (const byte) memoryRemap::remapBlocks#0<<(byte) 4 in 
Simplifying constant evaluating to zero >(const word) memoryRemap::lowerPageOffset#0 in 
Simplifying constant evaluating to zero <(const word) memoryRemap::upperPageOffset#0 in 
Simplifying constant evaluating to zero (const byte) memoryRemap::remapBlocks#0&(byte) $f0 in 
Simplifying constant evaluating to zero >(const word) memoryRemap::upperPageOffset#0 in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero memoryRemap::$3 in [5] (byte~) memoryRemap::$4 ← (const byte) memoryRemap::$1 | (byte~) memoryRemap::$3
Simplifying expression containing zero memoryRemap::$8 in [12] (byte~) memoryRemap::$9 ← (const byte) memoryRemap::$6 | (byte~) memoryRemap::$8
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) memoryRemap::remapBlocks#0
Eliminating unused constant (const word) memoryRemap::lowerPageOffset#0
Eliminating unused constant (const word) memoryRemap::upperPageOffset#0
Eliminating unused constant (const byte) memoryRemap::$1
Eliminating unused constant (const byte) memoryRemap::$6
Successful SSA optimization PassNEliminateUnusedVars
Alias memoryRemap::$4 = memoryRemap::$3 
Alias memoryRemap::$9 = memoryRemap::$8 
Successful SSA optimization Pass2AliasElimination
Constant right-side identified [1] (byte~) memoryRemap::$4 ← (const byte) memoryRemap::$2 & (byte) $f
Constant right-side identified [4] (byte~) memoryRemap::$9 ← (const byte) memoryRemap::$7 & (byte) $f
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) memoryRemap::$4 = memoryRemap::$2&$f
Constant (const byte) memoryRemap::$9 = memoryRemap::$7&$f
Successful SSA optimization Pass2ConstantIdentification
Simplifying constant evaluating to zero (const byte) memoryRemap::$2&(byte) $f in 
Simplifying constant evaluating to zero (const byte) memoryRemap::$7&(byte) $f in 
Successful SSA optimization PassNSimplifyConstantZero
Eliminating unused constant (const byte) memoryRemap::$2
Eliminating unused constant (const byte) memoryRemap::$7
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined memoryRemap::$4 = (byte) 0
Constant inlined memoryRemap::$5 = (byte) 0
Constant inlined memoryRemap::$0 = (byte) 0
Constant inlined memoryRemap::$9 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
CALL GRAPH
Calls in [main] to memoryRemap:1 memcpy_dma:3 

Created 0 initial phi equivalence classes
Coalesced down to 0 phi equivalence classes
Culled Empty Block (label) main::@2
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@1

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call memoryRemap 
  to:main::@1
main::@1: scope:[main]  from main
  [2] phi()
  [3] call memcpy_dma 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [4] return 
  to:@return

(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
memoryRemap: scope:[memoryRemap]  from main
  [5] *((const byte*) memoryRemap::aVal) ← (byte) 0
  [6] *((const byte*) memoryRemap::xVal) ← (byte) 0
  [7] *((const byte*) memoryRemap::yVal) ← (byte) 0
  [8] *((const byte*) memoryRemap::zVal) ← (byte) 0
  asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
  to:memoryRemap::@return
memoryRemap::@return: scope:[memoryRemap]  from memoryRemap
  [10] return 
  to:@return

(void()) memcpy_dma((void*) memcpy_dma::dest , (void*) memcpy_dma::src , (word) memcpy_dma::num)
memcpy_dma: scope:[memcpy_dma]  from main::@1
  [11] (byte) memcpy_dma::dmaMode#0 ← *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B)
  [12] *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (const word) memcpy_dma::num#0
  [13] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0
  [14] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0
  [15] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) 1
  [16] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (byte) 0
  [17] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (byte) 0
  [18] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command
  [19] *((byte*)(const nomodify struct F018_DMAGIC*) DMA) ← <&(struct DMA_LIST_F018B) memcpy_dma_command
  [20] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) memcpy_dma::dmaMode#0
  to:memcpy_dma::@return
memcpy_dma::@return: scope:[memcpy_dma]  from memcpy_dma
  [21] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) DMA_LIST_F018A::command
(word) DMA_LIST_F018A::count
(byte*) DMA_LIST_F018A::dest
(byte) DMA_LIST_F018A::dest_bank
(word) DMA_LIST_F018A::modulo
(byte*) DMA_LIST_F018A::src
(byte) DMA_LIST_F018A::src_bank
(byte) DMA_LIST_F018B::command
(word) DMA_LIST_F018B::count
(byte*) DMA_LIST_F018B::dest
(byte) DMA_LIST_F018B::dest_bank
(word) DMA_LIST_F018B::modulo
(byte*) DMA_LIST_F018B::src
(byte) DMA_LIST_F018B::src_bank
(byte) DMA_LIST_F018B::sub_command
(byte) F018_DMAGIC::ADDRBANK
(byte) F018_DMAGIC::ADDRLSB
(byte) F018_DMAGIC::ADDRLSBTRIG
(byte) F018_DMAGIC::ADDRMB
(byte) F018_DMAGIC::ADDRMSB
(byte) F018_DMAGIC::EN018B
(byte) F018_DMAGIC::ETRIG
(byte) F018_DMAGIC::MISC
(byte) F018_DMAGIC::UNUSED2
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(void()) main()
(void()) memcpy_dma((void*) memcpy_dma::dest , (void*) memcpy_dma::src , (word) memcpy_dma::num)
(void*) memcpy_dma::dest
(byte) memcpy_dma::dmaMode
(byte) memcpy_dma::dmaMode#0 2.4444444444444446
(word) memcpy_dma::num
(void*) memcpy_dma::src
(struct DMA_LIST_F018B) memcpy_dma_command loadstore = { command: (const nomodify byte) DMA_COMMAND_COPY, count: (word) 0, src: (byte*) 0, src_bank: (byte) 0, dest: (byte*) 0, dest_bank: (byte) 0, sub_command: (byte) 0, modulo: (word) 0 }
(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
(word) memoryRemap::lowerPageOffset
(byte) memoryRemap::remapBlocks
(word) memoryRemap::upperPageOffset

Initial phi equivalence classes
Added variable memcpy_dma::dmaMode#0 to live range equivalence class [ memcpy_dma::dmaMode#0 ]
Added variable memcpy_dma_command to live range equivalence class [ memcpy_dma_command ]
Complete equivalence classes
[ memcpy_dma::dmaMode#0 ]
[ memcpy_dma_command ]
Allocated zp[1]:2 [ memcpy_dma::dmaMode#0 ]
Allocated mem[12] [ memcpy_dma_command ]

INITIAL ASM
Target platform is mega65 / MEGA45GS02
  // File Comments
// MEGA65 DMA test
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
// Functions for using the F018 DMA for very fast copying or filling of memory
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // [1] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call memcpy_dma 
    // Move screen up using DMA
    jsr memcpy_dma
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    // [5] *((const byte*) memoryRemap::aVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta aVal
    // [6] *((const byte*) memoryRemap::xVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta xVal
    // [7] *((const byte*) memoryRemap::yVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // [8] *((const byte*) memoryRemap::zVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [10] return 
    rts
}
  // memcpy_dma
// Copy a memory block within the first 64K memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly
// to the memory block pointed to by destination.
// The underlying type of the objects pointed to by both the source and destination pointers
// are irrelevant for this function; The result is a binary copy of the data.
memcpy_dma: {
    .const num = $18*$50
    .label dest = DEFAULT_SCREEN
    .label src = DEFAULT_SCREEN+$50
    .label dmaMode = 2
    // [11] (byte) memcpy_dma::dmaMode#0 ← *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuz1=_deref_pbuc1 
    // Remember current F018 A/B mode
    lda DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    sta.z dmaMode
    // [12] *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (const word) memcpy_dma::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [13] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [14] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [15] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [16] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [17] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [18] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [19] *((byte*)(const nomodify struct F018_DMAGIC*) DMA) ← <&(struct DMA_LIST_F018B) memcpy_dma_command -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command
    sta DMA
    // [20] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) memcpy_dma::dmaMode#0 -- _deref_pbuc1=vbuz1 
    // Re-enable F018A mode
    lda.z dmaMode
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memcpy_dma::@return
  __breturn:
    // [21] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry for copying data
  memcpy_dma_command: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [5] *((const byte*) memoryRemap::aVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) memoryRemap::xVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [7] *((const byte*) memoryRemap::yVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) memoryRemap::zVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [12] *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (const word) memcpy_dma::num#0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ memcpy_dma::dmaMode#0 ]
Statement [13] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [14] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) 1 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [16] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (byte) 0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [17] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (byte) 0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [18] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [19] *((byte*)(const nomodify struct F018_DMAGIC*) DMA) ← <&(struct DMA_LIST_F018B) memcpy_dma_command [ memcpy_dma::dmaMode#0 ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 ] { }  ) always clobbers reg byte a 
Statement [5] *((const byte*) memoryRemap::aVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [6] *((const byte*) memoryRemap::xVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [7] *((const byte*) memoryRemap::yVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [8] *((const byte*) memoryRemap::zVal) ← (byte) 0 [ ] ( memoryRemap:1 [ memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  } always clobbers reg byte a reg byte x reg byte y reg byte z 
Statement [12] *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (const word) memcpy_dma::num#0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [13] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [14] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) 1 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [16] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (byte) 0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [17] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (byte) 0 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [18] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command [ memcpy_dma::dmaMode#0 memcpy_dma_command ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 memcpy_dma_command ] { }  ) always clobbers reg byte a 
Statement [19] *((byte*)(const nomodify struct F018_DMAGIC*) DMA) ← <&(struct DMA_LIST_F018B) memcpy_dma_command [ memcpy_dma::dmaMode#0 ] ( memcpy_dma:3 [ memcpy_dma::dmaMode#0 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ memcpy_dma::dmaMode#0 ] : zp[1]:2 , reg byte x , reg byte y , reg byte z , 
Potential registers mem[12] [ memcpy_dma_command ] : mem[12] , 

REGISTER UPLIFT SCOPES
Uplift Scope [memcpy_dma] 2.44: zp[1]:2 [ memcpy_dma::dmaMode#0 ] 
Uplift Scope [MOS6526_CIA] 
Uplift Scope [MOS6569_VICII] 
Uplift Scope [MOS6581_SID] 
Uplift Scope [MOS4569_VICIII] 
Uplift Scope [MEGA65_VICIV] 
Uplift Scope [memoryRemap] 
Uplift Scope [F018_DMAGIC] 
Uplift Scope [DMA_LIST_F018A] 
Uplift Scope [DMA_LIST_F018B] 
Uplift Scope [main] 
Uplift Scope [] 0: mem[12] [ memcpy_dma_command ] 

Uplifting [memcpy_dma] best 159 combination reg byte x [ memcpy_dma::dmaMode#0 ] 
Uplifting [MOS6526_CIA] best 159 combination 
Uplifting [MOS6569_VICII] best 159 combination 
Uplifting [MOS6581_SID] best 159 combination 
Uplifting [MOS4569_VICIII] best 159 combination 
Uplifting [MEGA65_VICIV] best 159 combination 
Uplifting [memoryRemap] best 159 combination 
Uplifting [F018_DMAGIC] best 159 combination 
Uplifting [DMA_LIST_F018A] best 159 combination 
Uplifting [DMA_LIST_F018B] best 159 combination 
Uplifting [main] best 159 combination 
Uplifting [] best 159 combination mem[12] [ memcpy_dma_command ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// MEGA65 DMA test
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
// Functions for using the F018 DMA for very fast copying or filling of memory
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // [1] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // [2] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [3] call memcpy_dma 
    // Move screen up using DMA
    jsr memcpy_dma
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    // [5] *((const byte*) memoryRemap::aVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta aVal
    // [6] *((const byte*) memoryRemap::xVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta xVal
    // [7] *((const byte*) memoryRemap::yVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta yVal
    // [8] *((const byte*) memoryRemap::zVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta zVal
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    jmp __breturn
    // memoryRemap::@return
  __breturn:
    // [10] return 
    rts
}
  // memcpy_dma
// Copy a memory block within the first 64K memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly
// to the memory block pointed to by destination.
// The underlying type of the objects pointed to by both the source and destination pointers
// are irrelevant for this function; The result is a binary copy of the data.
memcpy_dma: {
    .const num = $18*$50
    .label dest = DEFAULT_SCREEN
    .label src = DEFAULT_SCREEN+$50
    // [11] (byte) memcpy_dma::dmaMode#0 ← *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [12] *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (const word) memcpy_dma::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // [13] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // [14] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // [15] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // [16] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // [17] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // [18] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // [19] *((byte*)(const nomodify struct F018_DMAGIC*) DMA) ← <&(struct DMA_LIST_F018B) memcpy_dma_command -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command
    sta DMA
    // [20] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) memcpy_dma::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    jmp __breturn
    // memcpy_dma::@return
  __breturn:
    // [21] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry for copying data
  memcpy_dma_command: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1_from_main:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(const nomodify byte*) DEFAULT_SCREEN = (byte*) 2048
(const nomodify struct F018_DMAGIC*) DMA = (struct F018_DMAGIC*) 55040
(const nomodify byte) DMA_COMMAND_COPY = (byte) 0
(byte) DMA_LIST_F018A::command
(word) DMA_LIST_F018A::count
(byte*) DMA_LIST_F018A::dest
(byte) DMA_LIST_F018A::dest_bank
(word) DMA_LIST_F018A::modulo
(byte*) DMA_LIST_F018A::src
(byte) DMA_LIST_F018A::src_bank
(byte) DMA_LIST_F018B::command
(word) DMA_LIST_F018B::count
(byte*) DMA_LIST_F018B::dest
(byte) DMA_LIST_F018B::dest_bank
(word) DMA_LIST_F018B::modulo
(byte*) DMA_LIST_F018B::src
(byte) DMA_LIST_F018B::src_bank
(byte) DMA_LIST_F018B::sub_command
(byte) F018_DMAGIC::ADDRBANK
(byte) F018_DMAGIC::ADDRLSB
(byte) F018_DMAGIC::ADDRLSBTRIG
(byte) F018_DMAGIC::ADDRMB
(byte) F018_DMAGIC::ADDRMSB
(byte) F018_DMAGIC::EN018B
(byte) F018_DMAGIC::ETRIG
(byte) F018_DMAGIC::MISC
(const byte*) F018_DMAGIC::UNUSED1[(number) 8]  = { fill( 8, 0) }
(byte) F018_DMAGIC::UNUSED2
(byte) MEGA65_VICIV::ALPHADELAY
(byte) MEGA65_VICIV::B0PIX
(byte) MEGA65_VICIV::B0_ADDR
(byte) MEGA65_VICIV::B1PIX
(byte) MEGA65_VICIV::B1_ADDR
(byte) MEGA65_VICIV::B2PIX
(byte) MEGA65_VICIV::B2_ADDR
(byte) MEGA65_VICIV::B3PIX
(byte) MEGA65_VICIV::B3_ADDR
(byte) MEGA65_VICIV::B4PIX
(byte) MEGA65_VICIV::B4_ADDR
(byte) MEGA65_VICIV::B5PIX
(byte) MEGA65_VICIV::B5_ADDR
(byte) MEGA65_VICIV::B6PIX
(byte) MEGA65_VICIV::B6_ADDR
(byte) MEGA65_VICIV::B7PIX
(byte) MEGA65_VICIV::B7_ADDR
(byte) MEGA65_VICIV::BBDRPOS_HI
(byte) MEGA65_VICIV::BBDRPOS_LO
(byte) MEGA65_VICIV::BG_COLOR
(byte) MEGA65_VICIV::BG_COLOR1
(byte) MEGA65_VICIV::BG_COLOR2
(byte) MEGA65_VICIV::BG_COLOR3
(byte) MEGA65_VICIV::BORDER_COLOR
(byte) MEGA65_VICIV::BP16ENS
(byte) MEGA65_VICIV::BPCOMP
(byte) MEGA65_VICIV::BPX
(byte) MEGA65_VICIV::BPY
(byte) MEGA65_VICIV::CHARPTR_HILO
(byte) MEGA65_VICIV::CHARPTR_LOHI
(byte) MEGA65_VICIV::CHARPTR_LOLO
(byte) MEGA65_VICIV::CHARSTEP_HI
(byte) MEGA65_VICIV::CHARSTEP_LO
(byte) MEGA65_VICIV::CHRCOUNT
(byte) MEGA65_VICIV::CHRXSCL
(byte) MEGA65_VICIV::CHRYSCL
(byte) MEGA65_VICIV::COLPTR_HI
(byte) MEGA65_VICIV::COLPTR_LO
(byte) MEGA65_VICIV::CONTROL1
(byte) MEGA65_VICIV::CONTROL2
(byte) MEGA65_VICIV::CONTROLA
(byte) MEGA65_VICIV::CONTROLB
(byte) MEGA65_VICIV::CONTROLC
(byte) MEGA65_VICIV::DEBUG1
(byte) MEGA65_VICIV::DEBUGX
(byte) MEGA65_VICIV::DEBUGXY
(byte) MEGA65_VICIV::DEBUGY
(byte) MEGA65_VICIV::FNRASTER_HI
(byte) MEGA65_VICIV::FNRASTER_LO
(byte) MEGA65_VICIV::HPOS
(byte) MEGA65_VICIV::IRQ_ENABLE
(byte) MEGA65_VICIV::IRQ_STATUS
(byte) MEGA65_VICIV::KEY
(byte) MEGA65_VICIV::LIGHTPEN_X
(byte) MEGA65_VICIV::LIGHTPEN_Y
(byte) MEGA65_VICIV::MEMORY
(byte) MEGA65_VICIV::PALSEL
(byte) MEGA65_VICIV::RASLINE0
(byte) MEGA65_VICIV::RASTER
(byte) MEGA65_VICIV::ROWCOUNT
(byte) MEGA65_VICIV::RSTCMP
(byte) MEGA65_VICIV::RSTCOMP
(byte) MEGA65_VICIV::SBPDEBUG
(byte) MEGA65_VICIV::SCRNPTR_HIHI
(byte) MEGA65_VICIV::SCRNPTR_HILO
(byte) MEGA65_VICIV::SCRNPTR_LOHI
(byte) MEGA65_VICIV::SCRNPTR_LOLO
(byte) MEGA65_VICIV::SIDBDRWD_HI
(byte) MEGA65_VICIV::SIDBDRWD_LO
(byte) MEGA65_VICIV::SPR16EN
(byte) MEGA65_VICIV::SPRALPHAVAL
(byte) MEGA65_VICIV::SPRENALPHA
(byte) MEGA65_VICIV::SPRENV400
(byte) MEGA65_VICIV::SPRHGHT
(byte) MEGA65_VICIV::SPRHGTEN
(byte) MEGA65_VICIV::SPRITE0_COLOR
(byte) MEGA65_VICIV::SPRITE0_X
(byte) MEGA65_VICIV::SPRITE0_Y
(byte) MEGA65_VICIV::SPRITE1_COLOR
(byte) MEGA65_VICIV::SPRITE1_X
(byte) MEGA65_VICIV::SPRITE1_Y
(byte) MEGA65_VICIV::SPRITE2_COLOR
(byte) MEGA65_VICIV::SPRITE2_X
(byte) MEGA65_VICIV::SPRITE2_Y
(byte) MEGA65_VICIV::SPRITE3_COLOR
(byte) MEGA65_VICIV::SPRITE3_X
(byte) MEGA65_VICIV::SPRITE3_Y
(byte) MEGA65_VICIV::SPRITE4_COLOR
(byte) MEGA65_VICIV::SPRITE4_X
(byte) MEGA65_VICIV::SPRITE4_Y
(byte) MEGA65_VICIV::SPRITE5_COLOR
(byte) MEGA65_VICIV::SPRITE5_X
(byte) MEGA65_VICIV::SPRITE5_Y
(byte) MEGA65_VICIV::SPRITE6_COLOR
(byte) MEGA65_VICIV::SPRITE6_X
(byte) MEGA65_VICIV::SPRITE6_Y
(byte) MEGA65_VICIV::SPRITE7_COLOR
(byte) MEGA65_VICIV::SPRITE7_X
(byte) MEGA65_VICIV::SPRITE7_Y
(byte) MEGA65_VICIV::SPRITES_BG_COLLISION
(byte) MEGA65_VICIV::SPRITES_COLLISION
(byte) MEGA65_VICIV::SPRITES_ENABLE
(byte) MEGA65_VICIV::SPRITES_EXPAND_X
(byte) MEGA65_VICIV::SPRITES_EXPAND_Y
(byte) MEGA65_VICIV::SPRITES_MC
(byte) MEGA65_VICIV::SPRITES_MCOLOR1
(byte) MEGA65_VICIV::SPRITES_MCOLOR2
(byte) MEGA65_VICIV::SPRITES_PRIORITY
(byte) MEGA65_VICIV::SPRITES_XMSB
(byte) MEGA65_VICIV::SPRPTRADR_HILO
(byte) MEGA65_VICIV::SPRPTRADR_LOHI
(byte) MEGA65_VICIV::SPRPTRADR_LOLO
(byte) MEGA65_VICIV::SPRX64EN
(byte) MEGA65_VICIV::SPRXSMSBS
(byte) MEGA65_VICIV::SPRYSMSBSM
(byte) MEGA65_VICIV::SRPYMSBS
(byte) MEGA65_VICIV::SYNCPOL
(byte) MEGA65_VICIV::TBDRPOS_HI
(byte) MEGA65_VICIV::TBDRPOS_LO
(byte) MEGA65_VICIV::TEXTXPOS_HI
(byte) MEGA65_VICIV::TEXTXPOS_LO
(byte) MEGA65_VICIV::TEXTYPOS_HI
(byte) MEGA65_VICIV::TEXTYPOS_LO
(byte) MEGA65_VICIV::UNUSED
(byte) MEGA65_VICIV::VPOS
(byte) MEGA65_VICIV::VSYNDEL
(byte) MEGA65_VICIV::XPOS_HI
(byte) MEGA65_VICIV::XPOS_LO
(byte) MOS4569_VICIII::B0PIX
(byte) MOS4569_VICIII::B0_ADDR
(byte) MOS4569_VICIII::B1PIX
(byte) MOS4569_VICIII::B1_ADDR
(byte) MOS4569_VICIII::B2PIX
(byte) MOS4569_VICIII::B2_ADDR
(byte) MOS4569_VICIII::B3PIX
(byte) MOS4569_VICIII::B3_ADDR
(byte) MOS4569_VICIII::B4PIX
(byte) MOS4569_VICIII::B4_ADDR
(byte) MOS4569_VICIII::B5PIX
(byte) MOS4569_VICIII::B5_ADDR
(byte) MOS4569_VICIII::B6PIX
(byte) MOS4569_VICIII::B6_ADDR
(byte) MOS4569_VICIII::B7PIX
(byte) MOS4569_VICIII::B7_ADDR
(byte) MOS4569_VICIII::BG_COLOR
(byte) MOS4569_VICIII::BG_COLOR1
(byte) MOS4569_VICIII::BG_COLOR2
(byte) MOS4569_VICIII::BG_COLOR3
(byte) MOS4569_VICIII::BORDER_COLOR
(byte) MOS4569_VICIII::BPCOMP
(byte) MOS4569_VICIII::BPX
(byte) MOS4569_VICIII::BPY
(byte) MOS4569_VICIII::CONTROL1
(byte) MOS4569_VICIII::CONTROL2
(byte) MOS4569_VICIII::CONTROLA
(byte) MOS4569_VICIII::CONTROLB
(byte) MOS4569_VICIII::HPOS
(byte) MOS4569_VICIII::IRQ_ENABLE
(byte) MOS4569_VICIII::IRQ_STATUS
(byte) MOS4569_VICIII::KEY
(byte) MOS4569_VICIII::LIGHTPEN_X
(byte) MOS4569_VICIII::LIGHTPEN_Y
(byte) MOS4569_VICIII::MEMORY
(byte) MOS4569_VICIII::RASTER
(byte) MOS4569_VICIII::SPRITE0_COLOR
(byte) MOS4569_VICIII::SPRITE0_X
(byte) MOS4569_VICIII::SPRITE0_Y
(byte) MOS4569_VICIII::SPRITE1_COLOR
(byte) MOS4569_VICIII::SPRITE1_X
(byte) MOS4569_VICIII::SPRITE1_Y
(byte) MOS4569_VICIII::SPRITE2_COLOR
(byte) MOS4569_VICIII::SPRITE2_X
(byte) MOS4569_VICIII::SPRITE2_Y
(byte) MOS4569_VICIII::SPRITE3_COLOR
(byte) MOS4569_VICIII::SPRITE3_X
(byte) MOS4569_VICIII::SPRITE3_Y
(byte) MOS4569_VICIII::SPRITE4_COLOR
(byte) MOS4569_VICIII::SPRITE4_X
(byte) MOS4569_VICIII::SPRITE4_Y
(byte) MOS4569_VICIII::SPRITE5_COLOR
(byte) MOS4569_VICIII::SPRITE5_X
(byte) MOS4569_VICIII::SPRITE5_Y
(byte) MOS4569_VICIII::SPRITE6_COLOR
(byte) MOS4569_VICIII::SPRITE6_X
(byte) MOS4569_VICIII::SPRITE6_Y
(byte) MOS4569_VICIII::SPRITE7_COLOR
(byte) MOS4569_VICIII::SPRITE7_X
(byte) MOS4569_VICIII::SPRITE7_Y
(byte) MOS4569_VICIII::SPRITES_BG_COLLISION
(byte) MOS4569_VICIII::SPRITES_COLLISION
(byte) MOS4569_VICIII::SPRITES_ENABLE
(byte) MOS4569_VICIII::SPRITES_EXPAND_X
(byte) MOS4569_VICIII::SPRITES_EXPAND_Y
(byte) MOS4569_VICIII::SPRITES_MC
(byte) MOS4569_VICIII::SPRITES_MCOLOR1
(byte) MOS4569_VICIII::SPRITES_MCOLOR2
(byte) MOS4569_VICIII::SPRITES_PRIORITY
(byte) MOS4569_VICIII::SPRITES_XMSB
(byte) MOS4569_VICIII::UNUSED
(byte) MOS4569_VICIII::VPOS
(byte) MOS6526_CIA::INTERRUPT
(byte) MOS6526_CIA::PORT_A
(byte) MOS6526_CIA::PORT_A_DDR
(byte) MOS6526_CIA::PORT_B
(byte) MOS6526_CIA::PORT_B_DDR
(byte) MOS6526_CIA::SERIAL_DATA
(word) MOS6526_CIA::TIMER_A
(byte) MOS6526_CIA::TIMER_A_CONTROL
(word) MOS6526_CIA::TIMER_B
(byte) MOS6526_CIA::TIMER_B_CONTROL
(byte) MOS6526_CIA::TOD_10THS
(byte) MOS6526_CIA::TOD_HOURS
(byte) MOS6526_CIA::TOD_MIN
(byte) MOS6526_CIA::TOD_SEC
(byte) MOS6569_VICII::BG_COLOR
(byte) MOS6569_VICII::BG_COLOR1
(byte) MOS6569_VICII::BG_COLOR2
(byte) MOS6569_VICII::BG_COLOR3
(byte) MOS6569_VICII::BORDER_COLOR
(byte) MOS6569_VICII::CONTROL1
(byte) MOS6569_VICII::CONTROL2
(byte) MOS6569_VICII::IRQ_ENABLE
(byte) MOS6569_VICII::IRQ_STATUS
(byte) MOS6569_VICII::LIGHTPEN_X
(byte) MOS6569_VICII::LIGHTPEN_Y
(byte) MOS6569_VICII::MEMORY
(byte) MOS6569_VICII::RASTER
(byte) MOS6569_VICII::SPRITE0_COLOR
(byte) MOS6569_VICII::SPRITE0_X
(byte) MOS6569_VICII::SPRITE0_Y
(byte) MOS6569_VICII::SPRITE1_COLOR
(byte) MOS6569_VICII::SPRITE1_X
(byte) MOS6569_VICII::SPRITE1_Y
(byte) MOS6569_VICII::SPRITE2_COLOR
(byte) MOS6569_VICII::SPRITE2_X
(byte) MOS6569_VICII::SPRITE2_Y
(byte) MOS6569_VICII::SPRITE3_COLOR
(byte) MOS6569_VICII::SPRITE3_X
(byte) MOS6569_VICII::SPRITE3_Y
(byte) MOS6569_VICII::SPRITE4_COLOR
(byte) MOS6569_VICII::SPRITE4_X
(byte) MOS6569_VICII::SPRITE4_Y
(byte) MOS6569_VICII::SPRITE5_COLOR
(byte) MOS6569_VICII::SPRITE5_X
(byte) MOS6569_VICII::SPRITE5_Y
(byte) MOS6569_VICII::SPRITE6_COLOR
(byte) MOS6569_VICII::SPRITE6_X
(byte) MOS6569_VICII::SPRITE6_Y
(byte) MOS6569_VICII::SPRITE7_COLOR
(byte) MOS6569_VICII::SPRITE7_X
(byte) MOS6569_VICII::SPRITE7_Y
(byte) MOS6569_VICII::SPRITES_BG_COLLISION
(byte) MOS6569_VICII::SPRITES_COLLISION
(byte) MOS6569_VICII::SPRITES_ENABLE
(byte) MOS6569_VICII::SPRITES_EXPAND_X
(byte) MOS6569_VICII::SPRITES_EXPAND_Y
(byte) MOS6569_VICII::SPRITES_MC
(byte) MOS6569_VICII::SPRITES_MCOLOR1
(byte) MOS6569_VICII::SPRITES_MCOLOR2
(byte) MOS6569_VICII::SPRITES_PRIORITY
(byte) MOS6569_VICII::SPRITES_XMSB
(byte) MOS6581_SID::CH1_ATTACK_DECAY
(byte) MOS6581_SID::CH1_CONTROL
(word) MOS6581_SID::CH1_FREQ
(word) MOS6581_SID::CH1_PULSE_WIDTH
(byte) MOS6581_SID::CH1_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH2_ATTACK_DECAY
(byte) MOS6581_SID::CH2_CONTROL
(word) MOS6581_SID::CH2_FREQ
(word) MOS6581_SID::CH2_PULSE_WIDTH
(byte) MOS6581_SID::CH2_SUSTAIN_RELEASE
(byte) MOS6581_SID::CH3_ATTACK_DECAY
(byte) MOS6581_SID::CH3_CONTROL
(byte) MOS6581_SID::CH3_ENV
(word) MOS6581_SID::CH3_FREQ
(byte) MOS6581_SID::CH3_OSC
(word) MOS6581_SID::CH3_PULSE_WIDTH
(byte) MOS6581_SID::CH3_SUSTAIN_RELEASE
(byte) MOS6581_SID::FILTER_CUTOFF_HIGH
(byte) MOS6581_SID::FILTER_CUTOFF_LOW
(byte) MOS6581_SID::FILTER_SETUP
(byte) MOS6581_SID::POT_X
(byte) MOS6581_SID::POT_Y
(byte) MOS6581_SID::VOLUME_FILTER_MODE
(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT = (byte) 1
(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST = (byte) 6
(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC = (byte) 3
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = (byte) 2
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB = (byte) 4
(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = (byte) 1
(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B = (byte) 3
(void()) main()
(label) main::@1
(label) main::@return
(void()) memcpy_dma((void*) memcpy_dma::dest , (void*) memcpy_dma::src , (word) memcpy_dma::num)
(label) memcpy_dma::@return
(void*) memcpy_dma::dest
(const void*) memcpy_dma::dest#0 dest = (void*)(const nomodify byte*) DEFAULT_SCREEN
(byte) memcpy_dma::dmaMode
(byte) memcpy_dma::dmaMode#0 reg byte x 2.4444444444444446
(word) memcpy_dma::num
(const word) memcpy_dma::num#0 num = (word)(number) $18*(number) $50
(void*) memcpy_dma::src
(const void*) memcpy_dma::src#0 src = (void*)(const nomodify byte*) DEFAULT_SCREEN+(byte) $50
(struct DMA_LIST_F018B) memcpy_dma_command loadstore mem[12] = { command: (const nomodify byte) DMA_COMMAND_COPY, count: (word) 0, src: (byte*) 0, src_bank: (byte) 0, dest: (byte*) 0, dest_bank: (byte) 0, sub_command: (byte) 0, modulo: (word) 0 }
(void()) memoryRemap((byte) memoryRemap::remapBlocks , (word) memoryRemap::lowerPageOffset , (word) memoryRemap::upperPageOffset)
(label) memoryRemap::@return
(const byte*) memoryRemap::aVal = (byte*) 252
(word) memoryRemap::lowerPageOffset
(byte) memoryRemap::remapBlocks
(word) memoryRemap::upperPageOffset
(const byte*) memoryRemap::xVal = (byte*) 253
(const byte*) memoryRemap::yVal = (byte*) 254
(const byte*) memoryRemap::zVal = (byte*) 255

reg byte x [ memcpy_dma::dmaMode#0 ]
mem[12] [ memcpy_dma_command ]


FINAL ASSEMBLER
Score: 139

  // File Comments
// MEGA65 DMA test
// Appendix J in https://mega.scryptos.com/sharefolder-link/MEGA/MEGA65+filehost/Docs/MEGA65-Book_draft.pdf
// Functions for using the F018 DMA for very fast copying or filling of memory
// MEGA65 Registers and Constants
// The MOS 6526 Complex Interface Adapter (CIA)
// http://archive.6502.org/datasheets/mos_6526_cia_recreated.pdf
  // Upstart
.cpu _45gs02
  // MEGA65 platform PRG executable starting in MEGA65 mode.
.file [name="dma-test2.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$2001]
.segmentdef Code [start=$2017]
.segmentdef Data [startAfter="Code"]
.segment Basic
.byte $0a, $20, $0a, $00, $fe, $02, $20, $30, $00       // 10 BANK 0
.byte $15, $20, $14, $00, $9e, $20                      // 20 SYS 
.text toIntString(main)                                   //         NNNN
.byte $00, $00, $00                                     // 
  // Global Constants & labels
  // DMA command copy
  .const DMA_COMMAND_COPY = 0
  .const OFFSET_STRUCT_F018_DMAGIC_EN018B = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_COUNT = 1
  .const OFFSET_STRUCT_DMA_LIST_F018B_SRC = 3
  .const OFFSET_STRUCT_DMA_LIST_F018B_DEST = 6
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMB = 4
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRBANK = 2
  .const OFFSET_STRUCT_F018_DMAGIC_ADDRMSB = 1
  // DMAgic F018 Controller
  .label DMA = $d700
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $800
.segment Code
  // main
main: {
    // memoryRemap(0,0,0)
    // [1] call memoryRemap 
    // Map memory to BANK 0 : 0x00XXXX - giving access to I/O
    jsr memoryRemap
    // [2] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // memcpy_dma(DEFAULT_SCREEN, DEFAULT_SCREEN+80, 24*80)
    // [3] call memcpy_dma 
    // Move screen up using DMA
    jsr memcpy_dma
    // main::@return
    // }
    // [4] return 
    rts
}
  // memoryRemap
// Remap some of the eight 8K memory blocks in the 64K address space of the 6502 to point somewhere else in the first 1MB memory space of the MEGA65.
// After the remapping the CPU will access the mapped memory whenever it uses instructions that access a remapped block.
// See section 2.3.4 in http://www.zimmers.net/cbmpics/cbm/c65/c65manual.txt for a description of the CPU memory remapper of the C65.
// remapBlocks: Indicates which 8K blocks of the 6502 address space to remap. Each bit represents one 8K block
// - bit 0  Memory block $0000-$1fff. Use constant MEMORYBLOCK_0000.
// - bit 1  Memory block $2000-$3fff. Use constant MEMORYBLOCK_2000.
// - bit 2  Memory block $4000-$5fff. Use constant MEMORYBLOCK_4000.
// - bit 3  Memory block $6000-$7fff. Use constant MEMORYBLOCK_6000.
// - bit 4  Memory block $8000-$9fff. Use constant MEMORYBLOCK_8000.
// - bit 5  Memory block $a000-$bfff. Use constant MEMORYBLOCK_A000.
// - bit 6  Memory block $c000-$dfff. Use constant MEMORYBLOCK_C000.
// - bit 7  Memory block $e000-$ffff. Use constant MEMORYBLOCK_E000.
// lowerPageOffset: Offset that will be added to any remapped blocks in the lower 32K of memory (block 0-3).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 0 ($0000-$1fff) is remapped it will point to lowerPageOffset*$100.
// - If block 1 ($2000-$3fff) is remapped it will point to lowerPageOffset*$100 + $2000.
// - If block 2 ($4000-$5fff) is remapped it will point to lowerPageOffset*$100 + $4000.
// - If block 3 ($6000-$7fff) is remapped it will point to lowerPageOffset*$100 + $6000.
// upperPageOffset: Offset that will be added to any remapped blocks in the upper 32K of memory (block 4-7).
// The offset is a page offset (meaning it is multiplied by 0x100). Only the lower 12bits of the passed value is used.
// - If block 4 ($8000-$9fff) is remapped it will point to upperPageOffset*$100 + $8000
// - If block 5 ($a000-$bfff) is remapped it will point to upperPageOffset*$100 + $a000.
// - If block 6 ($c000-$dfff) is remapped it will point to upperPageOffset*$100 + $c000.
// - If block 7 ($e000-$ffff) is remapped it will point to upperPageOffset*$100 + $e000.
memoryRemap: {
    .label aVal = $fc
    .label xVal = $fd
    .label yVal = $fe
    .label zVal = $ff
    // *aVal = <lowerPageOffset
    // [5] *((const byte*) memoryRemap::aVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta aVal
    // *xVal = (remapBlocks << 4)   | (>lowerPageOffset & 0xf)
    // [6] *((const byte*) memoryRemap::xVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta xVal
    // *yVal = <upperPageOffset
    // [7] *((const byte*) memoryRemap::yVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta yVal
    // *zVal = (remapBlocks & 0xf0) | (>upperPageOffset & 0xf)
    // [8] *((const byte*) memoryRemap::zVal) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta zVal
    // asm
    // asm { ldaaVal ldxxVal ldyyVal ldzzVal map eom  }
    lda aVal
    ldx xVal
    ldy yVal
    ldz zVal
    map
    eom
    // memoryRemap::@return
    // }
    // [10] return 
    rts
}
  // memcpy_dma
// Copy a memory block within the first 64K memory space using MEGA65 DMagic DMA
// Copies the values of num bytes from the location pointed to by source directly
// to the memory block pointed to by destination.
// The underlying type of the objects pointed to by both the source and destination pointers
// are irrelevant for this function; The result is a binary copy of the data.
memcpy_dma: {
    .const num = $18*$50
    .label dest = DEFAULT_SCREEN
    .label src = DEFAULT_SCREEN+$50
    // dmaMode = DMA->EN018B
    // [11] (byte) memcpy_dma::dmaMode#0 ← *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) -- vbuxx=_deref_pbuc1 
    // Remember current F018 A/B mode
    ldx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma_command.count = num
    // [12] *((word*)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_COUNT) ← (const word) memcpy_dma::num#0 -- _deref_pwuc1=vwuc2 
    // Set up command
    lda #<num
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT
    lda #>num
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_COUNT+1
    // memcpy_dma_command.src = src
    // [13] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_SRC) ← (byte*)(const void*) memcpy_dma::src#0 -- _deref_qbuc1=pbuc2 
    lda #<src
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC
    lda #>src
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_SRC+1
    // memcpy_dma_command.dest = dest
    // [14] *((byte**)&(struct DMA_LIST_F018B) memcpy_dma_command+(const byte) OFFSET_STRUCT_DMA_LIST_F018B_DEST) ← (byte*)(const void*) memcpy_dma::dest#0 -- _deref_qbuc1=pbuc2 
    lda #<dest
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST
    lda #>dest
    sta memcpy_dma_command+OFFSET_STRUCT_DMA_LIST_F018B_DEST+1
    // DMA->EN018B = 1
    // [15] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) 1 -- _deref_pbuc1=vbuc2 
    // Set F018B mode
    lda #1
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // DMA->ADDRMB = 0
    // [16] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMB) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    // Set address of DMA list
    lda #0
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMB
    // DMA->ADDRBANK = 0
    // [17] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRBANK) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRBANK
    // DMA-> ADDRMSB = >&memcpy_dma_command
    // [18] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_ADDRMSB) ← >&(struct DMA_LIST_F018B) memcpy_dma_command -- _deref_pbuc1=vbuc2 
    lda #>memcpy_dma_command
    sta DMA+OFFSET_STRUCT_F018_DMAGIC_ADDRMSB
    // DMA-> ADDRLSBTRIG = <&memcpy_dma_command
    // [19] *((byte*)(const nomodify struct F018_DMAGIC*) DMA) ← <&(struct DMA_LIST_F018B) memcpy_dma_command -- _deref_pbuc1=vbuc2 
    // Trigger the DMA (without option lists)
    lda #<memcpy_dma_command
    sta DMA
    // DMA->EN018B = dmaMode
    // [20] *((byte*)(const nomodify struct F018_DMAGIC*) DMA+(const byte) OFFSET_STRUCT_F018_DMAGIC_EN018B) ← (byte) memcpy_dma::dmaMode#0 -- _deref_pbuc1=vbuxx 
    // Re-enable F018A mode
    stx DMA+OFFSET_STRUCT_F018_DMAGIC_EN018B
    // memcpy_dma::@return
    // }
    // [21] return 
    rts
}
  // File Data
.segment Data
  // DMA list entry for copying data
  memcpy_dma_command: .byte DMA_COMMAND_COPY
  .word 0, 0
  .byte 0
  .word 0
  .byte 0, 0
  .word 0

