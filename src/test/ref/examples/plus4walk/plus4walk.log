Fixing struct type size struct MOS7360_TED to 63
Fixing struct type SIZE_OF struct MOS7360_TED to 63
Fixing struct type SIZE_OF struct MOS7360_TED to 63
Inlined call call __init 

CONTROL FLOW GRAPH SSA

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main main::@14 main::@15
  (byte) memset::c#6 ← phi( main/(byte) memset::c#0 main::@14/(byte) memset::c#1 main::@15/(byte) memset::c#2 )
  (void*) memset::str#5 ← phi( main/(void*) memset::str#0 main::@14/(void*) memset::str#1 main::@15/(void*) memset::str#2 )
  (word) memset::num#3 ← phi( main/(word) memset::num#0 main::@14/(word) memset::num#1 main::@15/(word) memset::num#2 )
  (bool~) memset::$0 ← (word) memset::num#3 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@3
  (void*) memset::str#3 ← phi( memset/(void*) memset::str#5 memset::@3/(void*) memset::str#6 )
  (void*) memset::return#0 ← (void*) memset::str#3
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#5 ← phi( memset/(byte) memset::c#6 )
  (word) memset::num#4 ← phi( memset/(word) memset::num#3 )
  (void*) memset::str#4 ← phi( memset/(void*) memset::str#5 )
  (byte*~) memset::$4 ← (byte*)(void*) memset::str#4
  (byte*~) memset::$2 ← (byte*~) memset::$4 + (word) memset::num#4
  (byte*) memset::end#0 ← (byte*~) memset::$2
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#4
  to:memset::@3
memset::@3: scope:[memset]  from memset::@2 memset::@4
  (byte) memset::c#4 ← phi( memset::@2/(byte) memset::c#5 memset::@4/(byte) memset::c#3 )
  (void*) memset::str#6 ← phi( memset::@2/(void*) memset::str#4 memset::@4/(void*) memset::str#7 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@4/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@4/(byte*) memset::dst#1 )
  (bool~) memset::$3 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$3) goto memset::@4
  to:memset::@1
memset::@4: scope:[memset]  from memset::@3
  (void*) memset::str#7 ← phi( memset::@3/(void*) memset::str#6 )
  (byte*) memset::end#2 ← phi( memset::@3/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@3/(byte*) memset::dst#2 )
  (byte) memset::c#3 ← phi( memset::@3/(byte) memset::c#4 )
  *((byte*) memset::dst#3) ← (byte) memset::c#3
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@3
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#5 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#5
  return 
  to:@return

(word()) rand()
rand: scope:[rand]  from main::@2
  (word) rand_state#9 ← phi( main::@2/(word) rand_state#15 )
  (word~) rand::$0 ← (word) rand_state#9 << (number) 7
  (word) rand_state#0 ← (word) rand_state#9 ^ (word~) rand::$0
  (word~) rand::$1 ← (word) rand_state#0 >> (number) 9
  (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1
  (word~) rand::$2 ← (word) rand_state#1 << (number) 8
  (word) rand_state#2 ← (word) rand_state#1 ^ (word~) rand::$2
  (word) rand::return#0 ← (word) rand_state#2
  to:rand::@return
rand::@return: scope:[rand]  from rand
  (word) rand_state#10 ← phi( rand/(word) rand_state#2 )
  (word) rand::return#3 ← phi( rand/(word) rand::return#0 )
  (word) rand::return#1 ← (word) rand::return#3
  (word) rand_state#3 ← (word) rand_state#10
  return 
  to:@return

(void()) main()
main: scope:[main]  from __start::@1
  (word) rand_state#32 ← phi( __start::@1/(word) rand_state#17 )
  (void*) memset::str#0 ← (void*)(const nomodify byte*) DEFAULT_SCREEN
  (byte) memset::c#0 ← (number) $a0
  (word) memset::num#0 ← (number) $3e8
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:main::@14
main::@14: scope:[main]  from main
  (word) rand_state#29 ← phi( main/(word) rand_state#32 )
  (void*) memset::str#1 ← (void*)(const nomodify byte*) DEFAULT_COLORRAM
  (byte) memset::c#1 ← (number) 0
  (word) memset::num#1 ← (number) $3e8
  call memset 
  (void*) memset::return#3 ← (void*) memset::return#1
  to:main::@15
main::@15: scope:[main]  from main::@14
  (word) rand_state#20 ← phi( main::@14/(word) rand_state#29 )
  (void*) memset::str#2 ← (void*)(const byte*) VISITS
  (byte) memset::c#2 ← (number) 0
  (word) memset::num#2 ← (number) $3e8
  call memset 
  (void*) memset::return#4 ← (void*) memset::return#1
  to:main::@16
main::@16: scope:[main]  from main::@15
  (word) rand_state#18 ← phi( main::@15/(word) rand_state#20 )
  *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (number) 0
  *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (number) 0
  (byte) main::x#0 ← (byte) $14
  (byte) main::y#0 ← (byte) $c
  to:main::@1
main::@1: scope:[main]  from main::@16 main::@8
  (word) rand_state#16 ← phi( main::@16/(word) rand_state#18 main::@8/(word) rand_state#19 )
  (byte) main::x#8 ← phi( main::@16/(byte) main::x#0 main::@8/(byte) main::x#10 )
  (byte) main::y#8 ← phi( main::@16/(byte) main::y#0 main::@8/(byte) main::y#10 )
  (bool~) main::$25 ← (number) 0 != (number) 1
  if((bool~) main::$25) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  (word) rand_state#15 ← phi( main::@1/(word) rand_state#16 )
  (byte) main::x#5 ← phi( main::@1/(byte) main::x#8 )
  (byte) main::y#5 ← phi( main::@1/(byte) main::y#8 )
  (word~) main::$24 ← (word)(byte) main::y#5
  (number~) main::$3 ← (word~) main::$24 * (number) $28
  (number~) main::$4 ← (number~) main::$3 + (byte) main::x#5
  (word) main::offset#0 ← (number~) main::$4
  (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0
  *((byte*~) main::$5) ← ++ *((byte*~) main::$5)
  (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0
  (byte) main::cnt#0 ← *((byte*~) main::$6)
  (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0
  (number~) main::$9 ← (byte) main::cnt#0 & (number) $f
  *((byte*~) main::$8) ← *((const byte*) FADE + (number~) main::$9)
  call rand 
  (word) rand::return#2 ← (word) rand::return#1
  to:main::@17
main::@17: scope:[main]  from main::@2
  (byte) main::y#11 ← phi( main::@2/(byte) main::y#5 )
  (byte) main::x#11 ← phi( main::@2/(byte) main::x#5 )
  (word) rand_state#11 ← phi( main::@2/(word) rand_state#3 )
  (word) rand::return#4 ← phi( main::@2/(word) rand::return#2 )
  (word~) main::$10 ← (word) rand::return#4
  (word) rand_state#4 ← (word) rand_state#11
  (byte~) main::$11 ← > (word~) main::$10
  (byte) main::rnd#0 ← (byte~) main::$11
  (number~) main::$12 ← (byte) main::rnd#0 & (number) $80
  (bool~) main::$26 ← (number) 0 != (number~) main::$12
  if((bool~) main::$26) goto main::@3
  to:main::@9
main::@3: scope:[main]  from main::@17
  (word) rand_state#31 ← phi( main::@17/(word) rand_state#4 )
  (byte) main::y#16 ← phi( main::@17/(byte) main::y#11 )
  (byte) main::x#9 ← phi( main::@17/(byte) main::x#11 )
  (byte) main::rnd#1 ← phi( main::@17/(byte) main::rnd#0 )
  (number~) main::$18 ← (byte) main::rnd#1 & (number) $40
  (bool~) main::$27 ← (number) 0 != (number~) main::$18
  if((bool~) main::$27) goto main::@6
  to:main::@12
main::@9: scope:[main]  from main::@17
  (word) rand_state#30 ← phi( main::@17/(word) rand_state#4 )
  (byte) main::x#16 ← phi( main::@17/(byte) main::x#11 )
  (byte) main::y#9 ← phi( main::@17/(byte) main::y#11 )
  (byte) main::rnd#2 ← phi( main::@17/(byte) main::rnd#0 )
  (number~) main::$13 ← (byte) main::rnd#2 & (number) $40
  (bool~) main::$28 ← (number) 0 != (number~) main::$13
  if((bool~) main::$28) goto main::@4
  to:main::@10
main::@4: scope:[main]  from main::@9
  (word) rand_state#25 ← phi( main::@9/(word) rand_state#30 )
  (byte) main::x#14 ← phi( main::@9/(byte) main::x#16 )
  (byte) main::y#6 ← phi( main::@9/(byte) main::y#9 )
  (byte) main::y#1 ← ++ (byte) main::y#6
  (bool~) main::$16 ← (byte) main::y#1 == (number) $19
  (bool~) main::$17 ← ! (bool~) main::$16
  if((bool~) main::$17) goto main::@8
  to:main::@5
main::@10: scope:[main]  from main::@9
  (word) rand_state#21 ← phi( main::@9/(word) rand_state#30 )
  (byte) main::x#12 ← phi( main::@9/(byte) main::x#16 )
  (byte) main::y#7 ← phi( main::@9/(byte) main::y#9 )
  (byte) main::y#2 ← -- (byte) main::y#7
  (bool~) main::$14 ← (byte) main::y#2 == (number) $ff
  (bool~) main::$15 ← ! (bool~) main::$14
  if((bool~) main::$15) goto main::@8
  to:main::@11
main::@11: scope:[main]  from main::@10
  (word) rand_state#22 ← phi( main::@10/(word) rand_state#21 )
  (byte) main::x#13 ← phi( main::@10/(byte) main::x#12 )
  (byte) main::y#3 ← (number) 0
  to:main::@8
main::@5: scope:[main]  from main::@4
  (word) rand_state#26 ← phi( main::@4/(word) rand_state#25 )
  (byte) main::x#15 ← phi( main::@4/(byte) main::x#14 )
  (byte) main::y#4 ← (number) $18
  to:main::@8
main::@6: scope:[main]  from main::@3
  (word) rand_state#27 ← phi( main::@3/(word) rand_state#31 )
  (byte) main::y#14 ← phi( main::@3/(byte) main::y#16 )
  (byte) main::x#6 ← phi( main::@3/(byte) main::x#9 )
  (byte) main::x#1 ← ++ (byte) main::x#6
  (bool~) main::$21 ← (byte) main::x#1 == (number) $28
  (bool~) main::$22 ← ! (bool~) main::$21
  if((bool~) main::$22) goto main::@8
  to:main::@7
main::@12: scope:[main]  from main::@3
  (word) rand_state#23 ← phi( main::@3/(word) rand_state#31 )
  (byte) main::y#12 ← phi( main::@3/(byte) main::y#16 )
  (byte) main::x#7 ← phi( main::@3/(byte) main::x#9 )
  (byte) main::x#2 ← -- (byte) main::x#7
  (bool~) main::$19 ← (byte) main::x#2 == (number) $ff
  (bool~) main::$20 ← ! (bool~) main::$19
  if((bool~) main::$20) goto main::@8
  to:main::@13
main::@13: scope:[main]  from main::@12
  (word) rand_state#24 ← phi( main::@12/(word) rand_state#23 )
  (byte) main::y#13 ← phi( main::@12/(byte) main::y#12 )
  (byte) main::x#3 ← (number) 0
  to:main::@8
main::@7: scope:[main]  from main::@6
  (word) rand_state#28 ← phi( main::@6/(word) rand_state#27 )
  (byte) main::y#15 ← phi( main::@6/(byte) main::y#14 )
  (byte) main::x#4 ← (number) $27
  to:main::@8
main::@8: scope:[main]  from main::@10 main::@11 main::@12 main::@13 main::@4 main::@5 main::@6 main::@7 main::@8
  (word) rand_state#19 ← phi( main::@10/(word) rand_state#21 main::@11/(word) rand_state#22 main::@12/(word) rand_state#23 main::@13/(word) rand_state#24 main::@4/(word) rand_state#25 main::@5/(word) rand_state#26 main::@6/(word) rand_state#27 main::@7/(word) rand_state#28 main::@8/(word) rand_state#19 )
  (byte) main::x#10 ← phi( main::@10/(byte) main::x#12 main::@11/(byte) main::x#13 main::@12/(byte) main::x#2 main::@13/(byte) main::x#3 main::@4/(byte) main::x#14 main::@5/(byte) main::x#15 main::@6/(byte) main::x#1 main::@7/(byte) main::x#4 main::@8/(byte) main::x#10 )
  (byte) main::y#10 ← phi( main::@10/(byte) main::y#2 main::@11/(byte) main::y#3 main::@12/(byte) main::y#12 main::@13/(byte) main::y#13 main::@4/(byte) main::y#1 main::@5/(byte) main::y#4 main::@6/(byte) main::y#14 main::@7/(byte) main::y#15 main::@8/(byte) main::y#10 )
  (bool~) main::$23 ← *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO) != (number) $ff
  if((bool~) main::$23) goto main::@8
  to:main::@1
main::@return: scope:[main]  from main::@1
  (word) rand_state#12 ← phi( main::@1/(word) rand_state#16 )
  (word) rand_state#5 ← (word) rand_state#12
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  (word) rand_state#6 ← (word) 1
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  (word) rand_state#17 ← phi( __start::__init1/(word) rand_state#6 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  (word) rand_state#13 ← phi( __start::@1/(word) rand_state#5 )
  (word) rand_state#7 ← (word) rand_state#13
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  (word) rand_state#14 ← phi( __start::@2/(word) rand_state#7 )
  (word) rand_state#8 ← (word) rand_state#14
  return 
  to:@return

SYMBOL TABLE SSA
(byte) $0::BASIC
(byte) $0::CARTRIDGE_HIGH
(byte) $0::CARTRIDGE_LOW
(byte) $0::FUNCTION_HIGH
(byte) $0::FUNCTION_LOW
(byte) $0::KERNAL
(byte) $0::UNUSED
(const nomodify byte*) DEFAULT_COLORRAM = (byte*)(number) $800
(const nomodify byte*) DEFAULT_SCREEN = (byte*)(number) $c00
(const byte*) FADE[(number) $10]  = { (byte) 2, (byte) $12, (byte) $22, (byte) $32, (byte) $42, (byte) $52, (byte) $62, (byte) $72, (byte) $76, (byte) $66, (byte) $56, (byte) $46, (byte) $36, (byte) $26, (byte) $16, (byte) 6 }
(byte) MOS6529_PIO::PORT
(byte) MOS6551_ACIA::COMMAND
(byte) MOS6551_ACIA::CONTROL
(byte) MOS6551_ACIA::DATA
(byte) MOS6551_ACIA::STATUS
(byte) MOS7360_TED::BG_COLOR
(byte) MOS7360_TED::BG_COLOR1
(byte) MOS7360_TED::BG_COLOR2
(byte) MOS7360_TED::BG_COLOR3
(byte) MOS7360_TED::BORDER_COLOR
(byte) MOS7360_TED::CH1_FREQ_HI
(byte) MOS7360_TED::CH1_FREQ_LO
(byte) MOS7360_TED::CH2_FREQ_LO
(byte) MOS7360_TED::CHARPOS_HI
(byte) MOS7360_TED::CHARPOS_LO
(byte) MOS7360_TED::CONTROL1
(byte) MOS7360_TED::CONTROL2
(word) MOS7360_TED::COUNTER1
(word) MOS7360_TED::COUNTER2
(word) MOS7360_TED::COUNTER3
(byte) MOS7360_TED::CURSOR_HI
(byte) MOS7360_TED::CURSOR_LO
(byte) MOS7360_TED::HSCAN_POS
(byte) MOS7360_TED::IRQ_MASK
(byte) MOS7360_TED::IRQ_REQUEST
(volatile byte) MOS7360_TED::KEYBOARD_INPUT loadstore
(byte) MOS7360_TED::MEMORY1
(byte) MOS7360_TED::MEMORY2
(byte) MOS7360_TED::MEMORY3
(byte) MOS7360_TED::RAM_SWITCH
(byte) MOS7360_TED::RASTER_HI
(byte) MOS7360_TED::RASTER_IRQ
(byte) MOS7360_TED::RASTER_LO
(byte) MOS7360_TED::ROM_SWITCH
(byte) MOS7360_TED::SOUND_CONTROL
(const byte*) MOS7360_TED::UNUSED[(number) $1d]  = { fill( $1d, 0) }
(byte) MOS7360_TED::VSCAN_POS
(byte) MOS7501_PORT::DDR
(byte) MOS7501_PORT::PORT
(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR = (byte) $15
(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = (byte) $19
(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO = (byte) $1d
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(const nomodify struct MOS7360_TED*) TED = (struct MOS7360_TED*)(number) $ff00
(const byte*) VISITS[(number) $3e8]  = { fill( $3e8, 0) }
(void()) __start()
(label) __start::@1
(label) __start::@2
(label) __start::@return
(label) __start::__init1
(void()) main()
(word~) main::$10
(byte~) main::$11
(number~) main::$12
(number~) main::$13
(bool~) main::$14
(bool~) main::$15
(bool~) main::$16
(bool~) main::$17
(number~) main::$18
(bool~) main::$19
(bool~) main::$20
(bool~) main::$21
(bool~) main::$22
(bool~) main::$23
(word~) main::$24
(bool~) main::$25
(bool~) main::$26
(bool~) main::$27
(bool~) main::$28
(number~) main::$3
(number~) main::$4
(byte*~) main::$5
(byte*~) main::$6
(byte*~) main::$8
(number~) main::$9
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(byte) main::cnt
(byte) main::cnt#0
(word) main::offset
(word) main::offset#0
(byte) main::rnd
(byte) main::rnd#0
(byte) main::rnd#1
(byte) main::rnd#2
(byte) main::x
(byte) main::x#0
(byte) main::x#1
(byte) main::x#10
(byte) main::x#11
(byte) main::x#12
(byte) main::x#13
(byte) main::x#14
(byte) main::x#15
(byte) main::x#16
(byte) main::x#2
(byte) main::x#3
(byte) main::x#4
(byte) main::x#5
(byte) main::x#6
(byte) main::x#7
(byte) main::x#8
(byte) main::x#9
(byte) main::y
(byte) main::y#0
(byte) main::y#1
(byte) main::y#10
(byte) main::y#11
(byte) main::y#12
(byte) main::y#13
(byte) main::y#14
(byte) main::y#15
(byte) main::y#16
(byte) main::y#2
(byte) main::y#3
(byte) main::y#4
(byte) main::y#5
(byte) main::y#6
(byte) main::y#7
(byte) main::y#8
(byte) main::y#9
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(bool~) memset::$3
(byte*~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@4
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte) memset::c#5
(byte) memset::c#6
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(word) memset::num#3
(word) memset::num#4
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::return#4
(void*) memset::return#5
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(void*) memset::str#6
(void*) memset::str#7
(word()) rand()
(word~) rand::$0
(word~) rand::$1
(word~) rand::$2
(label) rand::@return
(word) rand::return
(word) rand::return#0
(word) rand::return#1
(word) rand::return#2
(word) rand::return#3
(word) rand::return#4
(word) rand_state
(word) rand_state#0
(word) rand_state#1
(word) rand_state#10
(word) rand_state#11
(word) rand_state#12
(word) rand_state#13
(word) rand_state#14
(word) rand_state#15
(word) rand_state#16
(word) rand_state#17
(word) rand_state#18
(word) rand_state#19
(word) rand_state#2
(word) rand_state#20
(word) rand_state#21
(word) rand_state#22
(word) rand_state#23
(word) rand_state#24
(word) rand_state#25
(word) rand_state#26
(word) rand_state#27
(word) rand_state#28
(word) rand_state#29
(word) rand_state#3
(word) rand_state#30
(word) rand_state#31
(word) rand_state#32
(word) rand_state#4
(word) rand_state#5
(word) rand_state#6
(word) rand_state#7
(word) rand_state#8
(word) rand_state#9

Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#3 > (number) 0
Adding number conversion cast (unumber) 7 in (word~) rand::$0 ← (word) rand_state#9 << (number) 7
Adding number conversion cast (unumber) 9 in (word~) rand::$1 ← (word) rand_state#0 >> (number) 9
Adding number conversion cast (unumber) 8 in (word~) rand::$2 ← (word) rand_state#1 << (number) 8
Adding number conversion cast (unumber) $a0 in (byte) memset::c#0 ← (number) $a0
Adding number conversion cast (unumber) $3e8 in (word) memset::num#0 ← (number) $3e8
Adding number conversion cast (unumber) 0 in (byte) memset::c#1 ← (number) 0
Adding number conversion cast (unumber) $3e8 in (word) memset::num#1 ← (number) $3e8
Adding number conversion cast (unumber) 0 in (byte) memset::c#2 ← (number) 0
Adding number conversion cast (unumber) $3e8 in (word) memset::num#2 ← (number) $3e8
Adding number conversion cast (unumber) 0 in *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (number) 0
Adding number conversion cast (unumber) 0 in *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (number) 0
Adding number conversion cast (unumber) $28 in (number~) main::$3 ← (word~) main::$24 * (number) $28
Adding number conversion cast (unumber) main::$3 in (number~) main::$3 ← (word~) main::$24 * (unumber)(number) $28
Adding number conversion cast (unumber) main::$4 in (number~) main::$4 ← (unumber~) main::$3 + (byte) main::x#5
Adding number conversion cast (unumber) $f in (number~) main::$9 ← (byte) main::cnt#0 & (number) $f
Adding number conversion cast (unumber) main::$9 in (number~) main::$9 ← (byte) main::cnt#0 & (unumber)(number) $f
Adding number conversion cast (unumber) $80 in (number~) main::$12 ← (byte) main::rnd#0 & (number) $80
Adding number conversion cast (unumber) main::$12 in (number~) main::$12 ← (byte) main::rnd#0 & (unumber)(number) $80
Adding number conversion cast (unumber) 0 in (bool~) main::$26 ← (number) 0 != (unumber~) main::$12
Adding number conversion cast (unumber) $40 in (number~) main::$18 ← (byte) main::rnd#1 & (number) $40
Adding number conversion cast (unumber) main::$18 in (number~) main::$18 ← (byte) main::rnd#1 & (unumber)(number) $40
Adding number conversion cast (unumber) 0 in (bool~) main::$27 ← (number) 0 != (unumber~) main::$18
Adding number conversion cast (unumber) $40 in (number~) main::$13 ← (byte) main::rnd#2 & (number) $40
Adding number conversion cast (unumber) main::$13 in (number~) main::$13 ← (byte) main::rnd#2 & (unumber)(number) $40
Adding number conversion cast (unumber) 0 in (bool~) main::$28 ← (number) 0 != (unumber~) main::$13
Adding number conversion cast (unumber) $19 in (bool~) main::$16 ← (byte) main::y#1 == (number) $19
Adding number conversion cast (unumber) $ff in (bool~) main::$14 ← (byte) main::y#2 == (number) $ff
Adding number conversion cast (unumber) 0 in (byte) main::y#3 ← (number) 0
Adding number conversion cast (unumber) $18 in (byte) main::y#4 ← (number) $18
Adding number conversion cast (unumber) $28 in (bool~) main::$21 ← (byte) main::x#1 == (number) $28
Adding number conversion cast (unumber) $ff in (bool~) main::$19 ← (byte) main::x#2 == (number) $ff
Adding number conversion cast (unumber) 0 in (byte) main::x#3 ← (number) 0
Adding number conversion cast (unumber) $27 in (byte) main::x#4 ← (number) $27
Adding number conversion cast (unumber) $ff in (bool~) main::$23 ← *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO) != (number) $ff
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#4
Inlining cast (byte) memset::c#0 ← (unumber)(number) $a0
Inlining cast (word) memset::num#0 ← (unumber)(number) $3e8
Inlining cast (byte) memset::c#1 ← (unumber)(number) 0
Inlining cast (word) memset::num#1 ← (unumber)(number) $3e8
Inlining cast (byte) memset::c#2 ← (unumber)(number) 0
Inlining cast (word) memset::num#2 ← (unumber)(number) $3e8
Inlining cast *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (unumber)(number) 0
Inlining cast *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (unumber)(number) 0
Inlining cast (byte) main::y#3 ← (unumber)(number) 0
Inlining cast (byte) main::y#4 ← (unumber)(number) $18
Inlining cast (byte) main::x#3 ← (unumber)(number) 0
Inlining cast (byte) main::x#4 ← (unumber)(number) $27
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 2048
Simplifying constant pointer cast (byte*) 3072
Simplifying constant pointer cast (struct MOS7360_TED*) 65280
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 9
Simplifying constant integer cast 8
Simplifying constant integer cast $a0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $28
Simplifying constant integer cast $f
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $40
Simplifying constant integer cast 0
Simplifying constant integer cast $19
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $18
Simplifying constant integer cast $28
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $27
Simplifying constant integer cast $ff
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $a0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) $ff
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in (unumber~) main::$3 ← (word~) main::$24 * (byte) $28
Inferred type updated to word in (unumber~) main::$4 ← (word~) main::$3 + (byte) main::x#5
Inferred type updated to byte in (unumber~) main::$9 ← (byte) main::cnt#0 & (byte) $f
Inferred type updated to byte in (unumber~) main::$12 ← (byte) main::rnd#0 & (byte) $80
Inferred type updated to byte in (unumber~) main::$18 ← (byte) main::rnd#1 & (byte) $40
Inferred type updated to byte in (unumber~) main::$13 ← (byte) main::rnd#2 & (byte) $40
Inversing boolean not [2] (bool~) memset::$1 ← (word) memset::num#3 <= (byte) 0 from [1] (bool~) memset::$0 ← (word) memset::num#3 > (byte) 0
Inversing boolean not [91] (bool~) main::$17 ← (byte) main::y#1 != (byte) $19 from [90] (bool~) main::$16 ← (byte) main::y#1 == (byte) $19
Inversing boolean not [96] (bool~) main::$15 ← (byte) main::y#2 != (byte) $ff from [95] (bool~) main::$14 ← (byte) main::y#2 == (byte) $ff
Inversing boolean not [105] (bool~) main::$22 ← (byte) main::x#1 != (byte) $28 from [104] (bool~) main::$21 ← (byte) main::x#1 == (byte) $28
Inversing boolean not [110] (bool~) main::$20 ← (byte) main::x#2 != (byte) $ff from [109] (bool~) main::$19 ← (byte) main::x#2 == (byte) $ff
Successful SSA optimization Pass2UnaryNotSimplification
Alias memset::return#0 = memset::str#3 memset::return#5 memset::return#1 
Alias memset::str#4 = memset::str#5 
Alias memset::num#3 = memset::num#4 
Alias memset::c#5 = memset::c#6 
Alias memset::end#0 = memset::$2 
Alias memset::c#3 = memset::c#4 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#6 = memset::str#7 
Alias rand::return#0 = rand::return#3 rand::return#1 
Alias rand_state#10 = rand_state#2 rand_state#3 
Alias rand_state#18 = rand_state#29 rand_state#32 rand_state#20 
Alias main::y#11 = main::y#5 main::y#8 main::y#16 main::y#9 main::y#6 main::y#7 main::y#14 main::y#12 main::y#13 main::y#15 
Alias main::x#11 = main::x#5 main::x#8 main::x#9 main::x#16 main::x#14 main::x#12 main::x#13 main::x#15 main::x#6 main::x#7 
Alias rand_state#12 = rand_state#15 rand_state#16 rand_state#5 
Alias main::offset#0 = main::$4 
Alias rand::return#2 = rand::return#4 
Alias rand_state#11 = rand_state#4 rand_state#31 rand_state#30 rand_state#25 rand_state#21 rand_state#22 rand_state#26 rand_state#27 rand_state#23 rand_state#24 rand_state#28 
Alias main::rnd#0 = main::$11 main::rnd#1 main::rnd#2 
Alias rand_state#17 = rand_state#6 
Alias rand_state#13 = rand_state#7 rand_state#14 rand_state#8 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#6 (void*) memset::str#4
Identical Phi Values (byte) memset::c#3 (byte) memset::c#5
Identical Phi Values (word) rand_state#9 (word) rand_state#12
Identical Phi Values (word) rand_state#18 (word) rand_state#17
Identical Phi Values (word) rand_state#11 (word) rand_state#10
Identical Phi Values (word) rand_state#19 (word) rand_state#11
Identical Phi Values (word) rand_state#13 (word) rand_state#12
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#4
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) memset::$1 [2] if((word) memset::num#3<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$3 [9] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@4
Simple Condition (bool~) main::$25 [44] if((number) 0!=(number) 1) goto main::@2
Simple Condition (bool~) main::$26 [62] if((byte) 0!=(byte~) main::$12) goto main::@3
Simple Condition (bool~) main::$27 [65] if((byte) 0!=(byte~) main::$18) goto main::@6
Simple Condition (bool~) main::$28 [68] if((byte) 0!=(byte~) main::$13) goto main::@4
Simple Condition (bool~) main::$17 [71] if((byte) main::y#1!=(byte) $19) goto main::@8
Simple Condition (bool~) main::$15 [74] if((byte) main::y#2!=(byte) $ff) goto main::@8
Simple Condition (bool~) main::$22 [79] if((byte) main::x#1!=(byte) $28) goto main::@8
Simple Condition (bool~) main::$20 [82] if((byte) main::x#2!=(byte) $ff) goto main::@8
Simple Condition (bool~) main::$23 [87] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@8
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const void*) memset::str#0 = (void*)DEFAULT_SCREEN
Constant (const byte) memset::c#0 = $a0
Constant (const word) memset::num#0 = $3e8
Constant (const void*) memset::str#1 = (void*)DEFAULT_COLORRAM
Constant (const byte) memset::c#1 = 0
Constant (const word) memset::num#1 = $3e8
Constant (const void*) memset::str#2 = (void*)VISITS
Constant (const byte) memset::c#2 = 0
Constant (const word) memset::num#2 = $3e8
Constant (const byte) main::x#0 = $14
Constant (const byte) main::y#0 = $c
Constant (const byte) main::y#3 = 0
Constant (const byte) main::y#4 = $18
Constant (const byte) main::x#3 = 0
Constant (const byte) main::x#4 = $27
Constant (const word) rand_state#17 = 1
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [44] if((number) 0!=(number) 1) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Eliminating unused variable (void*) memset::return#2 and assignment [19] (void*) memset::return#2 ← (void*) memset::str#4
Eliminating unused variable (void*) memset::return#3 and assignment [21] (void*) memset::return#3 ← (void*) memset::str#4
Eliminating unused variable (void*) memset::return#4 and assignment [23] (void*) memset::return#4 ← (void*) memset::str#4
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining Noop Cast [2] (byte*~) memset::$4 ← (byte*)(void*) memset::str#4 keeping memset::str#4
Inlining Noop Cast [4] (byte*) memset::dst#0 ← (byte*)(void*) memset::str#4 keeping memset::str#4
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift and addition[25] (word~) main::$3 ← (word~) main::$24 * (byte) $28
Inlining constant with var siblings (const void*) memset::str#0
Inlining constant with var siblings (const byte) memset::c#0
Inlining constant with var siblings (const word) memset::num#0
Inlining constant with var siblings (const void*) memset::str#1
Inlining constant with var siblings (const byte) memset::c#1
Inlining constant with var siblings (const word) memset::num#1
Inlining constant with var siblings (const void*) memset::str#2
Inlining constant with var siblings (const byte) memset::c#2
Inlining constant with var siblings (const word) memset::num#2
Inlining constant with var siblings (const byte) main::x#0
Inlining constant with var siblings (const byte) main::y#0
Inlining constant with var siblings (const byte) main::y#3
Inlining constant with var siblings (const byte) main::y#4
Inlining constant with var siblings (const byte) main::x#3
Inlining constant with var siblings (const byte) main::x#4
Inlining constant with var siblings (const word) rand_state#17
Constant inlined memset::str#2 = (void*)(const byte*) VISITS
Constant inlined memset::str#1 = (void*)(const nomodify byte*) DEFAULT_COLORRAM
Constant inlined rand_state#17 = (word) 1
Constant inlined memset::str#0 = (void*)(const nomodify byte*) DEFAULT_SCREEN
Constant inlined memset::num#2 = (word) $3e8
Constant inlined main::x#3 = (byte) 0
Constant inlined memset::num#1 = (word) $3e8
Constant inlined main::x#0 = (byte) $14
Constant inlined memset::num#0 = (word) $3e8
Constant inlined main::y#0 = (byte) $c
Constant inlined main::y#3 = (byte) 0
Constant inlined main::x#4 = (byte) $27
Constant inlined main::y#4 = (byte) $18
Constant inlined memset::c#0 = (byte) $a0
Constant inlined memset::c#1 = (byte) 0
Constant inlined memset::c#2 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Alias main::$3 = main::$31 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) memset::num#3 (word) $3e8
Successful SSA optimization Pass2IdenticalPhiElimination
if() condition always false - eliminating [1] if((word) $3e8<=(byte) 0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Added new block during phi lifting main::@18(between main::@8 and main::@1)
Added new block during phi lifting main::@19(between main::@10 and main::@8)
Added new block during phi lifting main::@20(between main::@12 and main::@8)
Added new block during phi lifting main::@21(between main::@4 and main::@8)
Added new block during phi lifting main::@22(between main::@6 and main::@8)
Added new block during phi lifting main::@23(between main::@8 and main::@8)
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [main] to memset:1 memset:3 memset:5 rand:21 

Created 8 initial phi equivalence classes
Coalesced [31] main::x#19 ← main::x#11
Coalesced [34] main::y#17 ← main::y#10
Coalesced (already) [35] main::x#17 ← main::x#10
Coalesced [36] rand_state#33 ← rand_state#10
Coalesced (already) [37] main::y#24 ← main::y#10
Coalesced (already) [38] main::x#24 ← main::x#10
Coalesced [39] main::y#18 ← main::y#2
Coalesced (already) [40] main::x#18 ← main::x#11
Coalesced (already) [43] main::x#22 ← main::x#11
Coalesced [44] main::y#21 ← main::y#1
Coalesced (already) [45] main::x#21 ← main::x#11
Coalesced (already) [50] main::y#20 ← main::y#11
Coalesced (already) [51] main::y#19 ← main::y#11
Coalesced [52] main::x#20 ← main::x#2
Coalesced (already) [55] main::y#23 ← main::y#11
Coalesced (already) [56] main::y#22 ← main::y#11
Coalesced [57] main::x#23 ← main::x#1
Coalesced [67] memset::dst#5 ← memset::dst#1
Coalesced down to 6 phi equivalence classes
Culled Empty Block (label) main::@11
Culled Empty Block (label) main::@18
Culled Empty Block (label) main::@23
Culled Empty Block (label) main::@5
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::@7
Culled Empty Block (label) memset::@1
Renumbering block memset::@2 to memset::@1
Renumbering block memset::@3 to memset::@2
Renumbering block memset::@4 to memset::@3
Renumbering block main::@6 to main::@5
Renumbering block main::@8 to main::@6
Renumbering block main::@9 to main::@7
Renumbering block main::@10 to main::@8
Renumbering block main::@12 to main::@9
Renumbering block main::@14 to main::@10
Renumbering block main::@15 to main::@11
Renumbering block main::@16 to main::@12
Renumbering block main::@17 to main::@13
Renumbering block main::@19 to main::@14
Renumbering block main::@20 to main::@15
Renumbering block main::@21 to main::@16
Renumbering block main::@22 to main::@17
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@10
Adding NOP phi() at start of main::@11
Adding NOP phi() at start of main::@14
Adding NOP phi() at start of main::@16
Adding NOP phi() at start of main::@15
Adding NOP phi() at start of main::@17

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  [0] phi()
  [1] call memset 
  to:main::@10
main::@10: scope:[main]  from main
  [2] phi()
  [3] call memset 
  to:main::@11
main::@11: scope:[main]  from main::@10
  [4] phi()
  [5] call memset 
  to:main::@12
main::@12: scope:[main]  from main::@11
  [6] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (byte) 0
  [7] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main::@12 main::@6
  [8] (word) rand_state#12 ← phi( main::@12/(word) 1 main::@6/(word) rand_state#10 )
  [8] (byte) main::x#11 ← phi( main::@12/(byte) $14 main::@6/(byte) main::x#10 )
  [8] (byte) main::y#11 ← phi( main::@12/(byte) $c main::@6/(byte) main::y#10 )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [9] (word~) main::$24 ← (word)(byte) main::y#11
  [10] (word~) main::$29 ← (word~) main::$24 << (byte) 2
  [11] (word~) main::$30 ← (word~) main::$29 + (word~) main::$24
  [12] (word~) main::$3 ← (word~) main::$30 << (byte) 3
  [13] (word) main::offset#0 ← (word~) main::$3 + (byte) main::x#11
  [14] (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0
  [15] *((byte*~) main::$5) ← ++ *((byte*~) main::$5)
  [16] (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0
  [17] (byte) main::cnt#0 ← *((byte*~) main::$6)
  [18] (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0
  [19] (byte~) main::$9 ← (byte) main::cnt#0 & (byte) $f
  [20] *((byte*~) main::$8) ← *((const byte*) FADE + (byte~) main::$9)
  [21] call rand 
  [22] (word) rand::return#2 ← (word) rand::return#0
  to:main::@13
main::@13: scope:[main]  from main::@2
  [23] (word~) main::$10 ← (word) rand::return#2
  [24] (byte) main::rnd#0 ← > (word~) main::$10
  [25] (byte~) main::$12 ← (byte) main::rnd#0 & (byte) $80
  [26] if((byte) 0!=(byte~) main::$12) goto main::@3
  to:main::@7
main::@7: scope:[main]  from main::@13
  [27] (byte~) main::$13 ← (byte) main::rnd#0 & (byte) $40
  [28] if((byte) 0!=(byte~) main::$13) goto main::@4
  to:main::@8
main::@8: scope:[main]  from main::@7
  [29] (byte) main::y#2 ← -- (byte) main::y#11
  [30] if((byte) main::y#2!=(byte) $ff) goto main::@14
  to:main::@6
main::@14: scope:[main]  from main::@8
  [31] phi()
  to:main::@6
main::@6: scope:[main]  from main::@14 main::@15 main::@16 main::@17 main::@4 main::@5 main::@6 main::@8 main::@9
  [32] (byte) main::x#10 ← phi( main::@14/(byte) main::x#11 main::@8/(byte) main::x#11 main::@15/(byte) main::x#2 main::@9/(byte) 0 main::@16/(byte) main::x#11 main::@4/(byte) main::x#11 main::@17/(byte) main::x#1 main::@5/(byte) $27 main::@6/(byte) main::x#10 )
  [32] (byte) main::y#10 ← phi( main::@14/(byte) main::y#2 main::@8/(byte) 0 main::@15/(byte) main::y#11 main::@9/(byte) main::y#11 main::@16/(byte) main::y#1 main::@4/(byte) $18 main::@17/(byte) main::y#11 main::@5/(byte) main::y#11 main::@6/(byte) main::y#10 )
  [33] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@6
  to:main::@1
main::@4: scope:[main]  from main::@7
  [34] (byte) main::y#1 ← ++ (byte) main::y#11
  [35] if((byte) main::y#1!=(byte) $19) goto main::@16
  to:main::@6
main::@16: scope:[main]  from main::@4
  [36] phi()
  to:main::@6
main::@3: scope:[main]  from main::@13
  [37] (byte~) main::$18 ← (byte) main::rnd#0 & (byte) $40
  [38] if((byte) 0!=(byte~) main::$18) goto main::@5
  to:main::@9
main::@9: scope:[main]  from main::@3
  [39] (byte) main::x#2 ← -- (byte) main::x#11
  [40] if((byte) main::x#2!=(byte) $ff) goto main::@15
  to:main::@6
main::@15: scope:[main]  from main::@9
  [41] phi()
  to:main::@6
main::@5: scope:[main]  from main::@3
  [42] (byte) main::x#1 ← ++ (byte) main::x#11
  [43] if((byte) main::x#1!=(byte) $28) goto main::@17
  to:main::@6
main::@17: scope:[main]  from main::@5
  [44] phi()
  to:main::@6

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from main main::@10 main::@11
  [45] (byte) memset::c#5 ← phi( main/(byte) $a0 main::@10/(byte) 0 main::@11/(byte) 0 )
  [45] (void*) memset::str#4 ← phi( main/(void*)(const nomodify byte*) DEFAULT_SCREEN main::@10/(void*)(const nomodify byte*) DEFAULT_COLORRAM main::@11/(void*)(const byte*) VISITS )
  to:memset::@1
memset::@1: scope:[memset]  from memset
  [46] (byte*) memset::end#0 ← (byte*)(void*) memset::str#4 + (word) $3e8
  [47] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#4
  to:memset::@2
memset::@2: scope:[memset]  from memset::@1 memset::@3
  [48] (byte*) memset::dst#2 ← phi( memset::@1/(byte*) memset::dst#4 memset::@3/(byte*) memset::dst#1 )
  [49] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3
  to:memset::@return
memset::@return: scope:[memset]  from memset::@2
  [50] return 
  to:@return
memset::@3: scope:[memset]  from memset::@2
  [51] *((byte*) memset::dst#2) ← (byte) memset::c#5
  [52] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@2

(word()) rand()
rand: scope:[rand]  from main::@2
  [53] (word~) rand::$0 ← (word) rand_state#12 << (byte) 7
  [54] (word) rand_state#0 ← (word) rand_state#12 ^ (word~) rand::$0
  [55] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9
  [56] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1
  [57] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8
  [58] (word) rand_state#10 ← (word) rand_state#1 ^ (word~) rand::$2
  [59] (word) rand::return#0 ← (word) rand_state#10
  to:rand::@return
rand::@return: scope:[rand]  from rand
  [60] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) $0::BASIC
(byte) $0::CARTRIDGE_HIGH
(byte) $0::CARTRIDGE_LOW
(byte) $0::FUNCTION_HIGH
(byte) $0::FUNCTION_LOW
(byte) $0::KERNAL
(byte) $0::UNUSED
(byte) MOS6529_PIO::PORT
(byte) MOS6551_ACIA::COMMAND
(byte) MOS6551_ACIA::CONTROL
(byte) MOS6551_ACIA::DATA
(byte) MOS6551_ACIA::STATUS
(byte) MOS7360_TED::BG_COLOR
(byte) MOS7360_TED::BG_COLOR1
(byte) MOS7360_TED::BG_COLOR2
(byte) MOS7360_TED::BG_COLOR3
(byte) MOS7360_TED::BORDER_COLOR
(byte) MOS7360_TED::CH1_FREQ_HI
(byte) MOS7360_TED::CH1_FREQ_LO
(byte) MOS7360_TED::CH2_FREQ_LO
(byte) MOS7360_TED::CHARPOS_HI
(byte) MOS7360_TED::CHARPOS_LO
(byte) MOS7360_TED::CONTROL1
(byte) MOS7360_TED::CONTROL2
(word) MOS7360_TED::COUNTER1
(word) MOS7360_TED::COUNTER2
(word) MOS7360_TED::COUNTER3
(byte) MOS7360_TED::CURSOR_HI
(byte) MOS7360_TED::CURSOR_LO
(byte) MOS7360_TED::HSCAN_POS
(byte) MOS7360_TED::IRQ_MASK
(byte) MOS7360_TED::IRQ_REQUEST
(volatile byte) MOS7360_TED::KEYBOARD_INPUT loadstore
(byte) MOS7360_TED::MEMORY1
(byte) MOS7360_TED::MEMORY2
(byte) MOS7360_TED::MEMORY3
(byte) MOS7360_TED::RAM_SWITCH
(byte) MOS7360_TED::RASTER_HI
(byte) MOS7360_TED::RASTER_IRQ
(byte) MOS7360_TED::RASTER_LO
(byte) MOS7360_TED::ROM_SWITCH
(byte) MOS7360_TED::SOUND_CONTROL
(byte) MOS7360_TED::VSCAN_POS
(byte) MOS7501_PORT::DDR
(byte) MOS7501_PORT::PORT
(void()) main()
(word~) main::$10 22.0
(byte~) main::$12 22.0
(byte~) main::$13 22.0
(byte~) main::$18 22.0
(word~) main::$24 16.5
(word~) main::$29 22.0
(word~) main::$3 22.0
(word~) main::$30 22.0
(byte*~) main::$5 33.0
(byte*~) main::$6 22.0
(byte*~) main::$8 11.0
(byte~) main::$9 22.0
(byte) main::cnt
(byte) main::cnt#0 11.0
(word) main::offset
(word) main::offset#0 8.8
(byte) main::rnd
(byte) main::rnd#0 14.666666666666666
(byte) main::x
(byte) main::x#1 11.0
(byte) main::x#10 184.5
(byte) main::x#11 6.137931034482759
(byte) main::x#2 11.0
(byte) main::y
(byte) main::y#1 11.0
(byte) main::y#10 184.5
(byte) main::y#11 5.758620689655173
(byte) main::y#2 11.0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte) memset::c#5 14.428571428571429
(byte*) memset::dst
(byte*) memset::dst#1 202.0
(byte*) memset::dst#2 138.33333333333331
(byte*) memset::dst#4 22.0
(byte*) memset::end
(byte*) memset::end#0 18.666666666666664
(word) memset::num
(void*) memset::return
(void*) memset::str
(void*) memset::str#4
(word()) rand()
(word~) rand::$0 202.0
(word~) rand::$1 202.0
(word~) rand::$2 202.0
(word) rand::return
(word) rand::return#0 37.33333333333333
(word) rand::return#2 22.0
(word) rand_state
(word) rand_state#0 151.5
(word) rand_state#1 151.5
(word) rand_state#10 11.222222222222223
(word) rand_state#12 21.642857142857142

Initial phi equivalence classes
[ main::y#11 main::y#10 main::y#2 main::y#1 ]
[ main::x#11 main::x#10 main::x#2 main::x#1 ]
[ rand_state#12 rand_state#10 ]
[ memset::str#4 ]
[ memset::c#5 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
Added variable main::$24 to live range equivalence class [ main::$24 ]
Added variable main::$29 to live range equivalence class [ main::$29 ]
Added variable main::$30 to live range equivalence class [ main::$30 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Added variable main::offset#0 to live range equivalence class [ main::offset#0 ]
Added variable main::$5 to live range equivalence class [ main::$5 ]
Added variable main::$6 to live range equivalence class [ main::$6 ]
Added variable main::cnt#0 to live range equivalence class [ main::cnt#0 ]
Added variable main::$8 to live range equivalence class [ main::$8 ]
Added variable main::$9 to live range equivalence class [ main::$9 ]
Added variable rand::return#2 to live range equivalence class [ rand::return#2 ]
Added variable main::$10 to live range equivalence class [ main::$10 ]
Added variable main::rnd#0 to live range equivalence class [ main::rnd#0 ]
Added variable main::$12 to live range equivalence class [ main::$12 ]
Added variable main::$13 to live range equivalence class [ main::$13 ]
Added variable main::$18 to live range equivalence class [ main::$18 ]
Added variable memset::end#0 to live range equivalence class [ memset::end#0 ]
Added variable rand::$0 to live range equivalence class [ rand::$0 ]
Added variable rand_state#0 to live range equivalence class [ rand_state#0 ]
Added variable rand::$1 to live range equivalence class [ rand::$1 ]
Added variable rand_state#1 to live range equivalence class [ rand_state#1 ]
Added variable rand::$2 to live range equivalence class [ rand::$2 ]
Added variable rand::return#0 to live range equivalence class [ rand::return#0 ]
Complete equivalence classes
[ main::y#11 main::y#10 main::y#2 main::y#1 ]
[ main::x#11 main::x#10 main::x#2 main::x#1 ]
[ rand_state#12 rand_state#10 ]
[ memset::str#4 ]
[ memset::c#5 ]
[ memset::dst#2 memset::dst#4 memset::dst#1 ]
[ main::$24 ]
[ main::$29 ]
[ main::$30 ]
[ main::$3 ]
[ main::offset#0 ]
[ main::$5 ]
[ main::$6 ]
[ main::cnt#0 ]
[ main::$8 ]
[ main::$9 ]
[ rand::return#2 ]
[ main::$10 ]
[ main::rnd#0 ]
[ main::$12 ]
[ main::$13 ]
[ main::$18 ]
[ memset::end#0 ]
[ rand::$0 ]
[ rand_state#0 ]
[ rand::$1 ]
[ rand_state#1 ]
[ rand::$2 ]
[ rand::return#0 ]
Allocated zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Allocated zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Allocated zp[2]:4 [ rand_state#12 rand_state#10 ]
Allocated zp[2]:6 [ memset::str#4 ]
Allocated zp[1]:8 [ memset::c#5 ]
Allocated zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ]
Allocated zp[2]:11 [ main::$24 ]
Allocated zp[2]:13 [ main::$29 ]
Allocated zp[2]:15 [ main::$30 ]
Allocated zp[2]:17 [ main::$3 ]
Allocated zp[2]:19 [ main::offset#0 ]
Allocated zp[2]:21 [ main::$5 ]
Allocated zp[2]:23 [ main::$6 ]
Allocated zp[1]:25 [ main::cnt#0 ]
Allocated zp[2]:26 [ main::$8 ]
Allocated zp[1]:28 [ main::$9 ]
Allocated zp[2]:29 [ rand::return#2 ]
Allocated zp[2]:31 [ main::$10 ]
Allocated zp[1]:33 [ main::rnd#0 ]
Allocated zp[1]:34 [ main::$12 ]
Allocated zp[1]:35 [ main::$13 ]
Allocated zp[1]:36 [ main::$18 ]
Allocated zp[2]:37 [ memset::end#0 ]
Allocated zp[2]:39 [ rand::$0 ]
Allocated zp[2]:41 [ rand_state#0 ]
Allocated zp[2]:43 [ rand::$1 ]
Allocated zp[2]:45 [ rand_state#1 ]
Allocated zp[2]:47 [ rand::$2 ]
Allocated zp[2]:49 [ rand::return#0 ]

INITIAL ASM
Target platform is plus4 / MOS6502X
  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
// Plus/4 / Commodore 16 registers and memory layout
// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  .file [name="plus4walk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
.segment Code


  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  // Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  // The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = $29
  // The random state variable
  .label rand_state_1 = $2d
  // The random state variable
  .label rand_state_2 = 4
.segment Code
  // main
main: {
    .label __3 = $11
    .label __5 = $15
    .label __6 = $17
    .label __8 = $1a
    .label __9 = $1c
    .label __10 = $1f
    .label __12 = $22
    .label __13 = $23
    .label __18 = $24
    .label __24 = $b
    .label offset = $13
    .label cnt = $19
    .label rnd = $21
    .label y = 2
    .label x = 3
    .label __29 = $d
    .label __30 = $f
    // [1] call memset 
    // [45] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [45] phi (byte) memset::c#5 = (byte) $a0 [phi:main->memset#0] -- vbuz1=vbuc1 
    lda #$a0
    sta.z memset.c
    // [45] phi (void*) memset::str#4 = (void*)(const nomodify byte*) DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [2] phi from main to main::@10 [phi:main->main::@10]
  __b10_from_main:
    jmp __b10
    // main::@10
  __b10:
    // [3] call memset 
    // [45] phi from main::@10 to memset [phi:main::@10->memset]
  memset_from___b10:
    // [45] phi (byte) memset::c#5 = (byte) 0 [phi:main::@10->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memset.c
    // [45] phi (void*) memset::str#4 = (void*)(const nomodify byte*) DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [4] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [5] call memset 
    // [45] phi from main::@11 to memset [phi:main::@11->memset]
  memset_from___b11:
    // [45] phi (byte) memset::c#5 = (byte) 0 [phi:main::@11->memset#0] -- vbuz1=vbuc1 
    lda #0
    sta.z memset.c
    // [45] phi (void*) memset::str#4 = (void*)(const byte*) VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    jmp __b12
    // main::@12
  __b12:
    // [6] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // [7] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [8] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
  __b1_from___b12:
    // [8] phi (word) rand_state#12 = (word) 1 [phi:main::@12->main::@1#0] -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state_2
    lda #>1
    sta.z rand_state_2+1
    // [8] phi (byte) main::x#11 = (byte) $14 [phi:main::@12->main::@1#1] -- vbuz1=vbuc1 
    lda #$14
    sta.z x
    // [8] phi (byte) main::y#11 = (byte) $c [phi:main::@12->main::@1#2] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    jmp __b1
    // main::@1
  __b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] (word~) main::$24 ← (word)(byte) main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [10] (word~) main::$29 ← (word~) main::$24 << (byte) 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [11] (word~) main::$30 ← (word~) main::$29 + (word~) main::$24 -- vwuz1=vwuz2_plus_vwuz3 
    lda.z __29
    clc
    adc.z __24
    sta.z __30
    lda.z __29+1
    adc.z __24+1
    sta.z __30+1
    // [12] (word~) main::$3 ← (word~) main::$30 << (byte) 3 -- vwuz1=vwuz2_rol_3 
    lda.z __30
    asl
    sta.z __3
    lda.z __30+1
    rol
    sta.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // [13] (word) main::offset#0 ← (word~) main::$3 + (byte) main::x#11 -- vwuz1=vwuz2_plus_vbuz3 
    lda.z x
    clc
    adc.z __3
    sta.z offset
    lda #0
    adc.z __3+1
    sta.z offset+1
    // [14] (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __5
    lda.z offset+1
    adc #>VISITS
    sta.z __5+1
    // [15] *((byte*~) main::$5) ← ++ *((byte*~) main::$5) -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__5),y
    clc
    adc #1
    ldy #0
    sta (__5),y
    // [16] (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // [17] (byte) main::cnt#0 ← *((byte*~) main::$6) -- vbuz1=_deref_pbuz2 
    ldy #0
    lda (__6),y
    sta.z cnt
    // [18] (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z offset+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // [19] (byte~) main::$9 ← (byte) main::cnt#0 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and.z cnt
    sta.z __9
    // [20] *((byte*~) main::$8) ← *((const byte*) FADE + (byte~) main::$9) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z __9
    lda FADE,y
    ldy #0
    sta (__8),y
    // [21] call rand 
    jsr rand
    // [22] (word) rand::return#2 ← (word) rand::return#0 -- vwuz1=vwuz2 
    lda.z rand.return
    sta.z rand.return_1
    lda.z rand.return+1
    sta.z rand.return_1+1
    jmp __b13
    // main::@13
  __b13:
    // [23] (word~) main::$10 ← (word) rand::return#2 -- vwuz1=vwuz2 
    lda.z rand.return_1
    sta.z __10
    lda.z rand.return_1+1
    sta.z __10+1
    // [24] (byte) main::rnd#0 ← > (word~) main::$10 -- vbuz1=_hi_vwuz2 
    lda.z __10+1
    sta.z rnd
    // [25] (byte~) main::$12 ← (byte) main::rnd#0 & (byte) $80 -- vbuz1=vbuz2_band_vbuc1 
    lda #$80
    and.z rnd
    sta.z __12
    // [26] if((byte) 0!=(byte~) main::$12) goto main::@3 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __12
    bne __b3
    jmp __b7
    // main::@7
  __b7:
    // [27] (byte~) main::$13 ← (byte) main::rnd#0 & (byte) $40 -- vbuz1=vbuz2_band_vbuc1 
    lda #$40
    and.z rnd
    sta.z __13
    // [28] if((byte) 0!=(byte~) main::$13) goto main::@4 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __13
    bne __b4
    jmp __b8
    // main::@8
  __b8:
    // [29] (byte) main::y#2 ← -- (byte) main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // [30] if((byte) main::y#2!=(byte) $ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b14_from___b8
    // [32] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b6
    // [31] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
  __b14_from___b8:
    jmp __b14
    // main::@14
  __b14:
    // [32] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
  __b6_from___b14:
  __b6_from___b15:
  __b6_from___b16:
  __b6_from___b17:
  __b6_from___b6:
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [33] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6_from___b6
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [8] phi (word) rand_state#12 = (word) rand_state#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [8] phi (byte) main::x#11 = (byte) main::x#10 [phi:main::@6->main::@1#1] -- register_copy 
    // [8] phi (byte) main::y#11 = (byte) main::y#10 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [34] (byte) main::y#1 ← ++ (byte) main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [35] if((byte) main::y#1!=(byte) $19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b16_from___b4
    // [32] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
  __b6_from___b4:
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [36] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
  __b16_from___b4:
    jmp __b16
    // main::@16
  __b16:
    jmp __b6_from___b16
    // main::@3
  __b3:
    // [37] (byte~) main::$18 ← (byte) main::rnd#0 & (byte) $40 -- vbuz1=vbuz2_band_vbuc1 
    lda #$40
    and.z rnd
    sta.z __18
    // [38] if((byte) 0!=(byte~) main::$18) goto main::@5 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __18
    bne __b5
    jmp __b9
    // main::@9
  __b9:
    // [39] (byte) main::x#2 ← -- (byte) main::x#11 -- vbuz1=_dec_vbuz1 
    dec.z x
    // [40] if((byte) main::x#2!=(byte) $ff) goto main::@15 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z x
    bne __b15_from___b9
    // [32] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
  __b6_from___b9:
    // [32] phi (byte) main::x#10 = (byte) 0 [phi:main::@9->main::@6#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // [32] phi (byte) main::y#10 = (byte) main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [41] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
  __b15_from___b9:
    jmp __b15
    // main::@15
  __b15:
    jmp __b6_from___b15
    // main::@5
  __b5:
    // [42] (byte) main::x#1 ← ++ (byte) main::x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [43] if((byte) main::x#1!=(byte) $28) goto main::@17 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp.z x
    bne __b17_from___b5
    // [32] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    // [32] phi (byte) main::x#10 = (byte) $27 [phi:main::@5->main::@6#0] -- vbuz1=vbuc1 
    lda #$27
    sta.z x
    // [32] phi (byte) main::y#10 = (byte) main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [44] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
  __b17_from___b5:
    jmp __b17
    // main::@17
  __b17:
    jmp __b6_from___b17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp(6) str, byte zp(8) c)
memset: {
    .label end = $25
    .label dst = 9
    .label str = 6
    .label c = 8
    jmp __b1
    // memset::@1
  __b1:
    // [46] (byte*) memset::end#0 ← (byte*)(void*) memset::str#4 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [47] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#4 -- pbuz1=pbuz2 
    lda.z str
    sta.z dst
    lda.z str+1
    sta.z dst+1
    // [48] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [48] phi (byte*) memset::dst#2 = (byte*) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [49] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [50] return 
    rts
    // memset::@3
  __b3:
    // [51] *((byte*) memset::dst#2) ← (byte) memset::c#5 -- _deref_pbuz1=vbuz2 
    lda.z c
    ldy #0
    sta (dst),y
    // [52] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = $27
    .label __1 = $2b
    .label __2 = $2f
    .label return = $31
    .label return_1 = $1d
    // [53] (word~) rand::$0 ← (word) rand_state#12 << (byte) 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state_2+1
    lsr
    lda.z rand_state_2
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // [54] (word) rand_state#0 ← (word) rand_state#12 ^ (word~) rand::$0 -- vwuz1=vwuz2_bxor_vwuz3 
    lda.z rand_state_2
    eor.z __0
    sta.z rand_state
    lda.z rand_state_2+1
    eor.z __0+1
    sta.z rand_state+1
    // [55] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9 -- vwuz1=vwuz2_ror_9 
    lda.z rand_state+1
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // [56] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1 -- vwuz1=vwuz2_bxor_vwuz3 
    lda.z rand_state
    eor.z __1
    sta.z rand_state_1
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state_1+1
    // [57] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state_1
    sta.z __2+1
    lda #0
    sta.z __2
    // [58] (word) rand_state#10 ← (word) rand_state#1 ^ (word~) rand::$2 -- vwuz1=vwuz2_bxor_vwuz3 
    lda.z rand_state_1
    eor.z __2
    sta.z rand_state_2
    lda.z rand_state_1+1
    eor.z __2+1
    sta.z rand_state_2+1
    // [59] (word) rand::return#0 ← (word) rand_state#10 -- vwuz1=vwuz2 
    lda.z rand_state_2
    sta.z return
    lda.z rand_state_2+1
    sta.z return+1
    jmp __breturn
    // rand::@return
  __breturn:
    // [60] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] (word~) main::$24 ← (word)(byte) main::y#11 [ main::y#11 main::x#11 rand_state#12 main::$24 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Statement [10] (word~) main::$29 ← (word~) main::$24 << (byte) 2 [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [11] (word~) main::$30 ← (word~) main::$29 + (word~) main::$24 [ main::y#11 main::x#11 rand_state#12 main::$30 ] (  [ main::y#11 main::x#11 rand_state#12 main::$30 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [12] (word~) main::$3 ← (word~) main::$30 << (byte) 3 [ main::y#11 main::x#11 rand_state#12 main::$3 ] (  [ main::y#11 main::x#11 rand_state#12 main::$3 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [13] (word) main::offset#0 ← (word~) main::$3 + (byte) main::x#11 [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [14] (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$5 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$5 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [15] *((byte*~) main::$5) ← ++ *((byte*~) main::$5) [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ]
Statement [16] (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [17] (byte) main::cnt#0 ← *((byte*~) main::$6) [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [18] (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] (  [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:25 [ main::cnt#0 ]
Statement [19] (byte~) main::$9 ← (byte) main::cnt#0 & (byte) $f [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] (  [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [20] *((byte*~) main::$8) ← *((const byte*) FADE + (byte~) main::$9) [ main::y#11 main::x#11 rand_state#12 ] (  [ main::y#11 main::x#11 rand_state#12 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [22] (word) rand::return#2 ← (word) rand::return#0 [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] (  [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [23] (word~) main::$10 ← (word) rand::return#2 [ main::y#11 main::x#11 rand_state#10 main::$10 ] (  [ main::y#11 main::x#11 rand_state#10 main::$10 ] { }  ) always clobbers reg byte a 
Statement [33] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@6 [ main::y#10 main::x#10 rand_state#10 ] (  [ main::y#10 main::x#10 rand_state#10 ] { }  ) always clobbers reg byte a 
Statement [46] (byte*) memset::end#0 ← (byte*)(void*) memset::str#4 + (word) $3e8 [ memset::str#4 memset::c#5 memset::end#0 ] ( memset:1 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:3 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:5 [ memset::str#4 memset::c#5 memset::end#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:8 [ memset::c#5 ]
Statement [47] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#4 [ memset::c#5 memset::end#0 memset::dst#4 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [49] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [51] *((byte*) memset::dst#2) ← (byte) memset::c#5 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:8 [ memset::c#5 ]
Statement [53] (word~) rand::$0 ← (word) rand_state#12 << (byte) 7 [ rand_state#12 rand::$0 ] ( rand:21 [ main::y#11 main::x#11 rand_state#12 rand::$0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [54] (word) rand_state#0 ← (word) rand_state#12 ^ (word~) rand::$0 [ rand_state#0 ] ( rand:21 [ main::y#11 main::x#11 rand_state#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [55] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9 [ rand_state#0 rand::$1 ] ( rand:21 [ main::y#11 main::x#11 rand_state#0 rand::$1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [56] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1 [ rand_state#1 ] ( rand:21 [ main::y#11 main::x#11 rand_state#1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [57] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8 [ rand_state#1 rand::$2 ] ( rand:21 [ main::y#11 main::x#11 rand_state#1 rand::$2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [58] (word) rand_state#10 ← (word) rand_state#1 ^ (word~) rand::$2 [ rand_state#10 ] ( rand:21 [ main::y#11 main::x#11 rand_state#10 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [59] (word) rand::return#0 ← (word) rand_state#10 [ rand_state#10 rand::return#0 ] ( rand:21 [ main::y#11 main::x#11 rand_state#10 rand::return#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [6] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [7] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [9] (word~) main::$24 ← (word)(byte) main::y#11 [ main::y#11 main::x#11 rand_state#12 main::$24 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [10] (word~) main::$29 ← (word~) main::$24 << (byte) 2 [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] (  [ main::y#11 main::x#11 rand_state#12 main::$24 main::$29 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [11] (word~) main::$30 ← (word~) main::$29 + (word~) main::$24 [ main::y#11 main::x#11 rand_state#12 main::$30 ] (  [ main::y#11 main::x#11 rand_state#12 main::$30 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [12] (word~) main::$3 ← (word~) main::$30 << (byte) 3 [ main::y#11 main::x#11 rand_state#12 main::$3 ] (  [ main::y#11 main::x#11 rand_state#12 main::$3 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [13] (word) main::offset#0 ← (word~) main::$3 + (byte) main::x#11 [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [14] (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$5 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$5 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [15] *((byte*~) main::$5) ← ++ *((byte*~) main::$5) [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [16] (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::$6 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [17] (byte) main::cnt#0 ← *((byte*~) main::$6) [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] (  [ main::y#11 main::x#11 rand_state#12 main::offset#0 main::cnt#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [18] (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0 [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] (  [ main::y#11 main::x#11 rand_state#12 main::cnt#0 main::$8 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [19] (byte~) main::$9 ← (byte) main::cnt#0 & (byte) $f [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] (  [ main::y#11 main::x#11 rand_state#12 main::$8 main::$9 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [20] *((byte*~) main::$8) ← *((const byte*) FADE + (byte~) main::$9) [ main::y#11 main::x#11 rand_state#12 ] (  [ main::y#11 main::x#11 rand_state#12 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a reg byte y 
Statement [22] (word) rand::return#2 ← (word) rand::return#0 [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] (  [ main::y#11 main::x#11 rand_state#10 rand::return#2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [23] (word~) main::$10 ← (word) rand::return#2 [ main::y#11 main::x#11 rand_state#10 main::$10 ] (  [ main::y#11 main::x#11 rand_state#10 main::$10 ] { }  ) always clobbers reg byte a 
Statement [33] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@6 [ main::y#10 main::x#10 rand_state#10 ] (  [ main::y#10 main::x#10 rand_state#10 ] { }  ) always clobbers reg byte a 
Statement [46] (byte*) memset::end#0 ← (byte*)(void*) memset::str#4 + (word) $3e8 [ memset::str#4 memset::c#5 memset::end#0 ] ( memset:1 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:3 [ memset::str#4 memset::c#5 memset::end#0 ] { }  memset:5 [ memset::str#4 memset::c#5 memset::end#0 ] { }  ) always clobbers reg byte a 
Statement [47] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#4 [ memset::c#5 memset::end#0 memset::dst#4 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#4 ] { }  ) always clobbers reg byte a 
Statement [49] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [51] *((byte*) memset::dst#2) ← (byte) memset::c#5 [ memset::c#5 memset::end#0 memset::dst#2 ] ( memset:1 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:3 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  memset:5 [ memset::c#5 memset::end#0 memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [53] (word~) rand::$0 ← (word) rand_state#12 << (byte) 7 [ rand_state#12 rand::$0 ] ( rand:21 [ main::y#11 main::x#11 rand_state#12 rand::$0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [54] (word) rand_state#0 ← (word) rand_state#12 ^ (word~) rand::$0 [ rand_state#0 ] ( rand:21 [ main::y#11 main::x#11 rand_state#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [55] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9 [ rand_state#0 rand::$1 ] ( rand:21 [ main::y#11 main::x#11 rand_state#0 rand::$1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [56] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1 [ rand_state#1 ] ( rand:21 [ main::y#11 main::x#11 rand_state#1 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [57] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8 [ rand_state#1 rand::$2 ] ( rand:21 [ main::y#11 main::x#11 rand_state#1 rand::$2 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [58] (word) rand_state#10 ← (word) rand_state#1 ^ (word~) rand::$2 [ rand_state#10 ] ( rand:21 [ main::y#11 main::x#11 rand_state#10 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Statement [59] (word) rand::return#0 ← (word) rand_state#10 [ rand_state#10 rand::return#0 ] ( rand:21 [ main::y#11 main::x#11 rand_state#10 rand::return#0 ] { { rand::return#0 = rand::return#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] : zp[1]:2 , reg byte x , 
Potential registers zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ] : zp[1]:3 , reg byte x , 
Potential registers zp[2]:4 [ rand_state#12 rand_state#10 ] : zp[2]:4 , 
Potential registers zp[2]:6 [ memset::str#4 ] : zp[2]:6 , 
Potential registers zp[1]:8 [ memset::c#5 ] : zp[1]:8 , reg byte x , 
Potential registers zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] : zp[2]:9 , 
Potential registers zp[2]:11 [ main::$24 ] : zp[2]:11 , 
Potential registers zp[2]:13 [ main::$29 ] : zp[2]:13 , 
Potential registers zp[2]:15 [ main::$30 ] : zp[2]:15 , 
Potential registers zp[2]:17 [ main::$3 ] : zp[2]:17 , 
Potential registers zp[2]:19 [ main::offset#0 ] : zp[2]:19 , 
Potential registers zp[2]:21 [ main::$5 ] : zp[2]:21 , 
Potential registers zp[2]:23 [ main::$6 ] : zp[2]:23 , 
Potential registers zp[1]:25 [ main::cnt#0 ] : zp[1]:25 , reg byte x , reg byte y , 
Potential registers zp[2]:26 [ main::$8 ] : zp[2]:26 , 
Potential registers zp[1]:28 [ main::$9 ] : zp[1]:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:29 [ rand::return#2 ] : zp[2]:29 , 
Potential registers zp[2]:31 [ main::$10 ] : zp[2]:31 , 
Potential registers zp[1]:33 [ main::rnd#0 ] : zp[1]:33 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:34 [ main::$12 ] : zp[1]:34 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:35 [ main::$13 ] : zp[1]:35 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:36 [ main::$18 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:37 [ memset::end#0 ] : zp[2]:37 , 
Potential registers zp[2]:39 [ rand::$0 ] : zp[2]:39 , 
Potential registers zp[2]:41 [ rand_state#0 ] : zp[2]:41 , 
Potential registers zp[2]:43 [ rand::$1 ] : zp[2]:43 , 
Potential registers zp[2]:45 [ rand_state#1 ] : zp[2]:45 , 
Potential registers zp[2]:47 [ rand::$2 ] : zp[2]:47 , 
Potential registers zp[2]:49 [ rand::return#0 ] : zp[2]:49 , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 212.64: zp[1]:3 [ main::x#11 main::x#10 main::x#2 main::x#1 ] 212.26: zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] 33: zp[2]:21 [ main::$5 ] 22: zp[2]:13 [ main::$29 ] 22: zp[2]:15 [ main::$30 ] 22: zp[2]:17 [ main::$3 ] 22: zp[2]:23 [ main::$6 ] 22: zp[1]:28 [ main::$9 ] 22: zp[2]:31 [ main::$10 ] 22: zp[1]:34 [ main::$12 ] 22: zp[1]:35 [ main::$13 ] 22: zp[1]:36 [ main::$18 ] 16.5: zp[2]:11 [ main::$24 ] 14.67: zp[1]:33 [ main::rnd#0 ] 11: zp[1]:25 [ main::cnt#0 ] 11: zp[2]:26 [ main::$8 ] 8.8: zp[2]:19 [ main::offset#0 ] 
Uplift Scope [rand] 202: zp[2]:39 [ rand::$0 ] 202: zp[2]:43 [ rand::$1 ] 202: zp[2]:47 [ rand::$2 ] 37.33: zp[2]:49 [ rand::return#0 ] 22: zp[2]:29 [ rand::return#2 ] 
Uplift Scope [memset] 362.33: zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] 18.67: zp[2]:37 [ memset::end#0 ] 14.43: zp[1]:8 [ memset::c#5 ] 0: zp[2]:6 [ memset::str#4 ] 
Uplift Scope [] 151.5: zp[2]:41 [ rand_state#0 ] 151.5: zp[2]:45 [ rand_state#1 ] 32.87: zp[2]:4 [ rand_state#12 rand_state#10 ] 
Uplift Scope [MOS7360_TED] 
Uplift Scope [MOS6551_ACIA] 
Uplift Scope [MOS6529_PIO] 
Uplift Scope [MOS7501_PORT] 
Uplift Scope [$0] 
Uplift Scope [RADIX] 

Uplifting [main] best 8334 combination reg byte x [ main::x#11 main::x#10 main::x#2 main::x#1 ] zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] zp[2]:21 [ main::$5 ] zp[2]:13 [ main::$29 ] zp[2]:15 [ main::$30 ] zp[2]:17 [ main::$3 ] zp[2]:23 [ main::$6 ] reg byte a [ main::$9 ] zp[2]:31 [ main::$10 ] reg byte a [ main::$12 ] reg byte a [ main::$13 ] zp[1]:36 [ main::$18 ] zp[2]:11 [ main::$24 ] zp[1]:33 [ main::rnd#0 ] zp[1]:25 [ main::cnt#0 ] zp[2]:26 [ main::$8 ] zp[2]:19 [ main::offset#0 ] 
Limited combination testing to 100 combinations of 12288 possible.
Uplifting [rand] best 8334 combination zp[2]:39 [ rand::$0 ] zp[2]:43 [ rand::$1 ] zp[2]:47 [ rand::$2 ] zp[2]:49 [ rand::return#0 ] zp[2]:29 [ rand::return#2 ] 
Uplifting [memset] best 8315 combination zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] zp[2]:37 [ memset::end#0 ] reg byte x [ memset::c#5 ] zp[2]:6 [ memset::str#4 ] 
Uplifting [] best 8315 combination zp[2]:41 [ rand_state#0 ] zp[2]:45 [ rand_state#1 ] zp[2]:4 [ rand_state#12 rand_state#10 ] 
Uplifting [MOS7360_TED] best 8315 combination 
Uplifting [MOS6551_ACIA] best 8315 combination 
Uplifting [MOS6529_PIO] best 8315 combination 
Uplifting [MOS7501_PORT] best 8315 combination 
Uplifting [$0] best 8315 combination 
Uplifting [RADIX] best 8315 combination 
Attempting to uplift remaining variables inzp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
Uplifting [main] best 8315 combination zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ] 
Attempting to uplift remaining variables inzp[1]:36 [ main::$18 ]
Uplifting [main] best 8255 combination reg byte a [ main::$18 ] 
Attempting to uplift remaining variables inzp[1]:33 [ main::rnd#0 ]
Uplifting [main] best 8195 combination reg byte y [ main::rnd#0 ] 
Attempting to uplift remaining variables inzp[1]:25 [ main::cnt#0 ]
Uplifting [main] best 8175 combination reg byte y [ main::cnt#0 ] 
Coalescing zero page register [ zp[2]:4 [ rand_state#12 rand_state#10 ] ] with [ zp[2]:41 [ rand_state#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:4 [ rand_state#12 rand_state#10 rand_state#0 ] ] with [ zp[2]:45 [ rand_state#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:6 [ memset::str#4 ] ] with [ zp[2]:9 [ memset::dst#2 memset::dst#4 memset::dst#1 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ main::$24 ] ] with [ zp[2]:15 [ main::$30 ] ] - score: 1
Coalescing zero page register [ zp[2]:17 [ main::$3 ] ] with [ zp[2]:19 [ main::offset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:29 [ rand::return#2 ] ] with [ zp[2]:31 [ main::$10 ] ] - score: 1
Coalescing zero page register [ zp[2]:29 [ rand::return#2 main::$10 ] ] with [ zp[2]:49 [ rand::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ main::$24 main::$30 ] ] with [ zp[2]:17 [ main::$3 main::offset#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:11 [ main::$24 main::$30 main::$3 main::offset#0 ] ] with [ zp[2]:26 [ main::$8 ] ] - score: 1
Coalescing zero page register [ zp[2]:6 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 ] ] with [ zp[2]:4 [ rand_state#12 rand_state#10 rand_state#0 rand_state#1 ] ]
Coalescing zero page register [ zp[2]:39 [ rand::$0 ] ] with [ zp[2]:37 [ memset::end#0 ] ]
Allocated (was zp[2]:6) zp[2]:3 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 rand_state#12 rand_state#10 rand_state#0 rand_state#1 ]
Allocated (was zp[2]:11) zp[2]:5 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 ]
Allocated (was zp[2]:13) zp[2]:7 [ main::$29 ]
Allocated (was zp[2]:21) zp[2]:9 [ main::$5 ]
Allocated (was zp[2]:23) zp[2]:11 [ main::$6 ]
Allocated (was zp[2]:29) zp[2]:13 [ rand::return#2 main::$10 rand::return#0 ]
Allocated (was zp[2]:39) zp[2]:15 [ rand::$0 memset::end#0 ]
Allocated (was zp[2]:43) zp[2]:17 [ rand::$1 ]
Allocated (was zp[2]:47) zp[2]:19 [ rand::$2 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
// Plus/4 / Commodore 16 registers and memory layout
// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  .file [name="plus4walk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
.segment Code


  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  // Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  // The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = 3
.segment Code
  // main
main: {
    .label __3 = 5
    .label __5 = 9
    .label __6 = $b
    .label __8 = 5
    .label __10 = $d
    .label __24 = 5
    .label offset = 5
    .label y = 2
    .label __29 = 7
    .label __30 = 5
    // [1] call memset 
    // [45] phi from main to memset [phi:main->memset]
  memset_from_main:
    // [45] phi (byte) memset::c#5 = (byte) $a0 [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #$a0
    // [45] phi (void*) memset::str#4 = (void*)(const nomodify byte*) DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [2] phi from main to main::@10 [phi:main->main::@10]
  __b10_from_main:
    jmp __b10
    // main::@10
  __b10:
    // [3] call memset 
    // [45] phi from main::@10 to memset [phi:main::@10->memset]
  memset_from___b10:
    // [45] phi (byte) memset::c#5 = (byte) 0 [phi:main::@10->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [45] phi (void*) memset::str#4 = (void*)(const nomodify byte*) DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [4] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
  __b11_from___b10:
    jmp __b11
    // main::@11
  __b11:
    // [5] call memset 
    // [45] phi from main::@11 to memset [phi:main::@11->memset]
  memset_from___b11:
    // [45] phi (byte) memset::c#5 = (byte) 0 [phi:main::@11->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [45] phi (void*) memset::str#4 = (void*)(const byte*) VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    jmp __b12
    // main::@12
  __b12:
    // [6] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // [7] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [8] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
  __b1_from___b12:
    // [8] phi (word) rand_state#12 = (word) 1 [phi:main::@12->main::@1#0] -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state
    lda #>1
    sta.z rand_state+1
    // [8] phi (byte) main::x#11 = (byte) $14 [phi:main::@12->main::@1#1] -- vbuxx=vbuc1 
    ldx #$14
    // [8] phi (byte) main::y#11 = (byte) $c [phi:main::@12->main::@1#2] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    jmp __b1
    // main::@1
  __b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] (word~) main::$24 ← (word)(byte) main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [10] (word~) main::$29 ← (word~) main::$24 << (byte) 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [11] (word~) main::$30 ← (word~) main::$29 + (word~) main::$24 -- vwuz1=vwuz2_plus_vwuz1 
    lda.z __30
    clc
    adc.z __29
    sta.z __30
    lda.z __30+1
    adc.z __29+1
    sta.z __30+1
    // [12] (word~) main::$3 ← (word~) main::$30 << (byte) 3 -- vwuz1=vwuz1_rol_3 
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // [13] (word) main::offset#0 ← (word~) main::$3 + (byte) main::x#11 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z offset
    sta.z offset
    bcc !+
    inc.z offset+1
  !:
    // [14] (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __5
    lda.z offset+1
    adc #>VISITS
    sta.z __5+1
    // [15] *((byte*~) main::$5) ← ++ *((byte*~) main::$5) -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__5),y
    clc
    adc #1
    ldy #0
    sta (__5),y
    // [16] (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // [17] (byte) main::cnt#0 ← *((byte*~) main::$6) -- vbuyy=_deref_pbuz1 
    ldy #0
    lda (__6),y
    tay
    // [18] (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z __8
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z __8+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // [19] (byte~) main::$9 ← (byte) main::cnt#0 & (byte) $f -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$f
    // [20] *((byte*~) main::$8) ← *((const byte*) FADE + (byte~) main::$9) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda FADE,y
    ldy #0
    sta (__8),y
    // [21] call rand 
    jsr rand
    // [22] (word) rand::return#2 ← (word) rand::return#0
    jmp __b13
    // main::@13
  __b13:
    // [23] (word~) main::$10 ← (word) rand::return#2
    // [24] (byte) main::rnd#0 ← > (word~) main::$10 -- vbuyy=_hi_vwuz1 
    ldy.z __10+1
    // [25] (byte~) main::$12 ← (byte) main::rnd#0 & (byte) $80 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$80
    // [26] if((byte) 0!=(byte~) main::$12) goto main::@3 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b3
    jmp __b7
    // main::@7
  __b7:
    // [27] (byte~) main::$13 ← (byte) main::rnd#0 & (byte) $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // [28] if((byte) 0!=(byte~) main::$13) goto main::@4 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b4
    jmp __b8
    // main::@8
  __b8:
    // [29] (byte) main::y#2 ← -- (byte) main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // [30] if((byte) main::y#2!=(byte) $ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b14_from___b8
    // [32] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
  __b6_from___b8:
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    jmp __b6
    // [31] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
  __b14_from___b8:
    jmp __b14
    // main::@14
  __b14:
    // [32] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
  __b6_from___b14:
  __b6_from___b15:
  __b6_from___b16:
  __b6_from___b17:
  __b6_from___b6:
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    jmp __b6
    // main::@6
  __b6:
    // [33] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6_from___b6
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
  __b1_from___b6:
    // [8] phi (word) rand_state#12 = (word) rand_state#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [8] phi (byte) main::x#11 = (byte) main::x#10 [phi:main::@6->main::@1#1] -- register_copy 
    // [8] phi (byte) main::y#11 = (byte) main::y#10 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [34] (byte) main::y#1 ← ++ (byte) main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // [35] if((byte) main::y#1!=(byte) $19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b16_from___b4
    // [32] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
  __b6_from___b4:
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [36] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
  __b16_from___b4:
    jmp __b16
    // main::@16
  __b16:
    jmp __b6_from___b16
    // main::@3
  __b3:
    // [37] (byte~) main::$18 ← (byte) main::rnd#0 & (byte) $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // [38] if((byte) 0!=(byte~) main::$18) goto main::@5 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b5
    jmp __b9
    // main::@9
  __b9:
    // [39] (byte) main::x#2 ← -- (byte) main::x#11 -- vbuxx=_dec_vbuxx 
    dex
    // [40] if((byte) main::x#2!=(byte) $ff) goto main::@15 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b15_from___b9
    // [32] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
  __b6_from___b9:
    // [32] phi (byte) main::x#10 = (byte) 0 [phi:main::@9->main::@6#0] -- vbuxx=vbuc1 
    ldx #0
    // [32] phi (byte) main::y#10 = (byte) main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [41] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
  __b15_from___b9:
    jmp __b15
    // main::@15
  __b15:
    jmp __b6_from___b15
    // main::@5
  __b5:
    // [42] (byte) main::x#1 ← ++ (byte) main::x#11 -- vbuxx=_inc_vbuxx 
    inx
    // [43] if((byte) main::x#1!=(byte) $28) goto main::@17 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne __b17_from___b5
    // [32] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    // [32] phi (byte) main::x#10 = (byte) $27 [phi:main::@5->main::@6#0] -- vbuxx=vbuc1 
    ldx #$27
    // [32] phi (byte) main::y#10 = (byte) main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [44] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
  __b17_from___b5:
    jmp __b17
    // main::@17
  __b17:
    jmp __b6_from___b17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp(3) str, byte register(X) c)
memset: {
    .label end = $f
    .label dst = 3
    .label str = 3
    jmp __b1
    // memset::@1
  __b1:
    // [46] (byte*) memset::end#0 ← (byte*)(void*) memset::str#4 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [47] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#4
    // [48] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
  __b2_from___b1:
  __b2_from___b3:
    // [48] phi (byte*) memset::dst#2 = (byte*) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    jmp __b2
    // memset::@2
  __b2:
    // [49] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    jmp __breturn
    // memset::@return
  __breturn:
    // [50] return 
    rts
    // memset::@3
  __b3:
    // [51] *((byte*) memset::dst#2) ← (byte) memset::c#5 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // [52] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2_from___b3
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = $f
    .label __1 = $11
    .label __2 = $13
    .label return = $d
    // [53] (word~) rand::$0 ← (word) rand_state#12 << (byte) 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state+1
    lsr
    lda.z rand_state
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // [54] (word) rand_state#0 ← (word) rand_state#12 ^ (word~) rand::$0 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __0
    sta.z rand_state
    lda.z rand_state+1
    eor.z __0+1
    sta.z rand_state+1
    // [55] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9 -- vwuz1=vwuz2_ror_9 
    lda.z rand_state+1
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // [56] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __1
    sta.z rand_state
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state+1
    // [57] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state
    sta.z __2+1
    lda #0
    sta.z __2
    // [58] (word) rand_state#10 ← (word) rand_state#1 ^ (word~) rand::$2 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __2
    sta.z rand_state
    lda.z rand_state+1
    eor.z __2+1
    sta.z rand_state+1
    // [59] (word) rand::return#0 ← (word) rand_state#10 -- vwuz1=vwuz2 
    lda.z rand_state
    sta.z return
    lda.z rand_state+1
    sta.z return+1
    jmp __breturn
    // rand::@return
  __breturn:
    // [60] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b10
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b13
Removing instruction jmp __b7
Removing instruction jmp __b8
Removing instruction jmp __b14
Removing instruction jmp __b6
Removing instruction jmp __b16
Removing instruction jmp __b9
Removing instruction jmp __b15
Removing instruction jmp __b17
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction ldy #0
Removing instruction ldy #0
Removing instruction lda.z rand_state+1
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b14_from___b8 with __b6
Replacing label __b6_from___b6 with __b6
Replacing label __b1 with __b2
Replacing label __b16_from___b4 with __b16
Replacing label __b6_from___b16 with __b6
Replacing label __b15_from___b9 with __b15
Replacing label __b6_from___b15 with __b6
Replacing label __b17_from___b5 with __b17
Replacing label __b6_from___b17 with __b6
Replacing label __b2_from___b3 with __b2
Removing instruction __b10_from_main:
Removing instruction memset_from___b10:
Removing instruction __b11_from___b10:
Removing instruction memset_from___b11:
Removing instruction __b1:
Removing instruction __b14_from___b8:
Removing instruction __b14:
Removing instruction __b6_from___b14:
Removing instruction __b6_from___b15:
Removing instruction __b6_from___b16:
Removing instruction __b6_from___b17:
Removing instruction __b6_from___b6:
Removing instruction __b16_from___b4:
Removing instruction __b15_from___b9:
Removing instruction __b17_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction memset_from_main:
Removing instruction __b10:
Removing instruction __b11:
Removing instruction __b12:
Removing instruction __b1_from___b12:
Removing instruction __b13:
Removing instruction __b7:
Removing instruction __b8:
Removing instruction __b6_from___b8:
Removing instruction __b1_from___b6:
Removing instruction __b6_from___b4:
Removing instruction __b9:
Removing instruction __b6_from___b9:
Removing instruction __b6_from___b5:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Skipping double jump to __b6 in bne __b16
Skipping double jump to __b6 in bne __b15
Skipping double jump to __b6 in bne __b17
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp __b6
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b16:
Removing instruction __b15:
Removing instruction __b17:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing unreachable instruction jmp __b6
Removing unreachable instruction jmp __b6
Removing unreachable instruction jmp __b6
Succesful ASM optimization Pass5UnreachableCodeElimination

FINAL SYMBOL TABLE
(byte) $0::BASIC
(byte) $0::CARTRIDGE_HIGH
(byte) $0::CARTRIDGE_LOW
(byte) $0::FUNCTION_HIGH
(byte) $0::FUNCTION_LOW
(byte) $0::KERNAL
(byte) $0::UNUSED
(const nomodify byte*) DEFAULT_COLORRAM = (byte*) 2048
(const nomodify byte*) DEFAULT_SCREEN = (byte*) 3072
(const byte*) FADE[(number) $10]  = { (byte) 2, (byte) $12, (byte) $22, (byte) $32, (byte) $42, (byte) $52, (byte) $62, (byte) $72, (byte) $76, (byte) $66, (byte) $56, (byte) $46, (byte) $36, (byte) $26, (byte) $16, (byte) 6 }
(byte) MOS6529_PIO::PORT
(byte) MOS6551_ACIA::COMMAND
(byte) MOS6551_ACIA::CONTROL
(byte) MOS6551_ACIA::DATA
(byte) MOS6551_ACIA::STATUS
(byte) MOS7360_TED::BG_COLOR
(byte) MOS7360_TED::BG_COLOR1
(byte) MOS7360_TED::BG_COLOR2
(byte) MOS7360_TED::BG_COLOR3
(byte) MOS7360_TED::BORDER_COLOR
(byte) MOS7360_TED::CH1_FREQ_HI
(byte) MOS7360_TED::CH1_FREQ_LO
(byte) MOS7360_TED::CH2_FREQ_LO
(byte) MOS7360_TED::CHARPOS_HI
(byte) MOS7360_TED::CHARPOS_LO
(byte) MOS7360_TED::CONTROL1
(byte) MOS7360_TED::CONTROL2
(word) MOS7360_TED::COUNTER1
(word) MOS7360_TED::COUNTER2
(word) MOS7360_TED::COUNTER3
(byte) MOS7360_TED::CURSOR_HI
(byte) MOS7360_TED::CURSOR_LO
(byte) MOS7360_TED::HSCAN_POS
(byte) MOS7360_TED::IRQ_MASK
(byte) MOS7360_TED::IRQ_REQUEST
(volatile byte) MOS7360_TED::KEYBOARD_INPUT loadstore
(byte) MOS7360_TED::MEMORY1
(byte) MOS7360_TED::MEMORY2
(byte) MOS7360_TED::MEMORY3
(byte) MOS7360_TED::RAM_SWITCH
(byte) MOS7360_TED::RASTER_HI
(byte) MOS7360_TED::RASTER_IRQ
(byte) MOS7360_TED::RASTER_LO
(byte) MOS7360_TED::ROM_SWITCH
(byte) MOS7360_TED::SOUND_CONTROL
(const byte*) MOS7360_TED::UNUSED[(number) $1d]  = { fill( $1d, 0) }
(byte) MOS7360_TED::VSCAN_POS
(byte) MOS7501_PORT::DDR
(byte) MOS7501_PORT::PORT
(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR = (byte) $15
(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = (byte) $19
(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO = (byte) $1d
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(const nomodify struct MOS7360_TED*) TED = (struct MOS7360_TED*) 65280
(const byte*) VISITS[(number) $3e8]  = { fill( $3e8, 0) }
(void()) main()
(word~) main::$10 zp[2]:13 22.0
(byte~) main::$12 reg byte a 22.0
(byte~) main::$13 reg byte a 22.0
(byte~) main::$18 reg byte a 22.0
(word~) main::$24 zp[2]:5 16.5
(word~) main::$29 zp[2]:7 22.0
(word~) main::$3 zp[2]:5 22.0
(word~) main::$30 zp[2]:5 22.0
(byte*~) main::$5 zp[2]:9 33.0
(byte*~) main::$6 zp[2]:11 22.0
(byte*~) main::$8 zp[2]:5 11.0
(byte~) main::$9 reg byte a 22.0
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@12
(label) main::@13
(label) main::@14
(label) main::@15
(label) main::@16
(label) main::@17
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@9
(byte) main::cnt
(byte) main::cnt#0 reg byte y 11.0
(word) main::offset
(word) main::offset#0 offset zp[2]:5 8.8
(byte) main::rnd
(byte) main::rnd#0 reg byte y 14.666666666666666
(byte) main::x
(byte) main::x#1 reg byte x 11.0
(byte) main::x#10 reg byte x 184.5
(byte) main::x#11 reg byte x 6.137931034482759
(byte) main::x#2 reg byte x 11.0
(byte) main::y
(byte) main::y#1 y zp[1]:2 11.0
(byte) main::y#10 y zp[1]:2 184.5
(byte) main::y#11 y zp[1]:2 5.758620689655173
(byte) main::y#2 y zp[1]:2 11.0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@3
(label) memset::@return
(byte) memset::c
(byte) memset::c#5 reg byte x 14.428571428571429
(byte*) memset::dst
(byte*) memset::dst#1 dst zp[2]:3 202.0
(byte*) memset::dst#2 dst zp[2]:3 138.33333333333331
(byte*) memset::dst#4 dst zp[2]:3 22.0
(byte*) memset::end
(byte*) memset::end#0 end zp[2]:15 18.666666666666664
(word) memset::num
(void*) memset::return
(void*) memset::str
(void*) memset::str#4 str zp[2]:3
(word()) rand()
(word~) rand::$0 zp[2]:15 202.0
(word~) rand::$1 zp[2]:17 202.0
(word~) rand::$2 zp[2]:19 202.0
(label) rand::@return
(word) rand::return
(word) rand::return#0 return zp[2]:13 37.33333333333333
(word) rand::return#2 return zp[2]:13 22.0
(word) rand_state
(word) rand_state#0 rand_state zp[2]:3 151.5
(word) rand_state#1 rand_state zp[2]:3 151.5
(word) rand_state#10 rand_state zp[2]:3 11.222222222222223
(word) rand_state#12 rand_state zp[2]:3 21.642857142857142

zp[1]:2 [ main::y#11 main::y#10 main::y#2 main::y#1 ]
reg byte x [ main::x#11 main::x#10 main::x#2 main::x#1 ]
zp[2]:3 [ memset::str#4 memset::dst#2 memset::dst#4 memset::dst#1 rand_state#12 rand_state#10 rand_state#0 rand_state#1 ]
reg byte x [ memset::c#5 ]
zp[2]:5 [ main::$24 main::$30 main::$3 main::offset#0 main::$8 ]
zp[2]:7 [ main::$29 ]
zp[2]:9 [ main::$5 ]
zp[2]:11 [ main::$6 ]
reg byte y [ main::cnt#0 ]
reg byte a [ main::$9 ]
zp[2]:13 [ rand::return#2 main::$10 rand::return#0 ]
reg byte y [ main::rnd#0 ]
reg byte a [ main::$12 ]
reg byte a [ main::$13 ]
reg byte a [ main::$18 ]
zp[2]:15 [ rand::$0 memset::end#0 ]
zp[2]:17 [ rand::$1 ]
zp[2]:19 [ rand::$2 ]


FINAL ASSEMBLER
Score: 6721

  // File Comments
// Random walk with color fading for Commodore Plus/4 / C16
// Plus/4 / Commodore 16 registers and memory layout
// http://zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/264_Hardware_Spec.pdf
// http://www.zimmers.net/anonftp/pub/cbm/schematics/computers/plus4/Plus_4_Technical_Docs.pdf
// http://personalpages.tds.net/~rcarlsen/cbm/c16/C16_Service_Manual_314001-03_(1984_Oct).pdf
// https://www.floodgap.com/retrobits/ckb/secret/264memory.txt
// The MOS 7360/8360 TED chip used for graphics and sound in Plus/4 and Commodore 16
// https://www.karlstechnology.com/commodore/TED7360-datasheet.pdf
// http://mclauchlan.site.net.au/scott/C=Hacking/C-Hacking12/gfx.html
  // Upstart
  .file [name="plus4walk.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$1001]
.segmentdef Code [start=$100d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
.segment Code


  // Global Constants & labels
  .const OFFSET_STRUCT_MOS7360_TED_BG_COLOR = $15
  .const OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR = $19
  .const OFFSET_STRUCT_MOS7360_TED_RASTER_LO = $1d
  // Default address of screen luminance/color matrix
  .label DEFAULT_COLORRAM = $800
  // Default address of screen character matrix
  .label DEFAULT_SCREEN = $c00
  // The TED chip controlling video and sound on the Plus/4 and Commodore 16
  .label TED = $ff00
  // The random state variable
  .label rand_state = 3
.segment Code
  // main
main: {
    .label __3 = 5
    .label __5 = 9
    .label __6 = $b
    .label __8 = 5
    .label __10 = $d
    .label __24 = 5
    .label offset = 5
    .label y = 2
    .label __29 = 7
    .label __30 = 5
    // memset(DEFAULT_SCREEN, 0xa0, 1000)
    // [1] call memset 
    // [45] phi from main to memset [phi:main->memset]
    // [45] phi (byte) memset::c#5 = (byte) $a0 [phi:main->memset#0] -- vbuxx=vbuc1 
    ldx #$a0
    // [45] phi (void*) memset::str#4 = (void*)(const nomodify byte*) DEFAULT_SCREEN [phi:main->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_SCREEN
    sta.z memset.str
    lda #>DEFAULT_SCREEN
    sta.z memset.str+1
    jsr memset
    // [2] phi from main to main::@10 [phi:main->main::@10]
    // main::@10
    // memset(DEFAULT_COLORRAM, 0, 1000)
    // [3] call memset 
    // [45] phi from main::@10 to memset [phi:main::@10->memset]
    // [45] phi (byte) memset::c#5 = (byte) 0 [phi:main::@10->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [45] phi (void*) memset::str#4 = (void*)(const nomodify byte*) DEFAULT_COLORRAM [phi:main::@10->memset#1] -- pvoz1=pvoc1 
    lda #<DEFAULT_COLORRAM
    sta.z memset.str
    lda #>DEFAULT_COLORRAM
    sta.z memset.str+1
    jsr memset
    // [4] phi from main::@10 to main::@11 [phi:main::@10->main::@11]
    // main::@11
    // memset(VISITS, 0, 1000)
    // [5] call memset 
    // [45] phi from main::@11 to memset [phi:main::@11->memset]
    // [45] phi (byte) memset::c#5 = (byte) 0 [phi:main::@11->memset#0] -- vbuxx=vbuc1 
    ldx #0
    // [45] phi (void*) memset::str#4 = (void*)(const byte*) VISITS [phi:main::@11->memset#1] -- pvoz1=pvoc1 
    lda #<VISITS
    sta.z memset.str
    lda #>VISITS
    sta.z memset.str+1
    jsr memset
    // main::@12
    // TED->BG_COLOR = 0
    // [6] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BG_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TED+OFFSET_STRUCT_MOS7360_TED_BG_COLOR
    // TED->BORDER_COLOR = 0
    // [7] *((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    sta TED+OFFSET_STRUCT_MOS7360_TED_BORDER_COLOR
    // [8] phi from main::@12 to main::@1 [phi:main::@12->main::@1]
    // [8] phi (word) rand_state#12 = (word) 1 [phi:main::@12->main::@1#0] -- vwuz1=vwuc1 
    lda #<1
    sta.z rand_state
    lda #>1
    sta.z rand_state+1
    // [8] phi (byte) main::x#11 = (byte) $14 [phi:main::@12->main::@1#1] -- vbuxx=vbuc1 
    ldx #$14
    // [8] phi (byte) main::y#11 = (byte) $c [phi:main::@12->main::@1#2] -- vbuz1=vbuc1 
    lda #$c
    sta.z y
    // main::@1
    // main::@2
  __b2:
    // (unsigned int)y*40
    // [9] (word~) main::$24 ← (word)(byte) main::y#11 -- vwuz1=_word_vbuz2 
    lda.z y
    sta.z __24
    lda #0
    sta.z __24+1
    // [10] (word~) main::$29 ← (word~) main::$24 << (byte) 2 -- vwuz1=vwuz2_rol_2 
    lda.z __24
    asl
    sta.z __29
    lda.z __24+1
    rol
    sta.z __29+1
    asl.z __29
    rol.z __29+1
    // [11] (word~) main::$30 ← (word~) main::$29 + (word~) main::$24 -- vwuz1=vwuz2_plus_vwuz1 
    lda.z __30
    clc
    adc.z __29
    sta.z __30
    lda.z __30+1
    adc.z __29+1
    sta.z __30+1
    // [12] (word~) main::$3 ← (word~) main::$30 << (byte) 3 -- vwuz1=vwuz1_rol_3 
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    asl.z __3
    rol.z __3+1
    // offset = (unsigned int)y*40+x
    // [13] (word) main::offset#0 ← (word~) main::$3 + (byte) main::x#11 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z offset
    sta.z offset
    bcc !+
    inc.z offset+1
  !:
    // VISITS+offset
    // [14] (byte*~) main::$5 ← (const byte*) VISITS + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __5
    lda.z offset+1
    adc #>VISITS
    sta.z __5+1
    // cnt = ++*(VISITS+offset)
    // [15] *((byte*~) main::$5) ← ++ *((byte*~) main::$5) -- _deref_pbuz1=_inc__deref_pbuz1 
    ldy #0
    lda (__5),y
    clc
    adc #1
    sta (__5),y
    // VISITS+offset
    // [16] (byte*~) main::$6 ← (const byte*) VISITS + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz2 
    lda.z offset
    clc
    adc #<VISITS
    sta.z __6
    lda.z offset+1
    adc #>VISITS
    sta.z __6+1
    // cnt = ++*(VISITS+offset)
    // [17] (byte) main::cnt#0 ← *((byte*~) main::$6) -- vbuyy=_deref_pbuz1 
    lda (__6),y
    tay
    // DEFAULT_COLORRAM+offset
    // [18] (byte*~) main::$8 ← (const nomodify byte*) DEFAULT_COLORRAM + (word) main::offset#0 -- pbuz1=pbuc1_plus_vwuz1 
    clc
    lda.z __8
    adc #<DEFAULT_COLORRAM
    sta.z __8
    lda.z __8+1
    adc #>DEFAULT_COLORRAM
    sta.z __8+1
    // cnt&0xf
    // [19] (byte~) main::$9 ← (byte) main::cnt#0 & (byte) $f -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$f
    // *(DEFAULT_COLORRAM+offset) = FADE[cnt&0xf]
    // [20] *((byte*~) main::$8) ← *((const byte*) FADE + (byte~) main::$9) -- _deref_pbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda FADE,y
    ldy #0
    sta (__8),y
    // rand()
    // [21] call rand 
    jsr rand
    // [22] (word) rand::return#2 ← (word) rand::return#0
    // main::@13
    // [23] (word~) main::$10 ← (word) rand::return#2
    // rnd = >rand()
    // [24] (byte) main::rnd#0 ← > (word~) main::$10 -- vbuyy=_hi_vwuz1 
    ldy.z __10+1
    // rnd & 0x80
    // [25] (byte~) main::$12 ← (byte) main::rnd#0 & (byte) $80 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$80
    // if(rnd & 0x80)
    // [26] if((byte) 0!=(byte~) main::$12) goto main::@3 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b3
    // main::@7
    // rnd & 0x40
    // [27] (byte~) main::$13 ← (byte) main::rnd#0 & (byte) $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // if(rnd & 0x40)
    // [28] if((byte) 0!=(byte~) main::$13) goto main::@4 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b4
    // main::@8
    // y--;
    // [29] (byte) main::y#2 ← -- (byte) main::y#11 -- vbuz1=_dec_vbuz1 
    dec.z y
    // if(y==0xff)
    // [30] if((byte) main::y#2!=(byte) $ff) goto main::@14 -- vbuz1_neq_vbuc1_then_la1 
    lda #$ff
    cmp.z y
    bne __b6
    // [32] phi from main::@8 to main::@6 [phi:main::@8->main::@6]
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@8->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) 0 [phi:main::@8->main::@6#1] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [31] phi from main::@8 to main::@14 [phi:main::@8->main::@14]
    // main::@14
    // [32] phi from main::@14 main::@15 main::@16 main::@17 main::@6 to main::@6 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6]
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) main::y#2 [phi:main::@14/main::@15/main::@16/main::@17/main::@6->main::@6#1] -- register_copy 
    // main::@6
  __b6:
    // while(TED->RASTER_LO!=0xff)
    // [33] if(*((byte*)(const nomodify struct MOS7360_TED*) TED+(const byte) OFFSET_STRUCT_MOS7360_TED_RASTER_LO)!=(byte) $ff) goto main::@6 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp TED+OFFSET_STRUCT_MOS7360_TED_RASTER_LO
    bne __b6
    // [8] phi from main::@6 to main::@1 [phi:main::@6->main::@1]
    // [8] phi (word) rand_state#12 = (word) rand_state#10 [phi:main::@6->main::@1#0] -- register_copy 
    // [8] phi (byte) main::x#11 = (byte) main::x#10 [phi:main::@6->main::@1#1] -- register_copy 
    // [8] phi (byte) main::y#11 = (byte) main::y#10 [phi:main::@6->main::@1#2] -- register_copy 
    jmp __b2
    // main::@4
  __b4:
    // y++;
    // [34] (byte) main::y#1 ← ++ (byte) main::y#11 -- vbuz1=_inc_vbuz1 
    inc.z y
    // if(y==25)
    // [35] if((byte) main::y#1!=(byte) $19) goto main::@16 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp.z y
    bne __b6
    // [32] phi from main::@4 to main::@6 [phi:main::@4->main::@6]
    // [32] phi (byte) main::x#10 = (byte) main::x#11 [phi:main::@4->main::@6#0] -- register_copy 
    // [32] phi (byte) main::y#10 = (byte) $18 [phi:main::@4->main::@6#1] -- vbuz1=vbuc1 
    lda #$18
    sta.z y
    jmp __b6
    // [36] phi from main::@4 to main::@16 [phi:main::@4->main::@16]
    // main::@16
    // main::@3
  __b3:
    // rnd& 0x40
    // [37] (byte~) main::$18 ← (byte) main::rnd#0 & (byte) $40 -- vbuaa=vbuyy_band_vbuc1 
    tya
    and #$40
    // if(rnd& 0x40)
    // [38] if((byte) 0!=(byte~) main::$18) goto main::@5 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b5
    // main::@9
    // x--;
    // [39] (byte) main::x#2 ← -- (byte) main::x#11 -- vbuxx=_dec_vbuxx 
    dex
    // if(x==0xff)
    // [40] if((byte) main::x#2!=(byte) $ff) goto main::@15 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$ff
    bne __b6
    // [32] phi from main::@9 to main::@6 [phi:main::@9->main::@6]
    // [32] phi (byte) main::x#10 = (byte) 0 [phi:main::@9->main::@6#0] -- vbuxx=vbuc1 
    ldx #0
    // [32] phi (byte) main::y#10 = (byte) main::y#11 [phi:main::@9->main::@6#1] -- register_copy 
    jmp __b6
    // [41] phi from main::@9 to main::@15 [phi:main::@9->main::@15]
    // main::@15
    // main::@5
  __b5:
    // x++;
    // [42] (byte) main::x#1 ← ++ (byte) main::x#11 -- vbuxx=_inc_vbuxx 
    inx
    // if(x==40)
    // [43] if((byte) main::x#1!=(byte) $28) goto main::@17 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne __b6
    // [32] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // [32] phi (byte) main::x#10 = (byte) $27 [phi:main::@5->main::@6#0] -- vbuxx=vbuc1 
    ldx #$27
    // [32] phi (byte) main::y#10 = (byte) main::y#11 [phi:main::@5->main::@6#1] -- register_copy 
    jmp __b6
    // [44] phi from main::@5 to main::@17 [phi:main::@5->main::@17]
    // main::@17
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
// memset(void* zp(3) str, byte register(X) c)
memset: {
    .label end = $f
    .label dst = 3
    .label str = 3
    // memset::@1
    // end = (char*)str + num
    // [46] (byte*) memset::end#0 ← (byte*)(void*) memset::str#4 + (word) $3e8 -- pbuz1=pbuz2_plus_vwuc1 
    lda.z str
    clc
    adc #<$3e8
    sta.z end
    lda.z str+1
    adc #>$3e8
    sta.z end+1
    // [47] (byte*) memset::dst#4 ← (byte*)(void*) memset::str#4
    // [48] phi from memset::@1 memset::@3 to memset::@2 [phi:memset::@1/memset::@3->memset::@2]
    // [48] phi (byte*) memset::dst#2 = (byte*) memset::dst#4 [phi:memset::@1/memset::@3->memset::@2#0] -- register_copy 
    // memset::@2
  __b2:
    // for(char* dst = str; dst!=end; dst++)
    // [49] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@3 -- pbuz1_neq_pbuz2_then_la1 
    lda.z dst+1
    cmp.z end+1
    bne __b3
    lda.z dst
    cmp.z end
    bne __b3
    // memset::@return
    // }
    // [50] return 
    rts
    // memset::@3
  __b3:
    // *dst = c
    // [51] *((byte*) memset::dst#2) ← (byte) memset::c#5 -- _deref_pbuz1=vbuxx 
    txa
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [52] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    jmp __b2
}
  // rand
// Returns a pseudo-random number in the range of 0 to RAND_MAX (65535)
// Uses an xorshift pseudorandom number generator that hits all different values
// Information https://en.wikipedia.org/wiki/Xorshift
// Source http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html
rand: {
    .label __0 = $f
    .label __1 = $11
    .label __2 = $13
    .label return = $d
    // rand_state << 7
    // [53] (word~) rand::$0 ← (word) rand_state#12 << (byte) 7 -- vwuz1=vwuz2_rol_7 
    lda.z rand_state+1
    lsr
    lda.z rand_state
    ror
    sta.z __0+1
    lda #0
    ror
    sta.z __0
    // rand_state ^= rand_state << 7
    // [54] (word) rand_state#0 ← (word) rand_state#12 ^ (word~) rand::$0 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __0
    sta.z rand_state
    lda.z rand_state+1
    eor.z __0+1
    sta.z rand_state+1
    // rand_state >> 9
    // [55] (word~) rand::$1 ← (word) rand_state#0 >> (byte) 9 -- vwuz1=vwuz2_ror_9 
    lsr
    sta.z __1
    lda #0
    sta.z __1+1
    // rand_state ^= rand_state >> 9
    // [56] (word) rand_state#1 ← (word) rand_state#0 ^ (word~) rand::$1 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __1
    sta.z rand_state
    lda.z rand_state+1
    eor.z __1+1
    sta.z rand_state+1
    // rand_state << 8
    // [57] (word~) rand::$2 ← (word) rand_state#1 << (byte) 8 -- vwuz1=vwuz2_rol_8 
    lda.z rand_state
    sta.z __2+1
    lda #0
    sta.z __2
    // rand_state ^= rand_state << 8
    // [58] (word) rand_state#10 ← (word) rand_state#1 ^ (word~) rand::$2 -- vwuz1=vwuz1_bxor_vwuz2 
    lda.z rand_state
    eor.z __2
    sta.z rand_state
    lda.z rand_state+1
    eor.z __2+1
    sta.z rand_state+1
    // return rand_state;
    // [59] (word) rand::return#0 ← (word) rand_state#10 -- vwuz1=vwuz2 
    lda.z rand_state
    sta.z return
    lda.z rand_state+1
    sta.z return+1
    // rand::@return
    // }
    // [60] return 
    rts
}
  // File Data
.segment Data
  // Colors to fade up/down when visiting a char multiple times
  FADE: .byte 2, $12, $22, $32, $42, $52, $62, $72, $76, $66, $56, $46, $36, $26, $16, 6
  // The number of times each character has been visited
  VISITS: .fill $3e8, 0

