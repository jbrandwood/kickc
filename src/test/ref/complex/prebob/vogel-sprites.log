Fixing pointer array-indexing *((const word*) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((const word*) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((const word*) PLEX_XPOS + (byte) init::i)
Fixing pointer array-indexing *((const word*) PLEX_XPOS + (byte) loop::i)
Warning! Adding boolean cast to non-boolean condition *((byte*) strcpy::src)
Warning! Adding boolean cast to non-boolean condition *((byte*) strlen::str)
Warning! Adding boolean cast to non-boolean condition (byte~) exit::$0
Warning! Adding boolean cast to non-boolean sub-expression (byte~) loop::$18
Identified constant variable (signed byte*) COS
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call plexSetScreen (byte*) plexInit::screen 
Inlined call call plexFreePrepare 
Inlined call call plexFreeAdd (byte) plexShowSprite::ypos 
Inlined call call mulf8s_prepare (signed byte) mulf8s::a 
Inlined call (byte~) loop::$13 ← call plexFreeNextYpos 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) plexInit::plexSetScreen1_@return
Culled Empty Block (label) plexInit::@2
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) plexSort::plexFreePrepare1_@return
Culled Empty Block (label) plexSort::@7
Culled Empty Block (label) @7
Culled Empty Block (label) plexShowSprite::plexFreeAdd1_@return
Culled Empty Block (label) plexShowSprite::@5
Culled Empty Block (label) plexShowSprite::@3
Culled Empty Block (label) @8
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @12
Culled Empty Block (label) mulf_init::@5
Culled Empty Block (label) mulf_init::@6
Culled Empty Block (label) mulf_init::@8
Culled Empty Block (label) mulf_init::@13
Culled Empty Block (label) mulf_init::@14
Culled Empty Block (label) mulf_init::@16
Culled Empty Block (label) @13
Culled Empty Block (label) @14
Culled Empty Block (label) mulf8u_prepared::@1
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) mulf8s_prepared::@5
Culled Empty Block (label) @18
Culled Empty Block (label) mulf8s::mulf8s_prepare1_@return
Culled Empty Block (label) mulf8s::@1
Culled Empty Block (label) @19
Culled Empty Block (label) @20
Culled Empty Block (label) @21
Culled Empty Block (label) @22
Culled Empty Block (label) @23
Culled Empty Block (label) memset::@7
Culled Empty Block (label) memset::@6
Culled Empty Block (label) memset::@8
Culled Empty Block (label) memset::@9
Culled Empty Block (label) memset::@3
Culled Empty Block (label) @24
Culled Empty Block (label) @25
Culled Empty Block (label) @26
Culled Empty Block (label) @27
Culled Empty Block (label) keyboard_matrix_read::@1
Culled Empty Block (label) @28
Culled Empty Block (label) keyboard_key_pressed::@1
Culled Empty Block (label) @29
Culled Empty Block (label) @30
Culled Empty Block (label) @31
Culled Empty Block (label) @32
Culled Empty Block (label) @33
Culled Empty Block (label) @34
Culled Empty Block (label) @35
Culled Empty Block (label) exit::@2
Culled Empty Block (label) exit::@4
Culled Empty Block (label) exit::@3
Culled Empty Block (label) exit::@5
Culled Empty Block (label) exit::@6
Culled Empty Block (label) @36
Culled Empty Block (label) loop::@2
Culled Empty Block (label) loop::@26
Culled Empty Block (label) loop::@3
Culled Empty Block (label) loop::@27
Culled Empty Block (label) loop::@9
Culled Empty Block (label) loop::@11
Culled Empty Block (label) loop::@12
Culled Empty Block (label) loop::@13
Culled Empty Block (label) loop::plexFreeNextYpos1_@1
Culled Empty Block (label) loop::@16
Culled Empty Block (label) loop::@18
Culled Empty Block (label) loop::@19
Culled Empty Block (label) loop::@20
Culled Empty Block (label) loop::@24
Culled Empty Block (label) loop::@22
Culled Empty Block (label) loop::@25
Culled Empty Block (label) loop::@23
Culled Empty Block (label) loop::@28

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@4
@4: scope:[]  from @begin
  (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number) $400+(number) $3f8
  (byte) plex_show_idx#0 ← (byte) 0
  (byte) plex_sprite_idx#0 ← (byte) 0
  (byte) plex_sprite_msb#0 ← (byte) 1
  to:@9

(void()) plexInit((byte*) plexInit::screen)
plexInit: scope:[plexInit]  from init
  (byte*) plexInit::screen#1 ← phi( init/(byte*) plexInit::screen#0 )
  (byte*) plexInit::plexSetScreen1_screen#0 ← (byte*) plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  (byte*) plexInit::plexSetScreen1_screen#1 ← phi( plexInit/(byte*) plexInit::plexSetScreen1_screen#0 )
  (byte*~) plexInit::plexSetScreen1_$0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#1 ← (byte*~) plexInit::plexSetScreen1_$0
  to:plexInit::@3
plexInit::@3: scope:[plexInit]  from plexInit::plexSetScreen1
  (byte*) PLEX_SCREEN_PTR#22 ← phi( plexInit::plexSetScreen1/(byte*) PLEX_SCREEN_PTR#1 )
  (byte) plexInit::i#0 ← (byte) 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@3
  (byte*) PLEX_SCREEN_PTR#15 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 plexInit::@3/(byte*) PLEX_SCREEN_PTR#22 )
  (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::@3/(byte) plexInit::i#0 )
  *((const byte*) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,PLEX_COUNT-1)
  (bool~) plexInit::$1 ← (byte) plexInit::i#1 != rangelast(0,PLEX_COUNT-1)
  if((bool~) plexInit::$1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  (byte*) PLEX_SCREEN_PTR#8 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 )
  (byte*) PLEX_SCREEN_PTR#2 ← (byte*) PLEX_SCREEN_PTR#8
  return 
  to:@return

(void()) plexSort()
plexSort: scope:[plexSort]  from loop::@7
  (byte) plexSort::m#0 ← (byte) 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  (byte) plexSort::m#2 ← phi( plexSort/(byte) plexSort::m#0 plexSort::@2/(byte) plexSort::m#1 )
  (number~) plexSort::$1 ← (byte) plexSort::m#2 + (number) 1
  (byte) plexSort::nxt_idx#0 ← *((const byte*) PLEX_SORTED_IDX + (number~) plexSort::$1)
  (byte) plexSort::nxt_y#0 ← *((const byte*) PLEX_YPOS + (byte) plexSort::nxt_idx#0)
  (bool~) plexSort::$2 ← (byte) plexSort::nxt_y#0 < *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))
  (bool~) plexSort::$3 ← ! (bool~) plexSort::$2
  if((bool~) plexSort::$3) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  (byte) plexSort::m#3 ← phi( plexSort::@1/(byte) plexSort::m#2 plexSort::@4/(byte) plexSort::m#5 )
  (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,PLEX_COUNT-2)
  (bool~) plexSort::$8 ← (byte) plexSort::m#1 != rangelast(0,PLEX_COUNT-2)
  if((bool~) plexSort::$8) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  (byte) plexSort::nxt_idx#3 ← phi( plexSort::@1/(byte) plexSort::nxt_idx#0 )
  (byte) plexSort::nxt_y#2 ← phi( plexSort::@1/(byte) plexSort::nxt_y#0 )
  (byte) plexSort::m#4 ← phi( plexSort::@1/(byte) plexSort::m#2 )
  (byte) plexSort::s#0 ← (byte) plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  (byte) plexSort::m#6 ← phi( plexSort::@3/(byte) plexSort::m#6 plexSort::@5/(byte) plexSort::m#4 )
  (byte) plexSort::nxt_idx#2 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 plexSort::@5/(byte) plexSort::nxt_idx#3 )
  (byte) plexSort::nxt_y#1 ← phi( plexSort::@3/(byte) plexSort::nxt_y#1 plexSort::@5/(byte) plexSort::nxt_y#2 )
  (byte) plexSort::s#3 ← phi( plexSort::@3/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#0 )
  (number~) plexSort::$4 ← (byte) plexSort::s#3 + (number) 1
  *((const byte*) PLEX_SORTED_IDX + (number~) plexSort::$4) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3)
  (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  (bool~) plexSort::$5 ← (byte) plexSort::s#1 != (number) $ff
  (bool~) plexSort::$6 ← (byte) plexSort::nxt_y#1 < *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))
  (bool~) plexSort::$7 ← (bool~) plexSort::$5 && (bool~) plexSort::$6
  if((bool~) plexSort::$7) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  (byte) plexSort::m#5 ← phi( plexSort::@3/(byte) plexSort::m#6 )
  (byte) plexSort::nxt_idx#1 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 )
  (byte) plexSort::s#4 ← phi( plexSort::@3/(byte) plexSort::s#1 )
  (byte) plexSort::s#2 ← ++ (byte) plexSort::s#4
  *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  (byte) plex_show_idx#1 ← (number) 0
  (byte) plex_sprite_idx#1 ← (number) 0
  (byte) plex_sprite_msb#1 ← (number) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  (byte) plex_sprite_msb#40 ← phi( plexSort::@6/(byte) plex_sprite_msb#1 )
  (byte) plex_sprite_idx#41 ← phi( plexSort::@6/(byte) plex_sprite_idx#1 )
  (byte) plex_show_idx#41 ← phi( plexSort::@6/(byte) plex_show_idx#1 )
  (byte) plexSort::plexFreePrepare1_s#0 ← (byte) 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#32 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_msb#40 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#34 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_idx#41 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#34 )
  (byte) plex_show_idx#34 ← phi( plexSort::plexFreePrepare1/(byte) plex_show_idx#41 plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#34 )
  (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) plexSort::plexFreePrepare1_s#0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
  (byte) plexSort::plexFreePrepare1_s#1 ← (byte) plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  (bool~) plexSort::plexFreePrepare1_$0 ← (byte) plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if((bool~) plexSort::plexFreePrepare1_$0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#23 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#22 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#34 )
  (byte) plex_show_idx#22 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#34 )
  (byte) plex_free_next#0 ← (number) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  (byte) plex_free_next#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_free_next#0 )
  (byte) plex_sprite_msb#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_msb#23 )
  (byte) plex_sprite_idx#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_idx#22 )
  (byte) plex_show_idx#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_show_idx#22 )
  (byte) plex_show_idx#2 ← (byte) plex_show_idx#11
  (byte) plex_sprite_idx#2 ← (byte) plex_sprite_idx#11
  (byte) plex_sprite_msb#2 ← (byte) plex_sprite_msb#12
  (byte) plex_free_next#1 ← (byte) plex_free_next#11
  return 
  to:@return

(void()) plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from loop::@17
  (byte) plex_sprite_msb#41 ← phi( loop::@17/(byte) plex_sprite_msb#28 )
  (byte*) PLEX_SCREEN_PTR#23 ← phi( loop::@17/(byte*) PLEX_SCREEN_PTR#27 )
  (byte) plex_free_next#21 ← phi( loop::@17/(byte) plex_free_next#28 )
  (byte) plex_show_idx#12 ← phi( loop::@17/(byte) plex_show_idx#23 )
  (byte) plex_sprite_idx#12 ← phi( loop::@17/(byte) plex_sprite_idx#23 )
  (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (number) 2
  (byte) plexShowSprite::plex_sprite_idx2#0 ← (number~) plexShowSprite::$0
  (byte) plexShowSprite::ypos#0 ← *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#12))
  *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::ypos#0
  (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← (byte) plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  (byte) plex_sprite_msb#33 ← phi( plexShowSprite/(byte) plex_sprite_msb#41 )
  (byte) plexShowSprite::plex_sprite_idx2#2 ← phi( plexShowSprite/(byte) plexShowSprite::plex_sprite_idx2#0 )
  (byte) plex_sprite_idx#24 ← phi( plexShowSprite/(byte) plex_sprite_idx#12 )
  (byte*) PLEX_SCREEN_PTR#16 ← phi( plexShowSprite/(byte*) PLEX_SCREEN_PTR#23 )
  (byte) plex_show_idx#24 ← phi( plexShowSprite/(byte) plex_show_idx#12 )
  (byte) plex_free_next#12 ← phi( plexShowSprite/(byte) plex_free_next#21 )
  (byte) plexShowSprite::plexFreeAdd1_ypos#1 ← phi( plexShowSprite/(byte) plexShowSprite::plexFreeAdd1_ypos#0 )
  (number~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
  *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#12) ← (number~) plexShowSprite::plexFreeAdd1_$0
  (number~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#12 + (number) 1
  (number~) plexShowSprite::plexFreeAdd1_$2 ← (number~) plexShowSprite::plexFreeAdd1_$1 & (number) 7
  (byte) plex_free_next#2 ← (number~) plexShowSprite::plexFreeAdd1_$2
  to:plexShowSprite::@7
plexShowSprite::@7: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  (byte) plex_free_next#40 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_free_next#2 )
  (byte) plex_sprite_msb#24 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_msb#33 )
  (byte) plexShowSprite::plex_sprite_idx2#1 ← phi( plexShowSprite::plexFreeAdd1/(byte) plexShowSprite::plex_sprite_idx2#2 )
  (byte) plex_sprite_idx#13 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_idx#24 )
  (byte*) PLEX_SCREEN_PTR#9 ← phi( plexShowSprite::plexFreeAdd1/(byte*) PLEX_SCREEN_PTR#16 )
  (byte) plex_show_idx#13 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_show_idx#24 )
  *((byte*) PLEX_SCREEN_PTR#9 + (byte) plex_sprite_idx#13) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#13))
  (byte) plexShowSprite::xpos_idx#0 ← *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#13)
  (byte~) plexShowSprite::$10 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$10)
  *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#1) ← (byte~) plexShowSprite::$2
  (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11)
  (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
  if((bool~) plexShowSprite::$4) goto plexShowSprite::@1
  to:plexShowSprite::@4
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#32 ← phi( plexShowSprite::@7/(byte) plex_free_next#40 )
  (byte) plex_show_idx#25 ← phi( plexShowSprite::@7/(byte) plex_show_idx#13 )
  (byte) plex_sprite_idx#25 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#13 )
  (byte) plex_sprite_msb#13 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#24 )
  *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#13
  to:plexShowSprite::@2
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#33 ← phi( plexShowSprite::@7/(byte) plex_free_next#40 )
  (byte) plex_show_idx#26 ← phi( plexShowSprite::@7/(byte) plex_show_idx#13 )
  (byte) plex_sprite_idx#26 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#13 )
  (byte) plex_sprite_msb#14 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#24 )
  (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#14
  *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (number~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@4
  (byte) plex_free_next#22 ← phi( plexShowSprite::@1/(byte) plex_free_next#32 plexShowSprite::@4/(byte) plex_free_next#33 )
  (byte) plex_sprite_msb#15 ← phi( plexShowSprite::@1/(byte) plex_sprite_msb#13 plexShowSprite::@4/(byte) plex_sprite_msb#14 )
  (byte) plex_show_idx#14 ← phi( plexShowSprite::@1/(byte) plex_show_idx#25 plexShowSprite::@4/(byte) plex_show_idx#26 )
  (byte) plex_sprite_idx#14 ← phi( plexShowSprite::@1/(byte) plex_sprite_idx#25 plexShowSprite::@4/(byte) plex_sprite_idx#26 )
  (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (number) 1
  (number~) plexShowSprite::$6 ← (number~) plexShowSprite::$5 & (number) 7
  (byte) plex_sprite_idx#3 ← (number~) plexShowSprite::$6
  (byte) plex_show_idx#3 ← ++ (byte) plex_show_idx#14
  (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#15 * (number) 2
  (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
  (bool~) plexShowSprite::$8 ← ! (bool~) plexShowSprite::$7
  if((bool~) plexShowSprite::$8) goto plexShowSprite::@return
  to:plexShowSprite::@6
plexShowSprite::@6: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_show_idx#27 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#27 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#23 ← phi( plexShowSprite::@2/(byte) plex_free_next#22 )
  (byte) plex_sprite_msb#4 ← (number) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@6
  (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@6/(byte) plex_sprite_msb#4 )
  (byte) plex_show_idx#15 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 plexShowSprite::@6/(byte) plex_show_idx#27 )
  (byte) plex_sprite_idx#15 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 plexShowSprite::@6/(byte) plex_sprite_idx#27 )
  (byte) plex_free_next#13 ← phi( plexShowSprite::@2/(byte) plex_free_next#22 plexShowSprite::@6/(byte) plex_free_next#23 )
  (byte) plex_free_next#3 ← (byte) plex_free_next#13
  (byte) plex_sprite_idx#4 ← (byte) plex_sprite_idx#15
  (byte) plex_show_idx#4 ← (byte) plex_show_idx#15
  (byte) plex_sprite_msb#5 ← (byte) plex_sprite_msb#16
  return 
  to:@return
@9: scope:[]  from @4
  (byte) plex_sprite_msb#39 ← phi( @4/(byte) plex_sprite_msb#0 )
  (byte) plex_sprite_idx#40 ← phi( @4/(byte) plex_sprite_idx#0 )
  (byte) plex_show_idx#40 ← phi( @4/(byte) plex_show_idx#0 )
  (byte*) PLEX_SCREEN_PTR#26 ← phi( @4/(byte*) PLEX_SCREEN_PTR#0 )
  (byte) plex_free_next#4 ← (byte) 0
  to:@37

(void()) mulf_init()
mulf_init: scope:[mulf_init]  from init::@4
  (word) mulf_init::sqr#0 ← (word) 0
  (byte) mulf_init::x_2#0 ← (byte) 0
  (byte) mulf_init::c#0 ← (byte) 0
  (byte*) mulf_init::sqr1_hi#0 ← (const byte*) mulf_sqr1_hi+(number) 1
  (byte*) mulf_init::sqr1_lo#0 ← (const byte*) mulf_sqr1_lo+(number) 1
  to:mulf_init::@1
mulf_init::@1: scope:[mulf_init]  from mulf_init mulf_init::@4
  (byte) mulf_init::x_2#5 ← phi( mulf_init/(byte) mulf_init::x_2#0 mulf_init::@4/(byte) mulf_init::x_2#2 )
  (byte*) mulf_init::sqr1_hi#5 ← phi( mulf_init/(byte*) mulf_init::sqr1_hi#0 mulf_init::@4/(byte*) mulf_init::sqr1_hi#1 )
  (word) mulf_init::sqr#6 ← phi( mulf_init/(word) mulf_init::sqr#0 mulf_init::@4/(word) mulf_init::sqr#1 )
  (byte) mulf_init::c#3 ← phi( mulf_init/(byte) mulf_init::c#0 mulf_init::@4/(byte) mulf_init::c#4 )
  (byte*) mulf_init::sqr1_lo#2 ← phi( mulf_init/(byte*) mulf_init::sqr1_lo#0 mulf_init::@4/(byte*) mulf_init::sqr1_lo#1 )
  (bool~) mulf_init::$0 ← (byte*) mulf_init::sqr1_lo#2 != (const byte*) mulf_sqr1_lo+(number) $200
  if((bool~) mulf_init::$0) goto mulf_init::@2
  to:mulf_init::@3
mulf_init::@2: scope:[mulf_init]  from mulf_init::@1
  (byte) mulf_init::x_2#4 ← phi( mulf_init::@1/(byte) mulf_init::x_2#5 )
  (byte*) mulf_init::sqr1_hi#3 ← phi( mulf_init::@1/(byte*) mulf_init::sqr1_hi#5 )
  (byte*) mulf_init::sqr1_lo#4 ← phi( mulf_init::@1/(byte*) mulf_init::sqr1_lo#2 )
  (word) mulf_init::sqr#5 ← phi( mulf_init::@1/(word) mulf_init::sqr#6 )
  (byte) mulf_init::c#2 ← phi( mulf_init::@1/(byte) mulf_init::c#3 )
  (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2
  (number~) mulf_init::$1 ← (byte) mulf_init::c#1 & (number) 1
  (bool~) mulf_init::$2 ← (number~) mulf_init::$1 == (number) 0
  (bool~) mulf_init::$3 ← ! (bool~) mulf_init::$2
  if((bool~) mulf_init::$3) goto mulf_init::@4
  to:mulf_init::@7
mulf_init::@3: scope:[mulf_init]  from mulf_init::@1
  (byte) mulf_init::x_255#0 ← (byte)(number) -1
  (byte) mulf_init::dir#0 ← (byte) $ff
  (byte*) mulf_init::sqr2_hi#0 ← (const byte*) mulf_sqr2_hi
  (byte*) mulf_init::sqr2_lo#0 ← (const byte*) mulf_sqr2_lo
  to:mulf_init::@9
mulf_init::@4: scope:[mulf_init]  from mulf_init::@2 mulf_init::@7
  (byte) mulf_init::c#4 ← phi( mulf_init::@2/(byte) mulf_init::c#1 mulf_init::@7/(byte) mulf_init::c#5 )
  (byte) mulf_init::x_2#2 ← phi( mulf_init::@2/(byte) mulf_init::x_2#4 mulf_init::@7/(byte) mulf_init::x_2#1 )
  (byte*) mulf_init::sqr1_hi#2 ← phi( mulf_init::@2/(byte*) mulf_init::sqr1_hi#3 mulf_init::@7/(byte*) mulf_init::sqr1_hi#4 )
  (byte*) mulf_init::sqr1_lo#3 ← phi( mulf_init::@2/(byte*) mulf_init::sqr1_lo#4 mulf_init::@7/(byte*) mulf_init::sqr1_lo#5 )
  (word) mulf_init::sqr#3 ← phi( mulf_init::@2/(word) mulf_init::sqr#5 mulf_init::@7/(word) mulf_init::sqr#2 )
  (byte~) mulf_init::$4 ← < (word) mulf_init::sqr#3
  *((byte*) mulf_init::sqr1_lo#3) ← (byte~) mulf_init::$4
  (byte~) mulf_init::$5 ← > (word) mulf_init::sqr#3
  *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5
  (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2
  (word~) mulf_init::$6 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2
  (word) mulf_init::sqr#1 ← (word~) mulf_init::$6
  (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#3
  to:mulf_init::@1
mulf_init::@7: scope:[mulf_init]  from mulf_init::@2
  (byte) mulf_init::c#5 ← phi( mulf_init::@2/(byte) mulf_init::c#1 )
  (byte*) mulf_init::sqr1_hi#4 ← phi( mulf_init::@2/(byte*) mulf_init::sqr1_hi#3 )
  (byte*) mulf_init::sqr1_lo#5 ← phi( mulf_init::@2/(byte*) mulf_init::sqr1_lo#4 )
  (word) mulf_init::sqr#4 ← phi( mulf_init::@2/(word) mulf_init::sqr#5 )
  (byte) mulf_init::x_2#3 ← phi( mulf_init::@2/(byte) mulf_init::x_2#4 )
  (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3
  (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4
  to:mulf_init::@4
mulf_init::@9: scope:[mulf_init]  from mulf_init::@12 mulf_init::@3
  (byte) mulf_init::dir#3 ← phi( mulf_init::@12/(byte) mulf_init::dir#4 mulf_init::@3/(byte) mulf_init::dir#0 )
  (byte*) mulf_init::sqr2_hi#3 ← phi( mulf_init::@12/(byte*) mulf_init::sqr2_hi#4 mulf_init::@3/(byte*) mulf_init::sqr2_hi#0 )
  (byte) mulf_init::x_255#3 ← phi( mulf_init::@12/(byte) mulf_init::x_255#4 mulf_init::@3/(byte) mulf_init::x_255#0 )
  (byte*) mulf_init::sqr2_lo#2 ← phi( mulf_init::@12/(byte*) mulf_init::sqr2_lo#1 mulf_init::@3/(byte*) mulf_init::sqr2_lo#0 )
  (bool~) mulf_init::$7 ← (byte*) mulf_init::sqr2_lo#2 != (const byte*) mulf_sqr2_lo+(number) $1ff
  if((bool~) mulf_init::$7) goto mulf_init::@10
  to:mulf_init::@11
mulf_init::@10: scope:[mulf_init]  from mulf_init::@9
  (byte) mulf_init::dir#2 ← phi( mulf_init::@9/(byte) mulf_init::dir#3 )
  (byte*) mulf_init::sqr2_hi#2 ← phi( mulf_init::@9/(byte*) mulf_init::sqr2_hi#3 )
  (byte*) mulf_init::sqr2_lo#3 ← phi( mulf_init::@9/(byte*) mulf_init::sqr2_lo#2 )
  (byte) mulf_init::x_255#2 ← phi( mulf_init::@9/(byte) mulf_init::x_255#3 )
  *((byte*) mulf_init::sqr2_lo#3) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2)
  *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2)
  (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2
  (byte~) mulf_init::$8 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2
  (byte) mulf_init::x_255#1 ← (byte~) mulf_init::$8
  (bool~) mulf_init::$9 ← (byte) mulf_init::x_255#1 == (number) 0
  (bool~) mulf_init::$10 ← ! (bool~) mulf_init::$9
  if((bool~) mulf_init::$10) goto mulf_init::@12
  to:mulf_init::@15
mulf_init::@11: scope:[mulf_init]  from mulf_init::@9
  *((const byte*) mulf_sqr2_lo+(number) $1ff) ← *((const byte*) mulf_sqr1_lo+(number) $100)
  *((const byte*) mulf_sqr2_hi+(number) $1ff) ← *((const byte*) mulf_sqr1_hi+(number) $100)
  to:mulf_init::@return
mulf_init::@12: scope:[mulf_init]  from mulf_init::@10 mulf_init::@15
  (byte) mulf_init::dir#4 ← phi( mulf_init::@10/(byte) mulf_init::dir#2 mulf_init::@15/(byte) mulf_init::dir#1 )
  (byte*) mulf_init::sqr2_hi#4 ← phi( mulf_init::@10/(byte*) mulf_init::sqr2_hi#1 mulf_init::@15/(byte*) mulf_init::sqr2_hi#5 )
  (byte) mulf_init::x_255#4 ← phi( mulf_init::@10/(byte) mulf_init::x_255#1 mulf_init::@15/(byte) mulf_init::x_255#5 )
  (byte*) mulf_init::sqr2_lo#4 ← phi( mulf_init::@10/(byte*) mulf_init::sqr2_lo#3 mulf_init::@15/(byte*) mulf_init::sqr2_lo#5 )
  (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#4
  to:mulf_init::@9
mulf_init::@15: scope:[mulf_init]  from mulf_init::@10
  (byte*) mulf_init::sqr2_hi#5 ← phi( mulf_init::@10/(byte*) mulf_init::sqr2_hi#1 )
  (byte) mulf_init::x_255#5 ← phi( mulf_init::@10/(byte) mulf_init::x_255#1 )
  (byte*) mulf_init::sqr2_lo#5 ← phi( mulf_init::@10/(byte*) mulf_init::sqr2_lo#3 )
  (byte) mulf_init::dir#1 ← (number) 1
  to:mulf_init::@12
mulf_init::@return: scope:[mulf_init]  from mulf_init::@11
  return 
  to:@return

(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
mulf8u_prepare: scope:[mulf8u_prepare]  from mulf8s::mulf8s_prepare1
  (byte) mulf8u_prepare::a#1 ← phi( mulf8s::mulf8s_prepare1/(byte) mulf8u_prepare::a#0 )
  *((const byte*) mulf8u_prepare::memA) ← (byte) mulf8u_prepare::a#1
  asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
  to:mulf8u_prepare::@return
mulf8u_prepare::@return: scope:[mulf8u_prepare]  from mulf8u_prepare
  return 
  to:@return

(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
mulf8u_prepared: scope:[mulf8u_prepared]  from mulf8s_prepared
  (byte) mulf8u_prepared::b#1 ← phi( mulf8s_prepared/(byte) mulf8u_prepared::b#0 )
  *((const byte*) mulf8u_prepared::memB) ← (byte) mulf8u_prepared::b#1
  asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
  (word) mulf8u_prepared::return#0 ← ((word)) { *((const byte*) mulf8u_prepared::memB), *((const byte*) mulf8u_prepared::resL) }
  to:mulf8u_prepared::@return
mulf8u_prepared::@return: scope:[mulf8u_prepared]  from mulf8u_prepared
  (word) mulf8u_prepared::return#3 ← phi( mulf8u_prepared/(word) mulf8u_prepared::return#0 )
  (word) mulf8u_prepared::return#1 ← (word) mulf8u_prepared::return#3
  return 
  to:@return

(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
mulf8s_prepared: scope:[mulf8s_prepared]  from mulf8s::@2
  (signed byte) mulf8s_prepared::b#1 ← phi( mulf8s::@2/(signed byte) mulf8s_prepared::b#0 )
  (byte~) mulf8s_prepared::$0 ← ((byte)) (signed byte) mulf8s_prepared::b#1
  (byte) mulf8u_prepared::b#0 ← (byte~) mulf8s_prepared::$0
  call mulf8u_prepared 
  (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#1
  to:mulf8s_prepared::@6
mulf8s_prepared::@6: scope:[mulf8s_prepared]  from mulf8s_prepared
  (signed byte) mulf8s_prepared::b#4 ← phi( mulf8s_prepared/(signed byte) mulf8s_prepared::b#1 )
  (word) mulf8u_prepared::return#4 ← phi( mulf8s_prepared/(word) mulf8u_prepared::return#2 )
  (word~) mulf8s_prepared::$1 ← (word) mulf8u_prepared::return#4
  (word) mulf8s_prepared::m#0 ← (word~) mulf8s_prepared::$1
  (bool~) mulf8s_prepared::$2 ← *((const signed byte*) mulf8s_prepared::memA) < (number) 0
  (bool~) mulf8s_prepared::$3 ← ! (bool~) mulf8s_prepared::$2
  if((bool~) mulf8s_prepared::$3) goto mulf8s_prepared::@1
  to:mulf8s_prepared::@3
mulf8s_prepared::@1: scope:[mulf8s_prepared]  from mulf8s_prepared::@3 mulf8s_prepared::@6
  (word) mulf8s_prepared::m#6 ← phi( mulf8s_prepared::@3/(word) mulf8s_prepared::m#1 mulf8s_prepared::@6/(word) mulf8s_prepared::m#0 )
  (signed byte) mulf8s_prepared::b#2 ← phi( mulf8s_prepared::@3/(signed byte) mulf8s_prepared::b#3 mulf8s_prepared::@6/(signed byte) mulf8s_prepared::b#4 )
  (bool~) mulf8s_prepared::$4 ← (signed byte) mulf8s_prepared::b#2 < (number) 0
  (bool~) mulf8s_prepared::$5 ← ! (bool~) mulf8s_prepared::$4
  if((bool~) mulf8s_prepared::$5) goto mulf8s_prepared::@2
  to:mulf8s_prepared::@4
mulf8s_prepared::@3: scope:[mulf8s_prepared]  from mulf8s_prepared::@6
  (signed byte) mulf8s_prepared::b#3 ← phi( mulf8s_prepared::@6/(signed byte) mulf8s_prepared::b#4 )
  (word) mulf8s_prepared::m#3 ← phi( mulf8s_prepared::@6/(word) mulf8s_prepared::m#0 )
  (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#3
  (byte~) mulf8s_prepared::$9 ← ((byte)) (signed byte) mulf8s_prepared::b#3
  (byte~) mulf8s_prepared::$10 ← (byte~) mulf8s_prepared::$8 - (byte~) mulf8s_prepared::$9
  (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$10
  (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#3 hi= (byte~) mulf8s_prepared::$15
  to:mulf8s_prepared::@1
mulf8s_prepared::@2: scope:[mulf8s_prepared]  from mulf8s_prepared::@1 mulf8s_prepared::@4
  (word) mulf8s_prepared::m#4 ← phi( mulf8s_prepared::@1/(word) mulf8s_prepared::m#6 mulf8s_prepared::@4/(word) mulf8s_prepared::m#2 )
  (signed word~) mulf8s_prepared::$6 ← ((signed word)) (word) mulf8s_prepared::m#4
  (signed word) mulf8s_prepared::return#0 ← (signed word~) mulf8s_prepared::$6
  to:mulf8s_prepared::@return
mulf8s_prepared::@4: scope:[mulf8s_prepared]  from mulf8s_prepared::@1
  (word) mulf8s_prepared::m#5 ← phi( mulf8s_prepared::@1/(word) mulf8s_prepared::m#6 )
  (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5
  (byte~) mulf8s_prepared::$13 ← ((byte)) *((const signed byte*) mulf8s_prepared::memA)
  (byte~) mulf8s_prepared::$14 ← (byte~) mulf8s_prepared::$12 - (byte~) mulf8s_prepared::$13
  (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$14
  (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16
  to:mulf8s_prepared::@2
mulf8s_prepared::@return: scope:[mulf8s_prepared]  from mulf8s_prepared::@2
  (signed word) mulf8s_prepared::return#3 ← phi( mulf8s_prepared::@2/(signed word) mulf8s_prepared::return#0 )
  (signed word) mulf8s_prepared::return#1 ← (signed word) mulf8s_prepared::return#3
  return 
  to:@return

(signed word()) mulf8s((signed byte) mulf8s::a , (signed byte) mulf8s::b)
mulf8s: scope:[mulf8s]  from loop::@30 loop::@6
  (signed byte) mulf8s::b#5 ← phi( loop::@30/(signed byte) mulf8s::b#1 loop::@6/(signed byte) mulf8s::b#0 )
  (signed byte) mulf8s::a#2 ← phi( loop::@30/(signed byte) mulf8s::a#1 loop::@6/(signed byte) mulf8s::a#0 )
  (signed byte) mulf8s::mulf8s_prepare1_a#0 ← (signed byte) mulf8s::a#2
  to:mulf8s::mulf8s_prepare1
mulf8s::mulf8s_prepare1: scope:[mulf8s]  from mulf8s
  (signed byte) mulf8s::b#4 ← phi( mulf8s/(signed byte) mulf8s::b#5 )
  (signed byte) mulf8s::mulf8s_prepare1_a#1 ← phi( mulf8s/(signed byte) mulf8s::mulf8s_prepare1_a#0 )
  (byte~) mulf8s::mulf8s_prepare1_$0 ← ((byte)) (signed byte) mulf8s::mulf8s_prepare1_a#1
  (byte) mulf8u_prepare::a#0 ← (byte~) mulf8s::mulf8s_prepare1_$0
  call mulf8u_prepare 
  to:mulf8s::@3
mulf8s::@3: scope:[mulf8s]  from mulf8s::mulf8s_prepare1
  (signed byte) mulf8s::b#3 ← phi( mulf8s::mulf8s_prepare1/(signed byte) mulf8s::b#4 )
  to:mulf8s::@2
mulf8s::@2: scope:[mulf8s]  from mulf8s::@3
  (signed byte) mulf8s::b#2 ← phi( mulf8s::@3/(signed byte) mulf8s::b#3 )
  (signed byte) mulf8s_prepared::b#0 ← (signed byte) mulf8s::b#2
  call mulf8s_prepared 
  (signed word) mulf8s_prepared::return#2 ← (signed word) mulf8s_prepared::return#1
  to:mulf8s::@4
mulf8s::@4: scope:[mulf8s]  from mulf8s::@2
  (signed word) mulf8s_prepared::return#4 ← phi( mulf8s::@2/(signed word) mulf8s_prepared::return#2 )
  (signed word~) mulf8s::$1 ← (signed word) mulf8s_prepared::return#4
  (signed word) mulf8s::return#0 ← (signed word~) mulf8s::$1
  to:mulf8s::@return
mulf8s::@return: scope:[mulf8s]  from mulf8s::@4
  (signed word) mulf8s::return#4 ← phi( mulf8s::@4/(signed word) mulf8s::return#0 )
  (signed word) mulf8s::return#1 ← (signed word) mulf8s::return#4
  return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from init::@6
  (byte) memset::c#4 ← phi( init::@6/(byte) memset::c#0 )
  (void*) memset::str#3 ← phi( init::@6/(void*) memset::str#0 )
  (word) memset::num#1 ← phi( init::@6/(word) memset::num#0 )
  (bool~) memset::$0 ← (word) memset::num#1 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@4
  (void*) memset::str#1 ← phi( memset/(void*) memset::str#3 memset::@4/(void*) memset::str#4 )
  (void*) memset::return#0 ← (void*) memset::str#1
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#3 ← phi( memset/(byte) memset::c#4 )
  (word) memset::num#2 ← phi( memset/(word) memset::num#1 )
  (void*) memset::str#2 ← phi( memset/(void*) memset::str#3 )
  (byte*~) memset::$2 ← ((byte*)) (void*) memset::str#2
  (byte*~) memset::$3 ← (byte*~) memset::$2 + (word) memset::num#2
  (byte*) memset::end#0 ← (byte*~) memset::$3
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#2
  to:memset::@4
memset::@4: scope:[memset]  from memset::@2 memset::@5
  (byte) memset::c#2 ← phi( memset::@2/(byte) memset::c#3 memset::@5/(byte) memset::c#1 )
  (void*) memset::str#4 ← phi( memset::@2/(void*) memset::str#2 memset::@5/(void*) memset::str#5 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@5/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@5/(byte*) memset::dst#1 )
  (bool~) memset::$4 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$4) goto memset::@5
  to:memset::@1
memset::@5: scope:[memset]  from memset::@4
  (void*) memset::str#5 ← phi( memset::@4/(void*) memset::str#4 )
  (byte*) memset::end#2 ← phi( memset::@4/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@4/(byte*) memset::dst#2 )
  (byte) memset::c#1 ← phi( memset::@4/(byte) memset::c#2 )
  *((byte*) memset::dst#3) ← (byte) memset::c#1
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@4
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#3 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#3
  return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  (byte) keyboard_matrix_read::rowid#1 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::rowid#0 )
  *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask + (byte) keyboard_matrix_read::rowid#1)
  (byte~) keyboard_matrix_read::$0 ← ~ *((const byte*) CIA1_PORT_B)
  (byte) keyboard_matrix_read::row_pressed_bits#0 ← (byte~) keyboard_matrix_read::$0
  (byte) keyboard_matrix_read::return#0 ← (byte) keyboard_matrix_read::row_pressed_bits#0
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  (byte) keyboard_matrix_read::return#3 ← phi( keyboard_matrix_read/(byte) keyboard_matrix_read::return#0 )
  (byte) keyboard_matrix_read::return#1 ← (byte) keyboard_matrix_read::return#3
  return 
  to:@return

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from exit::@1 loop::@21
  (byte) keyboard_key_pressed::key#2 ← phi( exit::@1/(byte) keyboard_key_pressed::key#0 loop::@21/(byte) keyboard_key_pressed::key#1 )
  (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#2 & (number) 7
  (byte) keyboard_key_pressed::colidx#0 ← (number~) keyboard_key_pressed::$0
  (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#2 >> (number) 3
  (byte) keyboard_key_pressed::rowidx#0 ← (byte~) keyboard_key_pressed::$1
  (byte) keyboard_matrix_read::rowid#0 ← (byte) keyboard_key_pressed::rowidx#0
  call keyboard_matrix_read 
  (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#1
  to:keyboard_key_pressed::@2
keyboard_key_pressed::@2: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  (byte) keyboard_key_pressed::colidx#1 ← phi( keyboard_key_pressed/(byte) keyboard_key_pressed::colidx#0 )
  (byte) keyboard_matrix_read::return#4 ← phi( keyboard_key_pressed/(byte) keyboard_matrix_read::return#2 )
  (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#4
  (byte~) keyboard_key_pressed::$3 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask + (byte) keyboard_key_pressed::colidx#1)
  (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$3
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@2
  (byte) keyboard_key_pressed::return#4 ← phi( keyboard_key_pressed::@2/(byte) keyboard_key_pressed::return#0 )
  (byte) keyboard_key_pressed::return#1 ← (byte) keyboard_key_pressed::return#4
  return 
  to:@return

(void()) main()
main: scope:[main]  from @37
  (byte) plex_free_next#34 ← phi( @37/(byte) plex_free_next#31 )
  (byte) plex_sprite_msb#34 ← phi( @37/(byte) plex_sprite_msb#31 )
  (byte) plex_sprite_idx#35 ← phi( @37/(byte) plex_sprite_idx#33 )
  (byte) plex_show_idx#35 ← phi( @37/(byte) plex_show_idx#33 )
  (byte*) PLEX_SCREEN_PTR#17 ← phi( @37/(byte*) PLEX_SCREEN_PTR#21 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (byte) plex_free_next#24 ← phi( main/(byte) plex_free_next#34 )
  (byte) plex_sprite_msb#25 ← phi( main/(byte) plex_sprite_msb#34 )
  (byte) plex_sprite_idx#28 ← phi( main/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#28 ← phi( main/(byte) plex_show_idx#35 )
  (byte*) PLEX_SCREEN_PTR#10 ← phi( main/(byte*) PLEX_SCREEN_PTR#6 )
  (byte*) PLEX_SCREEN_PTR#3 ← (byte*) PLEX_SCREEN_PTR#10
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) PLEX_SCREEN_PTR#24 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (byte) plex_free_next#14 ← phi( main::@1/(byte) plex_free_next#9 )
  (byte) plex_sprite_msb#17 ← phi( main::@1/(byte) plex_sprite_msb#10 )
  (byte) plex_sprite_idx#16 ← phi( main::@1/(byte) plex_sprite_idx#9 )
  (byte) plex_show_idx#16 ← phi( main::@1/(byte) plex_show_idx#9 )
  (byte) plex_show_idx#5 ← (byte) plex_show_idx#16
  (byte) plex_sprite_idx#5 ← (byte) plex_sprite_idx#16
  (byte) plex_sprite_msb#6 ← (byte) plex_sprite_msb#17
  (byte) plex_free_next#5 ← (byte) plex_free_next#14
  call exit 
  to:main::@3
main::@3: scope:[main]  from main::@2
  (byte) plex_free_next#25 ← phi( main::@2/(byte) plex_free_next#5 )
  (byte) plex_sprite_msb#26 ← phi( main::@2/(byte) plex_sprite_msb#6 )
  (byte) plex_sprite_idx#29 ← phi( main::@2/(byte) plex_sprite_idx#5 )
  (byte) plex_show_idx#29 ← phi( main::@2/(byte) plex_show_idx#5 )
  (byte*) PLEX_SCREEN_PTR#18 ← phi( main::@2/(byte*) PLEX_SCREEN_PTR#24 )
  asm { cli  }
  to:main::@return
main::@return: scope:[main]  from main::@3
  (byte) plex_free_next#15 ← phi( main::@3/(byte) plex_free_next#25 )
  (byte) plex_sprite_msb#18 ← phi( main::@3/(byte) plex_sprite_msb#26 )
  (byte) plex_sprite_idx#17 ← phi( main::@3/(byte) plex_sprite_idx#29 )
  (byte) plex_show_idx#17 ← phi( main::@3/(byte) plex_show_idx#29 )
  (byte*) PLEX_SCREEN_PTR#11 ← phi( main::@3/(byte*) PLEX_SCREEN_PTR#18 )
  (byte*) PLEX_SCREEN_PTR#4 ← (byte*) PLEX_SCREEN_PTR#11
  (byte) plex_show_idx#6 ← (byte) plex_show_idx#17
  (byte) plex_sprite_idx#6 ← (byte) plex_sprite_idx#17
  (byte) plex_sprite_msb#7 ← (byte) plex_sprite_msb#18
  (byte) plex_free_next#6 ← (byte) plex_free_next#15
  return 
  to:@return

(void()) init()
init: scope:[init]  from main
  (byte*) PLEX_SCREEN_PTR#19 ← phi( main/(byte*) PLEX_SCREEN_PTR#17 )
  *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(number) 3
  (byte*) plexInit::screen#0 ← (const byte*) SCREEN
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  (byte*) PLEX_SCREEN_PTR#12 ← phi( init/(byte*) PLEX_SCREEN_PTR#2 )
  (byte*) PLEX_SCREEN_PTR#5 ← (byte*) PLEX_SCREEN_PTR#12
  (byte) init::i#0 ← (byte) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  (byte*) PLEX_SCREEN_PTR#33 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#33 init::@5/(byte*) PLEX_SCREEN_PTR#5 )
  (byte) init::i#2 ← phi( init::@1/(byte) init::i#1 init::@5/(byte) init::i#0 )
  *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(number) $40
  (number~) init::$3 ← (byte) init::i#2 * (number) 5
  (number~) init::$4 ← (number) $18 + (number~) init::$3
  (byte~) init::$9 ← (byte) init::i#2 * (const byte) SIZEOF_WORD
  *((const word*) PLEX_XPOS + (byte~) init::$9) ← (number~) init::$4
  (number~) init::$5 ← (byte) init::i#2 * (number) 8
  (number~) init::$6 ← (number) $32 + (number~) init::$5
  *((const byte*) PLEX_YPOS + (byte) init::i#2) ← (number~) init::$6
  (byte) init::i#1 ← (byte) init::i#2 + rangenext(0,PLEX_COUNT-1)
  (bool~) init::$7 ← (byte) init::i#1 != rangelast(0,PLEX_COUNT-1)
  if((bool~) init::$7) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  (byte*) PLEX_SCREEN_PTR#31 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#33 )
  *((const byte*) SPRITES_ENABLE) ← (number) $ff
  (byte) init::i1#0 ← (byte) 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  (byte*) PLEX_SCREEN_PTR#29 ← phi( init::@2/(byte*) PLEX_SCREEN_PTR#31 init::@3/(byte*) PLEX_SCREEN_PTR#29 )
  (byte) init::i1#2 ← phi( init::@2/(byte) init::i1#0 init::@3/(byte) init::i1#1 )
  *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN
  (byte) init::i1#1 ← (byte) init::i1#2 + rangenext(0,7)
  (bool~) init::$8 ← (byte) init::i1#1 != rangelast(0,7)
  if((bool~) init::$8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  (byte*) PLEX_SCREEN_PTR#28 ← phi( init::@3/(byte*) PLEX_SCREEN_PTR#29 )
  call mulf_init 
  to:init::@6
init::@6: scope:[init]  from init::@4
  (byte*) PLEX_SCREEN_PTR#25 ← phi( init::@4/(byte*) PLEX_SCREEN_PTR#28 )
  (void*) memset::str#0 ← (void*)(const byte*) SCREEN
  (byte) memset::c#0 ← (byte) ' '
  (word) memset::num#0 ← (number) $3e8
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:init::@7
init::@7: scope:[init]  from init::@6
  (byte*) PLEX_SCREEN_PTR#20 ← phi( init::@6/(byte*) PLEX_SCREEN_PTR#25 )
  to:init::@return
init::@return: scope:[init]  from init::@7
  (byte*) PLEX_SCREEN_PTR#13 ← phi( init::@7/(byte*) PLEX_SCREEN_PTR#20 )
  (byte*) PLEX_SCREEN_PTR#6 ← (byte*) PLEX_SCREEN_PTR#13
  return 
  to:@return

(void()) exit()
exit: scope:[exit]  from main::@2
  to:exit::@1
exit::@1: scope:[exit]  from exit exit::@7
  (byte) keyboard_key_pressed::key#0 ← (const byte) KEY_SPACE
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#1
  to:exit::@7
exit::@7: scope:[exit]  from exit::@1
  (byte) keyboard_key_pressed::return#5 ← phi( exit::@1/(byte) keyboard_key_pressed::return#2 )
  (byte~) exit::$0 ← (byte) keyboard_key_pressed::return#5
  (bool~) exit::$1 ← (number) 0 != (byte~) exit::$0
  if((bool~) exit::$1) goto exit::@1
  to:exit::@return
exit::@return: scope:[exit]  from exit::@7
  return 
  to:@return

(void()) loop()
loop: scope:[loop]  from main::@1
  (byte*) PLEX_SCREEN_PTR#48 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (byte) plex_free_next#35 ← phi( main::@1/(byte) plex_free_next#24 )
  (byte) plex_sprite_msb#35 ← phi( main::@1/(byte) plex_sprite_msb#25 )
  (byte) plex_sprite_idx#36 ← phi( main::@1/(byte) plex_sprite_idx#28 )
  (byte) plex_show_idx#36 ← phi( main::@1/(byte) plex_show_idx#28 )
  (byte) loop::angle#0 ← (byte) 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@34
  (byte*) PLEX_SCREEN_PTR#47 ← phi( loop/(byte*) PLEX_SCREEN_PTR#48 loop::@34/(byte*) PLEX_SCREEN_PTR#49 )
  (byte) loop::angle#6 ← phi( loop/(byte) loop::angle#0 loop::@34/(byte) loop::angle#8 )
  (byte) plex_free_next#29 ← phi( loop/(byte) plex_free_next#35 loop::@34/(byte) plex_free_next#30 )
  (byte) plex_sprite_msb#29 ← phi( loop/(byte) plex_sprite_msb#35 loop::@34/(byte) plex_sprite_msb#30 )
  (byte) plex_sprite_idx#31 ← phi( loop/(byte) plex_sprite_idx#36 loop::@34/(byte) plex_sprite_idx#32 )
  (byte) plex_show_idx#31 ← phi( loop/(byte) plex_show_idx#36 loop::@34/(byte) plex_show_idx#32 )
  if(true) goto loop::@4
  to:loop::@return
loop::@4: scope:[loop]  from loop::@1 loop::@4
  (byte*) PLEX_SCREEN_PTR#46 ← phi( loop::@1/(byte*) PLEX_SCREEN_PTR#47 loop::@4/(byte*) PLEX_SCREEN_PTR#46 )
  (byte) plex_free_next#47 ← phi( loop::@1/(byte) plex_free_next#29 loop::@4/(byte) plex_free_next#47 )
  (byte) plex_sprite_msb#48 ← phi( loop::@1/(byte) plex_sprite_msb#29 loop::@4/(byte) plex_sprite_msb#48 )
  (byte) plex_sprite_idx#48 ← phi( loop::@1/(byte) plex_sprite_idx#31 loop::@4/(byte) plex_sprite_idx#48 )
  (byte) plex_show_idx#48 ← phi( loop::@1/(byte) plex_show_idx#31 loop::@4/(byte) plex_show_idx#48 )
  (byte) loop::angle#4 ← phi( loop::@1/(byte) loop::angle#6 loop::@4/(byte) loop::angle#4 )
  (bool~) loop::$0 ← *((const byte*) RASTER) < (number) $d8
  if((bool~) loop::$0) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  (byte*) PLEX_SCREEN_PTR#45 ← phi( loop::@4/(byte*) PLEX_SCREEN_PTR#46 )
  (byte) plex_free_next#46 ← phi( loop::@4/(byte) plex_free_next#47 )
  (byte) plex_sprite_msb#46 ← phi( loop::@4/(byte) plex_sprite_msb#48 )
  (byte) plex_sprite_idx#46 ← phi( loop::@4/(byte) plex_sprite_idx#48 )
  (byte) plex_show_idx#46 ← phi( loop::@4/(byte) plex_show_idx#48 )
  (byte) loop::angle#2 ← phi( loop::@4/(byte) loop::angle#4 )
  *((const byte*) BORDERCOL) ← (number) $f
  (signed byte) loop::r#0 ← (signed byte) $1e
  (byte) loop::a#0 ← (byte) loop::angle#2
  (byte) loop::i#0 ← (byte) 0
  to:loop::@6
loop::@6: scope:[loop]  from loop::@31 loop::@5
  (byte*) PLEX_SCREEN_PTR#44 ← phi( loop::@31/(byte*) PLEX_SCREEN_PTR#42 loop::@5/(byte*) PLEX_SCREEN_PTR#45 )
  (byte) loop::angle#10 ← phi( loop::@31/(byte) loop::angle#7 loop::@5/(byte) loop::angle#2 )
  (byte) plex_free_next#44 ← phi( loop::@31/(byte) plex_free_next#36 loop::@5/(byte) plex_free_next#46 )
  (byte) plex_sprite_msb#44 ← phi( loop::@31/(byte) plex_sprite_msb#36 loop::@5/(byte) plex_sprite_msb#46 )
  (byte) plex_sprite_idx#44 ← phi( loop::@31/(byte) plex_sprite_idx#37 loop::@5/(byte) plex_sprite_idx#46 )
  (byte) plex_show_idx#44 ← phi( loop::@31/(byte) plex_show_idx#37 loop::@5/(byte) plex_show_idx#46 )
  (byte) loop::i#4 ← phi( loop::@31/(byte) loop::i#1 loop::@5/(byte) loop::i#0 )
  (byte) loop::a#2 ← phi( loop::@31/(byte) loop::a#1 loop::@5/(byte) loop::a#0 )
  (signed byte) loop::r#2 ← phi( loop::@31/(signed byte) loop::r#1 loop::@5/(signed byte) loop::r#0 )
  *((const byte*) BORDERCOL) ← (number) 6
  (signed byte) mulf8s::a#0 ← (signed byte) loop::r#2
  (signed byte) mulf8s::b#0 ← *((const signed byte*) COS + (byte) loop::a#2)
  call mulf8s 
  (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#1
  to:loop::@30
loop::@30: scope:[loop]  from loop::@6
  (byte*) PLEX_SCREEN_PTR#43 ← phi( loop::@6/(byte*) PLEX_SCREEN_PTR#44 )
  (byte) loop::angle#9 ← phi( loop::@6/(byte) loop::angle#10 )
  (byte) plex_free_next#41 ← phi( loop::@6/(byte) plex_free_next#44 )
  (byte) plex_sprite_msb#42 ← phi( loop::@6/(byte) plex_sprite_msb#44 )
  (byte) plex_sprite_idx#42 ← phi( loop::@6/(byte) plex_sprite_idx#44 )
  (byte) plex_show_idx#42 ← phi( loop::@6/(byte) plex_show_idx#44 )
  (byte) loop::a#3 ← phi( loop::@6/(byte) loop::a#2 )
  (signed byte) loop::r#3 ← phi( loop::@6/(signed byte) loop::r#2 )
  (byte) loop::i#2 ← phi( loop::@6/(byte) loop::i#4 )
  (signed word) mulf8s::return#5 ← phi( loop::@6/(signed word) mulf8s::return#2 )
  (signed word~) loop::$1 ← (signed word) mulf8s::return#5
  (number~) loop::$2 ← (signed word~) loop::$1 * (number) 2
  (number~) loop::$3 ← (number~) loop::$2 + (number) $7d*(number) $100
  (signed word) loop::x#0 ← (number~) loop::$3
  (byte~) loop::$4 ← > (signed word) loop::x#0
  (byte~) loop::$20 ← (byte) loop::i#2 * (const byte) SIZEOF_WORD
  *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4
  (signed byte) mulf8s::a#1 ← (signed byte) loop::r#3
  (signed byte) mulf8s::b#1 ← *((const signed byte*) SIN + (byte) loop::a#3)
  call mulf8s 
  (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#1
  to:loop::@31
loop::@31: scope:[loop]  from loop::@30
  (byte*) PLEX_SCREEN_PTR#42 ← phi( loop::@30/(byte*) PLEX_SCREEN_PTR#43 )
  (byte) loop::angle#7 ← phi( loop::@30/(byte) loop::angle#9 )
  (byte) plex_free_next#36 ← phi( loop::@30/(byte) plex_free_next#41 )
  (byte) plex_sprite_msb#36 ← phi( loop::@30/(byte) plex_sprite_msb#42 )
  (byte) plex_sprite_idx#37 ← phi( loop::@30/(byte) plex_sprite_idx#42 )
  (byte) plex_show_idx#37 ← phi( loop::@30/(byte) plex_show_idx#42 )
  (signed byte) loop::r#4 ← phi( loop::@30/(signed byte) loop::r#3 )
  (byte) loop::a#4 ← phi( loop::@30/(byte) loop::a#3 )
  (byte) loop::i#3 ← phi( loop::@30/(byte) loop::i#2 )
  (signed word) mulf8s::return#6 ← phi( loop::@30/(signed word) mulf8s::return#3 )
  (signed word~) loop::$5 ← (signed word) mulf8s::return#6
  (number~) loop::$6 ← (signed word~) loop::$5 * (number) 2
  (number~) loop::$7 ← (number~) loop::$6 + (number) $7d*(number) $100
  (signed word) loop::y#0 ← (number~) loop::$7
  (byte~) loop::$8 ← > (signed word) loop::y#0
  *((const byte*) PLEX_YPOS + (byte) loop::i#3) ← (byte~) loop::$8
  (byte) loop::a#1 ← (byte) loop::a#4 + (number) $62
  (signed byte) loop::r#1 ← (signed byte) loop::r#4 + (number) 3
  (byte) loop::i#1 ← (byte) loop::i#3 + rangenext(0,NUM_BOBS-1)
  (bool~) loop::$9 ← (byte) loop::i#1 != rangelast(0,NUM_BOBS-1)
  if((bool~) loop::$9) goto loop::@6
  to:loop::@7
loop::@7: scope:[loop]  from loop::@31
  (byte*) PLEX_SCREEN_PTR#41 ← phi( loop::@31/(byte*) PLEX_SCREEN_PTR#42 )
  (byte) loop::angle#5 ← phi( loop::@31/(byte) loop::angle#7 )
  (byte) plex_free_next#26 ← phi( loop::@31/(byte) plex_free_next#36 )
  (byte) plex_sprite_msb#27 ← phi( loop::@31/(byte) plex_sprite_msb#36 )
  (byte) plex_sprite_idx#30 ← phi( loop::@31/(byte) plex_sprite_idx#37 )
  (byte) plex_show_idx#30 ← phi( loop::@31/(byte) plex_show_idx#37 )
  *((const byte*) BORDERCOL) ← (number) 3
  call plexSort 
  to:loop::@32
loop::@32: scope:[loop]  from loop::@7
  (byte*) PLEX_SCREEN_PTR#40 ← phi( loop::@7/(byte*) PLEX_SCREEN_PTR#41 )
  (byte) loop::angle#3 ← phi( loop::@7/(byte) loop::angle#5 )
  (byte) plex_free_next#16 ← phi( loop::@7/(byte) plex_free_next#1 )
  (byte) plex_sprite_msb#19 ← phi( loop::@7/(byte) plex_sprite_msb#2 )
  (byte) plex_sprite_idx#18 ← phi( loop::@7/(byte) plex_sprite_idx#2 )
  (byte) plex_show_idx#18 ← phi( loop::@7/(byte) plex_show_idx#2 )
  (byte) plex_show_idx#7 ← (byte) plex_show_idx#18
  (byte) plex_sprite_idx#7 ← (byte) plex_sprite_idx#18
  (byte) plex_sprite_msb#8 ← (byte) plex_sprite_msb#19
  (byte) plex_free_next#7 ← (byte) plex_free_next#16
  (byte) loop::angle#1 ← (byte) loop::angle#3 + (number) 3
  *((const byte*) BORDERCOL) ← (const byte) BLACK
  to:loop::@8
loop::@8: scope:[loop]  from loop::@32 loop::@8
  (byte) loop::angle#20 ← phi( loop::@32/(byte) loop::angle#1 loop::@8/(byte) loop::angle#20 )
  (byte*) PLEX_SCREEN_PTR#39 ← phi( loop::@32/(byte*) PLEX_SCREEN_PTR#40 loop::@8/(byte*) PLEX_SCREEN_PTR#39 )
  (byte) plex_sprite_msb#51 ← phi( loop::@32/(byte) plex_sprite_msb#8 loop::@8/(byte) plex_sprite_msb#51 )
  (byte) plex_show_idx#51 ← phi( loop::@32/(byte) plex_show_idx#7 loop::@8/(byte) plex_show_idx#51 )
  (byte) plex_sprite_idx#51 ← phi( loop::@32/(byte) plex_sprite_idx#7 loop::@8/(byte) plex_sprite_idx#51 )
  (byte) plex_free_next#42 ← phi( loop::@32/(byte) plex_free_next#7 loop::@8/(byte) plex_free_next#42 )
  (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8
  (bool~) loop::$12 ← (byte~) loop::$11 != (number) 0
  if((bool~) loop::$12) goto loop::@8
  to:loop::@10
loop::@10: scope:[loop]  from loop::@8
  (byte) loop::angle#19 ← phi( loop::@8/(byte) loop::angle#20 )
  (byte*) PLEX_SCREEN_PTR#37 ← phi( loop::@8/(byte*) PLEX_SCREEN_PTR#39 )
  (byte) plex_sprite_msb#50 ← phi( loop::@8/(byte) plex_sprite_msb#51 )
  (byte) plex_show_idx#50 ← phi( loop::@8/(byte) plex_show_idx#51 )
  (byte) plex_sprite_idx#50 ← phi( loop::@8/(byte) plex_sprite_idx#51 )
  (byte) plex_free_next#37 ← phi( loop::@8/(byte) plex_free_next#42 )
  (byte) loop::i1#0 ← (byte) 0
  to:loop::@14
loop::@14: scope:[loop]  from loop::@10 loop::@33
  (byte) loop::angle#18 ← phi( loop::@10/(byte) loop::angle#19 loop::@33/(byte) loop::angle#12 )
  (byte*) PLEX_SCREEN_PTR#36 ← phi( loop::@10/(byte*) PLEX_SCREEN_PTR#37 loop::@33/(byte*) PLEX_SCREEN_PTR#38 )
  (byte) loop::i1#8 ← phi( loop::@10/(byte) loop::i1#0 loop::@33/(byte) loop::i1#1 )
  (byte) plex_sprite_msb#49 ← phi( loop::@10/(byte) plex_sprite_msb#50 loop::@33/(byte) plex_sprite_msb#9 )
  (byte) plex_show_idx#49 ← phi( loop::@10/(byte) plex_show_idx#50 loop::@33/(byte) plex_show_idx#8 )
  (byte) plex_sprite_idx#49 ← phi( loop::@10/(byte) plex_sprite_idx#50 loop::@33/(byte) plex_sprite_idx#8 )
  (byte) plex_free_next#27 ← phi( loop::@10/(byte) plex_free_next#37 loop::@33/(byte) plex_free_next#8 )
  *((const byte*) BORDERCOL) ← (const byte) BLACK
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@14
  (byte) loop::angle#17 ← phi( loop::@14/(byte) loop::angle#18 )
  (byte*) PLEX_SCREEN_PTR#35 ← phi( loop::@14/(byte*) PLEX_SCREEN_PTR#36 )
  (byte) loop::i1#7 ← phi( loop::@14/(byte) loop::i1#8 )
  (byte) plex_sprite_msb#47 ← phi( loop::@14/(byte) plex_sprite_msb#49 )
  (byte) plex_show_idx#47 ← phi( loop::@14/(byte) plex_show_idx#49 )
  (byte) plex_sprite_idx#47 ← phi( loop::@14/(byte) plex_sprite_idx#49 )
  (byte) plex_free_next#17 ← phi( loop::@14/(byte) plex_free_next#27 )
  (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17)
  to:loop::plexFreeNextYpos1_@return
loop::plexFreeNextYpos1_@return: scope:[loop]  from loop::plexFreeNextYpos1
  (byte) loop::angle#16 ← phi( loop::plexFreeNextYpos1/(byte) loop::angle#17 )
  (byte*) PLEX_SCREEN_PTR#34 ← phi( loop::plexFreeNextYpos1/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) loop::i1#6 ← phi( loop::plexFreeNextYpos1/(byte) loop::i1#7 )
  (byte) plex_sprite_msb#45 ← phi( loop::plexFreeNextYpos1/(byte) plex_sprite_msb#47 )
  (byte) plex_free_next#45 ← phi( loop::plexFreeNextYpos1/(byte) plex_free_next#17 )
  (byte) plex_show_idx#45 ← phi( loop::plexFreeNextYpos1/(byte) plex_show_idx#47 )
  (byte) plex_sprite_idx#45 ← phi( loop::plexFreeNextYpos1/(byte) plex_sprite_idx#47 )
  (byte) loop::plexFreeNextYpos1_return#2 ← phi( loop::plexFreeNextYpos1/(byte) loop::plexFreeNextYpos1_return#0 )
  (byte) loop::plexFreeNextYpos1_return#1 ← (byte) loop::plexFreeNextYpos1_return#2
  to:loop::@29
loop::@29: scope:[loop]  from loop::plexFreeNextYpos1_@return
  (byte) loop::angle#15 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::angle#16 )
  (byte*) PLEX_SCREEN_PTR#32 ← phi( loop::plexFreeNextYpos1_@return/(byte*) PLEX_SCREEN_PTR#34 )
  (byte) loop::i1#5 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::i1#6 )
  (byte) plex_sprite_msb#43 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_sprite_msb#45 )
  (byte) plex_free_next#43 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_free_next#45 )
  (byte) plex_show_idx#43 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_show_idx#45 )
  (byte) plex_sprite_idx#43 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_sprite_idx#45 )
  (byte) loop::plexFreeNextYpos1_return#3 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::plexFreeNextYpos1_return#1 )
  (byte~) loop::$13 ← (byte) loop::plexFreeNextYpos1_return#3
  (byte) loop::rasterY#0 ← (byte~) loop::$13
  to:loop::@15
loop::@15: scope:[loop]  from loop::@15 loop::@29
  (byte) loop::angle#14 ← phi( loop::@15/(byte) loop::angle#14 loop::@29/(byte) loop::angle#15 )
  (byte*) PLEX_SCREEN_PTR#30 ← phi( loop::@15/(byte*) PLEX_SCREEN_PTR#30 loop::@29/(byte*) PLEX_SCREEN_PTR#32 )
  (byte) loop::i1#4 ← phi( loop::@15/(byte) loop::i1#4 loop::@29/(byte) loop::i1#5 )
  (byte) plex_sprite_msb#37 ← phi( loop::@15/(byte) plex_sprite_msb#37 loop::@29/(byte) plex_sprite_msb#43 )
  (byte) plex_free_next#38 ← phi( loop::@15/(byte) plex_free_next#38 loop::@29/(byte) plex_free_next#43 )
  (byte) plex_show_idx#38 ← phi( loop::@15/(byte) plex_show_idx#38 loop::@29/(byte) plex_show_idx#43 )
  (byte) plex_sprite_idx#38 ← phi( loop::@15/(byte) plex_sprite_idx#38 loop::@29/(byte) plex_sprite_idx#43 )
  (byte) loop::rasterY#1 ← phi( loop::@15/(byte) loop::rasterY#1 loop::@29/(byte) loop::rasterY#0 )
  (bool~) loop::$14 ← *((const byte*) RASTER) < (byte) loop::rasterY#1
  if((bool~) loop::$14) goto loop::@15
  to:loop::@17
loop::@17: scope:[loop]  from loop::@15
  (byte) loop::angle#13 ← phi( loop::@15/(byte) loop::angle#14 )
  (byte*) PLEX_SCREEN_PTR#27 ← phi( loop::@15/(byte*) PLEX_SCREEN_PTR#30 )
  (byte) loop::i1#3 ← phi( loop::@15/(byte) loop::i1#4 )
  (byte) plex_sprite_msb#28 ← phi( loop::@15/(byte) plex_sprite_msb#37 )
  (byte) plex_free_next#28 ← phi( loop::@15/(byte) plex_free_next#38 )
  (byte) plex_show_idx#23 ← phi( loop::@15/(byte) plex_show_idx#38 )
  (byte) plex_sprite_idx#23 ← phi( loop::@15/(byte) plex_sprite_idx#38 )
  *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL)
  call plexShowSprite 
  to:loop::@33
loop::@33: scope:[loop]  from loop::@17
  (byte*) PLEX_SCREEN_PTR#38 ← phi( loop::@17/(byte*) PLEX_SCREEN_PTR#27 )
  (byte) loop::angle#12 ← phi( loop::@17/(byte) loop::angle#13 )
  (byte) loop::i1#2 ← phi( loop::@17/(byte) loop::i1#3 )
  (byte) plex_sprite_msb#20 ← phi( loop::@17/(byte) plex_sprite_msb#5 )
  (byte) plex_show_idx#19 ← phi( loop::@17/(byte) plex_show_idx#4 )
  (byte) plex_sprite_idx#19 ← phi( loop::@17/(byte) plex_sprite_idx#4 )
  (byte) plex_free_next#18 ← phi( loop::@17/(byte) plex_free_next#3 )
  (byte) plex_free_next#8 ← (byte) plex_free_next#18
  (byte) plex_sprite_idx#8 ← (byte) plex_sprite_idx#19
  (byte) plex_show_idx#8 ← (byte) plex_show_idx#19
  (byte) plex_sprite_msb#9 ← (byte) plex_sprite_msb#20
  (byte) loop::i1#1 ← (byte) loop::i1#2 + rangenext(0,PLEX_COUNT-1)
  (bool~) loop::$17 ← (byte) loop::i1#1 != rangelast(0,PLEX_COUNT-1)
  if((bool~) loop::$17) goto loop::@14
  to:loop::@21
loop::@21: scope:[loop]  from loop::@33
  (byte*) PLEX_SCREEN_PTR#50 ← phi( loop::@33/(byte*) PLEX_SCREEN_PTR#38 )
  (byte) loop::angle#11 ← phi( loop::@33/(byte) loop::angle#12 )
  (byte) plex_free_next#39 ← phi( loop::@33/(byte) plex_free_next#8 )
  (byte) plex_sprite_msb#38 ← phi( loop::@33/(byte) plex_sprite_msb#9 )
  (byte) plex_sprite_idx#39 ← phi( loop::@33/(byte) plex_sprite_idx#8 )
  (byte) plex_show_idx#39 ← phi( loop::@33/(byte) plex_show_idx#8 )
  *((const byte*) BORDERCOL) ← (const byte) BLACK
  (byte) keyboard_key_pressed::key#1 ← (const byte) KEY_SPACE
  call keyboard_key_pressed 
  (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#1
  to:loop::@34
loop::@34: scope:[loop]  from loop::@21
  (byte*) PLEX_SCREEN_PTR#49 ← phi( loop::@21/(byte*) PLEX_SCREEN_PTR#50 )
  (byte) loop::angle#8 ← phi( loop::@21/(byte) loop::angle#11 )
  (byte) plex_free_next#30 ← phi( loop::@21/(byte) plex_free_next#39 )
  (byte) plex_sprite_msb#30 ← phi( loop::@21/(byte) plex_sprite_msb#38 )
  (byte) plex_sprite_idx#32 ← phi( loop::@21/(byte) plex_sprite_idx#39 )
  (byte) plex_show_idx#32 ← phi( loop::@21/(byte) plex_show_idx#39 )
  (byte) keyboard_key_pressed::return#6 ← phi( loop::@21/(byte) keyboard_key_pressed::return#3 )
  (byte~) loop::$18 ← (byte) keyboard_key_pressed::return#6
  (bool~) loop::$21 ← (number) 0 != (byte~) loop::$18
  (bool~) loop::$19 ← ! (bool~) loop::$21
  if((bool~) loop::$19) goto loop::@1
  to:loop::@return
loop::@return: scope:[loop]  from loop::@1 loop::@34
  (byte) plex_free_next#19 ← phi( loop::@1/(byte) plex_free_next#29 loop::@34/(byte) plex_free_next#30 )
  (byte) plex_sprite_msb#21 ← phi( loop::@1/(byte) plex_sprite_msb#29 loop::@34/(byte) plex_sprite_msb#30 )
  (byte) plex_sprite_idx#20 ← phi( loop::@1/(byte) plex_sprite_idx#31 loop::@34/(byte) plex_sprite_idx#32 )
  (byte) plex_show_idx#20 ← phi( loop::@1/(byte) plex_show_idx#31 loop::@34/(byte) plex_show_idx#32 )
  (byte) plex_show_idx#9 ← (byte) plex_show_idx#20
  (byte) plex_sprite_idx#9 ← (byte) plex_sprite_idx#20
  (byte) plex_sprite_msb#10 ← (byte) plex_sprite_msb#21
  (byte) plex_free_next#9 ← (byte) plex_free_next#19
  return 
  to:@return
@37: scope:[]  from @9
  (byte) plex_free_next#31 ← phi( @9/(byte) plex_free_next#4 )
  (byte) plex_sprite_msb#31 ← phi( @9/(byte) plex_sprite_msb#39 )
  (byte) plex_sprite_idx#33 ← phi( @9/(byte) plex_sprite_idx#40 )
  (byte) plex_show_idx#33 ← phi( @9/(byte) plex_show_idx#40 )
  (byte*) PLEX_SCREEN_PTR#21 ← phi( @9/(byte*) PLEX_SCREEN_PTR#26 )
  call main 
  to:@38
@38: scope:[]  from @37
  (byte) plex_free_next#20 ← phi( @37/(byte) plex_free_next#6 )
  (byte) plex_sprite_msb#22 ← phi( @37/(byte) plex_sprite_msb#7 )
  (byte) plex_sprite_idx#21 ← phi( @37/(byte) plex_sprite_idx#6 )
  (byte) plex_show_idx#21 ← phi( @37/(byte) plex_show_idx#6 )
  (byte*) PLEX_SCREEN_PTR#14 ← phi( @37/(byte*) PLEX_SCREEN_PTR#4 )
  (byte*) PLEX_SCREEN_PTR#7 ← (byte*) PLEX_SCREEN_PTR#14
  (byte) plex_show_idx#10 ← (byte) plex_show_idx#21
  (byte) plex_sprite_idx#10 ← (byte) plex_sprite_idx#21
  (byte) plex_sprite_msb#11 ← (byte) plex_sprite_msb#22
  (byte) plex_free_next#10 ← (byte) plex_free_next#20
  to:@end
@end: scope:[]  from @38

SYMBOL TABLE SSA
(label) @37
(label) @38
(label) @4
(label) @9
(label) @begin
(label) @end
(const byte) BLACK = (byte) 0
(const byte*) BORDERCOL = (byte*)(number) $d020
(const byte*) CIA1_PORT_A = (byte*)(number) $dc00
(const byte*) CIA1_PORT_B = (byte*)(number) $dc01
(const signed byte*) COS = (const signed byte*) SIN+(number) $40
(const byte*) D011 = (byte*)(number) $d011
(const byte) GREEN = (byte) 5
(const byte) KEY_SPACE = (byte) $3c
(const byte) NUM_BOBS = (byte) $10
(const byte) PLEX_COUNT = (byte) $20
(const byte*) PLEX_FREE_YPOS[(number) 8]  = { fill( 8, 0) }
(const byte*) PLEX_PTR[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(byte*) PLEX_SCREEN_PTR
(byte*) PLEX_SCREEN_PTR#0
(byte*) PLEX_SCREEN_PTR#1
(byte*) PLEX_SCREEN_PTR#10
(byte*) PLEX_SCREEN_PTR#11
(byte*) PLEX_SCREEN_PTR#12
(byte*) PLEX_SCREEN_PTR#13
(byte*) PLEX_SCREEN_PTR#14
(byte*) PLEX_SCREEN_PTR#15
(byte*) PLEX_SCREEN_PTR#16
(byte*) PLEX_SCREEN_PTR#17
(byte*) PLEX_SCREEN_PTR#18
(byte*) PLEX_SCREEN_PTR#19
(byte*) PLEX_SCREEN_PTR#2
(byte*) PLEX_SCREEN_PTR#20
(byte*) PLEX_SCREEN_PTR#21
(byte*) PLEX_SCREEN_PTR#22
(byte*) PLEX_SCREEN_PTR#23
(byte*) PLEX_SCREEN_PTR#24
(byte*) PLEX_SCREEN_PTR#25
(byte*) PLEX_SCREEN_PTR#26
(byte*) PLEX_SCREEN_PTR#27
(byte*) PLEX_SCREEN_PTR#28
(byte*) PLEX_SCREEN_PTR#29
(byte*) PLEX_SCREEN_PTR#3
(byte*) PLEX_SCREEN_PTR#30
(byte*) PLEX_SCREEN_PTR#31
(byte*) PLEX_SCREEN_PTR#32
(byte*) PLEX_SCREEN_PTR#33
(byte*) PLEX_SCREEN_PTR#34
(byte*) PLEX_SCREEN_PTR#35
(byte*) PLEX_SCREEN_PTR#36
(byte*) PLEX_SCREEN_PTR#37
(byte*) PLEX_SCREEN_PTR#38
(byte*) PLEX_SCREEN_PTR#39
(byte*) PLEX_SCREEN_PTR#4
(byte*) PLEX_SCREEN_PTR#40
(byte*) PLEX_SCREEN_PTR#41
(byte*) PLEX_SCREEN_PTR#42
(byte*) PLEX_SCREEN_PTR#43
(byte*) PLEX_SCREEN_PTR#44
(byte*) PLEX_SCREEN_PTR#45
(byte*) PLEX_SCREEN_PTR#46
(byte*) PLEX_SCREEN_PTR#47
(byte*) PLEX_SCREEN_PTR#48
(byte*) PLEX_SCREEN_PTR#49
(byte*) PLEX_SCREEN_PTR#5
(byte*) PLEX_SCREEN_PTR#50
(byte*) PLEX_SCREEN_PTR#6
(byte*) PLEX_SCREEN_PTR#7
(byte*) PLEX_SCREEN_PTR#8
(byte*) PLEX_SCREEN_PTR#9
(const byte*) PLEX_SORTED_IDX[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(const word*) PLEX_XPOS[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(const byte*) PLEX_YPOS[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(const byte*) RASTER = (byte*)(number) $d012
(const byte*) SCREEN = (byte*)(number) $400
(const signed byte*) SIN[(number) $140]  = kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
(const byte) SIZEOF_WORD = (byte) 2
(const byte*) SPRITE[]  = kickasm {{ .var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
(const byte*) SPRITES_COLS = (byte*)(number) $d027
(const byte*) SPRITES_ENABLE = (byte*)(number) $d015
(const byte*) SPRITES_XMSB = (byte*)(number) $d010
(const byte*) SPRITES_XPOS = (byte*)(number) $d000
(const byte*) SPRITES_YPOS = (byte*)(number) $d001
(const byte) VIC_DEN = (byte) $10
(const byte) VIC_RSEL = (byte) 8
(const byte) VIC_RST8 = (byte) $80
(void()) exit()
(byte~) exit::$0
(bool~) exit::$1
(label) exit::@1
(label) exit::@7
(label) exit::@return
(void()) init()
(number~) init::$3
(number~) init::$4
(number~) init::$5
(number~) init::$6
(bool~) init::$7
(bool~) init::$8
(byte~) init::$9
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@5
(label) init::@6
(label) init::@7
(label) init::@return
(byte) init::i
(byte) init::i#0
(byte) init::i#1
(byte) init::i#2
(byte) init::i1
(byte) init::i1#0
(byte) init::i1#1
(byte) init::i1#2
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(number~) keyboard_key_pressed::$0
(byte~) keyboard_key_pressed::$1
(byte~) keyboard_key_pressed::$2
(byte~) keyboard_key_pressed::$3
(label) keyboard_key_pressed::@2
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::colidx#0
(byte) keyboard_key_pressed::colidx#1
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::key#0
(byte) keyboard_key_pressed::key#1
(byte) keyboard_key_pressed::key#2
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0
(byte) keyboard_key_pressed::return#1
(byte) keyboard_key_pressed::return#2
(byte) keyboard_key_pressed::return#3
(byte) keyboard_key_pressed::return#4
(byte) keyboard_key_pressed::return#5
(byte) keyboard_key_pressed::return#6
(byte) keyboard_key_pressed::rowidx
(byte) keyboard_key_pressed::rowidx#0
(const byte*) keyboard_matrix_col_bitmask[(number) 8]  = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte~) keyboard_matrix_read::$0
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0
(byte) keyboard_matrix_read::return#1
(byte) keyboard_matrix_read::return#2
(byte) keyboard_matrix_read::return#3
(byte) keyboard_matrix_read::return#4
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::row_pressed_bits#0
(byte) keyboard_matrix_read::rowid
(byte) keyboard_matrix_read::rowid#0
(byte) keyboard_matrix_read::rowid#1
(const byte*) keyboard_matrix_row_bitmask[(number) 8]  = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) loop()
(bool~) loop::$0
(signed word~) loop::$1
(byte~) loop::$11
(bool~) loop::$12
(byte~) loop::$13
(bool~) loop::$14
(bool~) loop::$17
(byte~) loop::$18
(bool~) loop::$19
(number~) loop::$2
(byte~) loop::$20
(bool~) loop::$21
(number~) loop::$3
(byte~) loop::$4
(signed word~) loop::$5
(number~) loop::$6
(number~) loop::$7
(byte~) loop::$8
(bool~) loop::$9
(label) loop::@1
(label) loop::@10
(label) loop::@14
(label) loop::@15
(label) loop::@17
(label) loop::@21
(label) loop::@29
(label) loop::@30
(label) loop::@31
(label) loop::@32
(label) loop::@33
(label) loop::@34
(label) loop::@4
(label) loop::@5
(label) loop::@6
(label) loop::@7
(label) loop::@8
(label) loop::@return
(byte) loop::a
(byte) loop::a#0
(byte) loop::a#1
(byte) loop::a#2
(byte) loop::a#3
(byte) loop::a#4
(byte) loop::angle
(byte) loop::angle#0
(byte) loop::angle#1
(byte) loop::angle#10
(byte) loop::angle#11
(byte) loop::angle#12
(byte) loop::angle#13
(byte) loop::angle#14
(byte) loop::angle#15
(byte) loop::angle#16
(byte) loop::angle#17
(byte) loop::angle#18
(byte) loop::angle#19
(byte) loop::angle#2
(byte) loop::angle#20
(byte) loop::angle#3
(byte) loop::angle#4
(byte) loop::angle#5
(byte) loop::angle#6
(byte) loop::angle#7
(byte) loop::angle#8
(byte) loop::angle#9
(byte) loop::i
(byte) loop::i#0
(byte) loop::i#1
(byte) loop::i#2
(byte) loop::i#3
(byte) loop::i#4
(byte) loop::i1
(byte) loop::i1#0
(byte) loop::i1#1
(byte) loop::i1#2
(byte) loop::i1#3
(byte) loop::i1#4
(byte) loop::i1#5
(byte) loop::i1#6
(byte) loop::i1#7
(byte) loop::i1#8
(label) loop::plexFreeNextYpos1
(label) loop::plexFreeNextYpos1_@return
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0
(byte) loop::plexFreeNextYpos1_return#1
(byte) loop::plexFreeNextYpos1_return#2
(byte) loop::plexFreeNextYpos1_return#3
(signed byte) loop::r
(signed byte) loop::r#0
(signed byte) loop::r#1
(signed byte) loop::r#2
(signed byte) loop::r#3
(signed byte) loop::r#4
(byte) loop::rasterY
(byte) loop::rasterY#0
(byte) loop::rasterY#1
(signed word) loop::x
(signed word) loop::x#0
(signed word) loop::y
(signed word) loop::y#0
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(byte*~) memset::$3
(bool~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@4
(label) memset::@5
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(signed word()) mulf8s((signed byte) mulf8s::a , (signed byte) mulf8s::b)
(signed word~) mulf8s::$1
(label) mulf8s::@2
(label) mulf8s::@3
(label) mulf8s::@4
(label) mulf8s::@return
(signed byte) mulf8s::a
(signed byte) mulf8s::a#0
(signed byte) mulf8s::a#1
(signed byte) mulf8s::a#2
(signed byte) mulf8s::b
(signed byte) mulf8s::b#0
(signed byte) mulf8s::b#1
(signed byte) mulf8s::b#2
(signed byte) mulf8s::b#3
(signed byte) mulf8s::b#4
(signed byte) mulf8s::b#5
(label) mulf8s::mulf8s_prepare1
(byte~) mulf8s::mulf8s_prepare1_$0
(signed byte) mulf8s::mulf8s_prepare1_a
(signed byte) mulf8s::mulf8s_prepare1_a#0
(signed byte) mulf8s::mulf8s_prepare1_a#1
(signed word) mulf8s::return
(signed word) mulf8s::return#0
(signed word) mulf8s::return#1
(signed word) mulf8s::return#2
(signed word) mulf8s::return#3
(signed word) mulf8s::return#4
(signed word) mulf8s::return#5
(signed word) mulf8s::return#6
(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
(byte~) mulf8s_prepared::$0
(word~) mulf8s_prepared::$1
(byte~) mulf8s_prepared::$10
(byte~) mulf8s_prepared::$12
(byte~) mulf8s_prepared::$13
(byte~) mulf8s_prepared::$14
(byte~) mulf8s_prepared::$15
(byte~) mulf8s_prepared::$16
(bool~) mulf8s_prepared::$2
(bool~) mulf8s_prepared::$3
(bool~) mulf8s_prepared::$4
(bool~) mulf8s_prepared::$5
(signed word~) mulf8s_prepared::$6
(byte~) mulf8s_prepared::$8
(byte~) mulf8s_prepared::$9
(label) mulf8s_prepared::@1
(label) mulf8s_prepared::@2
(label) mulf8s_prepared::@3
(label) mulf8s_prepared::@4
(label) mulf8s_prepared::@6
(label) mulf8s_prepared::@return
(signed byte) mulf8s_prepared::b
(signed byte) mulf8s_prepared::b#0
(signed byte) mulf8s_prepared::b#1
(signed byte) mulf8s_prepared::b#2
(signed byte) mulf8s_prepared::b#3
(signed byte) mulf8s_prepared::b#4
(word) mulf8s_prepared::m
(word) mulf8s_prepared::m#0
(word) mulf8s_prepared::m#1
(word) mulf8s_prepared::m#2
(word) mulf8s_prepared::m#3
(word) mulf8s_prepared::m#4
(word) mulf8s_prepared::m#5
(word) mulf8s_prepared::m#6
(const signed byte*) mulf8s_prepared::memA = (signed byte*)(number) $fd
(signed word) mulf8s_prepared::return
(signed word) mulf8s_prepared::return#0
(signed word) mulf8s_prepared::return#1
(signed word) mulf8s_prepared::return#2
(signed word) mulf8s_prepared::return#3
(signed word) mulf8s_prepared::return#4
(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
(label) mulf8u_prepare::@return
(byte) mulf8u_prepare::a
(byte) mulf8u_prepare::a#0
(byte) mulf8u_prepare::a#1
(const byte*) mulf8u_prepare::memA = (byte*)(number) $fd
(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
(label) mulf8u_prepared::@return
(byte) mulf8u_prepared::b
(byte) mulf8u_prepared::b#0
(byte) mulf8u_prepared::b#1
(const byte*) mulf8u_prepared::memB = (byte*)(number) $ff
(const byte*) mulf8u_prepared::resL = (byte*)(number) $fe
(word) mulf8u_prepared::return
(word) mulf8u_prepared::return#0
(word) mulf8u_prepared::return#1
(word) mulf8u_prepared::return#2
(word) mulf8u_prepared::return#3
(word) mulf8u_prepared::return#4
(void()) mulf_init()
(bool~) mulf_init::$0
(number~) mulf_init::$1
(bool~) mulf_init::$10
(bool~) mulf_init::$2
(bool~) mulf_init::$3
(byte~) mulf_init::$4
(byte~) mulf_init::$5
(word~) mulf_init::$6
(bool~) mulf_init::$7
(byte~) mulf_init::$8
(bool~) mulf_init::$9
(label) mulf_init::@1
(label) mulf_init::@10
(label) mulf_init::@11
(label) mulf_init::@12
(label) mulf_init::@15
(label) mulf_init::@2
(label) mulf_init::@3
(label) mulf_init::@4
(label) mulf_init::@7
(label) mulf_init::@9
(label) mulf_init::@return
(byte) mulf_init::c
(byte) mulf_init::c#0
(byte) mulf_init::c#1
(byte) mulf_init::c#2
(byte) mulf_init::c#3
(byte) mulf_init::c#4
(byte) mulf_init::c#5
(byte) mulf_init::dir
(byte) mulf_init::dir#0
(byte) mulf_init::dir#1
(byte) mulf_init::dir#2
(byte) mulf_init::dir#3
(byte) mulf_init::dir#4
(word) mulf_init::sqr
(word) mulf_init::sqr#0
(word) mulf_init::sqr#1
(word) mulf_init::sqr#2
(word) mulf_init::sqr#3
(word) mulf_init::sqr#4
(word) mulf_init::sqr#5
(word) mulf_init::sqr#6
(byte*) mulf_init::sqr1_hi
(byte*) mulf_init::sqr1_hi#0
(byte*) mulf_init::sqr1_hi#1
(byte*) mulf_init::sqr1_hi#2
(byte*) mulf_init::sqr1_hi#3
(byte*) mulf_init::sqr1_hi#4
(byte*) mulf_init::sqr1_hi#5
(byte*) mulf_init::sqr1_lo
(byte*) mulf_init::sqr1_lo#0
(byte*) mulf_init::sqr1_lo#1
(byte*) mulf_init::sqr1_lo#2
(byte*) mulf_init::sqr1_lo#3
(byte*) mulf_init::sqr1_lo#4
(byte*) mulf_init::sqr1_lo#5
(byte*) mulf_init::sqr2_hi
(byte*) mulf_init::sqr2_hi#0
(byte*) mulf_init::sqr2_hi#1
(byte*) mulf_init::sqr2_hi#2
(byte*) mulf_init::sqr2_hi#3
(byte*) mulf_init::sqr2_hi#4
(byte*) mulf_init::sqr2_hi#5
(byte*) mulf_init::sqr2_lo
(byte*) mulf_init::sqr2_lo#0
(byte*) mulf_init::sqr2_lo#1
(byte*) mulf_init::sqr2_lo#2
(byte*) mulf_init::sqr2_lo#3
(byte*) mulf_init::sqr2_lo#4
(byte*) mulf_init::sqr2_lo#5
(byte) mulf_init::x_2
(byte) mulf_init::x_2#0
(byte) mulf_init::x_2#1
(byte) mulf_init::x_2#2
(byte) mulf_init::x_2#3
(byte) mulf_init::x_2#4
(byte) mulf_init::x_2#5
(byte) mulf_init::x_255
(byte) mulf_init::x_255#0
(byte) mulf_init::x_255#1
(byte) mulf_init::x_255#2
(byte) mulf_init::x_255#3
(byte) mulf_init::x_255#4
(byte) mulf_init::x_255#5
(const byte*) mulf_sqr1_hi[(number) $200]  = { fill( $200, 0) }
(const byte*) mulf_sqr1_lo[(number) $200]  = { fill( $200, 0) }
(const byte*) mulf_sqr2_hi[(number) $200]  = { fill( $200, 0) }
(const byte*) mulf_sqr2_lo[(number) $200]  = { fill( $200, 0) }
(void()) plexInit((byte*) plexInit::screen)
(bool~) plexInit::$1
(label) plexInit::@1
(label) plexInit::@3
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#0
(byte) plexInit::i#1
(byte) plexInit::i#2
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::plexSetScreen1_screen#0
(byte*) plexInit::plexSetScreen1_screen#1
(byte*) plexInit::screen
(byte*) plexInit::screen#0
(byte*) plexInit::screen#1
(void()) plexShowSprite()
(number~) plexShowSprite::$0
(byte~) plexShowSprite::$10
(byte~) plexShowSprite::$11
(byte~) plexShowSprite::$2
(byte~) plexShowSprite::$3
(bool~) plexShowSprite::$4
(number~) plexShowSprite::$5
(number~) plexShowSprite::$6
(bool~) plexShowSprite::$7
(bool~) plexShowSprite::$8
(number~) plexShowSprite::$9
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@4
(label) plexShowSprite::@6
(label) plexShowSprite::@7
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(number~) plexShowSprite::plexFreeAdd1_$1
(number~) plexShowSprite::plexFreeAdd1_$2
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0
(byte) plexShowSprite::plexFreeAdd1_ypos#1
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0
(byte) plexShowSprite::plex_sprite_idx2#1
(byte) plexShowSprite::plex_sprite_idx2#2
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0
(byte) plexShowSprite::ypos
(byte) plexShowSprite::ypos#0
(void()) plexSort()
(number~) plexSort::$1
(bool~) plexSort::$2
(bool~) plexSort::$3
(number~) plexSort::$4
(bool~) plexSort::$5
(bool~) plexSort::$6
(bool~) plexSort::$7
(bool~) plexSort::$8
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#0
(byte) plexSort::m#1
(byte) plexSort::m#2
(byte) plexSort::m#3
(byte) plexSort::m#4
(byte) plexSort::m#5
(byte) plexSort::m#6
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0
(byte) plexSort::nxt_idx#1
(byte) plexSort::nxt_idx#2
(byte) plexSort::nxt_idx#3
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0
(byte) plexSort::nxt_y#1
(byte) plexSort::nxt_y#2
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#0
(byte) plexSort::plexFreePrepare1_s#1
(byte) plexSort::plexFreePrepare1_s#2
(byte) plexSort::s
(byte) plexSort::s#0
(byte) plexSort::s#1
(byte) plexSort::s#2
(byte) plexSort::s#3
(byte) plexSort::s#4
(byte) plex_free_next
(byte) plex_free_next#0
(byte) plex_free_next#1
(byte) plex_free_next#10
(byte) plex_free_next#11
(byte) plex_free_next#12
(byte) plex_free_next#13
(byte) plex_free_next#14
(byte) plex_free_next#15
(byte) plex_free_next#16
(byte) plex_free_next#17
(byte) plex_free_next#18
(byte) plex_free_next#19
(byte) plex_free_next#2
(byte) plex_free_next#20
(byte) plex_free_next#21
(byte) plex_free_next#22
(byte) plex_free_next#23
(byte) plex_free_next#24
(byte) plex_free_next#25
(byte) plex_free_next#26
(byte) plex_free_next#27
(byte) plex_free_next#28
(byte) plex_free_next#29
(byte) plex_free_next#3
(byte) plex_free_next#30
(byte) plex_free_next#31
(byte) plex_free_next#32
(byte) plex_free_next#33
(byte) plex_free_next#34
(byte) plex_free_next#35
(byte) plex_free_next#36
(byte) plex_free_next#37
(byte) plex_free_next#38
(byte) plex_free_next#39
(byte) plex_free_next#4
(byte) plex_free_next#40
(byte) plex_free_next#41
(byte) plex_free_next#42
(byte) plex_free_next#43
(byte) plex_free_next#44
(byte) plex_free_next#45
(byte) plex_free_next#46
(byte) plex_free_next#47
(byte) plex_free_next#5
(byte) plex_free_next#6
(byte) plex_free_next#7
(byte) plex_free_next#8
(byte) plex_free_next#9
(byte) plex_show_idx
(byte) plex_show_idx#0
(byte) plex_show_idx#1
(byte) plex_show_idx#10
(byte) plex_show_idx#11
(byte) plex_show_idx#12
(byte) plex_show_idx#13
(byte) plex_show_idx#14
(byte) plex_show_idx#15
(byte) plex_show_idx#16
(byte) plex_show_idx#17
(byte) plex_show_idx#18
(byte) plex_show_idx#19
(byte) plex_show_idx#2
(byte) plex_show_idx#20
(byte) plex_show_idx#21
(byte) plex_show_idx#22
(byte) plex_show_idx#23
(byte) plex_show_idx#24
(byte) plex_show_idx#25
(byte) plex_show_idx#26
(byte) plex_show_idx#27
(byte) plex_show_idx#28
(byte) plex_show_idx#29
(byte) plex_show_idx#3
(byte) plex_show_idx#30
(byte) plex_show_idx#31
(byte) plex_show_idx#32
(byte) plex_show_idx#33
(byte) plex_show_idx#34
(byte) plex_show_idx#35
(byte) plex_show_idx#36
(byte) plex_show_idx#37
(byte) plex_show_idx#38
(byte) plex_show_idx#39
(byte) plex_show_idx#4
(byte) plex_show_idx#40
(byte) plex_show_idx#41
(byte) plex_show_idx#42
(byte) plex_show_idx#43
(byte) plex_show_idx#44
(byte) plex_show_idx#45
(byte) plex_show_idx#46
(byte) plex_show_idx#47
(byte) plex_show_idx#48
(byte) plex_show_idx#49
(byte) plex_show_idx#5
(byte) plex_show_idx#50
(byte) plex_show_idx#51
(byte) plex_show_idx#6
(byte) plex_show_idx#7
(byte) plex_show_idx#8
(byte) plex_show_idx#9
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0
(byte) plex_sprite_idx#1
(byte) plex_sprite_idx#10
(byte) plex_sprite_idx#11
(byte) plex_sprite_idx#12
(byte) plex_sprite_idx#13
(byte) plex_sprite_idx#14
(byte) plex_sprite_idx#15
(byte) plex_sprite_idx#16
(byte) plex_sprite_idx#17
(byte) plex_sprite_idx#18
(byte) plex_sprite_idx#19
(byte) plex_sprite_idx#2
(byte) plex_sprite_idx#20
(byte) plex_sprite_idx#21
(byte) plex_sprite_idx#22
(byte) plex_sprite_idx#23
(byte) plex_sprite_idx#24
(byte) plex_sprite_idx#25
(byte) plex_sprite_idx#26
(byte) plex_sprite_idx#27
(byte) plex_sprite_idx#28
(byte) plex_sprite_idx#29
(byte) plex_sprite_idx#3
(byte) plex_sprite_idx#30
(byte) plex_sprite_idx#31
(byte) plex_sprite_idx#32
(byte) plex_sprite_idx#33
(byte) plex_sprite_idx#34
(byte) plex_sprite_idx#35
(byte) plex_sprite_idx#36
(byte) plex_sprite_idx#37
(byte) plex_sprite_idx#38
(byte) plex_sprite_idx#39
(byte) plex_sprite_idx#4
(byte) plex_sprite_idx#40
(byte) plex_sprite_idx#41
(byte) plex_sprite_idx#42
(byte) plex_sprite_idx#43
(byte) plex_sprite_idx#44
(byte) plex_sprite_idx#45
(byte) plex_sprite_idx#46
(byte) plex_sprite_idx#47
(byte) plex_sprite_idx#48
(byte) plex_sprite_idx#49
(byte) plex_sprite_idx#5
(byte) plex_sprite_idx#50
(byte) plex_sprite_idx#51
(byte) plex_sprite_idx#6
(byte) plex_sprite_idx#7
(byte) plex_sprite_idx#8
(byte) plex_sprite_idx#9
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0
(byte) plex_sprite_msb#1
(byte) plex_sprite_msb#10
(byte) plex_sprite_msb#11
(byte) plex_sprite_msb#12
(byte) plex_sprite_msb#13
(byte) plex_sprite_msb#14
(byte) plex_sprite_msb#15
(byte) plex_sprite_msb#16
(byte) plex_sprite_msb#17
(byte) plex_sprite_msb#18
(byte) plex_sprite_msb#19
(byte) plex_sprite_msb#2
(byte) plex_sprite_msb#20
(byte) plex_sprite_msb#21
(byte) plex_sprite_msb#22
(byte) plex_sprite_msb#23
(byte) plex_sprite_msb#24
(byte) plex_sprite_msb#25
(byte) plex_sprite_msb#26
(byte) plex_sprite_msb#27
(byte) plex_sprite_msb#28
(byte) plex_sprite_msb#29
(byte) plex_sprite_msb#3
(byte) plex_sprite_msb#30
(byte) plex_sprite_msb#31
(byte) plex_sprite_msb#32
(byte) plex_sprite_msb#33
(byte) plex_sprite_msb#34
(byte) plex_sprite_msb#35
(byte) plex_sprite_msb#36
(byte) plex_sprite_msb#37
(byte) plex_sprite_msb#38
(byte) plex_sprite_msb#39
(byte) plex_sprite_msb#4
(byte) plex_sprite_msb#40
(byte) plex_sprite_msb#41
(byte) plex_sprite_msb#42
(byte) plex_sprite_msb#43
(byte) plex_sprite_msb#44
(byte) plex_sprite_msb#45
(byte) plex_sprite_msb#46
(byte) plex_sprite_msb#47
(byte) plex_sprite_msb#48
(byte) plex_sprite_msb#49
(byte) plex_sprite_msb#5
(byte) plex_sprite_msb#50
(byte) plex_sprite_msb#51
(byte) plex_sprite_msb#6
(byte) plex_sprite_msb#7
(byte) plex_sprite_msb#8
(byte) plex_sprite_msb#9

Fixing inline constructor with mulf8u_prepared::$0 ← (byte)*(mulf8u_prepared::memB) w= (byte)*(mulf8u_prepared::resL)
Successful SSA optimization Pass2FixInlineConstructors
Adding number conversion cast (unumber) $40 in 
Adding number conversion cast (unumber) $3f8 in (byte*~) plexInit::plexSetScreen1_$0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
Adding number conversion cast (unumber) 1 in (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) 1 in (number~) plexSort::$1 ← (byte) plexSort::m#2 + (number) 1
Adding number conversion cast (unumber) plexSort::$1 in (number~) plexSort::$1 ← (byte) plexSort::m#2 + (unumber)(number) 1
Adding number conversion cast (unumber) 2 in (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,PLEX_COUNT-2)
Adding number conversion cast (unumber) 1 in (number~) plexSort::$4 ← (byte) plexSort::s#3 + (number) 1
Adding number conversion cast (unumber) plexSort::$4 in (number~) plexSort::$4 ← (byte) plexSort::s#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $ff in (bool~) plexSort::$5 ← (byte) plexSort::s#1 != (number) $ff
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#1 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#1 ← (number) 1
Adding number conversion cast (unumber) 0 in *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#0 ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (number) 2
Adding number conversion cast (unumber) plexShowSprite::$0 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (unumber)(number) 2
Adding number conversion cast (unumber) $15 in (number~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0 in (number~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)(number) $15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#12 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1 in (number~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#12 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::plexFreeAdd1_$2 ← (unumber~) plexShowSprite::plexFreeAdd1_$1 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2 in (number~) plexShowSprite::plexFreeAdd1_$2 ← (unumber~) plexShowSprite::plexFreeAdd1_$1 & (unumber)(number) 7
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
Adding number conversion cast (unumber) $ff in (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#14
Adding number conversion cast (unumber) plexShowSprite::$9 in (number~) plexShowSprite::$9 ← (unumber)(number) $ff ^ (byte) plex_sprite_msb#14
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::$5 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::$6 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (unumber)(number) 7
Adding number conversion cast (unumber) 2 in (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#15 * (number) 2
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#4 ← (number) 1
Adding number conversion cast (unumber) 1 in (byte*) mulf_init::sqr1_hi#0 ← (const byte*) mulf_sqr1_hi+(number) 1
Adding number conversion cast (unumber) 1 in (byte*) mulf_init::sqr1_lo#0 ← (const byte*) mulf_sqr1_lo+(number) 1
Adding number conversion cast (unumber) $200 in (bool~) mulf_init::$0 ← (byte*) mulf_init::sqr1_lo#2 != (const byte*) mulf_sqr1_lo+(number) $200
Adding number conversion cast (unumber) 1 in (number~) mulf_init::$1 ← (byte) mulf_init::c#1 & (number) 1
Adding number conversion cast (unumber) mulf_init::$1 in (number~) mulf_init::$1 ← (byte) mulf_init::c#1 & (unumber)(number) 1
Adding number conversion cast (unumber) 0 in (bool~) mulf_init::$2 ← (unumber~) mulf_init::$1 == (number) 0
Adding number conversion cast (unumber) $1ff in (bool~) mulf_init::$7 ← (byte*) mulf_init::sqr2_lo#2 != (const byte*) mulf_sqr2_lo+(number) $1ff
Adding number conversion cast (unumber) 0 in (bool~) mulf_init::$9 ← (byte) mulf_init::x_255#1 == (number) 0
Adding number conversion cast (unumber) $100 in *((const byte*) mulf_sqr2_lo+(number) $1ff) ← *((const byte*) mulf_sqr1_lo+(number) $100)
Adding number conversion cast (unumber) $1ff in *((const byte*) mulf_sqr2_lo+(number) $1ff) ← *((const byte*) mulf_sqr1_lo+(unumber)(number) $100)
Adding number conversion cast (unumber) $100 in *((const byte*) mulf_sqr2_hi+(number) $1ff) ← *((const byte*) mulf_sqr1_hi+(number) $100)
Adding number conversion cast (unumber) $1ff in *((const byte*) mulf_sqr2_hi+(number) $1ff) ← *((const byte*) mulf_sqr1_hi+(unumber)(number) $100)
Adding number conversion cast (unumber) 1 in (byte) mulf_init::dir#1 ← (number) 1
Adding number conversion cast (snumber) 0 in (bool~) mulf8s_prepared::$2 ← *((const signed byte*) mulf8s_prepared::memA) < (number) 0
Adding number conversion cast (snumber) 0 in (bool~) mulf8s_prepared::$4 ← (signed byte) mulf8s_prepared::b#2 < (number) 0
Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#1 > (number) 0
Adding number conversion cast (unumber) 7 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#2 & (number) 7
Adding number conversion cast (unumber) keyboard_key_pressed::$0 in (number~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#2 & (unumber)(number) 7
Adding number conversion cast (unumber) 3 in (byte~) keyboard_key_pressed::$1 ← (byte) keyboard_key_pressed::key#2 >> (number) 3
Adding number conversion cast (unumber) VIC_DEN|VIC_RSEL|3 in *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(number) 3
Adding number conversion cast (unumber) 3 in *((const byte*) D011) ← ((unumber)) (const byte) VIC_DEN|(const byte) VIC_RSEL|(number) 3
Adding number conversion cast (unumber) $40 in *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(number) $40
Adding number conversion cast (unumber) 5 in (number~) init::$3 ← (byte) init::i#2 * (number) 5
Adding number conversion cast (unumber) init::$3 in (number~) init::$3 ← (byte) init::i#2 * (unumber)(number) 5
Adding number conversion cast (unumber) $18 in (number~) init::$4 ← (number) $18 + (unumber~) init::$3
Adding number conversion cast (unumber) init::$4 in (number~) init::$4 ← (unumber)(number) $18 + (unumber~) init::$3
Adding number conversion cast (unumber) 8 in (number~) init::$5 ← (byte) init::i#2 * (number) 8
Adding number conversion cast (unumber) init::$5 in (number~) init::$5 ← (byte) init::i#2 * (unumber)(number) 8
Adding number conversion cast (unumber) $32 in (number~) init::$6 ← (number) $32 + (unumber~) init::$5
Adding number conversion cast (unumber) init::$6 in (number~) init::$6 ← (unumber)(number) $32 + (unumber~) init::$5
Adding number conversion cast (unumber) 1 in (byte) init::i#1 ← (byte) init::i#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) $ff in *((const byte*) SPRITES_ENABLE) ← (number) $ff
Adding number conversion cast (unumber) $3e8 in (word) memset::num#0 ← (number) $3e8
Adding number conversion cast (unumber) 0 in (bool~) exit::$1 ← (number) 0 != (byte~) exit::$0
Adding number conversion cast (unumber) $d8 in (bool~) loop::$0 ← *((const byte*) RASTER) < (number) $d8
Adding number conversion cast (unumber) $f in *((const byte*) BORDERCOL) ← (number) $f
Adding number conversion cast (unumber) 6 in *((const byte*) BORDERCOL) ← (number) 6
Adding number conversion cast (snumber) 2 in (number~) loop::$2 ← (signed word~) loop::$1 * (number) 2
Adding number conversion cast (snumber) loop::$2 in (number~) loop::$2 ← (signed word~) loop::$1 * (snumber)(number) 2
Adding number conversion cast (snumber) $7d*$100 in (number~) loop::$3 ← (snumber~) loop::$2 + (number) $7d*(number) $100
Adding number conversion cast (snumber) loop::$3 in (number~) loop::$3 ← (snumber~) loop::$2 + (snumber)(number) $7d*(number) $100
Adding number conversion cast (snumber) 2 in (number~) loop::$6 ← (signed word~) loop::$5 * (number) 2
Adding number conversion cast (snumber) loop::$6 in (number~) loop::$6 ← (signed word~) loop::$5 * (snumber)(number) 2
Adding number conversion cast (snumber) $7d*$100 in (number~) loop::$7 ← (snumber~) loop::$6 + (number) $7d*(number) $100
Adding number conversion cast (snumber) loop::$7 in (number~) loop::$7 ← (snumber~) loop::$6 + (snumber)(number) $7d*(number) $100
Adding number conversion cast (unumber) $62 in (byte) loop::a#1 ← (byte) loop::a#4 + (number) $62
Adding number conversion cast (snumber) 3 in (signed byte) loop::r#1 ← (signed byte) loop::r#4 + (number) 3
Adding number conversion cast (unumber) 1 in (byte) loop::i#1 ← (byte) loop::i#3 + rangenext(0,NUM_BOBS-1)
Adding number conversion cast (unumber) 3 in *((const byte*) BORDERCOL) ← (number) 3
Adding number conversion cast (unumber) 3 in (byte) loop::angle#1 ← (byte) loop::angle#3 + (number) 3
Adding number conversion cast (unumber) 0 in (bool~) loop::$12 ← (byte~) loop::$11 != (number) 0
Adding number conversion cast (unumber) 1 in (byte) loop::i1#1 ← (byte) loop::i1#2 + rangenext(0,PLEX_COUNT-1)
Adding number conversion cast (unumber) 0 in (bool~) loop::$21 ← (number) 0 != (byte~) loop::$18
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte) plex_show_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#1 ← (unumber)(number) 1
Inlining cast *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (unumber)(number) 0
Inlining cast (byte) plex_free_next#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#4 ← (unumber)(number) 1
Inlining cast (byte) mulf_init::dir#1 ← (unumber)(number) 1
Inlining cast (byte~) mulf8s_prepared::$0 ← (byte)(signed byte) mulf8s_prepared::b#1
Inlining cast (byte~) mulf8s_prepared::$9 ← (byte)(signed byte) mulf8s_prepared::b#3
Inlining cast (signed word~) mulf8s_prepared::$6 ← (signed word)(word) mulf8s_prepared::m#4
Inlining cast (byte~) mulf8s_prepared::$13 ← (byte)*((const signed byte*) mulf8s_prepared::memA)
Inlining cast (byte~) mulf8s::mulf8s_prepare1_$0 ← (byte)(signed byte) mulf8s::mulf8s_prepare1_a#1
Inlining cast (byte*~) memset::$2 ← (byte*)(void*) memset::str#2
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#2
Inlining cast *((const byte*) D011) ← (unumber)(const byte) VIC_DEN|(const byte) VIC_RSEL|(unumber)(number) 3
Inlining cast *((const byte*) SPRITES_ENABLE) ← (unumber)(number) $ff
Inlining cast (word) memset::num#0 ← (unumber)(number) $3e8
Inlining cast *((const byte*) BORDERCOL) ← (unumber)(number) $f
Inlining cast *((const byte*) BORDERCOL) ← (unumber)(number) 6
Inlining cast *((const byte*) BORDERCOL) ← (unumber)(number) 3
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53265
Simplifying constant pointer cast (byte*) 56320
Simplifying constant pointer cast (byte*) 56321
Simplifying constant pointer cast (byte*) 253
Simplifying constant pointer cast (byte*) 254
Simplifying constant pointer cast (byte*) 255
Simplifying constant pointer cast (signed byte*) 253
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $40
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $15
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $200
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast -1
Simplifying constant integer cast $1ff
Simplifying constant integer cast 0
Simplifying constant integer cast $100
Simplifying constant integer cast $1ff
Simplifying constant integer cast $100
Simplifying constant integer cast $1ff
Simplifying constant integer cast 1
Simplifying constant integer cast *((const byte*) mulf8u_prepared::memB)
Simplifying constant integer cast *((const byte*) mulf8u_prepared::resL)
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 7
Simplifying constant integer cast 3
Simplifying constant integer cast (const byte) VIC_DEN|(const byte) VIC_RSEL|(unumber)(number) 3
Simplifying constant integer cast 3
Simplifying constant integer cast $40
Simplifying constant integer cast 5
Simplifying constant integer cast $18
Simplifying constant integer cast 8
Simplifying constant integer cast $32
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast $3e8
Simplifying constant integer cast 0
Simplifying constant integer cast $d8
Simplifying constant integer cast $f
Simplifying constant integer cast 6
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast $62
Simplifying constant integer cast 3
Simplifying constant integer cast 1
Simplifying constant integer cast 3
Simplifying constant integer cast 3
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $200
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (word) $100
Finalized unsigned number type (word) $1ff
Finalized unsigned number type (byte) 1
Finalized signed number type (signed byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $18
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $32
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $d8
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 6
Finalized signed number type (signed byte) 2
Finalized signed number type (signed byte) 2
Finalized unsigned number type (byte) $62
Finalized signed number type (signed byte) 3
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) plexSort::$1 ← (byte) plexSort::m#2 + (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$4 ← (byte) plexSort::s#3 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (byte) 2
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (byte) $15
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#12 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$2 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7
Inferred type updated to byte in (unumber~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#14
Inferred type updated to byte in (unumber~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
Inferred type updated to byte in (unumber~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1
Inferred type updated to byte in (unumber~) keyboard_key_pressed::$0 ← (byte) keyboard_key_pressed::key#2 & (byte) 7
Inferred type updated to byte in (unumber~) init::$3 ← (byte) init::i#2 * (byte) 5
Inferred type updated to byte in (unumber~) init::$4 ← (byte) $18 + (byte~) init::$3
Inferred type updated to byte in (unumber~) init::$5 ← (byte) init::i#2 * (byte) 8
Inferred type updated to byte in (unumber~) init::$6 ← (byte) $32 + (byte~) init::$5
Inferred type updated to signed word in (snumber~) loop::$2 ← (signed word~) loop::$1 * (signed byte) 2
Inferred type updated to signed word in (snumber~) loop::$3 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100
Inferred type updated to signed word in (snumber~) loop::$6 ← (signed word~) loop::$5 * (signed byte) 2
Inferred type updated to signed word in (snumber~) loop::$7 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100
Inversing boolean not [25] (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 >= *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2)) from [24] (bool~) plexSort::$2 ← (byte) plexSort::nxt_y#0 < *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))
Inversing boolean not [96] (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 != (byte) 0 from [95] (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (byte) 0
Inversing boolean not [120] (bool~) mulf_init::$3 ← (byte~) mulf_init::$1 != (byte) 0 from [119] (bool~) mulf_init::$2 ← (byte~) mulf_init::$1 == (byte) 0
Inversing boolean not [148] (bool~) mulf_init::$10 ← (byte) mulf_init::x_255#1 != (byte) 0 from [147] (bool~) mulf_init::$9 ← (byte) mulf_init::x_255#1 == (byte) 0
Inversing boolean not [178] (bool~) mulf8s_prepared::$3 ← *((const signed byte*) mulf8s_prepared::memA) >= (signed byte) 0 from [177] (bool~) mulf8s_prepared::$2 ← *((const signed byte*) mulf8s_prepared::memA) < (signed byte) 0
Inversing boolean not [182] (bool~) mulf8s_prepared::$5 ← (signed byte) mulf8s_prepared::b#2 >= (signed byte) 0 from [181] (bool~) mulf8s_prepared::$4 ← (signed byte) mulf8s_prepared::b#2 < (signed byte) 0
Inversing boolean not [221] (bool~) memset::$1 ← (word) memset::num#1 <= (byte) 0 from [220] (bool~) memset::$0 ← (word) memset::num#1 > (byte) 0
Inversing boolean not [419] (bool~) loop::$19 ← (byte) 0 == (byte~) loop::$18 from [418] (bool~) loop::$21 ← (byte) 0 != (byte~) loop::$18
Successful SSA optimization Pass2UnaryNotSimplification
Alias plexInit::plexSetScreen1_screen#0 = plexInit::screen#1 plexInit::plexSetScreen1_screen#1 
Alias PLEX_SCREEN_PTR#1 = plexInit::plexSetScreen1_$0 PLEX_SCREEN_PTR#22 
Alias PLEX_SCREEN_PTR#15 = PLEX_SCREEN_PTR#8 PLEX_SCREEN_PTR#2 
Alias plexSort::m#2 = plexSort::m#4 plexSort::s#0 
Alias plexSort::nxt_y#0 = plexSort::nxt_y#2 
Alias plexSort::nxt_idx#0 = plexSort::nxt_idx#3 
Alias plexSort::s#1 = plexSort::s#4 
Alias plexSort::nxt_idx#1 = plexSort::nxt_idx#2 
Alias plexSort::m#5 = plexSort::m#6 
Alias plex_show_idx#1 = plex_show_idx#41 
Alias plex_sprite_idx#1 = plex_sprite_idx#41 
Alias plex_sprite_msb#1 = plex_sprite_msb#40 
Alias plex_show_idx#11 = plex_show_idx#22 plex_show_idx#34 plex_show_idx#2 
Alias plex_sprite_idx#11 = plex_sprite_idx#22 plex_sprite_idx#34 plex_sprite_idx#2 
Alias plex_sprite_msb#12 = plex_sprite_msb#23 plex_sprite_msb#32 plex_sprite_msb#2 
Alias plex_free_next#0 = plex_free_next#11 plex_free_next#1 
Alias plexShowSprite::plex_sprite_idx2#0 = plexShowSprite::$0 plexShowSprite::plex_sprite_idx2#2 plexShowSprite::plex_sprite_idx2#1 
Alias plexShowSprite::plexFreeAdd1_ypos#0 = plexShowSprite::ypos#0 plexShowSprite::plexFreeAdd1_ypos#1 
Alias plex_free_next#12 = plex_free_next#21 
Alias plex_show_idx#12 = plex_show_idx#24 plex_show_idx#13 plex_show_idx#25 plex_show_idx#26 
Alias PLEX_SCREEN_PTR#16 = PLEX_SCREEN_PTR#23 PLEX_SCREEN_PTR#9 
Alias plex_sprite_idx#12 = plex_sprite_idx#24 plex_sprite_idx#13 plex_sprite_idx#25 plex_sprite_idx#26 
Alias plex_sprite_msb#13 = plex_sprite_msb#33 plex_sprite_msb#41 plex_sprite_msb#24 plex_sprite_msb#14 
Alias plex_free_next#2 = plexShowSprite::plexFreeAdd1_$2 plex_free_next#40 plex_free_next#32 plex_free_next#33 
Alias plex_sprite_idx#27 = plex_sprite_idx#3 plexShowSprite::$6 
Alias plex_free_next#22 = plex_free_next#23 
Alias plex_show_idx#27 = plex_show_idx#3 
Alias plex_free_next#13 = plex_free_next#3 
Alias plex_sprite_idx#15 = plex_sprite_idx#4 
Alias plex_show_idx#15 = plex_show_idx#4 
Alias plex_sprite_msb#16 = plex_sprite_msb#5 
Alias PLEX_SCREEN_PTR#0 = PLEX_SCREEN_PTR#26 PLEX_SCREEN_PTR#21 
Alias plex_show_idx#0 = plex_show_idx#40 plex_show_idx#33 
Alias plex_sprite_idx#0 = plex_sprite_idx#40 plex_sprite_idx#33 
Alias plex_sprite_msb#0 = plex_sprite_msb#39 plex_sprite_msb#31 
Alias mulf_init::c#2 = mulf_init::c#3 
Alias mulf_init::sqr#4 = mulf_init::sqr#5 mulf_init::sqr#6 
Alias mulf_init::sqr1_lo#2 = mulf_init::sqr1_lo#4 mulf_init::sqr1_lo#5 
Alias mulf_init::sqr1_hi#3 = mulf_init::sqr1_hi#5 mulf_init::sqr1_hi#4 
Alias mulf_init::x_2#3 = mulf_init::x_2#4 mulf_init::x_2#5 
Alias mulf_init::sqr#1 = mulf_init::$6 
Alias mulf_init::c#1 = mulf_init::c#5 
Alias mulf_init::x_255#2 = mulf_init::x_255#3 
Alias mulf_init::sqr2_lo#2 = mulf_init::sqr2_lo#3 mulf_init::sqr2_lo#5 
Alias mulf_init::sqr2_hi#2 = mulf_init::sqr2_hi#3 
Alias mulf_init::dir#2 = mulf_init::dir#3 
Alias mulf_init::x_255#1 = mulf_init::$8 mulf_init::x_255#5 
Alias mulf_init::sqr2_hi#1 = mulf_init::sqr2_hi#5 
Alias mulf8u_prepared::return#0 = mulf8u_prepared::$0 mulf8u_prepared::return#3 mulf8u_prepared::return#1 
Alias mulf8u_prepared::b#0 = mulf8s_prepared::$0 
Alias mulf8u_prepared::return#2 = mulf8u_prepared::return#4 
Alias mulf8s_prepared::b#1 = mulf8s_prepared::b#4 mulf8s_prepared::b#3 
Alias mulf8s_prepared::m#0 = mulf8s_prepared::$1 mulf8s_prepared::m#3 
Alias mulf8s_prepared::$15 = mulf8s_prepared::$10 
Alias mulf8s_prepared::return#0 = mulf8s_prepared::$6 mulf8s_prepared::return#3 mulf8s_prepared::return#1 
Alias mulf8s_prepared::m#5 = mulf8s_prepared::m#6 
Alias mulf8s_prepared::$16 = mulf8s_prepared::$14 
Alias mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#2 mulf8s::mulf8s_prepare1_a#1 
Alias mulf8s::b#2 = mulf8s::b#4 mulf8s::b#5 mulf8s::b#3 
Alias mulf8u_prepare::a#0 = mulf8s::mulf8s_prepare1_$0 
Alias mulf8s_prepared::return#2 = mulf8s_prepared::return#4 
Alias mulf8s::return#0 = mulf8s::$1 mulf8s::return#4 mulf8s::return#1 
Alias memset::return#0 = memset::str#1 memset::return#3 memset::return#1 
Alias memset::str#2 = memset::str#3 
Alias memset::num#1 = memset::num#2 
Alias memset::c#3 = memset::c#4 
Alias memset::end#0 = memset::$3 
Alias memset::c#1 = memset::c#2 
Alias memset::dst#2 = memset::dst#3 
Alias memset::end#1 = memset::end#2 
Alias memset::str#4 = memset::str#5 
Alias keyboard_matrix_read::return#0 = keyboard_matrix_read::row_pressed_bits#0 keyboard_matrix_read::$0 keyboard_matrix_read::return#3 keyboard_matrix_read::return#1 
Alias keyboard_key_pressed::colidx#0 = keyboard_key_pressed::$0 keyboard_key_pressed::colidx#1 
Alias keyboard_key_pressed::rowidx#0 = keyboard_key_pressed::$1 
Alias keyboard_matrix_read::return#2 = keyboard_matrix_read::return#4 
Alias keyboard_key_pressed::return#0 = keyboard_key_pressed::$3 keyboard_key_pressed::return#4 keyboard_key_pressed::return#1 
Alias plex_show_idx#28 = plex_show_idx#35 
Alias plex_sprite_idx#28 = plex_sprite_idx#35 
Alias plex_sprite_msb#25 = plex_sprite_msb#34 
Alias plex_free_next#24 = plex_free_next#34 
Alias PLEX_SCREEN_PTR#10 = PLEX_SCREEN_PTR#3 PLEX_SCREEN_PTR#24 PLEX_SCREEN_PTR#18 PLEX_SCREEN_PTR#11 PLEX_SCREEN_PTR#4 
Alias plex_show_idx#16 = plex_show_idx#5 plex_show_idx#29 plex_show_idx#17 plex_show_idx#6 
Alias plex_sprite_idx#16 = plex_sprite_idx#5 plex_sprite_idx#29 plex_sprite_idx#17 plex_sprite_idx#6 
Alias plex_sprite_msb#17 = plex_sprite_msb#6 plex_sprite_msb#26 plex_sprite_msb#18 plex_sprite_msb#7 
Alias plex_free_next#14 = plex_free_next#5 plex_free_next#25 plex_free_next#15 plex_free_next#6 
Alias PLEX_SCREEN_PTR#12 = PLEX_SCREEN_PTR#5 
Alias PLEX_SCREEN_PTR#31 = PLEX_SCREEN_PTR#33 
Alias PLEX_SCREEN_PTR#13 = PLEX_SCREEN_PTR#28 PLEX_SCREEN_PTR#29 PLEX_SCREEN_PTR#25 PLEX_SCREEN_PTR#20 PLEX_SCREEN_PTR#6 
Alias keyboard_key_pressed::return#2 = keyboard_key_pressed::return#5 
Alias loop::angle#2 = loop::angle#4 loop::a#0 
Alias plex_show_idx#46 = plex_show_idx#48 
Alias plex_sprite_idx#46 = plex_sprite_idx#48 
Alias plex_sprite_msb#46 = plex_sprite_msb#48 
Alias plex_free_next#46 = plex_free_next#47 
Alias PLEX_SCREEN_PTR#45 = PLEX_SCREEN_PTR#46 
Alias mulf8s::return#2 = mulf8s::return#5 
Alias loop::i#2 = loop::i#4 loop::i#3 
Alias loop::r#2 = loop::r#3 loop::r#4 
Alias loop::a#2 = loop::a#3 loop::a#4 
Alias plex_show_idx#30 = plex_show_idx#42 plex_show_idx#44 plex_show_idx#37 
Alias plex_sprite_idx#30 = plex_sprite_idx#42 plex_sprite_idx#44 plex_sprite_idx#37 
Alias plex_sprite_msb#27 = plex_sprite_msb#42 plex_sprite_msb#44 plex_sprite_msb#36 
Alias plex_free_next#26 = plex_free_next#41 plex_free_next#44 plex_free_next#36 
Alias loop::angle#10 = loop::angle#9 loop::angle#7 loop::angle#5 loop::angle#3 
Alias PLEX_SCREEN_PTR#40 = PLEX_SCREEN_PTR#43 PLEX_SCREEN_PTR#44 PLEX_SCREEN_PTR#42 PLEX_SCREEN_PTR#41 
Alias loop::x#0 = loop::$3 
Alias mulf8s::return#3 = mulf8s::return#6 
Alias loop::y#0 = loop::$7 
Alias plex_show_idx#18 = plex_show_idx#7 
Alias plex_sprite_idx#18 = plex_sprite_idx#7 
Alias plex_sprite_msb#19 = plex_sprite_msb#8 
Alias plex_free_next#16 = plex_free_next#7 
Alias plex_free_next#37 = plex_free_next#42 
Alias plex_sprite_idx#50 = plex_sprite_idx#51 
Alias plex_show_idx#50 = plex_show_idx#51 
Alias plex_sprite_msb#50 = plex_sprite_msb#51 
Alias PLEX_SCREEN_PTR#37 = PLEX_SCREEN_PTR#39 
Alias loop::angle#19 = loop::angle#20 
Alias plex_free_next#17 = plex_free_next#27 plex_free_next#45 plex_free_next#43 
Alias plex_sprite_idx#43 = plex_sprite_idx#47 plex_sprite_idx#49 plex_sprite_idx#45 
Alias plex_show_idx#43 = plex_show_idx#47 plex_show_idx#49 plex_show_idx#45 
Alias plex_sprite_msb#43 = plex_sprite_msb#47 plex_sprite_msb#49 plex_sprite_msb#45 
Alias loop::i1#5 = loop::i1#7 loop::i1#8 loop::i1#6 
Alias PLEX_SCREEN_PTR#32 = PLEX_SCREEN_PTR#35 PLEX_SCREEN_PTR#36 PLEX_SCREEN_PTR#34 
Alias loop::angle#15 = loop::angle#17 loop::angle#18 loop::angle#16 
Alias loop::plexFreeNextYpos1_return#0 = loop::plexFreeNextYpos1_return#2 loop::plexFreeNextYpos1_return#1 loop::plexFreeNextYpos1_return#3 loop::$13 loop::rasterY#0 
Alias plex_sprite_idx#23 = plex_sprite_idx#38 
Alias plex_show_idx#23 = plex_show_idx#38 
Alias plex_free_next#28 = plex_free_next#38 
Alias plex_sprite_msb#28 = plex_sprite_msb#37 
Alias loop::i1#2 = loop::i1#3 loop::i1#4 
Alias PLEX_SCREEN_PTR#27 = PLEX_SCREEN_PTR#30 PLEX_SCREEN_PTR#38 PLEX_SCREEN_PTR#50 PLEX_SCREEN_PTR#49 
Alias loop::angle#11 = loop::angle#13 loop::angle#14 loop::angle#12 loop::angle#8 
Alias plex_free_next#18 = plex_free_next#8 plex_free_next#39 plex_free_next#30 
Alias plex_sprite_idx#19 = plex_sprite_idx#8 plex_sprite_idx#39 plex_sprite_idx#32 
Alias plex_show_idx#19 = plex_show_idx#8 plex_show_idx#39 plex_show_idx#32 
Alias plex_sprite_msb#20 = plex_sprite_msb#9 plex_sprite_msb#38 plex_sprite_msb#30 
Alias keyboard_key_pressed::return#3 = keyboard_key_pressed::return#6 
Alias plex_show_idx#20 = plex_show_idx#9 
Alias plex_sprite_idx#20 = plex_sprite_idx#9 
Alias plex_sprite_msb#10 = plex_sprite_msb#21 
Alias plex_free_next#19 = plex_free_next#9 
Alias plex_free_next#31 = plex_free_next#4 
Alias PLEX_SCREEN_PTR#14 = PLEX_SCREEN_PTR#7 
Alias plex_show_idx#10 = plex_show_idx#21 
Alias plex_sprite_idx#10 = plex_sprite_idx#21 
Alias plex_sprite_msb#11 = plex_sprite_msb#22 
Alias plex_free_next#10 = plex_free_next#20 
Successful SSA optimization Pass2AliasElimination
Alias plex_sprite_idx#12 = plex_sprite_idx#14 
Alias plex_show_idx#12 = plex_show_idx#14 
Alias plex_sprite_msb#13 = plex_sprite_msb#15 
Alias plex_free_next#13 = plex_free_next#22 plex_free_next#2 
Alias plex_sprite_idx#15 = plex_sprite_idx#27 
Alias plex_show_idx#15 = plex_show_idx#27 
Alias mulf_init::sqr1_lo#2 = mulf_init::sqr1_lo#3 
Alias mulf_init::sqr1_hi#2 = mulf_init::sqr1_hi#3 
Alias mulf_init::c#1 = mulf_init::c#4 
Alias mulf_init::sqr2_lo#2 = mulf_init::sqr2_lo#4 
Alias mulf_init::x_255#1 = mulf_init::x_255#4 
Alias mulf_init::sqr2_hi#1 = mulf_init::sqr2_hi#4 
Alias mulf8s_prepared::b#1 = mulf8s_prepared::b#2 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) plexInit::plexSetScreen1_screen#0 (byte*) plexInit::screen#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#15 (byte*) PLEX_SCREEN_PTR#1
Identical Phi Values (byte) plexSort::nxt_y#1 (byte) plexSort::nxt_y#0
Identical Phi Values (byte) plexSort::nxt_idx#1 (byte) plexSort::nxt_idx#0
Identical Phi Values (byte) plexSort::m#5 (byte) plexSort::m#2
Identical Phi Values (byte) plex_show_idx#11 (byte) plex_show_idx#1
Identical Phi Values (byte) plex_sprite_idx#11 (byte) plex_sprite_idx#1
Identical Phi Values (byte) plex_sprite_msb#12 (byte) plex_sprite_msb#1
Identical Phi Values (byte) plex_sprite_idx#12 (byte) plex_sprite_idx#23
Identical Phi Values (byte) plex_show_idx#12 (byte) plex_show_idx#23
Identical Phi Values (byte) plex_free_next#12 (byte) plex_free_next#28
Identical Phi Values (byte*) PLEX_SCREEN_PTR#16 (byte*) PLEX_SCREEN_PTR#27
Identical Phi Values (byte) plex_sprite_msb#13 (byte) plex_sprite_msb#28
Identical Phi Values (byte) mulf8u_prepare::a#1 (byte) mulf8u_prepare::a#0
Identical Phi Values (byte) mulf8u_prepared::b#1 (byte) mulf8u_prepared::b#0
Identical Phi Values (signed byte) mulf8s_prepared::b#1 (signed byte) mulf8s_prepared::b#0
Identical Phi Values (word) memset::num#1 (word) memset::num#0
Identical Phi Values (void*) memset::str#2 (void*) memset::str#0
Identical Phi Values (byte) memset::c#3 (byte) memset::c#0
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#4 (void*) memset::str#2
Identical Phi Values (byte) memset::c#1 (byte) memset::c#3
Identical Phi Values (byte) keyboard_matrix_read::rowid#1 (byte) keyboard_matrix_read::rowid#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#17 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (byte) plex_show_idx#28 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_sprite_idx#28 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_sprite_msb#25 (byte) plex_sprite_msb#0
Identical Phi Values (byte) plex_free_next#24 (byte) plex_free_next#31
Identical Phi Values (byte*) PLEX_SCREEN_PTR#10 (byte*) PLEX_SCREEN_PTR#13
Identical Phi Values (byte) plex_show_idx#16 (byte) plex_show_idx#20
Identical Phi Values (byte) plex_sprite_idx#16 (byte) plex_sprite_idx#20
Identical Phi Values (byte) plex_sprite_msb#17 (byte) plex_sprite_msb#10
Identical Phi Values (byte) plex_free_next#14 (byte) plex_free_next#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#19 (byte*) PLEX_SCREEN_PTR#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#12 (byte*) PLEX_SCREEN_PTR#15
Identical Phi Values (byte*) PLEX_SCREEN_PTR#31 (byte*) PLEX_SCREEN_PTR#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#13 (byte*) PLEX_SCREEN_PTR#31
Identical Phi Values (byte) plex_show_idx#36 (byte) plex_show_idx#28
Identical Phi Values (byte) plex_sprite_idx#36 (byte) plex_sprite_idx#28
Identical Phi Values (byte) plex_sprite_msb#35 (byte) plex_sprite_msb#25
Identical Phi Values (byte) plex_free_next#35 (byte) plex_free_next#24
Identical Phi Values (byte*) PLEX_SCREEN_PTR#48 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) loop::angle#2 (byte) loop::angle#6
Identical Phi Values (byte) plex_show_idx#46 (byte) plex_show_idx#31
Identical Phi Values (byte) plex_sprite_idx#46 (byte) plex_sprite_idx#31
Identical Phi Values (byte) plex_sprite_msb#46 (byte) plex_sprite_msb#29
Identical Phi Values (byte) plex_free_next#46 (byte) plex_free_next#29
Identical Phi Values (byte*) PLEX_SCREEN_PTR#45 (byte*) PLEX_SCREEN_PTR#47
Identical Phi Values (byte) plex_show_idx#30 (byte) plex_show_idx#46
Identical Phi Values (byte) plex_sprite_idx#30 (byte) plex_sprite_idx#46
Identical Phi Values (byte) plex_sprite_msb#27 (byte) plex_sprite_msb#46
Identical Phi Values (byte) plex_free_next#26 (byte) plex_free_next#46
Identical Phi Values (byte) loop::angle#10 (byte) loop::angle#2
Identical Phi Values (byte*) PLEX_SCREEN_PTR#40 (byte*) PLEX_SCREEN_PTR#45
Identical Phi Values (byte) plex_show_idx#18 (byte) plex_show_idx#11
Identical Phi Values (byte) plex_sprite_idx#18 (byte) plex_sprite_idx#11
Identical Phi Values (byte) plex_sprite_msb#19 (byte) plex_sprite_msb#12
Identical Phi Values (byte) plex_free_next#16 (byte) plex_free_next#0
Identical Phi Values (byte) plex_free_next#37 (byte) plex_free_next#16
Identical Phi Values (byte) plex_sprite_idx#50 (byte) plex_sprite_idx#18
Identical Phi Values (byte) plex_show_idx#50 (byte) plex_show_idx#18
Identical Phi Values (byte) plex_sprite_msb#50 (byte) plex_sprite_msb#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#37 (byte*) PLEX_SCREEN_PTR#40
Identical Phi Values (byte) loop::angle#19 (byte) loop::angle#1
Identical Phi Values (byte) loop::rasterY#1 (byte) loop::plexFreeNextYpos1_return#0
Identical Phi Values (byte) plex_sprite_idx#23 (byte) plex_sprite_idx#43
Identical Phi Values (byte) plex_show_idx#23 (byte) plex_show_idx#43
Identical Phi Values (byte) plex_free_next#28 (byte) plex_free_next#17
Identical Phi Values (byte) plex_sprite_msb#28 (byte) plex_sprite_msb#43
Identical Phi Values (byte) loop::i1#2 (byte) loop::i1#5
Identical Phi Values (byte*) PLEX_SCREEN_PTR#27 (byte*) PLEX_SCREEN_PTR#32
Identical Phi Values (byte) loop::angle#11 (byte) loop::angle#15
Identical Phi Values (byte) plex_free_next#18 (byte) plex_free_next#13
Identical Phi Values (byte) plex_sprite_idx#19 (byte) plex_sprite_idx#15
Identical Phi Values (byte) plex_show_idx#19 (byte) plex_show_idx#15
Identical Phi Values (byte) plex_sprite_msb#20 (byte) plex_sprite_msb#16
Identical Phi Values (byte*) PLEX_SCREEN_PTR#14 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) plex_show_idx#10 (byte) plex_show_idx#16
Identical Phi Values (byte) plex_sprite_idx#10 (byte) plex_sprite_idx#16
Identical Phi Values (byte) plex_sprite_msb#11 (byte) plex_sprite_msb#17
Identical Phi Values (byte) plex_free_next#10 (byte) plex_free_next#14
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) plexSort::m#3 (byte) plexSort::m#2
Identical Phi Values (void*) memset::return#0 (void*) memset::str#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#32 (byte*) PLEX_SCREEN_PTR#47
Identical Phi Values (byte) loop::angle#15 (byte) loop::angle#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte*) PLEX_SCREEN_PTR#47 (byte*) PLEX_SCREEN_PTR#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [80] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) plexInit::$1 [11] if((byte) plexInit::i#1!=rangelast(0,PLEX_COUNT-1)) goto plexInit::@1
Simple Condition (bool~) plexSort::$3 [19] if((byte) plexSort::nxt_y#0>=*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2
Simple Condition (bool~) plexSort::$8 [23] if((byte) plexSort::m#1!=rangelast(0,PLEX_COUNT-2)) goto plexSort::@1
Simple Condition (bool~) plexSort::plexFreePrepare1_$0 [42] if((byte) plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition (bool~) plexShowSprite::$4 [61] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
Simple Condition (bool~) plexShowSprite::$8 [70] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
Simple Condition (bool~) mulf_init::$0 [82] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2
Simple Condition (bool~) mulf_init::$3 [86] if((byte~) mulf_init::$1!=(byte) 0) goto mulf_init::@4
Simple Condition (bool~) mulf_init::$7 [103] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@10
Simple Condition (bool~) mulf_init::$10 [109] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@12
Simple Condition (bool~) mulf8s_prepared::$3 [131] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1
Simple Condition (bool~) mulf8s_prepared::$5 [134] if((signed byte) mulf8s_prepared::b#0>=(signed byte) 0) goto mulf8s_prepared::@2
Simple Condition (bool~) memset::$1 [156] if((word) memset::num#0<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$4 [163] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@5
Simple Condition (bool~) init::$7 [206] if((byte) init::i#1!=rangelast(0,PLEX_COUNT-1)) goto init::@1
Simple Condition (bool~) init::$8 [213] if((byte) init::i1#1!=rangelast(0,7)) goto init::@3
Simple Condition (bool~) exit::$1 [226] if((byte) 0!=(byte~) exit::$0) goto exit::@1
Simple Condition (bool~) loop::$0 [234] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@4
Simple Condition (bool~) loop::$9 [263] if((byte) loop::i#1!=rangelast(0,NUM_BOBS-1)) goto loop::@6
Simple Condition (bool~) loop::$12 [272] if((byte~) loop::$11!=(byte) 0) goto loop::@8
Simple Condition (bool~) loop::$14 [279] if(*((const byte*) RASTER)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@15
Simple Condition (bool~) loop::$17 [285] if((byte) loop::i1#1!=rangelast(0,PLEX_COUNT-1)) goto loop::@14
Simple Condition (bool~) loop::$19 [292] if((byte) 0==(byte~) loop::$18) goto loop::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [30] (bool~) plexSort::$7 ← (bool~) plexSort::$5 && (bool~) plexSort::$6
Successful SSA optimization Pass2ConditionalAndOrRewriting
Negating conditional jump and destination [292] if((byte) 0!=(byte~) loop::$18) goto loop::@return
Constant (const byte*) PLEX_SCREEN_PTR#0 = (byte*)$400+$3f8
Constant (const byte) plex_show_idx#0 = 0
Constant (const byte) plex_sprite_idx#0 = 0
Constant (const byte) plex_sprite_msb#0 = 1
Constant (const byte) plexInit::i#0 = 0
Constant (const byte) plexSort::m#0 = 0
Constant (const byte) plex_show_idx#1 = 0
Constant (const byte) plex_sprite_idx#1 = 0
Constant (const byte) plex_sprite_msb#1 = 1
Constant (const byte) plexSort::plexFreePrepare1_s#0 = 0
Constant (const byte) plex_free_next#0 = 0
Constant (const byte) plex_sprite_msb#4 = 1
Constant (const byte) plex_free_next#31 = 0
Constant (const word) mulf_init::sqr#0 = 0
Constant (const byte) mulf_init::x_2#0 = 0
Constant (const byte) mulf_init::c#0 = 0
Constant (const byte*) mulf_init::sqr1_hi#0 = mulf_sqr1_hi+1
Constant (const byte*) mulf_init::sqr1_lo#0 = mulf_sqr1_lo+1
Constant (const byte) mulf_init::x_255#0 = -1
Constant (const byte) mulf_init::dir#0 = $ff
Constant (const byte*) mulf_init::sqr2_hi#0 = mulf_sqr2_hi
Constant (const byte*) mulf_init::sqr2_lo#0 = mulf_sqr2_lo
Constant (const byte) mulf_init::dir#1 = 1
Constant (const byte*) plexInit::screen#0 = SCREEN
Constant (const byte) init::i#0 = 0
Constant (const byte) init::i1#0 = 0
Constant (const void*) memset::str#0 = (void*)SCREEN
Constant (const byte) memset::c#0 = ' '
Constant (const word) memset::num#0 = $3e8
Constant (const byte) keyboard_key_pressed::key#0 = KEY_SPACE
Constant (const byte) loop::angle#0 = 0
Constant (const signed byte) loop::r#0 = $1e
Constant (const byte) loop::i#0 = 0
Constant (const byte) loop::i1#0 = 0
Constant (const byte) keyboard_key_pressed::key#1 = KEY_SPACE
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) memset::$2 = (byte*)memset::str#0
Constant (const byte*) memset::dst#0 = (byte*)memset::str#0
Constant (const void*) memset::return#2 = memset::str#0
Successful SSA optimization Pass2ConstantIdentification
if() condition always false - eliminating [156] if((const word) memset::num#0<=(byte) 0) goto memset::@1
Removing PHI-reference to removed block (loop::@1) in block loop::@return
Removing PHI-reference to removed block (loop::@1) in block loop::@return
Removing PHI-reference to removed block (loop::@1) in block loop::@return
Removing PHI-reference to removed block (loop::@1) in block loop::@return
if() condition always true - replacing block destination [231] if(true) goto loop::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [9] plexInit::i#1 ← ++ plexInit::i#2 to ++
Resolved ranged comparison value [11] if(plexInit::i#1!=rangelast(0,PLEX_COUNT-1)) goto plexInit::@1 to (const byte) PLEX_COUNT-(byte) 1+(number) 1
Resolved ranged next value [21] plexSort::m#1 ← ++ plexSort::m#2 to ++
Resolved ranged comparison value [23] if(plexSort::m#1!=rangelast(0,PLEX_COUNT-2)) goto plexSort::@1 to (const byte) PLEX_COUNT-(byte) 2+(number) 1
Resolved ranged next value [40] plexSort::plexFreePrepare1_s#1 ← ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [42] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to (number) 8
Resolved ranged next value [204] init::i#1 ← ++ init::i#2 to ++
Resolved ranged comparison value [206] if(init::i#1!=rangelast(0,PLEX_COUNT-1)) goto init::@1 to (const byte) PLEX_COUNT-(byte) 1+(number) 1
Resolved ranged next value [211] init::i1#1 ← ++ init::i1#2 to ++
Resolved ranged comparison value [213] if(init::i1#1!=rangelast(0,7)) goto init::@3 to (number) 8
Resolved ranged next value [261] loop::i#1 ← ++ loop::i#2 to ++
Resolved ranged comparison value [263] if(loop::i#1!=rangelast(0,NUM_BOBS-1)) goto loop::@6 to (const byte) NUM_BOBS-(byte) 1+(number) 1
Resolved ranged next value [283] loop::i1#1 ← ++ loop::i1#5 to ++
Resolved ranged comparison value [285] if(loop::i1#1!=rangelast(0,PLEX_COUNT-1)) goto loop::@14 to (const byte) PLEX_COUNT-(byte) 1+(number) 1
Eliminating unused variable - keeping the phi block (byte) plex_show_idx#31
Eliminating unused variable - keeping the phi block (byte) plex_sprite_idx#31
Eliminating unused variable - keeping the phi block (byte) plex_sprite_msb#29
Eliminating unused variable - keeping the phi block (byte) plex_free_next#29
Eliminating unused variable - keeping the phi block (byte) plex_show_idx#20
Eliminating unused variable - keeping the phi block (byte) plex_sprite_idx#20
Eliminating unused variable - keeping the phi block (byte) plex_sprite_msb#10
Eliminating unused variable - keeping the phi block (byte) plex_free_next#19
Eliminating unused constant (const void*) memset::return#2
Eliminating unused constant (const byte*) PLEX_SCREEN_PTR#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte) plex_show_idx#0
Eliminating unused constant (const byte) plex_sprite_idx#0
Eliminating unused constant (const byte) plex_sprite_msb#0
Eliminating unused constant (const byte) plex_free_next#31
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if((byte) plexInit::i#1!=(unumber)(const byte) PLEX_COUNT-(byte) 1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) PLEX_COUNT-2+1 in if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if((byte) plexSort::m#1!=(unumber)(const byte) PLEX_COUNT-(byte) 2+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) 8 in if((byte) plexSort::plexFreePrepare1_s#1!=(number) 8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if((byte) init::i#1!=(const byte) PLEX_COUNT-(byte) 1+(number) 1) goto init::@1
Adding number conversion cast (unumber) 1 in if((byte) init::i#1!=(unumber)(const byte) PLEX_COUNT-(byte) 1+(number) 1) goto init::@1
Adding number conversion cast (unumber) 8 in if((byte) init::i1#1!=(number) 8) goto init::@3
Adding number conversion cast (unumber) NUM_BOBS-1+1 in if((byte) loop::i#1!=(const byte) NUM_BOBS-(byte) 1+(number) 1) goto loop::@6
Adding number conversion cast (unumber) 1 in if((byte) loop::i#1!=(unumber)(const byte) NUM_BOBS-(byte) 1+(number) 1) goto loop::@6
Adding number conversion cast (unumber) PLEX_COUNT-1+1 in if((byte) loop::i1#1!=(const byte) PLEX_COUNT-(byte) 1+(number) 1) goto loop::@14
Adding number conversion cast (unumber) 1 in if((byte) loop::i1#1!=(unumber)(const byte) PLEX_COUNT-(byte) 1+(number) 1) goto loop::@14
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte) PLEX_COUNT-(byte) 1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) PLEX_COUNT-(byte) 2+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast (const byte) PLEX_COUNT-(byte) 1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast (const byte) NUM_BOBS-(byte) 1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) PLEX_COUNT-(byte) 1+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias plexShowSprite::$11 = plexShowSprite::$10 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) plexSort::$5 [19] if((byte) plexSort::s#1!=(byte) $ff) goto plexSort::@8
Simple Condition (bool~) plexSort::$6 [210] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [19] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [0] (byte*) PLEX_SCREEN_PTR#1 ← (const byte*) plexInit::screen#0 + (word) $3f8
Constant right-side identified [111] (byte*) memset::end#0 ← (const byte*) memset::$2 + (const word) memset::num#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) PLEX_SCREEN_PTR#1 = plexInit::screen#0+$3f8
Constant (const byte*) memset::end#0 = memset::$2+memset::num#0
Successful SSA optimization Pass2ConstantIdentification
Inlining Noop Cast [90] (byte~) mulf8s_prepared::$9 ← (byte)(signed byte) mulf8s_prepared::b#0 keeping mulf8s_prepared::b#0
Inlining Noop Cast [94] (signed word) mulf8s_prepared::return#0 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Inlining Noop Cast [96] (byte~) mulf8s_prepared::$13 ← (byte)*((const signed byte*) mulf8s_prepared::memA) keeping *(mulf8s_prepared::memA)
Successful SSA optimization Pass2NopCastInlining
Inlining Noop Cast [105] (signed word) mulf8s_prepared::return#2 ← (signed word)(word) mulf8s_prepared::m#4 keeping mulf8s_prepared::m#4
Successful SSA optimization Pass2NopCastInlining
Rewriting multiplication to use shift [24] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 * (byte) 2
Rewriting multiplication to use shift [33] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [44] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#43 * (byte) 2
Rewriting multiplication to use shift and addition[135] (byte~) init::$3 ← (byte) init::i#2 * (byte) 5
Rewriting multiplication to use shift [137] (byte~) init::$9 ← (byte) init::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [139] (byte~) init::$5 ← (byte) init::i#2 * (byte) 8
Rewriting multiplication to use shift [167] (signed word~) loop::$2 ← (signed word~) loop::$1 * (signed byte) 2
Rewriting multiplication to use shift [170] (byte~) loop::$20 ← (byte) loop::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [177] (signed word~) loop::$6 ← (signed word~) loop::$5 * (signed byte) 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) plexInit::i#0
Inlining constant with var siblings (const byte) plexSort::m#0
Inlining constant with var siblings (const byte) plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings (const word) mulf_init::sqr#0
Inlining constant with var siblings (const byte) mulf_init::x_2#0
Inlining constant with var siblings (const byte) mulf_init::c#0
Inlining constant with var siblings (const byte*) mulf_init::sqr1_hi#0
Inlining constant with var siblings (const byte*) mulf_init::sqr1_lo#0
Inlining constant with var siblings (const byte) mulf_init::x_255#0
Inlining constant with var siblings (const byte) mulf_init::dir#0
Inlining constant with var siblings (const byte*) mulf_init::sqr2_hi#0
Inlining constant with var siblings (const byte*) mulf_init::sqr2_lo#0
Inlining constant with var siblings (const byte) mulf_init::dir#1
Inlining constant with var siblings (const byte*) memset::dst#0
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#0
Inlining constant with var siblings (const byte) keyboard_key_pressed::key#1
Inlining constant with var siblings (const byte) init::i#0
Inlining constant with var siblings (const byte) init::i1#0
Inlining constant with var siblings (const byte) loop::angle#0
Inlining constant with var siblings (const signed byte) loop::r#0
Inlining constant with var siblings (const byte) loop::i#0
Inlining constant with var siblings (const byte) loop::i1#0
Inlining constant with var siblings (const byte) plex_show_idx#1
Inlining constant with var siblings (const byte) plex_sprite_idx#1
Inlining constant with var siblings (const byte) plex_sprite_msb#1
Inlining constant with var siblings (const byte) plex_free_next#0
Inlining constant with var siblings (const byte) plex_sprite_msb#4
Constant inlined mulf_init::c#0 = (byte) 0
Constant inlined mulf_init::sqr2_lo#0 = (const byte*) mulf_sqr2_lo
Constant inlined init::i#0 = (byte) 0
Constant inlined mulf_init::sqr2_hi#0 = (const byte*) mulf_sqr2_hi
Constant inlined plexSort::plexFreePrepare1_s#0 = (byte) 0
Constant inlined plexInit::i#0 = (byte) 0
Constant inlined plexSort::m#0 = (byte) 0
Constant inlined mulf_init::dir#1 = (byte) 1
Constant inlined plex_sprite_msb#4 = (byte) 1
Constant inlined memset::$2 = (byte*)(const void*) memset::str#0
Constant inlined mulf_init::dir#0 = (byte) $ff
Constant inlined plex_show_idx#1 = (byte) 0
Constant inlined plex_sprite_idx#1 = (byte) 0
Constant inlined plex_sprite_msb#1 = (byte) 1
Constant inlined plex_free_next#0 = (byte) 0
Constant inlined mulf_init::x_255#0 = (byte) -1
Constant inlined mulf_init::x_2#0 = (byte) 0
Constant inlined keyboard_key_pressed::key#0 = (const byte) KEY_SPACE
Constant inlined keyboard_key_pressed::key#1 = (const byte) KEY_SPACE
Constant inlined mulf_init::sqr#0 = (word) 0
Constant inlined loop::i1#0 = (byte) 0
Constant inlined plexInit::screen#0 = (const byte*) SCREEN
Constant inlined loop::angle#0 = (byte) 0
Constant inlined loop::i#0 = (byte) 0
Constant inlined mulf_init::sqr1_hi#0 = (const byte*) mulf_sqr1_hi+(byte) 1
Constant inlined init::i1#0 = (byte) 0
Constant inlined mulf_init::sqr1_lo#0 = (const byte*) mulf_sqr1_lo+(byte) 1
Constant inlined memset::dst#0 = (byte*)(const void*) memset::str#0
Constant inlined loop::r#0 = (signed byte) $1e
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(PLEX_SORTED_IDX+1 + plexSort::$1)
Consolidated array index constant in assignment *(PLEX_SORTED_IDX+1 + plexSort::$4)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias plexSort::m#2 = plexSort::$1 
Alias plexSort::s#3 = plexSort::$4 
Alias init::$3 = init::$11 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte) keyboard_key_pressed::key#2 (const byte) KEY_SPACE
Successful SSA optimization Pass2IdenticalPhiElimination
Constant right-side identified [111] (byte) keyboard_key_pressed::colidx#0 ← (const byte) KEY_SPACE & (byte) 7
Constant right-side identified [112] (byte) keyboard_key_pressed::rowidx#0 ← (const byte) KEY_SPACE >> (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) keyboard_key_pressed::colidx#0 = KEY_SPACE&7
Constant (const byte) keyboard_key_pressed::rowidx#0 = KEY_SPACE>>3
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte) keyboard_matrix_read::rowid#0 = keyboard_key_pressed::rowidx#0
Successful SSA optimization Pass2ConstantIdentification
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Constant inlined keyboard_matrix_read::rowid#0 = (const byte) keyboard_key_pressed::rowidx#0
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in *(keyboard_matrix_row_bitmask+keyboard_key_pressed::rowidx#0)
Consolidated array index constant in *(keyboard_matrix_col_bitmask+keyboard_key_pressed::colidx#0)
Successful SSA optimization Pass2ConstantAdditionElimination
Added new block during phi lifting plexInit::@4(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@10(between plexSort::@8 and plexSort::@3)
Added new block during phi lifting plexSort::@11(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting plexShowSprite::@8(between plexShowSprite::@2 and plexShowSprite::@return)
Added new block during phi lifting mulf_init::@17(between mulf_init::@2 and mulf_init::@4)
Added new block during phi lifting mulf_init::@18(between mulf_init::@10 and mulf_init::@12)
Added new block during phi lifting mulf8s_prepared::@7(between mulf8s_prepared::@6 and mulf8s_prepared::@1)
Added new block during phi lifting mulf8s_prepared::@8(between mulf8s_prepared::@1 and mulf8s_prepared::@2)
Added new block during phi lifting init::@8(between init::@1 and init::@1)
Added new block during phi lifting init::@9(between init::@3 and init::@3)
Added new block during phi lifting loop::@35(between loop::@34 and loop::@1)
Added new block during phi lifting loop::@36(between loop::@31 and loop::@6)
Added new block during phi lifting loop::@37(between loop::@33 and loop::@14)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @9
Adding NOP phi() at start of @37
Adding NOP phi() at start of @38
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of exit
Adding NOP phi() at start of exit::@1
Adding NOP phi() at start of keyboard_key_pressed
Adding NOP phi() at start of loop
Adding NOP phi() at start of loop::@10
Adding NOP phi() at start of loop::plexFreeNextYpos1_@return
Adding NOP phi() at start of loop::@29
Adding NOP phi() at start of plexShowSprite::@6
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::@6
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexSort::plexFreePrepare1_@2
Adding NOP phi() at start of mulf8s::@3
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of init::@4
Adding NOP phi() at start of init::@6
Adding NOP phi() at start of init::@7
Adding NOP phi() at start of memset
Adding NOP phi() at start of memset::@2
Adding NOP phi() at start of memset::@1
Adding NOP phi() at start of mulf_init
Adding NOP phi() at start of mulf_init::@3
Adding NOP phi() at start of mulf_init::@15
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1
Adding NOP phi() at start of plexInit::@3
CALL GRAPH
Calls in [] to main:4 
Calls in [main] to init:8 loop:10 exit:12 
Calls in [exit] to keyboard_key_pressed:17 
Calls in [keyboard_key_pressed] to keyboard_matrix_read:23 
Calls in [loop] to mulf8s:42 mulf8s:54 plexSort:66 plexShowSprite:79 keyboard_key_pressed:83 
Calls in [mulf8s] to mulf8u_prepare:151 mulf8s_prepared:154 
Calls in [mulf8s_prepared] to mulf8u_prepared:158 
Calls in [init] to plexInit:184 mulf_init:204 memset:206 

Created 33 initial phi equivalence classes
Not coalescing [35] loop::a#6 ← loop::angle#6
Coalesced [40] mulf8s::mulf8s_prepare1_a#3 ← mulf8s::a#0
Coalesced [41] mulf8s::b#7 ← mulf8s::b#0
Coalesced [52] mulf8s::mulf8s_prepare1_a#2 ← mulf8s::a#1
Coalesced [53] mulf8s::b#6 ← mulf8s::b#1
Coalesced [87] loop::angle#21 ← loop::angle#1
Coalesced [89] plex_free_next#48 ← plex_free_next#13
Coalesced [90] plex_sprite_idx#52 ← plex_sprite_idx#15
Coalesced [91] plex_show_idx#52 ← plex_show_idx#15
Coalesced [92] plex_sprite_msb#53 ← plex_sprite_msb#16
Coalesced [93] loop::i1#9 ← loop::i1#1
Coalesced [94] loop::r#5 ← loop::r#1
Coalesced [95] loop::a#5 ← loop::a#1
Coalesced [96] loop::i#5 ← loop::i#1
Coalesced [121] plex_sprite_msb#52 ← plex_sprite_msb#3
Not coalescing [128] plexSort::s#6 ← plexSort::m#2
Coalesced [146] plexSort::plexFreePrepare1_s#3 ← plexSort::plexFreePrepare1_s#1
Coalesced [147] plexSort::m#7 ← plexSort::m#1
Coalesced [148] plexSort::s#5 ← plexSort::s#1
Coalesced [165] mulf8s_prepared::m#7 ← mulf8s_prepared::m#1
Coalesced [171] mulf8s_prepared::m#10 ← mulf8s_prepared::m#2
Coalesced [174] mulf8s_prepared::m#9 ← mulf8s_prepared::m#5
Coalesced [175] mulf8s_prepared::m#8 ← mulf8s_prepared::m#0
Coalesced [209] init::i1#3 ← init::i1#1
Coalesced [210] init::i#3 ← init::i#1
Coalesced [219] memset::dst#4 ← memset::dst#1
Coalesced [237] mulf_init::sqr2_lo#6 ← mulf_init::sqr2_lo#1
Coalesced [238] mulf_init::x_255#6 ← mulf_init::x_255#1
Coalesced [239] mulf_init::sqr2_hi#6 ← mulf_init::sqr2_hi#1
Coalesced [240] mulf_init::dir#5 ← mulf_init::dir#4
Coalesced (already) [241] mulf_init::dir#6 ← mulf_init::dir#2
Coalesced [247] mulf_init::sqr#9 ← mulf_init::sqr#2
Coalesced [248] mulf_init::x_2#8 ← mulf_init::x_2#1
Coalesced [257] mulf_init::sqr1_lo#6 ← mulf_init::sqr1_lo#1
Coalesced [258] mulf_init::c#6 ← mulf_init::c#1
Coalesced [259] mulf_init::sqr#7 ← mulf_init::sqr#1
Coalesced [260] mulf_init::sqr1_hi#6 ← mulf_init::sqr1_hi#1
Coalesced [261] mulf_init::x_2#6 ← mulf_init::x_2#2
Coalesced [262] mulf_init::sqr#8 ← mulf_init::sqr#4
Coalesced (already) [263] mulf_init::x_2#7 ← mulf_init::x_2#3
Coalesced [272] plexInit::i#3 ← plexInit::i#1
Coalesced down to 28 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @9
Culled Empty Block (label) @38
Culled Empty Block (label) loop::@10
Culled Empty Block (label) loop::plexFreeNextYpos1_@return
Culled Empty Block (label) loop::@29
Culled Empty Block (label) loop::@35
Culled Empty Block (label) loop::@37
Culled Empty Block (label) loop::@36
Culled Empty Block (label) plexShowSprite::@6
Culled Empty Block (label) plexSort::@6
Culled Empty Block (label) plexSort::plexFreePrepare1_@2
Culled Empty Block (label) plexSort::@11
Culled Empty Block (label) plexSort::@9
Culled Empty Block (label) plexSort::@10
Culled Empty Block (label) mulf8s::@3
Culled Empty Block (label) mulf8s_prepared::@8
Culled Empty Block (label) mulf8s_prepared::@7
Culled Empty Block (label) init::@5
Culled Empty Block (label) init::@7
Culled Empty Block (label) init::@9
Culled Empty Block (label) init::@8
Culled Empty Block (label) memset::@2
Culled Empty Block (label) memset::@1
Culled Empty Block (label) mulf_init::@3
Culled Empty Block (label) mulf_init::@15
Culled Empty Block (label) mulf_init::@17
Culled Empty Block (label) plexInit::@3
Culled Empty Block (label) plexInit::@4
Renumbering block @37 to @1
Renumbering block plexSort::@8 to plexSort::@6
Renumbering block plexShowSprite::@4 to plexShowSprite::@3
Renumbering block plexShowSprite::@7 to plexShowSprite::@4
Renumbering block plexShowSprite::@8 to plexShowSprite::@5
Renumbering block mulf_init::@4 to mulf_init::@3
Renumbering block mulf_init::@7 to mulf_init::@4
Renumbering block mulf_init::@9 to mulf_init::@5
Renumbering block mulf_init::@10 to mulf_init::@6
Renumbering block mulf_init::@11 to mulf_init::@7
Renumbering block mulf_init::@12 to mulf_init::@8
Renumbering block mulf_init::@18 to mulf_init::@9
Renumbering block mulf8s_prepared::@6 to mulf8s_prepared::@5
Renumbering block mulf8s::@2 to mulf8s::@1
Renumbering block mulf8s::@4 to mulf8s::@2
Renumbering block memset::@4 to memset::@1
Renumbering block memset::@5 to memset::@2
Renumbering block keyboard_key_pressed::@2 to keyboard_key_pressed::@1
Renumbering block init::@6 to init::@5
Renumbering block exit::@7 to exit::@2
Renumbering block loop::@4 to loop::@2
Renumbering block loop::@5 to loop::@3
Renumbering block loop::@6 to loop::@4
Renumbering block loop::@7 to loop::@5
Renumbering block loop::@8 to loop::@6
Renumbering block loop::@14 to loop::@7
Renumbering block loop::@15 to loop::@8
Renumbering block loop::@17 to loop::@9
Renumbering block loop::@21 to loop::@10
Renumbering block loop::@30 to loop::@11
Renumbering block loop::@31 to loop::@12
Renumbering block loop::@32 to loop::@13
Renumbering block loop::@33 to loop::@14
Renumbering block loop::@34 to loop::@15
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of exit
Adding NOP phi() at start of exit::@1
Adding NOP phi() at start of keyboard_key_pressed
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexShowSprite::@5
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of init::@4
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of memset
Adding NOP phi() at start of mulf_init
Adding NOP phi() at start of mulf_init::@9
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  asm { sei  }
  [5] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [6] phi()
  [7] call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  [8] phi()
  [9] call exit 
  to:main::@3
main::@3: scope:[main]  from main::@2
  asm { cli  }
  to:main::@return
main::@return: scope:[main]  from main::@3
  [11] return 
  to:@return

(void()) exit()
exit: scope:[exit]  from main::@2
  [12] phi()
  to:exit::@1
exit::@1: scope:[exit]  from exit exit::@2
  [13] phi()
  [14] call keyboard_key_pressed 
  [15] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
  to:exit::@2
exit::@2: scope:[exit]  from exit::@1
  [16] (byte~) exit::$0 ← (byte) keyboard_key_pressed::return#2
  [17] if((byte) 0!=(byte~) exit::$0) goto exit::@1
  to:exit::@return
exit::@return: scope:[exit]  from exit::@2
  [18] return 
  to:@return

(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
keyboard_key_pressed: scope:[keyboard_key_pressed]  from exit::@1 loop::@10
  [19] phi()
  [20] call keyboard_matrix_read 
  [21] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
  to:keyboard_key_pressed::@1
keyboard_key_pressed::@1: scope:[keyboard_key_pressed]  from keyboard_key_pressed
  [22] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
  [23] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0)
  to:keyboard_key_pressed::@return
keyboard_key_pressed::@return: scope:[keyboard_key_pressed]  from keyboard_key_pressed::@1
  [24] return 
  to:@return

(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
keyboard_matrix_read: scope:[keyboard_matrix_read]  from keyboard_key_pressed
  [25] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0)
  [26] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B)
  to:keyboard_matrix_read::@return
keyboard_matrix_read::@return: scope:[keyboard_matrix_read]  from keyboard_matrix_read
  [27] return 
  to:@return

(void()) loop()
loop: scope:[loop]  from main::@1
  [28] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@15
  [29] (byte) loop::angle#6 ← phi( loop/(byte) 0 loop::@15/(byte) loop::angle#1 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [30] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  [31] *((const byte*) BORDERCOL) ← (byte) $f
  [32] (byte) loop::a#6 ← (byte) loop::angle#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@12 loop::@3
  [33] (byte) loop::i#2 ← phi( loop::@12/(byte) loop::i#1 loop::@3/(byte) 0 )
  [33] (byte) loop::a#2 ← phi( loop::@12/(byte) loop::a#1 loop::@3/(byte) loop::a#6 )
  [33] (signed byte) loop::r#2 ← phi( loop::@12/(signed byte) loop::r#1 loop::@3/(signed byte) $1e )
  [34] *((const byte*) BORDERCOL) ← (byte) 6
  [35] (signed byte) mulf8s::a#0 ← (signed byte) loop::r#2
  [36] (signed byte) mulf8s::b#0 ← *((const signed byte*) COS + (byte) loop::a#2)
  [37] call mulf8s 
  [38] (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#0
  to:loop::@11
loop::@11: scope:[loop]  from loop::@4
  [39] (signed word~) loop::$1 ← (signed word) mulf8s::return#2
  [40] (signed word~) loop::$2 ← (signed word~) loop::$1 << (byte) 1
  [41] (signed word) loop::x#0 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100
  [42] (byte~) loop::$4 ← > (signed word) loop::x#0
  [43] (byte~) loop::$20 ← (byte) loop::i#2 << (byte) 1
  [44] *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4
  [45] (signed byte) mulf8s::a#1 ← (signed byte) loop::r#2
  [46] (signed byte) mulf8s::b#1 ← *((const signed byte*) SIN + (byte) loop::a#2)
  [47] call mulf8s 
  [48] (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#0
  to:loop::@12
loop::@12: scope:[loop]  from loop::@11
  [49] (signed word~) loop::$5 ← (signed word) mulf8s::return#3
  [50] (signed word~) loop::$6 ← (signed word~) loop::$5 << (byte) 1
  [51] (signed word) loop::y#0 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100
  [52] (byte~) loop::$8 ← > (signed word) loop::y#0
  [53] *((const byte*) PLEX_YPOS + (byte) loop::i#2) ← (byte~) loop::$8
  [54] (byte) loop::a#1 ← (byte) loop::a#2 + (byte) $62
  [55] (signed byte) loop::r#1 ← (signed byte) loop::r#2 + (signed byte) 3
  [56] (byte) loop::i#1 ← ++ (byte) loop::i#2
  [57] if((byte) loop::i#1!=(const byte) NUM_BOBS-(byte) 1+(byte) 1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@12
  [58] *((const byte*) BORDERCOL) ← (byte) 3
  [59] call plexSort 
  to:loop::@13
loop::@13: scope:[loop]  from loop::@5
  [60] (byte) loop::angle#1 ← (byte) loop::angle#6 + (byte) 3
  [61] *((const byte*) BORDERCOL) ← (const byte) BLACK
  to:loop::@6
loop::@6: scope:[loop]  from loop::@13 loop::@6
  [62] (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8
  [63] if((byte~) loop::$11!=(byte) 0) goto loop::@6
  to:loop::@7
loop::@7: scope:[loop]  from loop::@14 loop::@6
  [64] (byte) loop::i1#5 ← phi( loop::@6/(byte) 0 loop::@14/(byte) loop::i1#1 )
  [64] (byte) plex_sprite_msb#43 ← phi( loop::@6/(byte) 1 loop::@14/(byte) plex_sprite_msb#16 )
  [64] (byte) plex_show_idx#43 ← phi( loop::@6/(byte) 0 loop::@14/(byte) plex_show_idx#15 )
  [64] (byte) plex_sprite_idx#43 ← phi( loop::@6/(byte) 0 loop::@14/(byte) plex_sprite_idx#15 )
  [64] (byte) plex_free_next#17 ← phi( loop::@6/(byte) 0 loop::@14/(byte) plex_free_next#13 )
  [65] *((const byte*) BORDERCOL) ← (const byte) BLACK
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@7
  [66] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17)
  to:loop::@8
loop::@8: scope:[loop]  from loop::@8 loop::plexFreeNextYpos1
  [67] if(*((const byte*) RASTER)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8
  to:loop::@9
loop::@9: scope:[loop]  from loop::@8
  [68] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL)
  [69] call plexShowSprite 
  to:loop::@14
loop::@14: scope:[loop]  from loop::@9
  [70] (byte) loop::i1#1 ← ++ (byte) loop::i1#5
  [71] if((byte) loop::i1#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@7
  to:loop::@10
loop::@10: scope:[loop]  from loop::@14
  [72] *((const byte*) BORDERCOL) ← (const byte) BLACK
  [73] call keyboard_key_pressed 
  [74] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
  to:loop::@15
loop::@15: scope:[loop]  from loop::@10
  [75] (byte~) loop::$18 ← (byte) keyboard_key_pressed::return#3
  [76] if((byte) 0!=(byte~) loop::$18) goto loop::@return
  to:loop::@1
loop::@return: scope:[loop]  from loop::@15
  [77] return 
  to:@return

(void()) plexShowSprite()
plexShowSprite: scope:[plexShowSprite]  from loop::@9
  [78] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 << (byte) 1
  [79] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43))
  [80] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [81] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15
  [82] *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0
  [83] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#17 + (byte) 1
  [84] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [85] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#43) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43))
  [86] (byte) plexShowSprite::xpos_idx#0 ← *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)
  [87] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1
  [88] (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11)
  [89] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2
  [90] (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11)
  [91] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@4
  [92] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#43
  [93] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [94] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#43 + (byte) 1
  [95] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7
  [96] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#43
  [97] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#43 << (byte) 1
  [98] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5
  to:plexShowSprite::@return
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::@2
  [99] phi()
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@5
  [100] (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@5/(byte) plex_sprite_msb#3 plexShowSprite::@2/(byte) 1 )
  [101] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@4
  [102] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#43
  to:plexShowSprite::@2

(void()) plexSort()
plexSort: scope:[plexSort]  from loop::@5
  [103] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [104] (byte) plexSort::m#2 ← phi( plexSort/(byte) 0 plexSort::@2/(byte) plexSort::m#1 )
  [105] (byte) plexSort::nxt_idx#0 ← *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2)
  [106] (byte) plexSort::nxt_y#0 ← *((const byte*) PLEX_YPOS + (byte) plexSort::nxt_idx#0)
  [107] if((byte) plexSort::nxt_y#0>=*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [108] (byte) plexSort::s#6 ← (byte) plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@6
  [109] (byte) plexSort::s#3 ← phi( plexSort::@6/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#6 )
  [110] *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3)
  [111] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  [112] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@3
  [113] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@6
  [114] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1
  [115] *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [116] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2
  [117] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@2
  [118] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [119] (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) 0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  [120] *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0
  [121] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2
  [122] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [123] return 
  to:@return

(signed word()) mulf8s((signed byte) mulf8s::a , (signed byte) mulf8s::b)
mulf8s: scope:[mulf8s]  from loop::@11 loop::@4
  [124] (signed byte) mulf8s::b#2 ← phi( loop::@11/(signed byte) mulf8s::b#1 loop::@4/(signed byte) mulf8s::b#0 )
  [124] (signed byte) mulf8s::mulf8s_prepare1_a#0 ← phi( loop::@11/(signed byte) mulf8s::a#1 loop::@4/(signed byte) mulf8s::a#0 )
  to:mulf8s::mulf8s_prepare1
mulf8s::mulf8s_prepare1: scope:[mulf8s]  from mulf8s
  [125] (byte) mulf8u_prepare::a#0 ← (byte)(signed byte) mulf8s::mulf8s_prepare1_a#0
  [126] call mulf8u_prepare 
  to:mulf8s::@1
mulf8s::@1: scope:[mulf8s]  from mulf8s::mulf8s_prepare1
  [127] (signed byte) mulf8s_prepared::b#0 ← (signed byte) mulf8s::b#2
  [128] call mulf8s_prepared 
  to:mulf8s::@2
mulf8s::@2: scope:[mulf8s]  from mulf8s::@1
  [129] (signed word) mulf8s::return#0 ← (signed word)(word) mulf8s_prepared::m#4
  to:mulf8s::@return
mulf8s::@return: scope:[mulf8s]  from mulf8s::@2
  [130] return 
  to:@return

(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
mulf8s_prepared: scope:[mulf8s_prepared]  from mulf8s::@1
  [131] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#0
  [132] call mulf8u_prepared 
  [133] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0
  to:mulf8s_prepared::@5
mulf8s_prepared::@5: scope:[mulf8s_prepared]  from mulf8s_prepared
  [134] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2
  [135] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1
  to:mulf8s_prepared::@3
mulf8s_prepared::@3: scope:[mulf8s_prepared]  from mulf8s_prepared::@5
  [136] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0
  [137] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#0
  [138] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15
  to:mulf8s_prepared::@1
mulf8s_prepared::@1: scope:[mulf8s_prepared]  from mulf8s_prepared::@3 mulf8s_prepared::@5
  [139] (word) mulf8s_prepared::m#5 ← phi( mulf8s_prepared::@3/(word) mulf8s_prepared::m#1 mulf8s_prepared::@5/(word) mulf8s_prepared::m#0 )
  [140] if((signed byte) mulf8s_prepared::b#0>=(signed byte) 0) goto mulf8s_prepared::@2
  to:mulf8s_prepared::@4
mulf8s_prepared::@4: scope:[mulf8s_prepared]  from mulf8s_prepared::@1
  [141] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5
  [142] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA)
  [143] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16
  to:mulf8s_prepared::@2
mulf8s_prepared::@2: scope:[mulf8s_prepared]  from mulf8s_prepared::@1 mulf8s_prepared::@4
  [144] (word) mulf8s_prepared::m#4 ← phi( mulf8s_prepared::@1/(word) mulf8s_prepared::m#5 mulf8s_prepared::@4/(word) mulf8s_prepared::m#2 )
  to:mulf8s_prepared::@return
mulf8s_prepared::@return: scope:[mulf8s_prepared]  from mulf8s_prepared::@2
  [145] return 
  to:@return

(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
mulf8u_prepared: scope:[mulf8u_prepared]  from mulf8s_prepared
  [146] *((const byte*) mulf8u_prepared::memB) ← (byte) mulf8u_prepared::b#0
  asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
  [148] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB) w= *((const byte*) mulf8u_prepared::resL)
  to:mulf8u_prepared::@return
mulf8u_prepared::@return: scope:[mulf8u_prepared]  from mulf8u_prepared
  [149] return 
  to:@return

(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
mulf8u_prepare: scope:[mulf8u_prepare]  from mulf8s::mulf8s_prepare1
  [150] *((const byte*) mulf8u_prepare::memA) ← (byte) mulf8u_prepare::a#0
  asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
  to:mulf8u_prepare::@return
mulf8u_prepare::@return: scope:[mulf8u_prepare]  from mulf8u_prepare
  [152] return 
  to:@return

(void()) init()
init: scope:[init]  from main
  [153] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3
  [154] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [155] (byte) init::i#2 ← phi( init::@1/(byte) init::i#1 init/(byte) 0 )
  [156] *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(byte) $40
  [157] (byte~) init::$10 ← (byte) init::i#2 << (byte) 2
  [158] (byte~) init::$3 ← (byte~) init::$10 + (byte) init::i#2
  [159] (byte~) init::$4 ← (byte) $18 + (byte~) init::$3
  [160] (byte~) init::$9 ← (byte) init::i#2 << (byte) 1
  [161] *((const word*) PLEX_XPOS + (byte~) init::$9) ← (byte~) init::$4
  [162] (byte~) init::$5 ← (byte) init::i#2 << (byte) 3
  [163] (byte~) init::$6 ← (byte) $32 + (byte~) init::$5
  [164] *((const byte*) PLEX_YPOS + (byte) init::i#2) ← (byte~) init::$6
  [165] (byte) init::i#1 ← ++ (byte) init::i#2
  [166] if((byte) init::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [167] *((const byte*) SPRITES_ENABLE) ← (byte) $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [168] (byte) init::i1#2 ← phi( init::@2/(byte) 0 init::@3/(byte) init::i1#1 )
  [169] *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN
  [170] (byte) init::i1#1 ← ++ (byte) init::i1#2
  [171] if((byte) init::i1#1!=(byte) 8) goto init::@3
  to:init::@4
init::@4: scope:[init]  from init::@3
  [172] phi()
  [173] call mulf_init 
  to:init::@5
init::@5: scope:[init]  from init::@4
  [174] phi()
  [175] call memset 
  to:init::@return
init::@return: scope:[init]  from init::@5
  [176] return 
  to:@return

(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
memset: scope:[memset]  from init::@5
  [177] phi()
  to:memset::@1
memset::@1: scope:[memset]  from memset memset::@2
  [178] (byte*) memset::dst#2 ← phi( memset/(byte*)(const void*) memset::str#0 memset::@2/(byte*) memset::dst#1 )
  [179] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [180] return 
  to:@return
memset::@2: scope:[memset]  from memset::@1
  [181] *((byte*) memset::dst#2) ← (const byte) memset::c#0
  [182] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2
  to:memset::@1

(void()) mulf_init()
mulf_init: scope:[mulf_init]  from init::@4
  [183] phi()
  to:mulf_init::@1
mulf_init::@1: scope:[mulf_init]  from mulf_init mulf_init::@3
  [184] (byte) mulf_init::x_2#3 ← phi( mulf_init/(byte) 0 mulf_init::@3/(byte) mulf_init::x_2#2 )
  [184] (byte*) mulf_init::sqr1_hi#2 ← phi( mulf_init/(const byte*) mulf_sqr1_hi+(byte) 1 mulf_init::@3/(byte*) mulf_init::sqr1_hi#1 )
  [184] (word) mulf_init::sqr#4 ← phi( mulf_init/(word) 0 mulf_init::@3/(word) mulf_init::sqr#1 )
  [184] (byte) mulf_init::c#2 ← phi( mulf_init/(byte) 0 mulf_init::@3/(byte) mulf_init::c#1 )
  [184] (byte*) mulf_init::sqr1_lo#2 ← phi( mulf_init/(const byte*) mulf_sqr1_lo+(byte) 1 mulf_init::@3/(byte*) mulf_init::sqr1_lo#1 )
  [185] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2
  to:mulf_init::@5
mulf_init::@5: scope:[mulf_init]  from mulf_init::@1 mulf_init::@8
  [186] (byte) mulf_init::dir#2 ← phi( mulf_init::@8/(byte) mulf_init::dir#4 mulf_init::@1/(byte) $ff )
  [186] (byte*) mulf_init::sqr2_hi#2 ← phi( mulf_init::@8/(byte*) mulf_init::sqr2_hi#1 mulf_init::@1/(const byte*) mulf_sqr2_hi )
  [186] (byte) mulf_init::x_255#2 ← phi( mulf_init::@8/(byte) mulf_init::x_255#1 mulf_init::@1/(byte) -1 )
  [186] (byte*) mulf_init::sqr2_lo#2 ← phi( mulf_init::@8/(byte*) mulf_init::sqr2_lo#1 mulf_init::@1/(const byte*) mulf_sqr2_lo )
  [187] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@6
  to:mulf_init::@7
mulf_init::@7: scope:[mulf_init]  from mulf_init::@5
  [188] *((const byte*) mulf_sqr2_lo+(word) $1ff) ← *((const byte*) mulf_sqr1_lo+(word) $100)
  [189] *((const byte*) mulf_sqr2_hi+(word) $1ff) ← *((const byte*) mulf_sqr1_hi+(word) $100)
  to:mulf_init::@return
mulf_init::@return: scope:[mulf_init]  from mulf_init::@7
  [190] return 
  to:@return
mulf_init::@6: scope:[mulf_init]  from mulf_init::@5
  [191] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2)
  [192] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2)
  [193] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2
  [194] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2
  [195] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@9
  to:mulf_init::@8
mulf_init::@9: scope:[mulf_init]  from mulf_init::@6
  [196] phi()
  to:mulf_init::@8
mulf_init::@8: scope:[mulf_init]  from mulf_init::@6 mulf_init::@9
  [197] (byte) mulf_init::dir#4 ← phi( mulf_init::@9/(byte) mulf_init::dir#2 mulf_init::@6/(byte) 1 )
  [198] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2
  to:mulf_init::@5
mulf_init::@2: scope:[mulf_init]  from mulf_init::@1
  [199] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2
  [200] (byte~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1
  [201] if((byte~) mulf_init::$1!=(byte) 0) goto mulf_init::@3
  to:mulf_init::@4
mulf_init::@4: scope:[mulf_init]  from mulf_init::@2
  [202] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3
  [203] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4
  to:mulf_init::@3
mulf_init::@3: scope:[mulf_init]  from mulf_init::@2 mulf_init::@4
  [204] (byte) mulf_init::x_2#2 ← phi( mulf_init::@2/(byte) mulf_init::x_2#3 mulf_init::@4/(byte) mulf_init::x_2#1 )
  [204] (word) mulf_init::sqr#3 ← phi( mulf_init::@2/(word) mulf_init::sqr#4 mulf_init::@4/(word) mulf_init::sqr#2 )
  [205] (byte~) mulf_init::$4 ← < (word) mulf_init::sqr#3
  [206] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$4
  [207] (byte~) mulf_init::$5 ← > (word) mulf_init::sqr#3
  [208] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5
  [209] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2
  [210] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2
  [211] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2
  to:mulf_init::@1

(void()) plexInit((byte*) plexInit::screen)
plexInit: scope:[plexInit]  from init
  [212] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [213] phi()
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [214] (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::plexSetScreen1/(byte) 0 )
  [215] *((const byte*) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  [216] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2
  [217] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [218] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte*) PLEX_SCREEN_PTR
(void()) exit()
(byte~) exit::$0 2002.0
(void()) init()
(byte~) init::$10 2002.0
(byte~) init::$3 2002.0
(byte~) init::$4 1001.0
(byte~) init::$5 2002.0
(byte~) init::$6 2002.0
(byte~) init::$9 2002.0
(byte) init::i
(byte) init::i#1 1501.5
(byte) init::i#2 800.8000000000001
(byte) init::i1
(byte) init::i1#1 1501.5
(byte) init::i1#2 1501.5
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 20002.0
(byte) keyboard_key_pressed::colidx
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 3000.75
(byte) keyboard_key_pressed::return#2 2002.0
(byte) keyboard_key_pressed::return#3 2002.0
(byte) keyboard_key_pressed::rowidx
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 36667.33333333333
(byte) keyboard_matrix_read::return#2 20002.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(void()) loop()
(signed word~) loop::$1 20002.0
(byte~) loop::$11 20002.0
(byte~) loop::$18 2002.0
(signed word~) loop::$2 20002.0
(byte~) loop::$20 20002.0
(byte~) loop::$4 10001.0
(signed word~) loop::$5 20002.0
(signed word~) loop::$6 20002.0
(byte~) loop::$8 20002.0
(byte) loop::a
(byte) loop::a#1 5000.5
(byte) loop::a#2 1952.6190476190475
(byte) loop::a#6 2002.0
(byte) loop::angle
(byte) loop::angle#1 117.76470588235294
(byte) loop::angle#6 96.87096774193549
(byte) loop::i
(byte) loop::i#1 15001.5
(byte) loop::i#2 1739.304347826087
(byte) loop::i1
(byte) loop::i1#1 15001.5
(byte) loop::i1#5 3333.6666666666665
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0 55001.0
(signed byte) loop::r
(signed byte) loop::r#1 6667.333333333333
(signed byte) loop::r#2 1818.3636363636363
(byte) loop::rasterY
(signed word) loop::x
(signed word) loop::x#0 20002.0
(signed word) loop::y
(signed word) loop::y#0 20002.0
(void()) main()
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte*) memset::dst
(byte*) memset::dst#1 20002.0
(byte*) memset::dst#2 13334.666666666666
(byte*) memset::end
(word) memset::num
(void*) memset::return
(void*) memset::str
(signed word()) mulf8s((signed byte) mulf8s::a , (signed byte) mulf8s::b)
(signed byte) mulf8s::a
(signed byte) mulf8s::a#0 10001.0
(signed byte) mulf8s::a#1 10001.0
(signed byte) mulf8s::b
(signed byte) mulf8s::b#0 20002.0
(signed byte) mulf8s::b#1 20002.0
(signed byte) mulf8s::b#2 40001.0
(signed byte) mulf8s::mulf8s_prepare1_a
(signed byte) mulf8s::mulf8s_prepare1_a#0 20002.0
(signed word) mulf8s::return
(signed word) mulf8s::return#0 30000.75
(signed word) mulf8s::return#2 20002.0
(signed word) mulf8s::return#3 20002.0
(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
(byte~) mulf8s_prepared::$12 2000002.0
(byte~) mulf8s_prepared::$15 2000002.0
(byte~) mulf8s_prepared::$16 2000002.0
(byte~) mulf8s_prepared::$8 2000002.0
(signed byte) mulf8s_prepared::b
(signed byte) mulf8s_prepared::b#0 110000.20000000001
(word) mulf8s_prepared::m
(word) mulf8s_prepared::m#0 1000001.0
(word) mulf8s_prepared::m#1 2000002.0
(word) mulf8s_prepared::m#2 2000002.0
(word) mulf8s_prepared::m#4 666667.3333333334
(word) mulf8s_prepared::m#5 1250001.25
(signed word) mulf8s_prepared::return
(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
(byte) mulf8u_prepare::a
(byte) mulf8u_prepare::a#0 1100002.0
(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
(byte) mulf8u_prepared::b
(byte) mulf8u_prepared::b#0 1.1000002E7
(word) mulf8u_prepared::return
(word) mulf8u_prepared::return#0 3666667.333333333
(word) mulf8u_prepared::return#2 2000002.0
(void()) mulf_init()
(byte~) mulf_init::$1 20002.0
(byte~) mulf_init::$4 20002.0
(byte~) mulf_init::$5 20002.0
(byte) mulf_init::c
(byte) mulf_init::c#1 2307.9230769230767
(byte) mulf_init::c#2 10001.0
(byte) mulf_init::dir
(byte) mulf_init::dir#2 3750.375
(byte) mulf_init::dir#4 10001.0
(word) mulf_init::sqr
(word) mulf_init::sqr#1 10001.0
(word) mulf_init::sqr#2 20002.0
(word) mulf_init::sqr#3 8334.166666666666
(word) mulf_init::sqr#4 5000.5
(byte*) mulf_init::sqr1_hi
(byte*) mulf_init::sqr1_hi#1 6667.333333333333
(byte*) mulf_init::sqr1_hi#2 2500.25
(byte*) mulf_init::sqr1_lo
(byte*) mulf_init::sqr1_lo#1 20002.0
(byte*) mulf_init::sqr1_lo#2 2857.4285714285716
(byte*) mulf_init::sqr2_hi
(byte*) mulf_init::sqr2_hi#1 3333.6666666666665
(byte*) mulf_init::sqr2_hi#2 7500.75
(byte*) mulf_init::sqr2_lo
(byte*) mulf_init::sqr2_lo#1 20002.0
(byte*) mulf_init::sqr2_lo#2 4444.888888888889
(byte) mulf_init::x_2
(byte) mulf_init::x_2#1 10001.0
(byte) mulf_init::x_2#2 5000.5
(byte) mulf_init::x_2#3 6000.6
(byte) mulf_init::x_255
(byte) mulf_init::x_255#1 6000.6
(byte) mulf_init::x_255#2 8000.8
(void()) plexInit((byte*) plexInit::screen)
(byte) plexInit::i
(byte) plexInit::i#1 15001.5
(byte) plexInit::i#2 20002.0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 100001.0
(byte~) plexShowSprite::$2 200002.0
(byte~) plexShowSprite::$3 200002.0
(byte~) plexShowSprite::$5 200002.0
(byte~) plexShowSprite::$9 200002.0
(byte~) plexShowSprite::plexFreeAdd1_$0 200002.0
(byte~) plexShowSprite::plexFreeAdd1_$1 200002.0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 150001.5
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 27273.0
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 200002.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(byte) plexSort::m
(byte) plexSort::m#1 1500001.5
(byte) plexSort::m#2 416667.0833333334
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 300000.30000000005
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 1500000.375
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 1500001.5
(byte) plexSort::plexFreePrepare1_s#2 1500001.5
(byte) plexSort::s
(byte) plexSort::s#1 1.3666668333333332E7
(byte) plexSort::s#2 2000002.0
(byte) plexSort::s#3 2.05000025E7
(byte) plexSort::s#6 2000002.0
(byte) plex_free_next
(byte) plex_free_next#13 5000.090909090909
(byte) plex_free_next#17 22000.4
(byte) plex_show_idx
(byte) plex_show_idx#15 12222.444444444445
(byte) plex_show_idx#43 17083.541666666664
(byte) plex_sprite_idx
(byte) plex_sprite_idx#15 11000.2
(byte) plex_sprite_idx#43 14091.090909090908
(byte) plex_sprite_msb
(byte) plex_sprite_msb#16 22000.4
(byte) plex_sprite_msb#3 100001.0
(byte) plex_sprite_msb#43 12400.16

Initial phi equivalence classes
[ loop::angle#6 loop::angle#1 ]
[ loop::r#2 loop::r#1 ]
[ loop::a#2 loop::a#1 loop::a#6 ]
[ loop::i#2 loop::i#1 ]
[ plex_free_next#17 plex_free_next#13 ]
[ plex_sprite_idx#43 plex_sprite_idx#15 ]
[ plex_show_idx#43 plex_show_idx#15 ]
[ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
[ loop::i1#5 loop::i1#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
[ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
[ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
[ init::i#2 init::i#1 ]
[ init::i1#2 init::i1#1 ]
[ memset::dst#2 memset::dst#1 ]
[ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
[ mulf_init::c#2 mulf_init::c#1 ]
[ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
[ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
[ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
[ mulf_init::x_255#2 mulf_init::x_255#1 ]
[ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
[ mulf_init::dir#2 mulf_init::dir#4 ]
[ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
[ plexInit::i#2 plexInit::i#1 ]
Added variable keyboard_key_pressed::return#2 to live range equivalence class [ keyboard_key_pressed::return#2 ]
Added variable exit::$0 to live range equivalence class [ exit::$0 ]
Added variable keyboard_matrix_read::return#2 to live range equivalence class [ keyboard_matrix_read::return#2 ]
Added variable keyboard_key_pressed::$2 to live range equivalence class [ keyboard_key_pressed::$2 ]
Added variable keyboard_key_pressed::return#0 to live range equivalence class [ keyboard_key_pressed::return#0 ]
Added variable keyboard_matrix_read::return#0 to live range equivalence class [ keyboard_matrix_read::return#0 ]
Added variable mulf8s::return#2 to live range equivalence class [ mulf8s::return#2 ]
Added variable loop::$1 to live range equivalence class [ loop::$1 ]
Added variable loop::$2 to live range equivalence class [ loop::$2 ]
Added variable loop::x#0 to live range equivalence class [ loop::x#0 ]
Added variable loop::$4 to live range equivalence class [ loop::$4 ]
Added variable loop::$20 to live range equivalence class [ loop::$20 ]
Added variable mulf8s::return#3 to live range equivalence class [ mulf8s::return#3 ]
Added variable loop::$5 to live range equivalence class [ loop::$5 ]
Added variable loop::$6 to live range equivalence class [ loop::$6 ]
Added variable loop::y#0 to live range equivalence class [ loop::y#0 ]
Added variable loop::$8 to live range equivalence class [ loop::$8 ]
Added variable loop::$11 to live range equivalence class [ loop::$11 ]
Added variable loop::plexFreeNextYpos1_return#0 to live range equivalence class [ loop::plexFreeNextYpos1_return#0 ]
Added variable keyboard_key_pressed::return#3 to live range equivalence class [ keyboard_key_pressed::return#3 ]
Added variable loop::$18 to live range equivalence class [ loop::$18 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to live range equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to live range equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$0 ]
Added variable plexShowSprite::plexFreeAdd1_$1 to live range equivalence class [ plexShowSprite::plexFreeAdd1_$1 ]
Added variable plexShowSprite::xpos_idx#0 to live range equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$11 to live range equivalence class [ plexShowSprite::$11 ]
Added variable plexShowSprite::$2 to live range equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$3 to live range equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$9 to live range equivalence class [ plexShowSprite::$9 ]
Added variable plexShowSprite::$5 to live range equivalence class [ plexShowSprite::$5 ]
Added variable plexSort::nxt_idx#0 to live range equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to live range equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to live range equivalence class [ plexSort::s#2 ]
Added variable mulf8u_prepare::a#0 to live range equivalence class [ mulf8u_prepare::a#0 ]
Added variable mulf8s_prepared::b#0 to live range equivalence class [ mulf8s_prepared::b#0 ]
Added variable mulf8s::return#0 to live range equivalence class [ mulf8s::return#0 ]
Added variable mulf8u_prepared::b#0 to live range equivalence class [ mulf8u_prepared::b#0 ]
Added variable mulf8u_prepared::return#2 to live range equivalence class [ mulf8u_prepared::return#2 ]
Added variable mulf8s_prepared::$8 to live range equivalence class [ mulf8s_prepared::$8 ]
Added variable mulf8s_prepared::$15 to live range equivalence class [ mulf8s_prepared::$15 ]
Added variable mulf8s_prepared::$12 to live range equivalence class [ mulf8s_prepared::$12 ]
Added variable mulf8s_prepared::$16 to live range equivalence class [ mulf8s_prepared::$16 ]
Added variable mulf8u_prepared::return#0 to live range equivalence class [ mulf8u_prepared::return#0 ]
Added variable init::$10 to live range equivalence class [ init::$10 ]
Added variable init::$3 to live range equivalence class [ init::$3 ]
Added variable init::$4 to live range equivalence class [ init::$4 ]
Added variable init::$9 to live range equivalence class [ init::$9 ]
Added variable init::$5 to live range equivalence class [ init::$5 ]
Added variable init::$6 to live range equivalence class [ init::$6 ]
Added variable mulf_init::$1 to live range equivalence class [ mulf_init::$1 ]
Added variable mulf_init::$4 to live range equivalence class [ mulf_init::$4 ]
Added variable mulf_init::$5 to live range equivalence class [ mulf_init::$5 ]
Complete equivalence classes
[ loop::angle#6 loop::angle#1 ]
[ loop::r#2 loop::r#1 ]
[ loop::a#2 loop::a#1 loop::a#6 ]
[ loop::i#2 loop::i#1 ]
[ plex_free_next#17 plex_free_next#13 ]
[ plex_sprite_idx#43 plex_sprite_idx#15 ]
[ plex_show_idx#43 plex_show_idx#15 ]
[ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
[ loop::i1#5 loop::i1#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
[ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
[ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
[ init::i#2 init::i#1 ]
[ init::i1#2 init::i1#1 ]
[ memset::dst#2 memset::dst#1 ]
[ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
[ mulf_init::c#2 mulf_init::c#1 ]
[ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
[ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
[ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
[ mulf_init::x_255#2 mulf_init::x_255#1 ]
[ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
[ mulf_init::dir#2 mulf_init::dir#4 ]
[ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
[ plexInit::i#2 plexInit::i#1 ]
[ keyboard_key_pressed::return#2 ]
[ exit::$0 ]
[ keyboard_matrix_read::return#2 ]
[ keyboard_key_pressed::$2 ]
[ keyboard_key_pressed::return#0 ]
[ keyboard_matrix_read::return#0 ]
[ mulf8s::return#2 ]
[ loop::$1 ]
[ loop::$2 ]
[ loop::x#0 ]
[ loop::$4 ]
[ loop::$20 ]
[ mulf8s::return#3 ]
[ loop::$5 ]
[ loop::$6 ]
[ loop::y#0 ]
[ loop::$8 ]
[ loop::$11 ]
[ loop::plexFreeNextYpos1_return#0 ]
[ keyboard_key_pressed::return#3 ]
[ loop::$18 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0 ]
[ plexShowSprite::plexFreeAdd1_$1 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$11 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$9 ]
[ plexShowSprite::$5 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ mulf8u_prepare::a#0 ]
[ mulf8s_prepared::b#0 ]
[ mulf8s::return#0 ]
[ mulf8u_prepared::b#0 ]
[ mulf8u_prepared::return#2 ]
[ mulf8s_prepared::$8 ]
[ mulf8s_prepared::$15 ]
[ mulf8s_prepared::$12 ]
[ mulf8s_prepared::$16 ]
[ mulf8u_prepared::return#0 ]
[ init::$10 ]
[ init::$3 ]
[ init::$4 ]
[ init::$9 ]
[ init::$5 ]
[ init::$6 ]
[ mulf_init::$1 ]
[ mulf_init::$4 ]
[ mulf_init::$5 ]
Allocated zp[1]:2 [ loop::angle#6 loop::angle#1 ]
Allocated zp[1]:3 [ loop::r#2 loop::r#1 ]
Allocated zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ]
Allocated zp[1]:5 [ loop::i#2 loop::i#1 ]
Allocated zp[1]:6 [ plex_free_next#17 plex_free_next#13 ]
Allocated zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ]
Allocated zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ]
Allocated zp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
Allocated zp[1]:10 [ loop::i1#5 loop::i1#1 ]
Allocated zp[1]:11 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp[1]:12 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp[1]:13 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp[1]:14 [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
Allocated zp[1]:15 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
Allocated zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ]
Allocated zp[1]:18 [ init::i#2 init::i#1 ]
Allocated zp[1]:19 [ init::i1#2 init::i1#1 ]
Allocated zp[2]:20 [ memset::dst#2 memset::dst#1 ]
Allocated zp[2]:22 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ]
Allocated zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ]
Allocated zp[2]:25 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
Allocated zp[1]:27 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Allocated zp[2]:28 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
Allocated zp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Allocated zp[2]:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
Allocated zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ]
Allocated zp[2]:34 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
Allocated zp[1]:36 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp[1]:37 [ keyboard_key_pressed::return#2 ]
Allocated zp[1]:38 [ exit::$0 ]
Allocated zp[1]:39 [ keyboard_matrix_read::return#2 ]
Allocated zp[1]:40 [ keyboard_key_pressed::$2 ]
Allocated zp[1]:41 [ keyboard_key_pressed::return#0 ]
Allocated zp[1]:42 [ keyboard_matrix_read::return#0 ]
Allocated zp[2]:43 [ mulf8s::return#2 ]
Allocated zp[2]:45 [ loop::$1 ]
Allocated zp[2]:47 [ loop::$2 ]
Allocated zp[2]:49 [ loop::x#0 ]
Allocated zp[1]:51 [ loop::$4 ]
Allocated zp[1]:52 [ loop::$20 ]
Allocated zp[2]:53 [ mulf8s::return#3 ]
Allocated zp[2]:55 [ loop::$5 ]
Allocated zp[2]:57 [ loop::$6 ]
Allocated zp[2]:59 [ loop::y#0 ]
Allocated zp[1]:61 [ loop::$8 ]
Allocated zp[1]:62 [ loop::$11 ]
Allocated zp[1]:63 [ loop::plexFreeNextYpos1_return#0 ]
Allocated zp[1]:64 [ keyboard_key_pressed::return#3 ]
Allocated zp[1]:65 [ loop::$18 ]
Allocated zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp[1]:67 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp[1]:68 [ plexShowSprite::plexFreeAdd1_$0 ]
Allocated zp[1]:69 [ plexShowSprite::plexFreeAdd1_$1 ]
Allocated zp[1]:70 [ plexShowSprite::xpos_idx#0 ]
Allocated zp[1]:71 [ plexShowSprite::$11 ]
Allocated zp[1]:72 [ plexShowSprite::$2 ]
Allocated zp[1]:73 [ plexShowSprite::$3 ]
Allocated zp[1]:74 [ plexShowSprite::$9 ]
Allocated zp[1]:75 [ plexShowSprite::$5 ]
Allocated zp[1]:76 [ plexSort::nxt_idx#0 ]
Allocated zp[1]:77 [ plexSort::nxt_y#0 ]
Allocated zp[1]:78 [ plexSort::s#2 ]
Allocated zp[1]:79 [ mulf8u_prepare::a#0 ]
Allocated zp[1]:80 [ mulf8s_prepared::b#0 ]
Allocated zp[2]:81 [ mulf8s::return#0 ]
Allocated zp[1]:83 [ mulf8u_prepared::b#0 ]
Allocated zp[2]:84 [ mulf8u_prepared::return#2 ]
Allocated zp[1]:86 [ mulf8s_prepared::$8 ]
Allocated zp[1]:87 [ mulf8s_prepared::$15 ]
Allocated zp[1]:88 [ mulf8s_prepared::$12 ]
Allocated zp[1]:89 [ mulf8s_prepared::$16 ]
Allocated zp[2]:90 [ mulf8u_prepared::return#0 ]
Allocated zp[1]:92 [ init::$10 ]
Allocated zp[1]:93 [ init::$3 ]
Allocated zp[1]:94 [ init::$4 ]
Allocated zp[1]:95 [ init::$9 ]
Allocated zp[1]:96 [ init::$5 ]
Allocated zp[1]:97 [ init::$6 ]
Allocated zp[1]:98 [ mulf_init::$1 ]
Allocated zp[1]:99 [ mulf_init::$4 ]
Allocated zp[1]:100 [ mulf_init::$5 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Same animation using a multiplexer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const KEY_SPACE = $3c
  // The BASIC screen
  .label SCREEN = $400
  // The number of BOBs to render
  .const NUM_BOBS = $10
  .label COS = SIN+$40
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = 9
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = 6
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = 7
  // The index in the PLEX tables of the next sprite to show
  // Prepare for showing the sprites
  .label plex_show_idx = 8
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // asm { sei  }
    sei
    // [5] call init 
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [7] call loop 
    // [28] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from___b1:
    jsr loop
    // [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] call exit 
    // [12] phi from main::@2 to exit [phi:main::@2->exit]
  exit_from___b2:
    jsr exit
    jmp __b3
    // main::@3
  __b3:
    // asm { cli  }
    cli
    jmp __breturn
    // main::@return
  __breturn:
    // [11] return 
    rts
}
  // exit
// Exit the program
exit: {
    .label __0 = $26
    // [13] phi from exit exit::@2 to exit::@1 [phi:exit/exit::@2->exit::@1]
  __b1_from_exit:
  __b1_from___b2:
    jmp __b1
  // Wait for space release
    // exit::@1
  __b1:
    // [14] call keyboard_key_pressed 
    // [19] phi from exit::@1 to keyboard_key_pressed [phi:exit::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    jsr keyboard_key_pressed
    // [15] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_1
    jmp __b2
    // exit::@2
  __b2:
    // [16] (byte~) exit::$0 ← (byte) keyboard_key_pressed::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_1
    sta.z __0
    // [17] if((byte) 0!=(byte~) exit::$0) goto exit::@1 -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __0
    bne __b1_from___b2
    jmp __breturn
    // exit::@return
  __breturn:
    // [18] return 
    rts
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    .label __2 = $28
    .label return = $29
    .label return_1 = $25
    .label return_2 = $40
    // [20] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [21] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return
    sta.z keyboard_matrix_read.return_1
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [22] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2 -- vbuz1=vbuz2 
    lda.z keyboard_matrix_read.return_1
    sta.z __2
    // [23] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0) -- vbuz1=vbuz2_band__deref_pbuc1 
    lda keyboard_matrix_col_bitmask+colidx
    and.z __2
    sta.z return
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [24] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    .label return = $2a
    .label return_1 = $27
    // [25] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1_PORT_A
    // [26] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuz1=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    sta.z return
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [27] return 
    rts
}
  // loop
// The main loop
loop: {
    .label __1 = $2d
    .label __2 = $2f
    .label __4 = $33
    .label __5 = $37
    .label __6 = $39
    .label __8 = $3d
    .label __11 = $3e
    .label __18 = $41
    .label __20 = $34
    .label x = $31
    .label y = $3b
    .label a = 4
    .label r = 3
    .label i = 5
    // Render Rotated BOBs
    .label angle = 2
    .label plexFreeNextYpos1_return = $3f
    .label i1 = $a
    // [29] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [29] phi (byte) loop::angle#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z angle
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [30] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@2 -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda RASTER
    cmp #$d8
    bcc __b2
    jmp __b3
    // loop::@3
  __b3:
    // [31] *((const byte*) BORDERCOL) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta BORDERCOL
    // [32] (byte) loop::a#6 ← (byte) loop::angle#6 -- vbuz1=vbuz2 
    lda.z angle
    sta.z a
    // [33] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [33] phi (byte) loop::i#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [33] phi (byte) loop::a#2 = (byte) loop::a#6 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [33] phi (signed byte) loop::r#2 = (signed byte) $1e [phi:loop::@3->loop::@4#2] -- vbsz1=vbsc1 
    lda #$1e
    sta.z r
    jmp __b4
    // [33] phi from loop::@12 to loop::@4 [phi:loop::@12->loop::@4]
  __b4_from___b12:
    // [33] phi (byte) loop::i#2 = (byte) loop::i#1 [phi:loop::@12->loop::@4#0] -- register_copy 
    // [33] phi (byte) loop::a#2 = (byte) loop::a#1 [phi:loop::@12->loop::@4#1] -- register_copy 
    // [33] phi (signed byte) loop::r#2 = (signed byte) loop::r#1 [phi:loop::@12->loop::@4#2] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [34] *((const byte*) BORDERCOL) ← (byte) 6 -- _deref_pbuc1=vbuc2 
    //kickasm {{ .break }}
    lda #6
    sta BORDERCOL
    // [35] (signed byte) mulf8s::a#0 ← (signed byte) loop::r#2 -- vbsz1=vbsz2 
    lda.z r
    sta.z mulf8s.a
    // [36] (signed byte) mulf8s::b#0 ← *((const signed byte*) COS + (byte) loop::a#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy.z a
    lda COS,y
    sta.z mulf8s.b
    // [37] call mulf8s 
    // [124] phi from loop::@4 to mulf8s [phi:loop::@4->mulf8s]
  mulf8s_from___b4:
    // [124] phi (signed byte) mulf8s::b#2 = (signed byte) mulf8s::b#0 [phi:loop::@4->mulf8s#0] -- register_copy 
    // [124] phi (signed byte) mulf8s::mulf8s_prepare1_a#0 = (signed byte) mulf8s::a#0 [phi:loop::@4->mulf8s#1] -- register_copy 
    jsr mulf8s
    // [38] (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#0 -- vwsz1=vwsz2 
    lda.z mulf8s.return
    sta.z mulf8s.return_1
    lda.z mulf8s.return+1
    sta.z mulf8s.return_1+1
    jmp __b11
    // loop::@11
  __b11:
    // [39] (signed word~) loop::$1 ← (signed word) mulf8s::return#2 -- vwsz1=vwsz2 
    lda.z mulf8s.return_1
    sta.z __1
    lda.z mulf8s.return_1+1
    sta.z __1+1
    // [40] (signed word~) loop::$2 ← (signed word~) loop::$1 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda.z __1
    asl
    sta.z __2
    lda.z __1+1
    rol
    sta.z __2+1
    // [41] (signed word) loop::x#0 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100 -- vwsz1=vwsz2_plus_vwsc1 
    lda.z __2
    clc
    adc #<$7d*$100
    sta.z x
    lda.z __2+1
    adc #>$7d*$100
    sta.z x+1
    // [42] (byte~) loop::$4 ← > (signed word) loop::x#0 -- vbuz1=_hi_vwsz2 
    lda.z x+1
    sta.z __4
    // [43] (byte~) loop::$20 ← (byte) loop::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __20
    // [44] *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4 -- pwuc1_derefidx_vbuz1=vbuz2 
    lda.z __20
    ldx.z __4
    tay
    txa
    sta PLEX_XPOS,y
    // [45] (signed byte) mulf8s::a#1 ← (signed byte) loop::r#2 -- vbsz1=vbsz2 
    lda.z r
    sta.z mulf8s.a
    // [46] (signed byte) mulf8s::b#1 ← *((const signed byte*) SIN + (byte) loop::a#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy.z a
    lda SIN,y
    sta.z mulf8s.b
    // [47] call mulf8s 
    // [124] phi from loop::@11 to mulf8s [phi:loop::@11->mulf8s]
  mulf8s_from___b11:
    // [124] phi (signed byte) mulf8s::b#2 = (signed byte) mulf8s::b#1 [phi:loop::@11->mulf8s#0] -- register_copy 
    // [124] phi (signed byte) mulf8s::mulf8s_prepare1_a#0 = (signed byte) mulf8s::a#1 [phi:loop::@11->mulf8s#1] -- register_copy 
    jsr mulf8s
    // [48] (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#0 -- vwsz1=vwsz2 
    lda.z mulf8s.return
    sta.z mulf8s.return_2
    lda.z mulf8s.return+1
    sta.z mulf8s.return_2+1
    jmp __b12
    // loop::@12
  __b12:
    // [49] (signed word~) loop::$5 ← (signed word) mulf8s::return#3 -- vwsz1=vwsz2 
    lda.z mulf8s.return_2
    sta.z __5
    lda.z mulf8s.return_2+1
    sta.z __5+1
    // [50] (signed word~) loop::$6 ← (signed word~) loop::$5 << (byte) 1 -- vwsz1=vwsz2_rol_1 
    lda.z __5
    asl
    sta.z __6
    lda.z __5+1
    rol
    sta.z __6+1
    // [51] (signed word) loop::y#0 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100 -- vwsz1=vwsz2_plus_vwsc1 
    lda.z __6
    clc
    adc #<$7d*$100
    sta.z y
    lda.z __6+1
    adc #>$7d*$100
    sta.z y+1
    // [52] (byte~) loop::$8 ← > (signed word) loop::y#0 -- vbuz1=_hi_vwsz2 
    lda.z y+1
    sta.z __8
    // [53] *((const byte*) PLEX_YPOS + (byte) loop::i#2) ← (byte~) loop::$8 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __8
    ldy.z i
    sta PLEX_YPOS,y
    // [54] (byte) loop::a#1 ← (byte) loop::a#2 + (byte) $62 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z a
    axs #-[$62]
    stx.z a
    // [55] (signed byte) loop::r#1 ← (signed byte) loop::r#2 + (signed byte) 3 -- vbsz1=vbsz1_plus_vbsc1 
    lax.z r
    axs #-[3]
    stx.z r
    // [56] (byte) loop::i#1 ← ++ (byte) loop::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [57] if((byte) loop::i#1!=(const byte) NUM_BOBS-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #NUM_BOBS-1+1
    cmp.z i
    bne __b4_from___b12
    jmp __b5
    // loop::@5
  __b5:
    // [58] *((const byte*) BORDERCOL) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta BORDERCOL
    // [59] call plexSort 
    // [103] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from___b5:
    jsr plexSort
    jmp __b13
    // loop::@13
  __b13:
    // [60] (byte) loop::angle#1 ← (byte) loop::angle#6 + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z angle
    axs #-[3]
    stx.z angle
    // [61] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp __b6
  // Sort the sprites by y-position
    // loop::@6
  __b6:
    // [62] (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    sta.z __11
    // [63] if((byte~) loop::$11!=(byte) 0) goto loop::@6 -- vbuz1_neq_0_then_la1 
    lda.z __11
    cmp #0
    bne __b6
    // [64] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  __b7_from___b6:
    // [64] phi (byte) loop::i1#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    // [64] phi (byte) plex_sprite_msb#43 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [64] phi (byte) plex_show_idx#43 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [64] phi (byte) plex_sprite_idx#43 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [64] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp __b7
  // Show the sprites
    // [64] phi from loop::@14 to loop::@7 [phi:loop::@14->loop::@7]
  __b7_from___b14:
    // [64] phi (byte) loop::i1#5 = (byte) loop::i1#1 [phi:loop::@14->loop::@7#0] -- register_copy 
    // [64] phi (byte) plex_sprite_msb#43 = (byte) plex_sprite_msb#16 [phi:loop::@14->loop::@7#1] -- register_copy 
    // [64] phi (byte) plex_show_idx#43 = (byte) plex_show_idx#15 [phi:loop::@14->loop::@7#2] -- register_copy 
    // [64] phi (byte) plex_sprite_idx#43 = (byte) plex_sprite_idx#15 [phi:loop::@14->loop::@7#3] -- register_copy 
    // [64] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@14->loop::@7#4] -- register_copy 
    jmp __b7
    // loop::@7
  __b7:
    // [65] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp plexFreeNextYpos1
    // loop::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [66] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    jmp __b8
    // loop::@8
  __b8:
    // [67] if(*((const byte*) RASTER)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc __b8
    jmp __b9
    // loop::@9
  __b9:
    // [68] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [69] call plexShowSprite 
    jsr plexShowSprite
    jmp __b14
    // loop::@14
  __b14:
    // [70] (byte) loop::i1#1 ← ++ (byte) loop::i1#5 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [71] if((byte) loop::i1#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i1
    bne __b7_from___b14
    jmp __b10
    // loop::@10
  __b10:
    // [72] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [73] call keyboard_key_pressed 
    // [19] phi from loop::@10 to keyboard_key_pressed [phi:loop::@10->keyboard_key_pressed]
  keyboard_key_pressed_from___b10:
    jsr keyboard_key_pressed
    // [74] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return
    sta.z keyboard_key_pressed.return_2
    jmp __b15
    // loop::@15
  __b15:
    // [75] (byte~) loop::$18 ← (byte) keyboard_key_pressed::return#3 -- vbuz1=vbuz2 
    lda.z keyboard_key_pressed.return_2
    sta.z __18
    // [76] if((byte) 0!=(byte~) loop::$18) goto loop::@return -- vbuc1_neq_vbuz1_then_la1 
    lda #0
    cmp.z __18
    bne __breturn
    // [29] phi from loop::@15 to loop::@1 [phi:loop::@15->loop::@1]
  __b1_from___b15:
    // [29] phi (byte) loop::angle#6 = (byte) loop::angle#1 [phi:loop::@15->loop::@1#0] -- register_copy 
    jmp __b1
    // loop::@return
  __breturn:
    // [77] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label __2 = $48
    .label __3 = $49
    .label __5 = $4b
    .label __9 = $4a
    .label __11 = $47
    .label plexFreeAdd1___0 = $44
    .label plexFreeAdd1___1 = $45
    .label plex_sprite_idx2 = $42
    .label plexFreeAdd1_ypos = $43
    .label xpos_idx = $46
    // [78] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [79] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) -- vbuz1=pbuc1_derefidx_(pbuc2_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    ldx PLEX_YPOS,y
    stx.z plexFreeAdd1_ypos
    // [80] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z plexFreeAdd1_ypos
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [81] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuz1=vbuz2_plus_vbuc1 
    lax.z plexFreeAdd1_ypos
    axs #-[$15]
    stx.z plexFreeAdd1___0
    // [82] *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z plexFreeAdd1___0
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [83] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#17 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z plex_free_next
    iny
    sty.z plexFreeAdd1___1
    // [84] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z plexFreeAdd1___1
    sta.z plex_free_next
    jmp __b4
    // plexShowSprite::@4
  __b4:
    // [85] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#43) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // [86] (byte) plexShowSprite::xpos_idx#0 ← *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    sta.z xpos_idx
    // [87] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z xpos_idx
    asl
    sta.z __11
    // [88] (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuz1=_lo_pwuc1_derefidx_vbuz2 
    ldy.z __11
    lda PLEX_XPOS,y
    sta.z __2
    // [89] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __2
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [90] (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuz1=_hi_pwuc1_derefidx_vbuz2 
    ldy.z __11
    lda PLEX_XPOS+1,y
    sta.z __3
    // [91] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuz1_neq_0_then_la1 
    lda.z __3
    cmp #0
    bne __b1
    jmp __b3
    // plexShowSprite::@3
  __b3:
    // [92] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#43 -- vbuz1=vbuc1_bxor_vbuz2 
    lda #$ff
    eor.z plex_sprite_msb
    sta.z __9
    // [93] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuz1 
    lda SPRITES_XMSB
    and.z __9
    sta SPRITES_XMSB
    jmp __b2
    // plexShowSprite::@2
  __b2:
    // [94] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#43 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z plex_sprite_idx
    iny
    sty.z __5
    // [95] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z __5
    sta.z plex_sprite_idx
    // [96] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#43 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [97] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#43 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [98] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __b5_from___b2
    // [100] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  __breturn_from___b2:
    // [100] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    jmp __breturn
    // [99] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  __b5_from___b2:
    jmp __b5
    // plexShowSprite::@5
  __b5:
    // [100] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  __breturn_from___b5:
    // [100] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    jmp __breturn
    // plexShowSprite::@return
  __breturn:
    // [101] return 
    rts
    // plexShowSprite::@1
  __b1:
    // [102] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#43 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $4c
    .label nxt_y = $4d
    .label m = $b
    .label s = $c
    .label s_1 = $4e
    .label plexFreePrepare1_s = $d
    // [104] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  __b1_from_plexSort:
    // [104] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp __b1
    // [104] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  __b1_from___b2:
    // [104] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp __b1
    // plexSort::@1
  __b1:
    // [105] (byte) plexSort::nxt_idx#0 ← *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [106] (byte) plexSort::nxt_y#0 ← *((const byte*) PLEX_YPOS + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [107] if((byte) plexSort::nxt_y#0>=*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    jmp __b5
    // plexSort::@5
  __b5:
    // [108] (byte) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuz1=vbuz2 
    lda.z m
    sta.z s
    // [109] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  __b3_from___b5:
  __b3_from___b6:
    // [109] phi (byte) plexSort::s#3 = (byte) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    jmp __b3
    // plexSort::@3
  __b3:
    // [110] *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z s
    lda PLEX_SORTED_IDX,y
    sta PLEX_SORTED_IDX+1,y
    // [111] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuz1=_dec_vbuz1 
    dec.z s
    // [112] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$ff
    cmp.z s
    beq __b4
    jmp __b6
    // plexSort::@6
  __b6:
    // [113] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z s
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3_from___b6
    jmp __b4
    // plexSort::@4
  __b4:
    // [114] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuz1=_inc_vbuz2 
    ldy.z s
    iny
    sty.z s_1
    // [115] *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z nxt_idx
    ldy.z s_1
    sta PLEX_SORTED_IDX,y
    jmp __b2
    // plexSort::@2
  __b2:
    // [116] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [117] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1_from___b2
    // [118] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  plexFreePrepare1_from___b2:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [119] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1:
    // [119] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z plexFreePrepare1_s
    jmp plexFreePrepare1___b1
    // [119] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1___b1:
    // [119] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // [120] *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy.z plexFreePrepare1_s
    sta PLEX_FREE_YPOS,y
    // [121] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuz1=_inc_vbuz1 
    inc.z plexFreePrepare1_s
    // [122] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z plexFreePrepare1_s
    bne plexFreePrepare1___b1_from_plexFreePrepare1___b1
    jmp __breturn
    // plexSort::@return
  __breturn:
    // [123] return 
    rts
}
  // mulf8s
// Fast multiply two signed bytes to a word result
// mulf8s(signed byte zp($e) a, signed byte zp($f) b)
mulf8s: {
    .label mulf8s_prepare1_a = $e
    .label return = $51
    .label a = $e
    .label b = $f
    .label return_1 = $2b
    .label return_2 = $35
    jmp mulf8s_prepare1
    // mulf8s::mulf8s_prepare1
  mulf8s_prepare1:
    // [125] (byte) mulf8u_prepare::a#0 ← (byte)(signed byte) mulf8s::mulf8s_prepare1_a#0 -- vbuz1=vbuz2 
    lda.z mulf8s_prepare1_a
    sta.z mulf8u_prepare.a
    // [126] call mulf8u_prepare 
    jsr mulf8u_prepare
    jmp __b1
    // mulf8s::@1
  __b1:
    // [127] (signed byte) mulf8s_prepared::b#0 ← (signed byte) mulf8s::b#2 -- vbsz1=vbsz2 
    lda.z b
    sta.z mulf8s_prepared.b
    // [128] call mulf8s_prepared 
    jsr mulf8s_prepared
    jmp __b2
    // mulf8s::@2
  __b2:
    // [129] (signed word) mulf8s::return#0 ← (signed word)(word) mulf8s_prepared::m#4 -- vwsz1=vwsz2 
    lda.z mulf8s_prepared.m
    sta.z return
    lda.z mulf8s_prepared.m+1
    sta.z return+1
    jmp __breturn
    // mulf8s::@return
  __breturn:
    // [130] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8s_prepare(byte a)
// mulf8s_prepared(signed byte zp($50) b)
mulf8s_prepared: {
    .label memA = $fd
    .label __8 = $56
    .label __12 = $58
    .label __15 = $57
    .label __16 = $59
    .label m = $10
    .label b = $50
    // [131] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#0 -- vbuz1=vbuz2 
    lda.z b
    sta.z mulf8u_prepared.b
    // [132] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [133] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 -- vwuz1=vwuz2 
    lda.z mulf8u_prepared.return
    sta.z mulf8u_prepared.return_1
    lda.z mulf8u_prepared.return+1
    sta.z mulf8u_prepared.return_1+1
    jmp __b5
    // mulf8s_prepared::@5
  __b5:
    // [134] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 -- vwuz1=vwuz2 
    lda.z mulf8u_prepared.return_1
    sta.z m
    lda.z mulf8u_prepared.return_1+1
    sta.z m+1
    // [135] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl __b1_from___b5
    jmp __b3
    // mulf8s_prepared::@3
  __b3:
    // [136] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 -- vbuz1=_hi_vwuz2 
    lda.z m+1
    sta.z __8
    // [137] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#0 -- vbuz1=vbuz2_minus_vbuz3 
    lda.z __8
    sec
    sbc.z b
    sta.z __15
    // [138] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15 -- vwuz1=vwuz1_sethi_vbuz2 
    lda.z __15
    sta.z m+1
    // [139] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
  __b1_from___b3:
  __b1_from___b5:
    // [139] phi (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    jmp __b1
    // mulf8s_prepared::@1
  __b1:
    // [140] if((signed byte) mulf8s_prepared::b#0>=(signed byte) 0) goto mulf8s_prepared::@2 -- vbsz1_ge_0_then_la1 
    lda.z b
    cmp #0
    bpl __b2_from___b1
    jmp __b4
    // mulf8s_prepared::@4
  __b4:
    // [141] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 -- vbuz1=_hi_vwuz2 
    lda.z m+1
    sta.z __12
    // [142] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA) -- vbuz1=vbuz2_minus__deref_pbuc1 
    lda.z __12
    sec
    sbc memA
    sta.z __16
    // [143] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16 -- vwuz1=vwuz1_sethi_vbuz2 
    lda.z __16
    sta.z m+1
    // [144] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
  __b2_from___b1:
  __b2_from___b4:
    // [144] phi (word) mulf8s_prepared::m#4 = (word) mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    jmp __b2
    // mulf8s_prepared::@2
  __b2:
    jmp __breturn
    // mulf8s_prepared::@return
  __breturn:
    // [145] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8u_prepare(byte a)
// mulf8u_prepared(byte zp($53) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = $5a
    .label b = $53
    .label return_1 = $54
    // [146] *((const byte*) mulf8u_prepared::memB) ← (byte) mulf8u_prepared::b#0 -- _deref_pbuc1=vbuz1 
    lda.z b
    sta memB
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    ldx memB
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // [148] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB) w= *((const byte*) mulf8u_prepared::resL) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta.z return
    lda memB
    sta.z return+1
    jmp __breturn
    // mulf8u_prepared::@return
  __breturn:
    // [149] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned byte to a word result
// mulf8u_prepare(byte zp($4f) a)
mulf8u_prepare: {
    .label memA = $fd
    .label a = $4f
    // [150] *((const byte*) mulf8u_prepare::memA) ← (byte) mulf8u_prepare::a#0 -- _deref_pbuc1=vbuz1 
    lda.z a
    sta memA
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    lda memA
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    jmp __breturn
    // mulf8u_prepare::@return
  __breturn:
    // [152] return 
    rts
}
  // init
// Initialize the program
init: {
    .label __3 = $5d
    .label __4 = $5e
    .label __5 = $60
    .label __6 = $61
    .label __9 = $5f
    .label i = $12
    .label i1 = $13
    .label __10 = $5c
    // [153] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [154] call plexInit 
  // Initialize the multiplexer
    // [212] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [155] phi from init to init::@1 [phi:init->init::@1]
  __b1_from_init:
    // [155] phi (byte) init::i#2 = (byte) 0 [phi:init->init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
  // Set the sprite pointers & initial positions
    // [155] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  __b1_from___b1:
    // [155] phi (byte) init::i#2 = (byte) init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    jmp __b1
    // init::@1
  __b1:
    // [156] *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #$ff&SPRITE/$40
    ldy.z i
    sta PLEX_PTR,y
    // [157] (byte~) init::$10 ← (byte) init::i#2 << (byte) 2 -- vbuz1=vbuz2_rol_2 
    lda.z i
    asl
    asl
    sta.z __10
    // [158] (byte~) init::$3 ← (byte~) init::$10 + (byte) init::i#2 -- vbuz1=vbuz2_plus_vbuz3 
    lda.z __10
    clc
    adc.z i
    sta.z __3
    // [159] (byte~) init::$4 ← (byte) $18 + (byte~) init::$3 -- vbuz1=vbuc1_plus_vbuz2 
    lax.z __3
    axs #-[$18]
    stx.z __4
    // [160] (byte~) init::$9 ← (byte) init::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __9
    // [161] *((const word*) PLEX_XPOS + (byte~) init::$9) ← (byte~) init::$4 -- pwuc1_derefidx_vbuz1=vbuz2 
    lda.z __9
    ldx.z __4
    tay
    txa
    sta PLEX_XPOS,y
    // [162] (byte~) init::$5 ← (byte) init::i#2 << (byte) 3 -- vbuz1=vbuz2_rol_3 
    lda.z i
    asl
    asl
    asl
    sta.z __5
    // [163] (byte~) init::$6 ← (byte) $32 + (byte~) init::$5 -- vbuz1=vbuc1_plus_vbuz2 
    lax.z __5
    axs #-[$32]
    stx.z __6
    // [164] *((const byte*) PLEX_YPOS + (byte) init::i#2) ← (byte~) init::$6 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z __6
    ldy.z i
    sta PLEX_YPOS,y
    // [165] (byte) init::i#1 ← ++ (byte) init::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [166] if((byte) init::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1_from___b1
    jmp __b2
    // init::@2
  __b2:
    // [167] *((const byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [168] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  __b3_from___b2:
    // [168] phi (byte) init::i1#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    jmp __b3
    // [168] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  __b3_from___b3:
    // [168] phi (byte) init::i1#2 = (byte) init::i1#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp __b3
    // init::@3
  __b3:
    // [169] *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z i1
    sta SPRITES_COLS,y
    // [170] (byte) init::i1#1 ← ++ (byte) init::i1#2 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [171] if((byte) init::i1#1!=(byte) 8) goto init::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z i1
    bne __b3_from___b3
    // [172] phi from init::@3 to init::@4 [phi:init::@3->init::@4]
  __b4_from___b3:
    jmp __b4
    // init::@4
  __b4:
    // [173] call mulf_init 
    // [183] phi from init::@4 to mulf_init [phi:init::@4->mulf_init]
  mulf_init_from___b4:
    jsr mulf_init
    // [174] phi from init::@4 to init::@5 [phi:init::@4->init::@5]
  __b5_from___b4:
    jmp __b5
    // init::@5
  __b5:
    // [175] call memset 
  // Clear screen
    // [177] phi from init::@5 to memset [phi:init::@5->memset]
  memset_from___b5:
    jsr memset
    jmp __breturn
    // init::@return
  __breturn:
    // [176] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .label str = SCREEN
    .const c = ' '
    .const num = $3e8
    .label end = str+num
    .label dst = $14
    // [178] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [178] phi (byte*) memset::dst#2 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [179] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [180] return 
    rts
    // memset::@2
  __b2:
    // [181] *((byte*) memset::dst#2) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [182] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [178] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [178] phi (byte*) memset::dst#2 = (byte*) memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    .label __1 = $62
    .label __4 = $63
    .label __5 = $64
    // x/2
    .label c = $18
    // Counter used for determining x%2==0
    .label sqr1_hi = $19
    // Fill mulf_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
    .label sqr = $22
    .label sqr1_lo = $16
    // sqr = (x*x)/4
    .label x_2 = $1b
    // Decrease or increase x_255 - initially we decrease
    .label sqr2_hi = $1f
    // Fill mulf_sqr2 = g(x) = f(x-255) : If x-255<0 then g(x)=f(255-x) (because x*x = -x*-x)
    // g(0) = f(255), g(1) = f(254), ..., g(254) = f(1), g(255) = f(0), g(256) = f(1), ..., g(510) = f(255), g(511) = f(256)
    .label x_255 = $1e
    .label sqr2_lo = $1c
    //Start with g(0)=f(255)
    .label dir = $21
    // [184] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
  __b1_from_mulf_init:
    // [184] phi (byte) mulf_init::x_2#3 = (byte) 0 [phi:mulf_init->mulf_init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z x_2
    // [184] phi (byte*) mulf_init::sqr1_hi#2 = (const byte*) mulf_sqr1_hi+(byte) 1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta.z sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta.z sqr1_hi+1
    // [184] phi (word) mulf_init::sqr#4 = (word) 0 [phi:mulf_init->mulf_init::@1#2] -- vwuz1=vwuc1 
    lda #<0
    sta.z sqr
    lda #>0
    sta.z sqr+1
    // [184] phi (byte) mulf_init::c#2 = (byte) 0 [phi:mulf_init->mulf_init::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // [184] phi (byte*) mulf_init::sqr1_lo#2 = (const byte*) mulf_sqr1_lo+(byte) 1 [phi:mulf_init->mulf_init::@1#4] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta.z sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta.z sqr1_lo+1
    jmp __b1
    // mulf_init::@1
  __b1:
    // [185] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne __b2
    lda.z sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne __b2
    // [186] phi from mulf_init::@1 to mulf_init::@5 [phi:mulf_init::@1->mulf_init::@5]
  __b5_from___b1:
    // [186] phi (byte) mulf_init::dir#2 = (byte) $ff [phi:mulf_init::@1->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z dir
    // [186] phi (byte*) mulf_init::sqr2_hi#2 = (const byte*) mulf_sqr2_hi [phi:mulf_init::@1->mulf_init::@5#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta.z sqr2_hi
    lda #>mulf_sqr2_hi
    sta.z sqr2_hi+1
    // [186] phi (byte) mulf_init::x_255#2 = (byte) -1 [phi:mulf_init::@1->mulf_init::@5#2] -- vbuz1=vbuc1 
    lda #-1
    sta.z x_255
    // [186] phi (byte*) mulf_init::sqr2_lo#2 = (const byte*) mulf_sqr2_lo [phi:mulf_init::@1->mulf_init::@5#3] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta.z sqr2_lo
    lda #>mulf_sqr2_lo
    sta.z sqr2_lo+1
    jmp __b5
    // mulf_init::@5
  __b5:
    // [187] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@6 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne __b6
    lda.z sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne __b6
    jmp __b7
    // mulf_init::@7
  __b7:
    // [188] *((const byte*) mulf_sqr2_lo+(word) $1ff) ← *((const byte*) mulf_sqr1_lo+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // [189] *((const byte*) mulf_sqr2_hi+(word) $1ff) ← *((const byte*) mulf_sqr1_hi+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    jmp __breturn
    // mulf_init::@return
  __breturn:
    // [190] return 
    rts
    // mulf_init::@6
  __b6:
    // [191] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z x_255
    lda mulf_sqr1_lo,y
    ldy #0
    sta (sqr2_lo),y
    // [192] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuz2 
    ldy.z x_255
    lda mulf_sqr1_hi,y
    ldy #0
    sta (sqr2_hi),y
    // [193] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_hi
    bne !+
    inc.z sqr2_hi+1
  !:
    // [194] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 -- vbuz1=vbuz1_plus_vbuz2 
    lda.z x_255
    clc
    adc.z dir
    sta.z x_255
    // [195] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@9 -- vbuz1_neq_0_then_la1 
    lda.z x_255
    cmp #0
    bne __b9_from___b6
    // [197] phi from mulf_init::@6 to mulf_init::@8 [phi:mulf_init::@6->mulf_init::@8]
  __b8_from___b6:
    // [197] phi (byte) mulf_init::dir#4 = (byte) 1 [phi:mulf_init::@6->mulf_init::@8#0] -- vbuz1=vbuc1 
    lda #1
    sta.z dir
    jmp __b8
    // [196] phi from mulf_init::@6 to mulf_init::@9 [phi:mulf_init::@6->mulf_init::@9]
  __b9_from___b6:
    jmp __b9
    // mulf_init::@9
  __b9:
    // [197] phi from mulf_init::@9 to mulf_init::@8 [phi:mulf_init::@9->mulf_init::@8]
  __b8_from___b9:
    // [197] phi (byte) mulf_init::dir#4 = (byte) mulf_init::dir#2 [phi:mulf_init::@9->mulf_init::@8#0] -- register_copy 
    jmp __b8
    // mulf_init::@8
  __b8:
    // [198] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_lo
    bne !+
    inc.z sqr2_lo+1
  !:
    // [186] phi from mulf_init::@8 to mulf_init::@5 [phi:mulf_init::@8->mulf_init::@5]
  __b5_from___b8:
    // [186] phi (byte) mulf_init::dir#2 = (byte) mulf_init::dir#4 [phi:mulf_init::@8->mulf_init::@5#0] -- register_copy 
    // [186] phi (byte*) mulf_init::sqr2_hi#2 = (byte*) mulf_init::sqr2_hi#1 [phi:mulf_init::@8->mulf_init::@5#1] -- register_copy 
    // [186] phi (byte) mulf_init::x_255#2 = (byte) mulf_init::x_255#1 [phi:mulf_init::@8->mulf_init::@5#2] -- register_copy 
    // [186] phi (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#1 [phi:mulf_init::@8->mulf_init::@5#3] -- register_copy 
    jmp __b5
    // mulf_init::@2
  __b2:
    // [199] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [200] (byte~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1 -- vbuz1=vbuz2_band_vbuc1 
    lda #1
    and.z c
    sta.z __1
    // [201] if((byte~) mulf_init::$1!=(byte) 0) goto mulf_init::@3 -- vbuz1_neq_0_then_la1 
    lda.z __1
    cmp #0
    bne __b3_from___b2
    jmp __b4
    // mulf_init::@4
  __b4:
    // [202] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3 -- vbuz1=_inc_vbuz1 
    inc.z x_2
    // [203] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc.z sqr
    bne !+
    inc.z sqr+1
  !:
    // [204] phi from mulf_init::@2 mulf_init::@4 to mulf_init::@3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [204] phi (byte) mulf_init::x_2#2 = (byte) mulf_init::x_2#3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#0] -- register_copy 
    // [204] phi (word) mulf_init::sqr#3 = (word) mulf_init::sqr#4 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#1] -- register_copy 
    jmp __b3
    // mulf_init::@3
  __b3:
    // [205] (byte~) mulf_init::$4 ← < (word) mulf_init::sqr#3 -- vbuz1=_lo_vwuz2 
    lda.z sqr
    sta.z __4
    // [206] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$4 -- _deref_pbuz1=vbuz2 
    lda.z __4
    ldy #0
    sta (sqr1_lo),y
    // [207] (byte~) mulf_init::$5 ← > (word) mulf_init::sqr#3 -- vbuz1=_hi_vwuz2 
    lda.z sqr+1
    sta.z __5
    // [208] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5 -- _deref_pbuz1=vbuz2 
    lda.z __5
    ldy #0
    sta (sqr1_hi),y
    // [209] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_hi
    bne !+
    inc.z sqr1_hi+1
  !:
    // [210] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuz2 
    lda.z x_2
    clc
    adc.z sqr
    sta.z sqr
    bcc !+
    inc.z sqr+1
  !:
    // [211] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_lo
    bne !+
    inc.z sqr1_lo+1
  !:
    // [184] phi from mulf_init::@3 to mulf_init::@1 [phi:mulf_init::@3->mulf_init::@1]
  __b1_from___b3:
    // [184] phi (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#2 [phi:mulf_init::@3->mulf_init::@1#0] -- register_copy 
    // [184] phi (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#1 [phi:mulf_init::@3->mulf_init::@1#1] -- register_copy 
    // [184] phi (word) mulf_init::sqr#4 = (word) mulf_init::sqr#1 [phi:mulf_init::@3->mulf_init::@1#2] -- register_copy 
    // [184] phi (byte) mulf_init::c#2 = (byte) mulf_init::c#1 [phi:mulf_init::@3->mulf_init::@1#3] -- register_copy 
    // [184] phi (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#1 [phi:mulf_init::@3->mulf_init::@1#4] -- register_copy 
    jmp __b1
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    .label i = $24
    // [213] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [214] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  __b1_from_plexSetScreen1:
    // [214] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
    // [214] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  __b1_from___b1:
    // [214] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp __b1
    // plexInit::@1
  __b1:
    // [215] *((const byte*) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy.z i
    tya
    sta PLEX_SORTED_IDX,y
    // [216] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [217] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1_from___b1
    jmp __breturn
    // plexInit::@return
  __breturn:
    // [218] return 
    rts
}
  // File Data
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // The BOB sprite
  .align $1000
SPRITE:
.var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  // Sine and Cosine tables
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [25] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) [ ] ( main:2::exit:9::keyboard_key_pressed:14::keyboard_matrix_read:20 [ ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:2::loop:7::keyboard_key_pressed:73::keyboard_matrix_read:20 [ loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ loop::angle#6 loop::angle#1 ]
Statement [26] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::exit:9::keyboard_key_pressed:14::keyboard_matrix_read:20 [ keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:2::loop:7::keyboard_key_pressed:73::keyboard_matrix_read:20 [ loop::angle#1 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [30] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@2 [ loop::angle#6 ] ( main:2::loop:7 [ loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [31] *((const byte*) BORDERCOL) ← (byte) $f [ loop::angle#6 ] ( main:2::loop:7 [ loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [34] *((const byte*) BORDERCOL) ← (byte) 6 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:3 [ loop::r#2 loop::r#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ]
Removing always clobbered register reg byte a as potential for zp[1]:5 [ loop::i#2 loop::i#1 ]
Statement [38] (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#0 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [39] (signed word~) loop::$1 ← (signed word) mulf8s::return#2 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [40] (signed word~) loop::$2 ← (signed word~) loop::$1 << (byte) 1 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [41] (signed word) loop::x#0 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [43] (byte~) loop::$20 ← (byte) loop::i#2 << (byte) 1 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:51 [ loop::$4 ]
Statement [44] *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [48] (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#0 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [49] (signed word~) loop::$5 ← (signed word) mulf8s::return#3 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] { }  ) always clobbers reg byte a 
Statement [50] (signed word~) loop::$6 ← (signed word~) loop::$5 << (byte) 1 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] { }  ) always clobbers reg byte a 
Statement [51] (signed word) loop::y#0 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] { }  ) always clobbers reg byte a 
Statement [54] (byte) loop::a#1 ← (byte) loop::a#2 + (byte) $62 [ loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [55] (signed byte) loop::r#1 ← (signed byte) loop::r#2 + (signed byte) 3 [ loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] ( main:2::loop:7 [ loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [58] *((const byte*) BORDERCOL) ← (byte) 3 [ loop::angle#6 ] ( main:2::loop:7 [ loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [60] (byte) loop::angle#1 ← (byte) loop::angle#6 + (byte) 3 [ loop::angle#1 ] ( main:2::loop:7 [ loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [61] *((const byte*) BORDERCOL) ← (const byte) BLACK [ loop::angle#1 ] ( main:2::loop:7 [ loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [62] (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8 [ loop::angle#1 loop::$11 ] ( main:2::loop:7 [ loop::angle#1 loop::$11 ] { }  ) always clobbers reg byte a 
Statement [65] *((const byte*) BORDERCOL) ← (const byte) BLACK [ loop::angle#1 plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 loop::i1#5 ] ( main:2::loop:7 [ loop::angle#1 plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 loop::i1#5 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:6 [ plex_free_next#17 plex_free_next#13 ]
Removing always clobbered register reg byte a as potential for zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ]
Removing always clobbered register reg byte a as potential for zp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
Removing always clobbered register reg byte a as potential for zp[1]:10 [ loop::i1#5 loop::i1#1 ]
Statement [72] *((const byte*) BORDERCOL) ← (const byte) BLACK [ loop::angle#1 ] ( main:2::loop:7 [ loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } }  ) always clobbers reg byte a 
Statement [78] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 << (byte) 1 [ plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plexShowSprite::plex_sprite_idx2#0 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [85] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#43) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [87] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] { }  ) always clobbers reg byte a 
Statement [88] (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:71 [ plexShowSprite::$11 ]
Statement [90] (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$3 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$3 ] { }  ) always clobbers reg byte a 
Statement [92] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#43 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$9 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$9 ] { }  ) always clobbers reg byte a 
Statement [93] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] { }  ) always clobbers reg byte a 
Statement [102] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#43 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] { }  ) always clobbers reg byte a 
Statement [110] *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:11 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:76 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:77 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:12 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [113] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [115] *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [120] *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:13 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [129] (signed word) mulf8s::return#0 ← (signed word)(word) mulf8s_prepared::m#4 [ mulf8s::return#0 ] ( main:2::loop:7::mulf8s:37 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [133] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 [ mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:80 [ mulf8s_prepared::b#0 ]
Statement [134] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [135] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [137] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#0 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [142] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA) [ mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte x as potential for zp[1]:2 [ loop::angle#6 loop::angle#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:3 [ loop::r#2 loop::r#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ]
Removing always clobbered register reg byte x as potential for zp[1]:5 [ loop::i#2 loop::i#1 ]
Removing always clobbered register reg byte x as potential for zp[1]:80 [ mulf8s_prepared::b#0 ]
Statement [148] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB) w= *((const byte*) mulf8u_prepared::resL) [ mulf8u_prepared::return#0 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128::mulf8u_prepared:132 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128::mulf8u_prepared:132 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:15 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
Statement [153] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 [ ] ( main:2::init:5 [ ] { }  ) always clobbers reg byte a 
Statement [156] *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(byte) $40 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:18 [ init::i#2 init::i#1 ]
Statement [157] (byte~) init::$10 ← (byte) init::i#2 << (byte) 2 [ init::i#2 init::$10 ] ( main:2::init:5 [ init::i#2 init::$10 ] { }  ) always clobbers reg byte a 
Statement [158] (byte~) init::$3 ← (byte~) init::$10 + (byte) init::i#2 [ init::i#2 init::$3 ] ( main:2::init:5 [ init::i#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [160] (byte~) init::$9 ← (byte) init::i#2 << (byte) 1 [ init::i#2 init::$4 init::$9 ] ( main:2::init:5 [ init::i#2 init::$4 init::$9 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:94 [ init::$4 ]
Statement [161] *((const word*) PLEX_XPOS + (byte~) init::$9) ← (byte~) init::$4 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] { }  ) always clobbers reg byte a 
Statement [162] (byte~) init::$5 ← (byte) init::i#2 << (byte) 3 [ init::i#2 init::$5 ] ( main:2::init:5 [ init::i#2 init::$5 ] { }  ) always clobbers reg byte a 
Statement [167] *((const byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:2::init:5 [ ] { }  ) always clobbers reg byte a 
Statement [169] *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN [ init::i1#2 ] ( main:2::init:5 [ init::i1#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:19 [ init::i1#2 init::i1#1 ]
Statement [179] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:2::init:5::memset:175 [ memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [181] *((byte*) memset::dst#2) ← (const byte) memset::c#0 [ memset::dst#2 ] ( main:2::init:5::memset:175 [ memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [185] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:27 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Statement [187] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@6 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ]
Statement [188] *((const byte*) mulf_sqr2_lo+(word) $1ff) ← *((const byte*) mulf_sqr1_lo+(word) $100) [ ] ( main:2::init:5::mulf_init:173 [ ] { }  ) always clobbers reg byte a 
Statement [189] *((const byte*) mulf_sqr2_hi+(word) $1ff) ← *((const byte*) mulf_sqr1_hi+(word) $100) [ ] ( main:2::init:5::mulf_init:173 [ ] { }  ) always clobbers reg byte a 
Statement [191] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2) [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ]
Statement [192] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2) [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [194] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] { }  ) always clobbers reg byte a 
Statement [200] (byte~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] { }  ) always clobbers reg byte a 
Statement [206] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$4 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ]
Removing always clobbered register reg byte y as potential for zp[1]:27 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
Statement [208] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [210] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] { }  ) always clobbers reg byte a 
Statement [25] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) [ ] ( main:2::exit:9::keyboard_key_pressed:14::keyboard_matrix_read:20 [ ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:2::loop:7::keyboard_key_pressed:73::keyboard_matrix_read:20 [ loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [26] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) [ keyboard_matrix_read::return#0 ] ( main:2::exit:9::keyboard_key_pressed:14::keyboard_matrix_read:20 [ keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#2 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  main:2::loop:7::keyboard_key_pressed:73::keyboard_matrix_read:20 [ loop::angle#1 keyboard_matrix_read::return#0 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } { keyboard_matrix_read::return#0 = keyboard_matrix_read::return#2 } }  ) always clobbers reg byte a 
Statement [30] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@2 [ loop::angle#6 ] ( main:2::loop:7 [ loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [31] *((const byte*) BORDERCOL) ← (byte) $f [ loop::angle#6 ] ( main:2::loop:7 [ loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [34] *((const byte*) BORDERCOL) ← (byte) 6 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [38] (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#0 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  ) always clobbers reg byte a 
Statement [39] (signed word~) loop::$1 ← (signed word) mulf8s::return#2 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$1 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [40] (signed word~) loop::$2 ← (signed word~) loop::$1 << (byte) 1 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [41] (signed word) loop::x#0 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::x#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [43] (byte~) loop::$20 ← (byte) loop::i#2 << (byte) 1 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$4 loop::$20 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [44] *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [48] (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#0 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#3 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [49] (signed word~) loop::$5 ← (signed word) mulf8s::return#3 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$5 ] { }  ) always clobbers reg byte a 
Statement [50] (signed word~) loop::$6 ← (signed word~) loop::$5 << (byte) 1 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::$6 ] { }  ) always clobbers reg byte a 
Statement [51] (signed word) loop::y#0 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 loop::y#0 ] { }  ) always clobbers reg byte a 
Statement [54] (byte) loop::a#1 ← (byte) loop::a#2 + (byte) $62 [ loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] ( main:2::loop:7 [ loop::angle#6 loop::r#2 loop::i#2 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [55] (signed byte) loop::r#1 ← (signed byte) loop::r#2 + (signed byte) 3 [ loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] ( main:2::loop:7 [ loop::angle#6 loop::i#2 loop::r#1 loop::a#1 ] { }  ) always clobbers reg byte a 
Statement [58] *((const byte*) BORDERCOL) ← (byte) 3 [ loop::angle#6 ] ( main:2::loop:7 [ loop::angle#6 ] { }  ) always clobbers reg byte a 
Statement [60] (byte) loop::angle#1 ← (byte) loop::angle#6 + (byte) 3 [ loop::angle#1 ] ( main:2::loop:7 [ loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [61] *((const byte*) BORDERCOL) ← (const byte) BLACK [ loop::angle#1 ] ( main:2::loop:7 [ loop::angle#1 ] { }  ) always clobbers reg byte a 
Statement [62] (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8 [ loop::angle#1 loop::$11 ] ( main:2::loop:7 [ loop::angle#1 loop::$11 ] { }  ) always clobbers reg byte a 
Statement [65] *((const byte*) BORDERCOL) ← (const byte) BLACK [ loop::angle#1 plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 loop::i1#5 ] ( main:2::loop:7 [ loop::angle#1 plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 loop::i1#5 ] { }  ) always clobbers reg byte a 
Statement [72] *((const byte*) BORDERCOL) ← (const byte) BLACK [ loop::angle#1 ] ( main:2::loop:7 [ loop::angle#1 ] { { keyboard_key_pressed::return#0 = keyboard_key_pressed::return#3 } }  ) always clobbers reg byte a 
Statement [78] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 << (byte) 1 [ plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plexShowSprite::plex_sprite_idx2#0 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_free_next#17 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [85] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#43) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] { }  ) always clobbers reg byte a 
Statement [87] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] { }  ) always clobbers reg byte a 
Statement [88] (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] { }  ) always clobbers reg byte a 
Statement [90] (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$3 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$3 ] { }  ) always clobbers reg byte a 
Statement [92] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#43 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$9 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 plexShowSprite::$9 ] { }  ) always clobbers reg byte a 
Statement [93] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] { }  ) always clobbers reg byte a 
Statement [102] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#43 [ plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] ( main:2::loop:7::plexShowSprite:69 [ loop::angle#1 loop::i1#5 plex_sprite_idx#43 plex_show_idx#43 plex_sprite_msb#43 plex_free_next#13 ] { }  ) always clobbers reg byte a 
Statement [107] if((byte) plexSort::nxt_y#0>=*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] { }  ) always clobbers reg byte a 
Statement [110] *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] { }  ) always clobbers reg byte a 
Statement [113] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] { }  ) always clobbers reg byte a 
Statement [115] *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::m#2 ] { }  ) always clobbers reg byte a 
Statement [120] *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:2::loop:7::plexSort:59 [ loop::angle#6 plexSort::plexFreePrepare1_s#2 ] { }  ) always clobbers reg byte a 
Statement [129] (signed word) mulf8s::return#0 ← (signed word)(word) mulf8s_prepared::m#4 [ mulf8s::return#0 ] ( main:2::loop:7::mulf8s:37 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [133] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0 [ mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#2 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement [134] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [135] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [137] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#0 [ mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8s_prepared::m#0 mulf8s_prepared::$15 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement [142] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA) [ mulf8s_prepared::m#5 mulf8s_prepared::$16 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::m#5 mulf8s_prepared::$16 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } }  ) always clobbers reg byte a 
Statement asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  } always clobbers reg byte a reg byte x 
Statement [148] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB) w= *((const byte*) mulf8u_prepared::resL) [ mulf8u_prepared::return#0 ] ( main:2::loop:7::mulf8s:37::mulf8s_prepared:128::mulf8u_prepared:132 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#0 loop::r#2 } { mulf8s::b#0 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#2 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  main:2::loop:7::mulf8s:47::mulf8s_prepared:128::mulf8u_prepared:132 [ loop::angle#6 loop::r#2 loop::a#2 loop::i#2 mulf8s_prepared::b#0 mulf8u_prepared::return#0 ] { { mulf8s::mulf8s_prepare1_a#0 = mulf8s::a#1 loop::r#2 } { mulf8s::b#1 = mulf8s::b#2 mulf8s_prepared::b#0 } { mulf8s::return#0 = mulf8s::return#3 } { mulf8u_prepared::return#0 = mulf8u_prepared::return#2 } }  ) always clobbers reg byte a 
Statement asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  } always clobbers reg byte a 
Statement [153] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 [ ] ( main:2::init:5 [ ] { }  ) always clobbers reg byte a 
Statement [156] *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(byte) $40 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] { }  ) always clobbers reg byte a 
Statement [157] (byte~) init::$10 ← (byte) init::i#2 << (byte) 2 [ init::i#2 init::$10 ] ( main:2::init:5 [ init::i#2 init::$10 ] { }  ) always clobbers reg byte a 
Statement [158] (byte~) init::$3 ← (byte~) init::$10 + (byte) init::i#2 [ init::i#2 init::$3 ] ( main:2::init:5 [ init::i#2 init::$3 ] { }  ) always clobbers reg byte a 
Statement [160] (byte~) init::$9 ← (byte) init::i#2 << (byte) 1 [ init::i#2 init::$4 init::$9 ] ( main:2::init:5 [ init::i#2 init::$4 init::$9 ] { }  ) always clobbers reg byte a 
Statement [161] *((const word*) PLEX_XPOS + (byte~) init::$9) ← (byte~) init::$4 [ init::i#2 ] ( main:2::init:5 [ init::i#2 ] { }  ) always clobbers reg byte a 
Statement [162] (byte~) init::$5 ← (byte) init::i#2 << (byte) 3 [ init::i#2 init::$5 ] ( main:2::init:5 [ init::i#2 init::$5 ] { }  ) always clobbers reg byte a 
Statement [167] *((const byte*) SPRITES_ENABLE) ← (byte) $ff [ ] ( main:2::init:5 [ ] { }  ) always clobbers reg byte a 
Statement [169] *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN [ init::i1#2 ] ( main:2::init:5 [ init::i1#2 ] { }  ) always clobbers reg byte a 
Statement [179] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#2 ] ( main:2::init:5::memset:175 [ memset::dst#2 ] { }  ) always clobbers reg byte a 
Statement [181] *((byte*) memset::dst#2) ← (const byte) memset::c#0 [ memset::dst#2 ] ( main:2::init:5::memset:175 [ memset::dst#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [185] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::c#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 ] { }  ) always clobbers reg byte a 
Statement [187] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@6 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a 
Statement [188] *((const byte*) mulf_sqr2_lo+(word) $1ff) ← *((const byte*) mulf_sqr1_lo+(word) $100) [ ] ( main:2::init:5::mulf_init:173 [ ] { }  ) always clobbers reg byte a 
Statement [189] *((const byte*) mulf_sqr2_hi+(word) $1ff) ← *((const byte*) mulf_sqr1_hi+(word) $100) [ ] ( main:2::init:5::mulf_init:173 [ ] { }  ) always clobbers reg byte a 
Statement [191] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2) [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [192] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2) [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::x_255#2 mulf_init::sqr2_hi#2 mulf_init::dir#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [194] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr2_lo#2 mulf_init::dir#2 mulf_init::x_255#1 mulf_init::sqr2_hi#1 ] { }  ) always clobbers reg byte a 
Statement [200] (byte~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::sqr#4 mulf_init::sqr1_hi#2 mulf_init::x_2#3 mulf_init::c#1 mulf_init::$1 ] { }  ) always clobbers reg byte a 
Statement [206] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$4 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [208] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_hi#2 mulf_init::c#1 mulf_init::x_2#2 mulf_init::sqr#3 ] { }  ) always clobbers reg byte y 
Statement [210] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] ( main:2::init:5::mulf_init:173 [ mulf_init::sqr1_lo#2 mulf_init::c#1 mulf_init::sqr#1 mulf_init::sqr1_hi#1 mulf_init::x_2#2 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ loop::angle#6 loop::angle#1 ] : zp[1]:2 , reg byte y , 
Potential registers zp[1]:3 [ loop::r#2 loop::r#1 ] : zp[1]:3 , reg byte y , 
Potential registers zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ] : zp[1]:4 , reg byte y , 
Potential registers zp[1]:5 [ loop::i#2 loop::i#1 ] : zp[1]:5 , reg byte y , 
Potential registers zp[1]:6 [ plex_free_next#17 plex_free_next#13 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ] : zp[1]:7 , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ] : zp[1]:9 , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ loop::i1#5 loop::i1#1 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[1]:11 [ plexSort::m#2 plexSort::m#1 ] : zp[1]:11 , reg byte x , reg byte y , 
Potential registers zp[1]:12 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp[1]:12 , reg byte x , reg byte y , 
Potential registers zp[1]:13 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp[1]:13 , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:15 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ] : zp[1]:15 , reg byte x , reg byte y , 
Potential registers zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] : zp[2]:16 , 
Potential registers zp[1]:18 [ init::i#2 init::i#1 ] : zp[1]:18 , reg byte x , reg byte y , 
Potential registers zp[1]:19 [ init::i1#2 init::i1#1 ] : zp[1]:19 , reg byte x , reg byte y , 
Potential registers zp[2]:20 [ memset::dst#2 memset::dst#1 ] : zp[2]:20 , 
Potential registers zp[2]:22 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] : zp[2]:22 , 
Potential registers zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ] : zp[1]:24 , reg byte x , 
Potential registers zp[2]:25 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] : zp[2]:25 , 
Potential registers zp[1]:27 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] : zp[1]:27 , reg byte x , 
Potential registers zp[2]:28 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] : zp[2]:28 , 
Potential registers zp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ] : zp[1]:30 , reg byte x , 
Potential registers zp[2]:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] : zp[2]:31 , 
Potential registers zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ] : zp[1]:33 , reg byte x , 
Potential registers zp[2]:34 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] : zp[2]:34 , 
Potential registers zp[1]:36 [ plexInit::i#2 plexInit::i#1 ] : zp[1]:36 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:37 [ keyboard_key_pressed::return#2 ] : zp[1]:37 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:38 [ exit::$0 ] : zp[1]:38 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:39 [ keyboard_matrix_read::return#2 ] : zp[1]:39 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:40 [ keyboard_key_pressed::$2 ] : zp[1]:40 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:41 [ keyboard_key_pressed::return#0 ] : zp[1]:41 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:42 [ keyboard_matrix_read::return#0 ] : zp[1]:42 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:43 [ mulf8s::return#2 ] : zp[2]:43 , 
Potential registers zp[2]:45 [ loop::$1 ] : zp[2]:45 , 
Potential registers zp[2]:47 [ loop::$2 ] : zp[2]:47 , 
Potential registers zp[2]:49 [ loop::x#0 ] : zp[2]:49 , 
Potential registers zp[1]:51 [ loop::$4 ] : zp[1]:51 , reg byte x , reg byte y , 
Potential registers zp[1]:52 [ loop::$20 ] : zp[1]:52 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:53 [ mulf8s::return#3 ] : zp[2]:53 , 
Potential registers zp[2]:55 [ loop::$5 ] : zp[2]:55 , 
Potential registers zp[2]:57 [ loop::$6 ] : zp[2]:57 , 
Potential registers zp[2]:59 [ loop::y#0 ] : zp[2]:59 , 
Potential registers zp[1]:61 [ loop::$8 ] : zp[1]:61 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:62 [ loop::$11 ] : zp[1]:62 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:63 [ loop::plexFreeNextYpos1_return#0 ] : zp[1]:63 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:64 [ keyboard_key_pressed::return#3 ] : zp[1]:64 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:65 [ loop::$18 ] : zp[1]:65 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ] : zp[1]:66 , reg byte x , reg byte y , 
Potential registers zp[1]:67 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp[1]:67 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:68 [ plexShowSprite::plexFreeAdd1_$0 ] : zp[1]:68 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:69 [ plexShowSprite::plexFreeAdd1_$1 ] : zp[1]:69 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:70 [ plexShowSprite::xpos_idx#0 ] : zp[1]:70 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:71 [ plexShowSprite::$11 ] : zp[1]:71 , reg byte x , reg byte y , 
Potential registers zp[1]:72 [ plexShowSprite::$2 ] : zp[1]:72 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:73 [ plexShowSprite::$3 ] : zp[1]:73 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:74 [ plexShowSprite::$9 ] : zp[1]:74 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:75 [ plexShowSprite::$5 ] : zp[1]:75 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:76 [ plexSort::nxt_idx#0 ] : zp[1]:76 , reg byte x , reg byte y , 
Potential registers zp[1]:77 [ plexSort::nxt_y#0 ] : zp[1]:77 , reg byte x , reg byte y , 
Potential registers zp[1]:78 [ plexSort::s#2 ] : zp[1]:78 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:79 [ mulf8u_prepare::a#0 ] : zp[1]:79 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:80 [ mulf8s_prepared::b#0 ] : zp[1]:80 , reg byte y , 
Potential registers zp[2]:81 [ mulf8s::return#0 ] : zp[2]:81 , 
Potential registers zp[1]:83 [ mulf8u_prepared::b#0 ] : zp[1]:83 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:84 [ mulf8u_prepared::return#2 ] : zp[2]:84 , 
Potential registers zp[1]:86 [ mulf8s_prepared::$8 ] : zp[1]:86 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:87 [ mulf8s_prepared::$15 ] : zp[1]:87 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:88 [ mulf8s_prepared::$12 ] : zp[1]:88 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:89 [ mulf8s_prepared::$16 ] : zp[1]:89 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:90 [ mulf8u_prepared::return#0 ] : zp[2]:90 , 
Potential registers zp[1]:92 [ init::$10 ] : zp[1]:92 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:93 [ init::$3 ] : zp[1]:93 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:94 [ init::$4 ] : zp[1]:94 , reg byte x , reg byte y , 
Potential registers zp[1]:95 [ init::$9 ] : zp[1]:95 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:96 [ init::$5 ] : zp[1]:96 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:97 [ init::$6 ] : zp[1]:97 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:98 [ mulf_init::$1 ] : zp[1]:98 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:99 [ mulf_init::$4 ] : zp[1]:99 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:100 [ mulf_init::$5 ] : zp[1]:100 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 36,166,672.83: zp[1]:12 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 3,000,003: zp[1]:13 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 2,000,002: zp[1]:78 [ plexSort::s#2 ] 1,916,668.58: zp[1]:11 [ plexSort::m#2 plexSort::m#1 ] 1,500,000.38: zp[1]:77 [ plexSort::nxt_y#0 ] 300,000.3: zp[1]:76 [ plexSort::nxt_idx#0 ] 
Uplift Scope [mulf8u_prepared] 11,000,002: zp[1]:83 [ mulf8u_prepared::b#0 ] 3,666,667.33: zp[2]:90 [ mulf8u_prepared::return#0 ] 2,000,002: zp[2]:84 [ mulf8u_prepared::return#2 ] 
Uplift Scope [mulf8s_prepared] 6,916,673.58: zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] 2,000,002: zp[1]:86 [ mulf8s_prepared::$8 ] 2,000,002: zp[1]:87 [ mulf8s_prepared::$15 ] 2,000,002: zp[1]:88 [ mulf8s_prepared::$12 ] 2,000,002: zp[1]:89 [ mulf8s_prepared::$16 ] 110,000.2: zp[1]:80 [ mulf8s_prepared::b#0 ] 
Uplift Scope [plexShowSprite] 200,002: zp[1]:68 [ plexShowSprite::plexFreeAdd1_$0 ] 200,002: zp[1]:69 [ plexShowSprite::plexFreeAdd1_$1 ] 200,002: zp[1]:70 [ plexShowSprite::xpos_idx#0 ] 200,002: zp[1]:72 [ plexShowSprite::$2 ] 200,002: zp[1]:73 [ plexShowSprite::$3 ] 200,002: zp[1]:74 [ plexShowSprite::$9 ] 200,002: zp[1]:75 [ plexShowSprite::$5 ] 150,001.5: zp[1]:67 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 100,001: zp[1]:71 [ plexShowSprite::$11 ] 27,273: zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [mulf8u_prepare] 1,100,002: zp[1]:79 [ mulf8u_prepare::a#0 ] 
Uplift Scope [loop] 55,001: zp[1]:63 [ loop::plexFreeNextYpos1_return#0 ] 20,002: zp[2]:45 [ loop::$1 ] 20,002: zp[2]:47 [ loop::$2 ] 20,002: zp[2]:49 [ loop::x#0 ] 20,002: zp[1]:52 [ loop::$20 ] 20,002: zp[2]:55 [ loop::$5 ] 20,002: zp[2]:57 [ loop::$6 ] 20,002: zp[2]:59 [ loop::y#0 ] 20,002: zp[1]:61 [ loop::$8 ] 20,002: zp[1]:62 [ loop::$11 ] 18,335.17: zp[1]:10 [ loop::i1#5 loop::i1#1 ] 16,740.8: zp[1]:5 [ loop::i#2 loop::i#1 ] 10,001: zp[1]:51 [ loop::$4 ] 8,955.12: zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ] 8,485.7: zp[1]:3 [ loop::r#2 loop::r#1 ] 2,002: zp[1]:65 [ loop::$18 ] 214.64: zp[1]:2 [ loop::angle#6 loop::angle#1 ] 
Uplift Scope [mulf_init] 43,337.67: zp[2]:34 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] 24,446.89: zp[2]:28 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] 22,859.43: zp[2]:22 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] 21,002.1: zp[1]:27 [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] 20,002: zp[1]:98 [ mulf_init::$1 ] 20,002: zp[1]:99 [ mulf_init::$4 ] 20,002: zp[1]:100 [ mulf_init::$5 ] 14,001.4: zp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ] 13,751.38: zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ] 12,308.92: zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ] 10,834.42: zp[2]:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] 9,167.58: zp[2]:25 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] 
Uplift Scope [] 134,401.56: zp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ] 29,305.99: zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ] 27,000.49: zp[1]:6 [ plex_free_next#17 plex_free_next#13 ] 25,091.29: zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ] 
Uplift Scope [mulf8s] 80,005: zp[1]:15 [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ] 40,004: zp[1]:14 [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ] 30,000.75: zp[2]:81 [ mulf8s::return#0 ] 20,002: zp[2]:43 [ mulf8s::return#2 ] 20,002: zp[2]:53 [ mulf8s::return#3 ] 
Uplift Scope [keyboard_matrix_read] 36,667.33: zp[1]:42 [ keyboard_matrix_read::return#0 ] 20,002: zp[1]:39 [ keyboard_matrix_read::return#2 ] 
Uplift Scope [plexInit] 35,003.5: zp[1]:36 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [memset] 33,336.67: zp[2]:20 [ memset::dst#2 memset::dst#1 ] 
Uplift Scope [keyboard_key_pressed] 20,002: zp[1]:40 [ keyboard_key_pressed::$2 ] 3,000.75: zp[1]:41 [ keyboard_key_pressed::return#0 ] 2,002: zp[1]:37 [ keyboard_key_pressed::return#2 ] 2,002: zp[1]:64 [ keyboard_key_pressed::return#3 ] 
Uplift Scope [init] 3,003: zp[1]:19 [ init::i1#2 init::i1#1 ] 2,302.3: zp[1]:18 [ init::i#2 init::i#1 ] 2,002: zp[1]:92 [ init::$10 ] 2,002: zp[1]:93 [ init::$3 ] 2,002: zp[1]:95 [ init::$9 ] 2,002: zp[1]:96 [ init::$5 ] 2,002: zp[1]:97 [ init::$6 ] 1,001: zp[1]:94 [ init::$4 ] 
Uplift Scope [exit] 2,002: zp[1]:38 [ exit::$0 ] 
Uplift Scope [main] 

Uplifting [plexSort] best 106800 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] reg byte x [ plexSort::s#2 ] zp[1]:11 [ plexSort::m#2 plexSort::m#1 ] zp[1]:77 [ plexSort::nxt_y#0 ] zp[1]:76 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 100 combinations of 972 possible.
Uplifting [mulf8u_prepared] best 106794 combination reg byte a [ mulf8u_prepared::b#0 ] zp[2]:90 [ mulf8u_prepared::return#0 ] zp[2]:84 [ mulf8u_prepared::return#2 ] 
Uplifting [mulf8s_prepared] best 106770 combination zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] reg byte a [ mulf8s_prepared::$8 ] reg byte a [ mulf8s_prepared::$15 ] reg byte a [ mulf8s_prepared::$12 ] reg byte a [ mulf8s_prepared::$16 ] zp[1]:80 [ mulf8s_prepared::b#0 ] 
Limited combination testing to 100 combinations of 512 possible.
Uplifting [plexShowSprite] best 106748 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1 ] reg byte a [ plexShowSprite::xpos_idx#0 ] reg byte a [ plexShowSprite::$2 ] zp[1]:73 [ plexShowSprite::$3 ] zp[1]:74 [ plexShowSprite::$9 ] zp[1]:75 [ plexShowSprite::$5 ] zp[1]:67 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp[1]:71 [ plexShowSprite::$11 ] zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 100 combinations of 589824 possible.
Uplifting [mulf8u_prepare] best 106742 combination reg byte a [ mulf8u_prepare::a#0 ] 
Uplifting [loop] best 104942 combination zp[1]:63 [ loop::plexFreeNextYpos1_return#0 ] zp[2]:45 [ loop::$1 ] zp[2]:47 [ loop::$2 ] zp[2]:49 [ loop::x#0 ] reg byte a [ loop::$20 ] zp[2]:55 [ loop::$5 ] zp[2]:57 [ loop::$6 ] zp[2]:59 [ loop::y#0 ] reg byte a [ loop::$8 ] reg byte a [ loop::$11 ] zp[1]:10 [ loop::i1#5 loop::i1#1 ] zp[1]:5 [ loop::i#2 loop::i#1 ] zp[1]:51 [ loop::$4 ] zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ] zp[1]:3 [ loop::r#2 loop::r#1 ] zp[1]:65 [ loop::$18 ] zp[1]:2 [ loop::angle#6 loop::angle#1 ] 
Limited combination testing to 100 combinations of 147456 possible.
Uplifting [mulf_init] best 104692 combination zp[2]:34 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ] zp[2]:28 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ] zp[2]:22 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] reg byte x [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ] reg byte a [ mulf_init::$1 ] reg byte a [ mulf_init::$4 ] reg byte a [ mulf_init::$5 ] zp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ] zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ] zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ] zp[2]:31 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ] zp[2]:25 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ] 
Limited combination testing to 100 combinations of 1024 possible.
Uplifting [] best 104692 combination zp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ] zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ] zp[1]:6 [ plex_free_next#17 plex_free_next#13 ] zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ] 
Uplifting [mulf8s] best 103486 combination reg byte x [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ] reg byte a [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ] zp[2]:81 [ mulf8s::return#0 ] zp[2]:43 [ mulf8s::return#2 ] zp[2]:53 [ mulf8s::return#3 ] 
Uplifting [keyboard_matrix_read] best 103474 combination reg byte a [ keyboard_matrix_read::return#0 ] reg byte a [ keyboard_matrix_read::return#2 ] 
Uplifting [plexInit] best 103354 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [memset] best 103354 combination zp[2]:20 [ memset::dst#2 memset::dst#1 ] 
Uplifting [keyboard_key_pressed] best 103165 combination reg byte a [ keyboard_key_pressed::$2 ] reg byte a [ keyboard_key_pressed::return#0 ] reg byte a [ keyboard_key_pressed::return#2 ] reg byte a [ keyboard_key_pressed::return#3 ] 
Limited combination testing to 100 combinations of 256 possible.
Uplifting [init] best 102945 combination reg byte x [ init::i1#2 init::i1#1 ] zp[1]:18 [ init::i#2 init::i#1 ] reg byte a [ init::$10 ] reg byte a [ init::$3 ] zp[1]:95 [ init::$9 ] zp[1]:96 [ init::$5 ] zp[1]:97 [ init::$6 ] zp[1]:94 [ init::$4 ] 
Limited combination testing to 100 combinations of 27648 possible.
Uplifting [exit] best 102885 combination reg byte a [ exit::$0 ] 
Uplifting [main] best 102885 combination 
Attempting to uplift remaining variables inzp[1]:11 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 102885 combination zp[1]:11 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp[1]:77 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 102885 combination zp[1]:77 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp[1]:76 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 102885 combination zp[1]:76 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp[1]:73 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 102879 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp[1]:74 [ plexShowSprite::$9 ]
Uplifting [plexShowSprite] best 102873 combination reg byte a [ plexShowSprite::$9 ] 
Attempting to uplift remaining variables inzp[1]:75 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 102867 combination reg byte x [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp[1]:67 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 102858 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
Uplifting [] best 102858 combination zp[1]:9 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ] 
Attempting to uplift remaining variables inzp[1]:80 [ mulf8s_prepared::b#0 ]
Uplifting [mulf8s_prepared] best 102858 combination zp[1]:80 [ mulf8s_prepared::b#0 ] 
Attempting to uplift remaining variables inzp[1]:71 [ plexShowSprite::$11 ]
Uplifting [plexShowSprite] best 102851 combination reg byte x [ plexShowSprite::$11 ] 
Attempting to uplift remaining variables inzp[1]:63 [ loop::plexFreeNextYpos1_return#0 ]
Uplifting [loop] best 102851 combination zp[1]:63 [ loop::plexFreeNextYpos1_return#0 ] 
Attempting to uplift remaining variables inzp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ]
Uplifting [] best 102851 combination zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ] 
Attempting to uplift remaining variables inzp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 102851 combination zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ] 
Attempting to uplift remaining variables inzp[1]:6 [ plex_free_next#17 plex_free_next#13 ]
Uplifting [] best 102851 combination zp[1]:6 [ plex_free_next#17 plex_free_next#13 ] 
Attempting to uplift remaining variables inzp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ]
Uplifting [] best 102851 combination zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ] 
Attempting to uplift remaining variables inzp[1]:10 [ loop::i1#5 loop::i1#1 ]
Uplifting [loop] best 102851 combination zp[1]:10 [ loop::i1#5 loop::i1#1 ] 
Attempting to uplift remaining variables inzp[1]:5 [ loop::i#2 loop::i#1 ]
Uplifting [loop] best 102851 combination zp[1]:5 [ loop::i#2 loop::i#1 ] 
Attempting to uplift remaining variables inzp[1]:30 [ mulf_init::x_255#2 mulf_init::x_255#1 ]
Uplifting [mulf_init] best 102711 combination reg byte x [ mulf_init::x_255#2 mulf_init::x_255#1 ] 
Attempting to uplift remaining variables inzp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ]
Uplifting [mulf_init] best 102711 combination zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ] 
Attempting to uplift remaining variables inzp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ]
Uplifting [mulf_init] best 102711 combination zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ] 
Attempting to uplift remaining variables inzp[1]:51 [ loop::$4 ]
Uplifting [loop] best 102111 combination reg byte x [ loop::$4 ] 
Attempting to uplift remaining variables inzp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ]
Uplifting [loop] best 102111 combination zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ] 
Attempting to uplift remaining variables inzp[1]:3 [ loop::r#2 loop::r#1 ]
Uplifting [loop] best 102111 combination zp[1]:3 [ loop::r#2 loop::r#1 ] 
Attempting to uplift remaining variables inzp[1]:18 [ init::i#2 init::i#1 ]
Uplifting [init] best 102111 combination zp[1]:18 [ init::i#2 init::i#1 ] 
Attempting to uplift remaining variables inzp[1]:65 [ loop::$18 ]
Uplifting [loop] best 102051 combination reg byte a [ loop::$18 ] 
Attempting to uplift remaining variables inzp[1]:95 [ init::$9 ]
Uplifting [init] best 101991 combination reg byte a [ init::$9 ] 
Attempting to uplift remaining variables inzp[1]:96 [ init::$5 ]
Uplifting [init] best 101951 combination reg byte a [ init::$5 ] 
Attempting to uplift remaining variables inzp[1]:97 [ init::$6 ]
Uplifting [init] best 101891 combination reg byte a [ init::$6 ] 
Attempting to uplift remaining variables inzp[1]:94 [ init::$4 ]
Uplifting [init] best 101831 combination reg byte x [ init::$4 ] 
Attempting to uplift remaining variables inzp[1]:2 [ loop::angle#6 loop::angle#1 ]
Uplifting [loop] best 101831 combination zp[1]:2 [ loop::angle#6 loop::angle#1 ] 
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 ] ] with [ zp[2]:81 [ mulf8s::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 ] ] with [ zp[2]:84 [ mulf8u_prepared::return#2 ] ] - score: 1
Coalescing zero page register [ zp[2]:43 [ mulf8s::return#2 ] ] with [ zp[2]:45 [ loop::$1 ] ] - score: 1
Coalescing zero page register [ zp[2]:47 [ loop::$2 ] ] with [ zp[2]:49 [ loop::x#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:53 [ mulf8s::return#3 ] ] with [ zp[2]:55 [ loop::$5 ] ] - score: 1
Coalescing zero page register [ zp[2]:57 [ loop::$6 ] ] with [ zp[2]:59 [ loop::y#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 ] ] with [ zp[2]:43 [ mulf8s::return#2 loop::$1 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 ] ] with [ zp[2]:53 [ mulf8s::return#3 loop::$5 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 ] ] with [ zp[2]:90 [ mulf8u_prepared::return#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 ] ] with [ zp[2]:47 [ loop::$2 loop::x#0 ] ] - score: 1
Coalescing zero page register [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 ] ] with [ zp[2]:57 [ loop::$6 loop::y#0 ] ] - score: 1
Coalescing zero page register [ zp[1]:6 [ plex_free_next#17 plex_free_next#13 ] ] with [ zp[1]:3 [ loop::r#2 loop::r#1 ] ]
Coalescing zero page register [ zp[1]:7 [ plex_sprite_idx#43 plex_sprite_idx#15 ] ] with [ zp[1]:4 [ loop::a#2 loop::a#1 loop::a#6 ] ]
Coalescing zero page register [ zp[1]:8 [ plex_show_idx#43 plex_show_idx#15 ] ] with [ zp[1]:5 [ loop::i#2 loop::i#1 ] ]
Coalescing zero page register [ zp[1]:18 [ init::i#2 init::i#1 ] ] with [ zp[1]:2 [ loop::angle#6 loop::angle#1 ] ]
Coalescing zero page register [ zp[2]:20 [ memset::dst#2 memset::dst#1 ] ] with [ zp[2]:16 [ mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 ] ]
Coalescing zero page register [ zp[1]:24 [ mulf_init::c#2 mulf_init::c#1 ] ] with [ zp[1]:10 [ loop::i1#5 loop::i1#1 ] ]
Coalescing zero page register [ zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 ] ] with [ zp[1]:11 [ plexSort::m#2 plexSort::m#1 ] ]
Coalescing zero page register [ zp[1]:76 [ plexSort::nxt_idx#0 ] ] with [ zp[1]:66 [ plexShowSprite::plex_sprite_idx2#0 ] ]
Coalescing zero page register [ zp[1]:80 [ mulf8s_prepared::b#0 ] ] with [ zp[1]:77 [ plexSort::nxt_y#0 ] ]
Coalescing zero page register [ zp[2]:22 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 ] ] with [ zp[2]:20 [ memset::dst#2 memset::dst#1 mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 ] ]
Coalescing zero page register [ zp[1]:63 [ loop::plexFreeNextYpos1_return#0 ] ] with [ zp[1]:33 [ mulf_init::dir#2 mulf_init::dir#4 plexSort::m#2 plexSort::m#1 ] ]
Allocated (was zp[1]:6) zp[1]:2 [ plex_free_next#17 plex_free_next#13 loop::r#2 loop::r#1 ]
Allocated (was zp[1]:7) zp[1]:3 [ plex_sprite_idx#43 plex_sprite_idx#15 loop::a#2 loop::a#1 loop::a#6 ]
Allocated (was zp[1]:8) zp[1]:4 [ plex_show_idx#43 plex_show_idx#15 loop::i#2 loop::i#1 ]
Allocated (was zp[1]:9) zp[1]:5 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
Allocated (was zp[1]:18) zp[1]:6 [ init::i#2 init::i#1 loop::angle#6 loop::angle#1 ]
Allocated (was zp[2]:22) zp[2]:7 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 memset::dst#2 memset::dst#1 mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 ]
Allocated (was zp[1]:24) zp[1]:9 [ mulf_init::c#2 mulf_init::c#1 loop::i1#5 loop::i1#1 ]
Allocated (was zp[2]:25) zp[2]:10 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
Allocated (was zp[2]:28) zp[2]:12 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
Allocated (was zp[2]:31) zp[2]:14 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
Allocated (was zp[2]:34) zp[2]:16 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
Allocated (was zp[1]:63) zp[1]:18 [ loop::plexFreeNextYpos1_return#0 mulf_init::dir#2 mulf_init::dir#4 plexSort::m#2 plexSort::m#1 ]
Allocated (was zp[1]:76) zp[1]:19 [ plexSort::nxt_idx#0 plexShowSprite::plex_sprite_idx2#0 ]
Allocated (was zp[1]:80) zp[1]:20 [ mulf8s_prepared::b#0 plexSort::nxt_y#0 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Same animation using a multiplexer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const KEY_SPACE = $3c
  // The BASIC screen
  .label SCREEN = $400
  // The number of BOBs to render
  .const NUM_BOBS = $10
  .label COS = SIN+$40
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = 5
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = 2
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = 3
  // The index in the PLEX tables of the next sprite to show
  // Prepare for showing the sprites
  .label plex_show_idx = 4
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    // asm { sei  }
    sei
    // [5] call init 
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    jmp __b1
    // main::@1
  __b1:
    // [7] call loop 
    // [28] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from___b1:
    jsr loop
    // [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
  __b2_from___b1:
    jmp __b2
    // main::@2
  __b2:
    // [9] call exit 
    // [12] phi from main::@2 to exit [phi:main::@2->exit]
  exit_from___b2:
    jsr exit
    jmp __b3
    // main::@3
  __b3:
    // asm { cli  }
    cli
    jmp __breturn
    // main::@return
  __breturn:
    // [11] return 
    rts
}
  // exit
// Exit the program
exit: {
    // [13] phi from exit exit::@2 to exit::@1 [phi:exit/exit::@2->exit::@1]
  __b1_from_exit:
  __b1_from___b2:
    jmp __b1
  // Wait for space release
    // exit::@1
  __b1:
    // [14] call keyboard_key_pressed 
    // [19] phi from exit::@1 to keyboard_key_pressed [phi:exit::@1->keyboard_key_pressed]
  keyboard_key_pressed_from___b1:
    jsr keyboard_key_pressed
    // [15] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    jmp __b2
    // exit::@2
  __b2:
    // [16] (byte~) exit::$0 ← (byte) keyboard_key_pressed::return#2
    // [17] if((byte) 0!=(byte~) exit::$0) goto exit::@1 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __b1_from___b2
    jmp __breturn
    // exit::@return
  __breturn:
    // [18] return 
    rts
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    // [20] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [21] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    jmp __b1
    // keyboard_key_pressed::@1
  __b1:
    // [22] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // [23] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band__deref_pbuc1 
    and keyboard_matrix_col_bitmask+colidx
    jmp __breturn
    // keyboard_key_pressed::@return
  __breturn:
    // [24] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    // [25] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1_PORT_A
    // [26] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    jmp __breturn
    // keyboard_matrix_read::@return
  __breturn:
    // [27] return 
    rts
}
  // loop
// The main loop
loop: {
    .label __1 = 7
    .label __2 = 7
    .label __5 = 7
    .label __6 = 7
    .label x = 7
    .label y = 7
    .label a = 3
    .label r = 2
    .label i = 4
    // Render Rotated BOBs
    .label angle = 6
    .label plexFreeNextYpos1_return = $12
    .label i1 = 9
    // [29] phi from loop to loop::@1 [phi:loop->loop::@1]
  __b1_from_loop:
    // [29] phi (byte) loop::angle#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z angle
    jmp __b1
    // loop::@1
  __b1:
    jmp __b2
    // loop::@2
  __b2:
    // [30] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@2 -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda RASTER
    cmp #$d8
    bcc __b2
    jmp __b3
    // loop::@3
  __b3:
    // [31] *((const byte*) BORDERCOL) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta BORDERCOL
    // [32] (byte) loop::a#6 ← (byte) loop::angle#6 -- vbuz1=vbuz2 
    lda.z angle
    sta.z a
    // [33] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  __b4_from___b3:
    // [33] phi (byte) loop::i#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [33] phi (byte) loop::a#2 = (byte) loop::a#6 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [33] phi (signed byte) loop::r#2 = (signed byte) $1e [phi:loop::@3->loop::@4#2] -- vbsz1=vbsc1 
    lda #$1e
    sta.z r
    jmp __b4
    // [33] phi from loop::@12 to loop::@4 [phi:loop::@12->loop::@4]
  __b4_from___b12:
    // [33] phi (byte) loop::i#2 = (byte) loop::i#1 [phi:loop::@12->loop::@4#0] -- register_copy 
    // [33] phi (byte) loop::a#2 = (byte) loop::a#1 [phi:loop::@12->loop::@4#1] -- register_copy 
    // [33] phi (signed byte) loop::r#2 = (signed byte) loop::r#1 [phi:loop::@12->loop::@4#2] -- register_copy 
    jmp __b4
    // loop::@4
  __b4:
    // [34] *((const byte*) BORDERCOL) ← (byte) 6 -- _deref_pbuc1=vbuc2 
    //kickasm {{ .break }}
    lda #6
    sta BORDERCOL
    // [35] (signed byte) mulf8s::a#0 ← (signed byte) loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [36] (signed byte) mulf8s::b#0 ← *((const signed byte*) COS + (byte) loop::a#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx COS,y
    // [37] call mulf8s 
    // [124] phi from loop::@4 to mulf8s [phi:loop::@4->mulf8s]
  mulf8s_from___b4:
    // [124] phi (signed byte) mulf8s::b#2 = (signed byte) mulf8s::b#0 [phi:loop::@4->mulf8s#0] -- register_copy 
    // [124] phi (signed byte) mulf8s::mulf8s_prepare1_a#0 = (signed byte) mulf8s::a#0 [phi:loop::@4->mulf8s#1] -- register_copy 
    jsr mulf8s
    // [38] (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#0
    jmp __b11
    // loop::@11
  __b11:
    // [39] (signed word~) loop::$1 ← (signed word) mulf8s::return#2
    // [40] (signed word~) loop::$2 ← (signed word~) loop::$1 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl.z __2
    rol.z __2+1
    // [41] (signed word) loop::x#0 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z x
    adc #<$7d*$100
    sta.z x
    lda.z x+1
    adc #>$7d*$100
    sta.z x+1
    // [42] (byte~) loop::$4 ← > (signed word) loop::x#0 -- vbuxx=_hi_vwsz1 
    ldx.z x+1
    // [43] (byte~) loop::$20 ← (byte) loop::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [44] *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    // [45] (signed byte) mulf8s::a#1 ← (signed byte) loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [46] (signed byte) mulf8s::b#1 ← *((const signed byte*) SIN + (byte) loop::a#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx SIN,y
    // [47] call mulf8s 
    // [124] phi from loop::@11 to mulf8s [phi:loop::@11->mulf8s]
  mulf8s_from___b11:
    // [124] phi (signed byte) mulf8s::b#2 = (signed byte) mulf8s::b#1 [phi:loop::@11->mulf8s#0] -- register_copy 
    // [124] phi (signed byte) mulf8s::mulf8s_prepare1_a#0 = (signed byte) mulf8s::a#1 [phi:loop::@11->mulf8s#1] -- register_copy 
    jsr mulf8s
    // [48] (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#0
    jmp __b12
    // loop::@12
  __b12:
    // [49] (signed word~) loop::$5 ← (signed word) mulf8s::return#3
    // [50] (signed word~) loop::$6 ← (signed word~) loop::$5 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl.z __6
    rol.z __6+1
    // [51] (signed word) loop::y#0 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z y
    adc #<$7d*$100
    sta.z y
    lda.z y+1
    adc #>$7d*$100
    sta.z y+1
    // [52] (byte~) loop::$8 ← > (signed word) loop::y#0 -- vbuaa=_hi_vwsz1 
    lda.z y+1
    // [53] *((const byte*) PLEX_YPOS + (byte) loop::i#2) ← (byte~) loop::$8 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // [54] (byte) loop::a#1 ← (byte) loop::a#2 + (byte) $62 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z a
    axs #-[$62]
    stx.z a
    // [55] (signed byte) loop::r#1 ← (signed byte) loop::r#2 + (signed byte) 3 -- vbsz1=vbsz1_plus_vbsc1 
    lax.z r
    axs #-[3]
    stx.z r
    // [56] (byte) loop::i#1 ← ++ (byte) loop::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [57] if((byte) loop::i#1!=(const byte) NUM_BOBS-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #NUM_BOBS-1+1
    cmp.z i
    bne __b4_from___b12
    jmp __b5
    // loop::@5
  __b5:
    // [58] *((const byte*) BORDERCOL) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta BORDERCOL
    // [59] call plexSort 
    // [103] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from___b5:
    jsr plexSort
    jmp __b13
    // loop::@13
  __b13:
    // [60] (byte) loop::angle#1 ← (byte) loop::angle#6 + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z angle
    axs #-[3]
    stx.z angle
    // [61] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp __b6
  // Sort the sprites by y-position
    // loop::@6
  __b6:
    // [62] (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    // [63] if((byte~) loop::$11!=(byte) 0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b6
    // [64] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  __b7_from___b6:
    // [64] phi (byte) loop::i1#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    // [64] phi (byte) plex_sprite_msb#43 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [64] phi (byte) plex_show_idx#43 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [64] phi (byte) plex_sprite_idx#43 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [64] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp __b7
  // Show the sprites
    // [64] phi from loop::@14 to loop::@7 [phi:loop::@14->loop::@7]
  __b7_from___b14:
    // [64] phi (byte) loop::i1#5 = (byte) loop::i1#1 [phi:loop::@14->loop::@7#0] -- register_copy 
    // [64] phi (byte) plex_sprite_msb#43 = (byte) plex_sprite_msb#16 [phi:loop::@14->loop::@7#1] -- register_copy 
    // [64] phi (byte) plex_show_idx#43 = (byte) plex_show_idx#15 [phi:loop::@14->loop::@7#2] -- register_copy 
    // [64] phi (byte) plex_sprite_idx#43 = (byte) plex_sprite_idx#15 [phi:loop::@14->loop::@7#3] -- register_copy 
    // [64] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@14->loop::@7#4] -- register_copy 
    jmp __b7
    // loop::@7
  __b7:
    // [65] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp plexFreeNextYpos1
    // loop::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [66] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    jmp __b8
    // loop::@8
  __b8:
    // [67] if(*((const byte*) RASTER)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc __b8
    jmp __b9
    // loop::@9
  __b9:
    // [68] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [69] call plexShowSprite 
    jsr plexShowSprite
    jmp __b14
    // loop::@14
  __b14:
    // [70] (byte) loop::i1#1 ← ++ (byte) loop::i1#5 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [71] if((byte) loop::i1#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i1
    bne __b7_from___b14
    jmp __b10
    // loop::@10
  __b10:
    // [72] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [73] call keyboard_key_pressed 
    // [19] phi from loop::@10 to keyboard_key_pressed [phi:loop::@10->keyboard_key_pressed]
  keyboard_key_pressed_from___b10:
    jsr keyboard_key_pressed
    // [74] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
    jmp __b15
    // loop::@15
  __b15:
    // [75] (byte~) loop::$18 ← (byte) keyboard_key_pressed::return#3
    // [76] if((byte) 0!=(byte~) loop::$18) goto loop::@return -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __breturn
    // [29] phi from loop::@15 to loop::@1 [phi:loop::@15->loop::@1]
  __b1_from___b15:
    // [29] phi (byte) loop::angle#6 = (byte) loop::angle#1 [phi:loop::@15->loop::@1#0] -- register_copy 
    jmp __b1
    // loop::@return
  __breturn:
    // [77] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $13
    // [78] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [79] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // [80] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [81] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // [82] *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [83] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#17 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // [84] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_free_next
    jmp __b4
    // plexShowSprite::@4
  __b4:
    // [85] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#43) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // [86] (byte) plexShowSprite::xpos_idx#0 ← *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // [87] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [88] (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // [89] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [90] (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // [91] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    jmp __b3
    // plexShowSprite::@3
  __b3:
    // [92] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#43 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // [93] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp __b2
    // plexShowSprite::@2
  __b2:
    // [94] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#43 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // [95] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_sprite_idx
    // [96] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#43 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [97] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#43 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [98] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __b5_from___b2
    // [100] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  __breturn_from___b2:
    // [100] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    jmp __breturn
    // [99] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  __b5_from___b2:
    jmp __b5
    // plexShowSprite::@5
  __b5:
    // [100] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  __breturn_from___b5:
    // [100] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    jmp __breturn
    // plexShowSprite::@return
  __breturn:
    // [101] return 
    rts
    // plexShowSprite::@1
  __b1:
    // [102] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#43 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $13
    .label nxt_y = $14
    .label m = $12
    // [104] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  __b1_from_plexSort:
    // [104] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp __b1
    // [104] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  __b1_from___b2:
    // [104] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp __b1
    // plexSort::@1
  __b1:
    // [105] (byte) plexSort::nxt_idx#0 ← *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [106] (byte) plexSort::nxt_y#0 ← *((const byte*) PLEX_YPOS + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [107] if((byte) plexSort::nxt_y#0>=*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    jmp __b5
    // plexSort::@5
  __b5:
    // [108] (byte) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    ldx.z m
    // [109] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  __b3_from___b5:
  __b3_from___b6:
    // [109] phi (byte) plexSort::s#3 = (byte) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    jmp __b3
    // plexSort::@3
  __b3:
    // [110] *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // [111] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // [112] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    jmp __b6
    // plexSort::@6
  __b6:
    // [113] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3_from___b6
    jmp __b4
    // plexSort::@4
  __b4:
    // [114] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // [115] *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp __b2
    // plexSort::@2
  __b2:
    // [116] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [117] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1_from___b2
    // [118] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  plexFreePrepare1_from___b2:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [119] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1:
    // [119] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1___b1
    // [119] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1___b1_from_plexFreePrepare1___b1:
    // [119] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1___b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // [120] *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // [121] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [122] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1_from_plexFreePrepare1___b1
    jmp __breturn
    // plexSort::@return
  __breturn:
    // [123] return 
    rts
}
  // mulf8s
// Fast multiply two signed bytes to a word result
// mulf8s(signed byte register(A) a, signed byte register(X) b)
mulf8s: {
    .label return = 7
    jmp mulf8s_prepare1
    // mulf8s::mulf8s_prepare1
  mulf8s_prepare1:
    // [125] (byte) mulf8u_prepare::a#0 ← (byte)(signed byte) mulf8s::mulf8s_prepare1_a#0
    // [126] call mulf8u_prepare 
    jsr mulf8u_prepare
    jmp __b1
    // mulf8s::@1
  __b1:
    // [127] (signed byte) mulf8s_prepared::b#0 ← (signed byte) mulf8s::b#2 -- vbsz1=vbsxx 
    stx.z mulf8s_prepared.b
    // [128] call mulf8s_prepared 
    jsr mulf8s_prepared
    jmp __b2
    // mulf8s::@2
  __b2:
    // [129] (signed word) mulf8s::return#0 ← (signed word)(word) mulf8s_prepared::m#4
    jmp __breturn
    // mulf8s::@return
  __breturn:
    // [130] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8s_prepare(byte a)
// mulf8s_prepared(signed byte zp($14) b)
mulf8s_prepared: {
    .label memA = $fd
    .label m = 7
    .label b = $14
    // [131] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#0 -- vbuaa=vbuz1 
    lda.z b
    // [132] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [133] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0
    jmp __b5
    // mulf8s_prepared::@5
  __b5:
    // [134] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2
    // [135] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl __b1_from___b5
    jmp __b3
    // mulf8s_prepared::@3
  __b3:
    // [136] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // [137] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#0 -- vbuaa=vbuaa_minus_vbuz1 
    sec
    sbc.z b
    // [138] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [139] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
  __b1_from___b3:
  __b1_from___b5:
    // [139] phi (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    jmp __b1
    // mulf8s_prepared::@1
  __b1:
    // [140] if((signed byte) mulf8s_prepared::b#0>=(signed byte) 0) goto mulf8s_prepared::@2 -- vbsz1_ge_0_then_la1 
    lda.z b
    cmp #0
    bpl __b2_from___b1
    jmp __b4
    // mulf8s_prepared::@4
  __b4:
    // [141] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // [142] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA) -- vbuaa=vbuaa_minus__deref_pbuc1 
    sec
    sbc memA
    // [143] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [144] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
  __b2_from___b1:
  __b2_from___b4:
    // [144] phi (word) mulf8s_prepared::m#4 = (word) mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    jmp __b2
    // mulf8s_prepared::@2
  __b2:
    jmp __breturn
    // mulf8s_prepared::@return
  __breturn:
    // [145] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8u_prepare(byte a)
// mulf8u_prepared(byte register(A) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = 7
    // [146] *((const byte*) mulf8u_prepared::memB) ← (byte) mulf8u_prepared::b#0 -- _deref_pbuc1=vbuaa 
    sta memB
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    ldx memB
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // [148] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB) w= *((const byte*) mulf8u_prepared::resL) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta.z return
    lda memB
    sta.z return+1
    jmp __breturn
    // mulf8u_prepared::@return
  __breturn:
    // [149] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned byte to a word result
// mulf8u_prepare(byte register(A) a)
mulf8u_prepare: {
    .label memA = $fd
    // [150] *((const byte*) mulf8u_prepare::memA) ← (byte) mulf8u_prepare::a#0 -- _deref_pbuc1=vbuaa 
    sta memA
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    lda memA
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    jmp __breturn
    // mulf8u_prepare::@return
  __breturn:
    // [152] return 
    rts
}
  // init
// Initialize the program
init: {
    .label i = 6
    // [153] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [154] call plexInit 
  // Initialize the multiplexer
    // [212] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [155] phi from init to init::@1 [phi:init->init::@1]
  __b1_from_init:
    // [155] phi (byte) init::i#2 = (byte) 0 [phi:init->init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b1
  // Set the sprite pointers & initial positions
    // [155] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  __b1_from___b1:
    // [155] phi (byte) init::i#2 = (byte) init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    jmp __b1
    // init::@1
  __b1:
    // [156] *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #$ff&SPRITE/$40
    ldy.z i
    sta PLEX_PTR,y
    // [157] (byte~) init::$10 ← (byte) init::i#2 << (byte) 2 -- vbuaa=vbuz1_rol_2 
    lda.z i
    asl
    asl
    // [158] (byte~) init::$3 ← (byte~) init::$10 + (byte) init::i#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z i
    // [159] (byte~) init::$4 ← (byte) $18 + (byte~) init::$3 -- vbuxx=vbuc1_plus_vbuaa 
    tax
    axs #-[$18]
    // [160] (byte~) init::$9 ← (byte) init::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [161] *((const word*) PLEX_XPOS + (byte~) init::$9) ← (byte~) init::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    // [162] (byte~) init::$5 ← (byte) init::i#2 << (byte) 3 -- vbuaa=vbuz1_rol_3 
    lda.z i
    asl
    asl
    asl
    // [163] (byte~) init::$6 ← (byte) $32 + (byte~) init::$5 -- vbuaa=vbuc1_plus_vbuaa 
    clc
    adc #$32
    // [164] *((const byte*) PLEX_YPOS + (byte) init::i#2) ← (byte~) init::$6 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // [165] (byte) init::i#1 ← ++ (byte) init::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [166] if((byte) init::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1_from___b1
    jmp __b2
    // init::@2
  __b2:
    // [167] *((const byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [168] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  __b3_from___b2:
    // [168] phi (byte) init::i1#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b3
    // [168] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  __b3_from___b3:
    // [168] phi (byte) init::i1#2 = (byte) init::i1#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp __b3
    // init::@3
  __b3:
    // [169] *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // [170] (byte) init::i1#1 ← ++ (byte) init::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [171] if((byte) init::i1#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3_from___b3
    // [172] phi from init::@3 to init::@4 [phi:init::@3->init::@4]
  __b4_from___b3:
    jmp __b4
    // init::@4
  __b4:
    // [173] call mulf_init 
    // [183] phi from init::@4 to mulf_init [phi:init::@4->mulf_init]
  mulf_init_from___b4:
    jsr mulf_init
    // [174] phi from init::@4 to init::@5 [phi:init::@4->init::@5]
  __b5_from___b4:
    jmp __b5
    // init::@5
  __b5:
    // [175] call memset 
  // Clear screen
    // [177] phi from init::@5 to memset [phi:init::@5->memset]
  memset_from___b5:
    jsr memset
    jmp __breturn
    // init::@return
  __breturn:
    // [176] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .label str = SCREEN
    .const c = ' '
    .const num = $3e8
    .label end = str+num
    .label dst = 7
    // [178] phi from memset to memset::@1 [phi:memset->memset::@1]
  __b1_from_memset:
    // [178] phi (byte*) memset::dst#2 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    jmp __b1
    // memset::@1
  __b1:
    // [179] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    jmp __breturn
    // memset::@return
  __breturn:
    // [180] return 
    rts
    // memset::@2
  __b2:
    // [181] *((byte*) memset::dst#2) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [182] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [178] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
  __b1_from___b2:
    // [178] phi (byte*) memset::dst#2 = (byte*) memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    // x/2
    .label c = 9
    // Counter used for determining x%2==0
    .label sqr1_hi = $a
    // Fill mulf_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
    .label sqr = $10
    .label sqr1_lo = 7
    // Decrease or increase x_255 - initially we decrease
    .label sqr2_hi = $e
    .label sqr2_lo = $c
    //Start with g(0)=f(255)
    .label dir = $12
    // [184] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
  __b1_from_mulf_init:
    // [184] phi (byte) mulf_init::x_2#3 = (byte) 0 [phi:mulf_init->mulf_init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [184] phi (byte*) mulf_init::sqr1_hi#2 = (const byte*) mulf_sqr1_hi+(byte) 1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta.z sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta.z sqr1_hi+1
    // [184] phi (word) mulf_init::sqr#4 = (word) 0 [phi:mulf_init->mulf_init::@1#2] -- vwuz1=vwuc1 
    lda #<0
    sta.z sqr
    lda #>0
    sta.z sqr+1
    // [184] phi (byte) mulf_init::c#2 = (byte) 0 [phi:mulf_init->mulf_init::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // [184] phi (byte*) mulf_init::sqr1_lo#2 = (const byte*) mulf_sqr1_lo+(byte) 1 [phi:mulf_init->mulf_init::@1#4] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta.z sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta.z sqr1_lo+1
    jmp __b1
    // mulf_init::@1
  __b1:
    // [185] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne __b2
    lda.z sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne __b2
    // [186] phi from mulf_init::@1 to mulf_init::@5 [phi:mulf_init::@1->mulf_init::@5]
  __b5_from___b1:
    // [186] phi (byte) mulf_init::dir#2 = (byte) $ff [phi:mulf_init::@1->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z dir
    // [186] phi (byte*) mulf_init::sqr2_hi#2 = (const byte*) mulf_sqr2_hi [phi:mulf_init::@1->mulf_init::@5#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta.z sqr2_hi
    lda #>mulf_sqr2_hi
    sta.z sqr2_hi+1
    // [186] phi (byte) mulf_init::x_255#2 = (byte) -1 [phi:mulf_init::@1->mulf_init::@5#2] -- vbuxx=vbuc1 
    ldx #-1
    // [186] phi (byte*) mulf_init::sqr2_lo#2 = (const byte*) mulf_sqr2_lo [phi:mulf_init::@1->mulf_init::@5#3] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta.z sqr2_lo
    lda #>mulf_sqr2_lo
    sta.z sqr2_lo+1
    jmp __b5
    // mulf_init::@5
  __b5:
    // [187] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@6 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne __b6
    lda.z sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne __b6
    jmp __b7
    // mulf_init::@7
  __b7:
    // [188] *((const byte*) mulf_sqr2_lo+(word) $1ff) ← *((const byte*) mulf_sqr1_lo+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // [189] *((const byte*) mulf_sqr2_hi+(word) $1ff) ← *((const byte*) mulf_sqr1_hi+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    jmp __breturn
    // mulf_init::@return
  __breturn:
    // [190] return 
    rts
    // mulf_init::@6
  __b6:
    // [191] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_lo,x
    ldy #0
    sta (sqr2_lo),y
    // [192] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_hi,x
    ldy #0
    sta (sqr2_hi),y
    // [193] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_hi
    bne !+
    inc.z sqr2_hi+1
  !:
    // [194] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dir
    tax
    // [195] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@9 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b9_from___b6
    // [197] phi from mulf_init::@6 to mulf_init::@8 [phi:mulf_init::@6->mulf_init::@8]
  __b8_from___b6:
    // [197] phi (byte) mulf_init::dir#4 = (byte) 1 [phi:mulf_init::@6->mulf_init::@8#0] -- vbuz1=vbuc1 
    lda #1
    sta.z dir
    jmp __b8
    // [196] phi from mulf_init::@6 to mulf_init::@9 [phi:mulf_init::@6->mulf_init::@9]
  __b9_from___b6:
    jmp __b9
    // mulf_init::@9
  __b9:
    // [197] phi from mulf_init::@9 to mulf_init::@8 [phi:mulf_init::@9->mulf_init::@8]
  __b8_from___b9:
    // [197] phi (byte) mulf_init::dir#4 = (byte) mulf_init::dir#2 [phi:mulf_init::@9->mulf_init::@8#0] -- register_copy 
    jmp __b8
    // mulf_init::@8
  __b8:
    // [198] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_lo
    bne !+
    inc.z sqr2_lo+1
  !:
    // [186] phi from mulf_init::@8 to mulf_init::@5 [phi:mulf_init::@8->mulf_init::@5]
  __b5_from___b8:
    // [186] phi (byte) mulf_init::dir#2 = (byte) mulf_init::dir#4 [phi:mulf_init::@8->mulf_init::@5#0] -- register_copy 
    // [186] phi (byte*) mulf_init::sqr2_hi#2 = (byte*) mulf_init::sqr2_hi#1 [phi:mulf_init::@8->mulf_init::@5#1] -- register_copy 
    // [186] phi (byte) mulf_init::x_255#2 = (byte) mulf_init::x_255#1 [phi:mulf_init::@8->mulf_init::@5#2] -- register_copy 
    // [186] phi (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#1 [phi:mulf_init::@8->mulf_init::@5#3] -- register_copy 
    jmp __b5
    // mulf_init::@2
  __b2:
    // [199] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [200] (byte~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1 -- vbuaa=vbuz1_band_vbuc1 
    lda #1
    and.z c
    // [201] if((byte~) mulf_init::$1!=(byte) 0) goto mulf_init::@3 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b3_from___b2
    jmp __b4
    // mulf_init::@4
  __b4:
    // [202] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3 -- vbuxx=_inc_vbuxx 
    inx
    // [203] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc.z sqr
    bne !+
    inc.z sqr+1
  !:
    // [204] phi from mulf_init::@2 mulf_init::@4 to mulf_init::@3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [204] phi (byte) mulf_init::x_2#2 = (byte) mulf_init::x_2#3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#0] -- register_copy 
    // [204] phi (word) mulf_init::sqr#3 = (word) mulf_init::sqr#4 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#1] -- register_copy 
    jmp __b3
    // mulf_init::@3
  __b3:
    // [205] (byte~) mulf_init::$4 ← < (word) mulf_init::sqr#3 -- vbuaa=_lo_vwuz1 
    lda.z sqr
    // [206] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$4 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_lo),y
    // [207] (byte~) mulf_init::$5 ← > (word) mulf_init::sqr#3 -- vbuaa=_hi_vwuz1 
    lda.z sqr+1
    // [208] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_hi),y
    // [209] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_hi
    bne !+
    inc.z sqr1_hi+1
  !:
    // [210] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z sqr
    sta.z sqr
    bcc !+
    inc.z sqr+1
  !:
    // [211] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_lo
    bne !+
    inc.z sqr1_lo+1
  !:
    // [184] phi from mulf_init::@3 to mulf_init::@1 [phi:mulf_init::@3->mulf_init::@1]
  __b1_from___b3:
    // [184] phi (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#2 [phi:mulf_init::@3->mulf_init::@1#0] -- register_copy 
    // [184] phi (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#1 [phi:mulf_init::@3->mulf_init::@1#1] -- register_copy 
    // [184] phi (word) mulf_init::sqr#4 = (word) mulf_init::sqr#1 [phi:mulf_init::@3->mulf_init::@1#2] -- register_copy 
    // [184] phi (byte) mulf_init::c#2 = (byte) mulf_init::c#1 [phi:mulf_init::@3->mulf_init::@1#3] -- register_copy 
    // [184] phi (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#1 [phi:mulf_init::@3->mulf_init::@1#4] -- register_copy 
    jmp __b1
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // [213] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [214] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  __b1_from_plexSetScreen1:
    // [214] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp __b1
    // [214] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  __b1_from___b1:
    // [214] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp __b1
    // plexInit::@1
  __b1:
    // [215] *((const byte*) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // [216] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [217] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1_from___b1
    jmp __breturn
    // plexInit::@return
  __breturn:
    // [218] return 
    rts
}
  // File Data
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // The BOB sprite
  .align $1000
SPRITE:
.var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  // Sine and Cosine tables
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b11
Removing instruction jmp __b12
Removing instruction jmp __b5
Removing instruction jmp __b13
Removing instruction jmp __b6
Removing instruction jmp __b7
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp __b8
Removing instruction jmp __b9
Removing instruction jmp __b14
Removing instruction jmp __b10
Removing instruction jmp __b15
Removing instruction jmp plexFreeAdd1
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __b2
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b6
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1___b1
Removing instruction jmp __breturn
Removing instruction jmp mulf8s_prepare1
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __b5
Removing instruction jmp __b3
Removing instruction jmp __b1
Removing instruction jmp __b4
Removing instruction jmp __b2
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b4
Removing instruction jmp __b5
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __breturn
Removing instruction jmp __b9
Removing instruction jmp __b8
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp plexSetScreen1
Removing instruction jmp __b1
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing instruction ldx.z x+1 with TAX
Removing instruction lda.z y+1
Removing instruction lda #0
Removing instruction lda #0
Replacing instruction ldy.z nxt_idx with TAY
Removing instruction lda.z nxt_y
Replacing instruction ldx memB with TAX
Removing instruction lda memA
Replacing instruction lda.z i with TYA
Replacing instruction lda.z i with TYA
Replacing instruction lda #<0 with TXA
Removing instruction lda #>0
Removing instruction lda #0
Removing instruction ldy #0
Removing instruction ldy #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b4_from___b12 with __b4
Replacing label __b7_from___b14 with __b7
Replacing label __b1 with __b2
Replacing label __b5_from___b2 with __b5
Replacing label __breturn with __b5
Replacing label __b3_from___b6 with __b3
Replacing label __b1_from___b2 with __b1
Replacing label plexFreePrepare1___b1_from_plexFreePrepare1___b1 with plexFreePrepare1___b1
Replacing label __b1_from___b5 with __b1
Replacing label __b2_from___b1 with __b2
Replacing label __b1_from___b1 with __b1
Replacing label __b3_from___b3 with __b3
Replacing label __b9_from___b6 with __b8
Replacing label __b3_from___b2 with __b3
Replacing label __b1_from___b1 with __b1
Removing instruction __b1_from___bbegin:
Removing instruction __b1:
Removing instruction __bend_from___b1:
Removing instruction __b1_from_main:
Removing instruction loop_from___b1:
Removing instruction __b2_from___b1:
Removing instruction exit_from___b2:
Removing instruction __b1_from_exit:
Removing instruction keyboard_key_pressed_from___b1:
Removing instruction __b1:
Removing instruction __b4_from___b12:
Removing instruction __b7_from___b14:
Removing instruction __b5_from___b2:
Removing instruction __breturn_from___b5:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction __b3_from___b5:
Removing instruction __b3_from___b6:
Removing instruction plexFreePrepare1_from___b2:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1___b1_from_plexFreePrepare1___b1:
Removing instruction __breturn:
Removing instruction __b1_from___b3:
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b4:
Removing instruction __breturn:
Removing instruction __b1_from___b1:
Removing instruction __b3_from___b3:
Removing instruction __b4_from___b3:
Removing instruction mulf_init_from___b4:
Removing instruction __b5_from___b4:
Removing instruction __b9_from___b6:
Removing instruction __b9:
Removing instruction __b8_from___b9:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b4:
Removing instruction plexSetScreen1_from_plexInit:
Removing instruction __b1_from_plexSetScreen1:
Removing instruction __b1_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __breturn:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction __b1_from_loop:
Removing instruction __b3:
Removing instruction __b4_from___b3:
Removing instruction mulf8s_from___b4:
Removing instruction __b11:
Removing instruction mulf8s_from___b11:
Removing instruction __b12:
Removing instruction __b5:
Removing instruction plexSort_from___b5:
Removing instruction __b13:
Removing instruction __b7_from___b6:
Removing instruction plexFreeNextYpos1:
Removing instruction __b9:
Removing instruction __b14:
Removing instruction __b10:
Removing instruction keyboard_key_pressed_from___b10:
Removing instruction __b15:
Removing instruction __b1_from___b15:
Removing instruction plexFreeAdd1:
Removing instruction __b4:
Removing instruction __b3:
Removing instruction __breturn_from___b2:
Removing instruction __b1_from_plexSort:
Removing instruction __b5:
Removing instruction __b6:
Removing instruction plexFreePrepare1:
Removing instruction __breturn:
Removing instruction mulf8s_prepare1:
Removing instruction __b1:
Removing instruction __b2:
Removing instruction __b5:
Removing instruction __b3:
Removing instruction __b4:
Removing instruction __breturn:
Removing instruction __breturn:
Removing instruction plexInit_from_init:
Removing instruction __b1_from_init:
Removing instruction __b2:
Removing instruction __b3_from___b2:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction memset_from___b5:
Removing instruction __breturn:
Removing instruction __b1_from_memset:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Removing instruction __b1_from_mulf_init:
Removing instruction __b5_from___b1:
Removing instruction __b7:
Removing instruction __breturn:
Removing instruction __b8_from___b6:
Removing instruction __b5_from___b8:
Removing instruction __b4:
Removing instruction __b1_from___b3:
Removing instruction plexSetScreen1:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp __b5
Succesful ASM optimization Pass5DoubleJumpElimination
Relabelling long label __b1_from___b2 to b1
Succesful ASM optimization Pass5RelabelLongLabels
Removing instruction jmp __b4
Removing instruction jmp __b7
Removing instruction jmp __b1
Removing instruction jmp plexFreePrepare1___b1
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __b8
Removing instruction jmp __b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx.z m
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte) BLACK = (byte) 0
(const byte*) BORDERCOL = (byte*) 53280
(const byte*) CIA1_PORT_A = (byte*) 56320
(const byte*) CIA1_PORT_B = (byte*) 56321
(const signed byte*) COS = (const signed byte*) SIN+(byte) $40
(const byte*) D011 = (byte*) 53265
(const byte) GREEN = (byte) 5
(const byte) KEY_SPACE = (byte) $3c
(const byte) NUM_BOBS = (byte) $10
(const byte) PLEX_COUNT = (byte) $20
(const byte*) PLEX_FREE_YPOS[(number) 8]  = { fill( 8, 0) }
(const byte*) PLEX_PTR[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(byte*) PLEX_SCREEN_PTR
(const byte*) PLEX_SCREEN_PTR#1 PLEX_SCREEN_PTR = (const byte*) SCREEN+(word) $3f8
(const byte*) PLEX_SORTED_IDX[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(const word*) PLEX_XPOS[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(const byte*) PLEX_YPOS[(const byte) PLEX_COUNT]  = { fill( PLEX_COUNT, 0) }
(const byte*) RASTER = (byte*) 53266
(const byte*) SCREEN = (byte*) 1024
(const signed byte*) SIN[(number) $140]  = kickasm {{ .for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))
 }}
(const byte*) SPRITE[]  = kickasm {{ .var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
(const byte*) SPRITES_COLS = (byte*) 53287
(const byte*) SPRITES_ENABLE = (byte*) 53269
(const byte*) SPRITES_XMSB = (byte*) 53264
(const byte*) SPRITES_XPOS = (byte*) 53248
(const byte*) SPRITES_YPOS = (byte*) 53249
(const byte) VIC_DEN = (byte) $10
(const byte) VIC_RSEL = (byte) 8
(const byte) VIC_RST8 = (byte) $80
(void()) exit()
(byte~) exit::$0 reg byte a 2002.0
(label) exit::@1
(label) exit::@2
(label) exit::@return
(void()) init()
(byte~) init::$10 reg byte a 2002.0
(byte~) init::$3 reg byte a 2002.0
(byte~) init::$4 reg byte x 1001.0
(byte~) init::$5 reg byte a 2002.0
(byte~) init::$6 reg byte a 2002.0
(byte~) init::$9 reg byte a 2002.0
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@4
(label) init::@5
(label) init::@return
(byte) init::i
(byte) init::i#1 i zp[1]:6 1501.5
(byte) init::i#2 i zp[1]:6 800.8000000000001
(byte) init::i1
(byte) init::i1#1 reg byte x 1501.5
(byte) init::i1#2 reg byte x 1501.5
(byte()) keyboard_key_pressed((byte) keyboard_key_pressed::key)
(byte~) keyboard_key_pressed::$2 reg byte a 20002.0
(label) keyboard_key_pressed::@1
(label) keyboard_key_pressed::@return
(byte) keyboard_key_pressed::colidx
(const byte) keyboard_key_pressed::colidx#0 colidx = (const byte) KEY_SPACE&(byte) 7
(byte) keyboard_key_pressed::key
(byte) keyboard_key_pressed::return
(byte) keyboard_key_pressed::return#0 reg byte a 3000.75
(byte) keyboard_key_pressed::return#2 reg byte a 2002.0
(byte) keyboard_key_pressed::return#3 reg byte a 2002.0
(byte) keyboard_key_pressed::rowidx
(const byte) keyboard_key_pressed::rowidx#0 rowidx = (const byte) KEY_SPACE>>(byte) 3
(const byte*) keyboard_matrix_col_bitmask[(number) 8]  = { (byte) 1, (byte) 2, (byte) 4, (byte) 8, (byte) $10, (byte) $20, (byte) $40, (byte) $80 }
(byte()) keyboard_matrix_read((byte) keyboard_matrix_read::rowid)
(label) keyboard_matrix_read::@return
(byte) keyboard_matrix_read::return
(byte) keyboard_matrix_read::return#0 reg byte a 36667.33333333333
(byte) keyboard_matrix_read::return#2 reg byte a 20002.0
(byte) keyboard_matrix_read::row_pressed_bits
(byte) keyboard_matrix_read::rowid
(const byte*) keyboard_matrix_row_bitmask[(number) 8]  = { (byte) $fe, (byte) $fd, (byte) $fb, (byte) $f7, (byte) $ef, (byte) $df, (byte) $bf, (byte) $7f }
(void()) loop()
(signed word~) loop::$1 zp[2]:7 20002.0
(byte~) loop::$11 reg byte a 20002.0
(byte~) loop::$18 reg byte a 2002.0
(signed word~) loop::$2 zp[2]:7 20002.0
(byte~) loop::$20 reg byte a 20002.0
(byte~) loop::$4 reg byte x 10001.0
(signed word~) loop::$5 zp[2]:7 20002.0
(signed word~) loop::$6 zp[2]:7 20002.0
(byte~) loop::$8 reg byte a 20002.0
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@12
(label) loop::@13
(label) loop::@14
(label) loop::@15
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@6
(label) loop::@7
(label) loop::@8
(label) loop::@9
(label) loop::@return
(byte) loop::a
(byte) loop::a#1 a zp[1]:3 5000.5
(byte) loop::a#2 a zp[1]:3 1952.6190476190475
(byte) loop::a#6 a zp[1]:3 2002.0
(byte) loop::angle
(byte) loop::angle#1 angle zp[1]:6 117.76470588235294
(byte) loop::angle#6 angle zp[1]:6 96.87096774193549
(byte) loop::i
(byte) loop::i#1 i zp[1]:4 15001.5
(byte) loop::i#2 i zp[1]:4 1739.304347826087
(byte) loop::i1
(byte) loop::i1#1 i1 zp[1]:9 15001.5
(byte) loop::i1#5 i1 zp[1]:9 3333.6666666666665
(label) loop::plexFreeNextYpos1
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0 plexFreeNextYpos1_return zp[1]:18 55001.0
(signed byte) loop::r
(signed byte) loop::r#1 r zp[1]:2 6667.333333333333
(signed byte) loop::r#2 r zp[1]:2 1818.3636363636363
(byte) loop::rasterY
(signed word) loop::x
(signed word) loop::x#0 x zp[2]:7 20002.0
(signed word) loop::y
(signed word) loop::y#0 y zp[2]:7 20002.0
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@return
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@return
(byte) memset::c
(const byte) memset::c#0 c = (byte) ' '
(byte*) memset::dst
(byte*) memset::dst#1 dst zp[2]:7 20002.0
(byte*) memset::dst#2 dst zp[2]:7 13334.666666666666
(byte*) memset::end
(const byte*) memset::end#0 end = (byte*)(const void*) memset::str#0+(const word) memset::num#0
(word) memset::num
(const word) memset::num#0 num = (word) $3e8
(void*) memset::return
(void*) memset::str
(const void*) memset::str#0 str = (void*)(const byte*) SCREEN
(signed word()) mulf8s((signed byte) mulf8s::a , (signed byte) mulf8s::b)
(label) mulf8s::@1
(label) mulf8s::@2
(label) mulf8s::@return
(signed byte) mulf8s::a
(signed byte) mulf8s::a#0 reg byte a 10001.0
(signed byte) mulf8s::a#1 reg byte a 10001.0
(signed byte) mulf8s::b
(signed byte) mulf8s::b#0 reg byte x 20002.0
(signed byte) mulf8s::b#1 reg byte x 20002.0
(signed byte) mulf8s::b#2 reg byte x 40001.0
(label) mulf8s::mulf8s_prepare1
(signed byte) mulf8s::mulf8s_prepare1_a
(signed byte) mulf8s::mulf8s_prepare1_a#0 reg byte a 20002.0
(signed word) mulf8s::return
(signed word) mulf8s::return#0 return zp[2]:7 30000.75
(signed word) mulf8s::return#2 return zp[2]:7 20002.0
(signed word) mulf8s::return#3 return zp[2]:7 20002.0
(signed word()) mulf8s_prepared((signed byte) mulf8s_prepared::b)
(byte~) mulf8s_prepared::$12 reg byte a 2000002.0
(byte~) mulf8s_prepared::$15 reg byte a 2000002.0
(byte~) mulf8s_prepared::$16 reg byte a 2000002.0
(byte~) mulf8s_prepared::$8 reg byte a 2000002.0
(label) mulf8s_prepared::@1
(label) mulf8s_prepared::@2
(label) mulf8s_prepared::@3
(label) mulf8s_prepared::@4
(label) mulf8s_prepared::@5
(label) mulf8s_prepared::@return
(signed byte) mulf8s_prepared::b
(signed byte) mulf8s_prepared::b#0 b zp[1]:20 110000.20000000001
(word) mulf8s_prepared::m
(word) mulf8s_prepared::m#0 m zp[2]:7 1000001.0
(word) mulf8s_prepared::m#1 m zp[2]:7 2000002.0
(word) mulf8s_prepared::m#2 m zp[2]:7 2000002.0
(word) mulf8s_prepared::m#4 m zp[2]:7 666667.3333333334
(word) mulf8s_prepared::m#5 m zp[2]:7 1250001.25
(const signed byte*) mulf8s_prepared::memA = (signed byte*) 253
(signed word) mulf8s_prepared::return
(void()) mulf8u_prepare((byte) mulf8u_prepare::a)
(label) mulf8u_prepare::@return
(byte) mulf8u_prepare::a
(byte) mulf8u_prepare::a#0 reg byte a 1100002.0
(const byte*) mulf8u_prepare::memA = (byte*) 253
(word()) mulf8u_prepared((byte) mulf8u_prepared::b)
(label) mulf8u_prepared::@return
(byte) mulf8u_prepared::b
(byte) mulf8u_prepared::b#0 reg byte a 1.1000002E7
(const byte*) mulf8u_prepared::memB = (byte*) 255
(const byte*) mulf8u_prepared::resL = (byte*) 254
(word) mulf8u_prepared::return
(word) mulf8u_prepared::return#0 return zp[2]:7 3666667.333333333
(word) mulf8u_prepared::return#2 return zp[2]:7 2000002.0
(void()) mulf_init()
(byte~) mulf_init::$1 reg byte a 20002.0
(byte~) mulf_init::$4 reg byte a 20002.0
(byte~) mulf_init::$5 reg byte a 20002.0
(label) mulf_init::@1
(label) mulf_init::@2
(label) mulf_init::@3
(label) mulf_init::@4
(label) mulf_init::@5
(label) mulf_init::@6
(label) mulf_init::@7
(label) mulf_init::@8
(label) mulf_init::@9
(label) mulf_init::@return
(byte) mulf_init::c
(byte) mulf_init::c#1 c zp[1]:9 2307.9230769230767
(byte) mulf_init::c#2 c zp[1]:9 10001.0
(byte) mulf_init::dir
(byte) mulf_init::dir#2 dir zp[1]:18 3750.375
(byte) mulf_init::dir#4 dir zp[1]:18 10001.0
(word) mulf_init::sqr
(word) mulf_init::sqr#1 sqr zp[2]:16 10001.0
(word) mulf_init::sqr#2 sqr zp[2]:16 20002.0
(word) mulf_init::sqr#3 sqr zp[2]:16 8334.166666666666
(word) mulf_init::sqr#4 sqr zp[2]:16 5000.5
(byte*) mulf_init::sqr1_hi
(byte*) mulf_init::sqr1_hi#1 sqr1_hi zp[2]:10 6667.333333333333
(byte*) mulf_init::sqr1_hi#2 sqr1_hi zp[2]:10 2500.25
(byte*) mulf_init::sqr1_lo
(byte*) mulf_init::sqr1_lo#1 sqr1_lo zp[2]:7 20002.0
(byte*) mulf_init::sqr1_lo#2 sqr1_lo zp[2]:7 2857.4285714285716
(byte*) mulf_init::sqr2_hi
(byte*) mulf_init::sqr2_hi#1 sqr2_hi zp[2]:14 3333.6666666666665
(byte*) mulf_init::sqr2_hi#2 sqr2_hi zp[2]:14 7500.75
(byte*) mulf_init::sqr2_lo
(byte*) mulf_init::sqr2_lo#1 sqr2_lo zp[2]:12 20002.0
(byte*) mulf_init::sqr2_lo#2 sqr2_lo zp[2]:12 4444.888888888889
(byte) mulf_init::x_2
(byte) mulf_init::x_2#1 reg byte x 10001.0
(byte) mulf_init::x_2#2 reg byte x 5000.5
(byte) mulf_init::x_2#3 reg byte x 6000.6
(byte) mulf_init::x_255
(byte) mulf_init::x_255#1 reg byte x 6000.6
(byte) mulf_init::x_255#2 reg byte x 8000.8
(const byte*) mulf_sqr1_hi[(number) $200]  = { fill( $200, 0) }
(const byte*) mulf_sqr1_lo[(number) $200]  = { fill( $200, 0) }
(const byte*) mulf_sqr2_hi[(number) $200]  = { fill( $200, 0) }
(const byte*) mulf_sqr2_lo[(number) $200]  = { fill( $200, 0) }
(void()) plexInit((byte*) plexInit::screen)
(label) plexInit::@1
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#1 reg byte x 15001.5
(byte) plexInit::i#2 reg byte x 20002.0
(label) plexInit::plexSetScreen1
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 reg byte x 100001.0
(byte~) plexShowSprite::$2 reg byte a 200002.0
(byte~) plexShowSprite::$3 reg byte a 200002.0
(byte~) plexShowSprite::$5 reg byte x 200002.0
(byte~) plexShowSprite::$9 reg byte a 200002.0
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@5
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(byte~) plexShowSprite::plexFreeAdd1_$0 reg byte a 200002.0
(byte~) plexShowSprite::plexFreeAdd1_$1 reg byte x 200002.0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 150001.5
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp[1]:19 27273.0
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 reg byte a 200002.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#1 m zp[1]:18 1500001.5
(byte) plexSort::m#2 m zp[1]:18 416667.0833333334
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 nxt_idx zp[1]:19 300000.30000000005
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 nxt_y zp[1]:20 1500000.375
(label) plexSort::plexFreePrepare1
(label) plexSort::plexFreePrepare1_@1
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 reg byte x 1500001.5
(byte) plexSort::plexFreePrepare1_s#2 reg byte x 1500001.5
(byte) plexSort::s
(byte) plexSort::s#1 reg byte x 1.3666668333333332E7
(byte) plexSort::s#2 reg byte x 2000002.0
(byte) plexSort::s#3 reg byte x 2.05000025E7
(byte) plexSort::s#6 reg byte x 2000002.0
(byte) plex_free_next
(byte) plex_free_next#13 plex_free_next zp[1]:2 5000.090909090909
(byte) plex_free_next#17 plex_free_next zp[1]:2 22000.4
(byte) plex_show_idx
(byte) plex_show_idx#15 plex_show_idx zp[1]:4 12222.444444444445
(byte) plex_show_idx#43 plex_show_idx zp[1]:4 17083.541666666664
(byte) plex_sprite_idx
(byte) plex_sprite_idx#15 plex_sprite_idx zp[1]:3 11000.2
(byte) plex_sprite_idx#43 plex_sprite_idx zp[1]:3 14091.090909090908
(byte) plex_sprite_msb
(byte) plex_sprite_msb#16 plex_sprite_msb zp[1]:5 22000.4
(byte) plex_sprite_msb#3 plex_sprite_msb zp[1]:5 100001.0
(byte) plex_sprite_msb#43 plex_sprite_msb zp[1]:5 12400.16

zp[1]:2 [ plex_free_next#17 plex_free_next#13 loop::r#2 loop::r#1 ]
zp[1]:3 [ plex_sprite_idx#43 plex_sprite_idx#15 loop::a#2 loop::a#1 loop::a#6 ]
zp[1]:4 [ plex_show_idx#43 plex_show_idx#15 loop::i#2 loop::i#1 ]
zp[1]:5 [ plex_sprite_msb#43 plex_sprite_msb#16 plex_sprite_msb#3 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
reg byte a [ mulf8s::mulf8s_prepare1_a#0 mulf8s::a#1 mulf8s::a#0 ]
reg byte x [ mulf8s::b#2 mulf8s::b#1 mulf8s::b#0 ]
zp[1]:6 [ init::i#2 init::i#1 loop::angle#6 loop::angle#1 ]
reg byte x [ init::i1#2 init::i1#1 ]
zp[2]:7 [ mulf_init::sqr1_lo#2 mulf_init::sqr1_lo#1 memset::dst#2 memset::dst#1 mulf8s_prepared::m#4 mulf8s_prepared::m#5 mulf8s_prepared::m#1 mulf8s_prepared::m#0 mulf8s_prepared::m#2 mulf8s::return#0 mulf8u_prepared::return#2 mulf8s::return#2 loop::$1 mulf8s::return#3 loop::$5 mulf8u_prepared::return#0 loop::$2 loop::x#0 loop::$6 loop::y#0 ]
zp[1]:9 [ mulf_init::c#2 mulf_init::c#1 loop::i1#5 loop::i1#1 ]
zp[2]:10 [ mulf_init::sqr1_hi#2 mulf_init::sqr1_hi#1 ]
reg byte x [ mulf_init::x_2#3 mulf_init::x_2#2 mulf_init::x_2#1 ]
zp[2]:12 [ mulf_init::sqr2_lo#2 mulf_init::sqr2_lo#1 ]
reg byte x [ mulf_init::x_255#2 mulf_init::x_255#1 ]
zp[2]:14 [ mulf_init::sqr2_hi#2 mulf_init::sqr2_hi#1 ]
zp[2]:16 [ mulf_init::sqr#3 mulf_init::sqr#4 mulf_init::sqr#1 mulf_init::sqr#2 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
reg byte a [ keyboard_key_pressed::return#2 ]
reg byte a [ exit::$0 ]
reg byte a [ keyboard_matrix_read::return#2 ]
reg byte a [ keyboard_key_pressed::$2 ]
reg byte a [ keyboard_key_pressed::return#0 ]
reg byte a [ keyboard_matrix_read::return#0 ]
reg byte x [ loop::$4 ]
reg byte a [ loop::$20 ]
reg byte a [ loop::$8 ]
reg byte a [ loop::$11 ]
zp[1]:18 [ loop::plexFreeNextYpos1_return#0 mulf_init::dir#2 mulf_init::dir#4 plexSort::m#2 plexSort::m#1 ]
reg byte a [ keyboard_key_pressed::return#3 ]
reg byte a [ loop::$18 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$11 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$9 ]
reg byte x [ plexShowSprite::$5 ]
zp[1]:19 [ plexSort::nxt_idx#0 plexShowSprite::plex_sprite_idx2#0 ]
reg byte x [ plexSort::s#2 ]
reg byte a [ mulf8u_prepare::a#0 ]
zp[1]:20 [ mulf8s_prepared::b#0 plexSort::nxt_y#0 ]
reg byte a [ mulf8u_prepared::b#0 ]
reg byte a [ mulf8s_prepared::$8 ]
reg byte a [ mulf8s_prepared::$15 ]
reg byte a [ mulf8s_prepared::$12 ]
reg byte a [ mulf8s_prepared::$16 ]
reg byte a [ init::$10 ]
reg byte a [ init::$3 ]
reg byte x [ init::$4 ]
reg byte a [ init::$9 ]
reg byte a [ init::$5 ]
reg byte a [ init::$6 ]
reg byte a [ mulf_init::$1 ]
reg byte a [ mulf_init::$4 ]
reg byte a [ mulf_init::$5 ]


FINAL ASSEMBLER
Score: 75580

  // File Comments
// Same animation using a multiplexer
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // CIA#1 Port A: keyboard matrix columns and joystick #2
  .label CIA1_PORT_A = $dc00
  // CIA#1 Port B: keyboard matrix rows and joystick #1.
  .label CIA1_PORT_B = $dc01
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  .const KEY_SPACE = $3c
  // The BASIC screen
  .label SCREEN = $400
  // The number of BOBs to render
  .const NUM_BOBS = $10
  .label COS = SIN+$40
  // The address of the sprite pointers on the current screen (screen+$3f8).
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  // The MSB bit of the next sprite to use for showing
  .label plex_sprite_msb = 5
  // The index of the sprite that is free next. Since sprites are used round-robin this moves forward each time a sprite is shown.
  .label plex_free_next = 2
  // The index the next sprite to use for showing (sprites are used round-robin)
  .label plex_sprite_idx = 3
  // The index in the PLEX tables of the next sprite to show
  // Prepare for showing the sprites
  .label plex_show_idx = 4
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    // asm
    // asm { sei  }
    sei
    // init()
    // [5] call init 
    jsr init
    // [6] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // loop()
    // [7] call loop 
    // [28] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
    // [8] phi from main::@1 to main::@2 [phi:main::@1->main::@2]
    // main::@2
    // exit()
    // [9] call exit 
    // [12] phi from main::@2 to exit [phi:main::@2->exit]
    jsr exit
    // main::@3
    // asm
    // asm { cli  }
    cli
    // main::@return
    // }
    // [11] return 
    rts
}
  // exit
// Exit the program
exit: {
    // [13] phi from exit exit::@2 to exit::@1 [phi:exit/exit::@2->exit::@1]
  b1:
  // Wait for space release
    // exit::@1
    // keyboard_key_pressed(KEY_SPACE)
    // [14] call keyboard_key_pressed 
    // [19] phi from exit::@1 to keyboard_key_pressed [phi:exit::@1->keyboard_key_pressed]
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [15] (byte) keyboard_key_pressed::return#2 ← (byte) keyboard_key_pressed::return#0
    // exit::@2
    // [16] (byte~) exit::$0 ← (byte) keyboard_key_pressed::return#2
    // while(keyboard_key_pressed(KEY_SPACE))
    // [17] if((byte) 0!=(byte~) exit::$0) goto exit::@1 -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne b1
    // exit::@return
    // }
    // [18] return 
    rts
}
  // keyboard_key_pressed
// Determines whether a specific key is currently pressed by accessing the matrix directly
// The key is a keyboard code defined from the keyboard matrix by %00rrrccc, where rrr is the row ID (0-7) and ccc is the column ID (0-7)
// All keys exist as as KEY_XXX constants.
// Returns zero if the key is not pressed and a non-zero value if the key is currently pressed
keyboard_key_pressed: {
    .const colidx = KEY_SPACE&7
    .label rowidx = KEY_SPACE>>3
    // keyboard_matrix_read(rowidx)
    // [20] call keyboard_matrix_read 
    jsr keyboard_matrix_read
    // [21] (byte) keyboard_matrix_read::return#2 ← (byte) keyboard_matrix_read::return#0
    // keyboard_key_pressed::@1
    // [22] (byte~) keyboard_key_pressed::$2 ← (byte) keyboard_matrix_read::return#2
    // keyboard_matrix_read(rowidx) & keyboard_matrix_col_bitmask[colidx]
    // [23] (byte) keyboard_key_pressed::return#0 ← (byte~) keyboard_key_pressed::$2 & *((const byte*) keyboard_matrix_col_bitmask+(const byte) keyboard_key_pressed::colidx#0) -- vbuaa=vbuaa_band__deref_pbuc1 
    and keyboard_matrix_col_bitmask+colidx
    // keyboard_key_pressed::@return
    // }
    // [24] return 
    rts
}
  // keyboard_matrix_read
// Read a single row of the keyboard matrix
// The row ID (0-7) of the keyboard matrix row to read. See the C64 key matrix for row IDs.
// Returns the keys pressed on the row as bits according to the C64 key matrix.
// Notice: If the C64 normal interrupt is still running it will occasionally interrupt right between the read & write
// leading to erroneous readings. You must disable kill the normal interrupt or sei/cli around calls to the keyboard matrix reader.
keyboard_matrix_read: {
    // *CIA1_PORT_A = keyboard_matrix_row_bitmask[rowid]
    // [25] *((const byte*) CIA1_PORT_A) ← *((const byte*) keyboard_matrix_row_bitmask+(const byte) keyboard_key_pressed::rowidx#0) -- _deref_pbuc1=_deref_pbuc2 
    lda keyboard_matrix_row_bitmask+keyboard_key_pressed.rowidx
    sta CIA1_PORT_A
    // ~*CIA1_PORT_B
    // [26] (byte) keyboard_matrix_read::return#0 ← ~ *((const byte*) CIA1_PORT_B) -- vbuaa=_bnot__deref_pbuc1 
    lda CIA1_PORT_B
    eor #$ff
    // keyboard_matrix_read::@return
    // }
    // [27] return 
    rts
}
  // loop
// The main loop
loop: {
    .label __1 = 7
    .label __2 = 7
    .label __5 = 7
    .label __6 = 7
    .label x = 7
    .label y = 7
    .label a = 3
    .label r = 2
    .label i = 4
    // Render Rotated BOBs
    .label angle = 6
    .label plexFreeNextYpos1_return = $12
    .label i1 = 9
    // [29] phi from loop to loop::@1 [phi:loop->loop::@1]
    // [29] phi (byte) loop::angle#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z angle
    // loop::@1
    // loop::@2
  __b2:
    // while (*RASTER<0xd8)
    // [30] if(*((const byte*) RASTER)<(byte) $d8) goto loop::@2 -- _deref_pbuc1_lt_vbuc2_then_la1 
    lda RASTER
    cmp #$d8
    bcc __b2
    // loop::@3
    // *BORDERCOL = 0xf
    // [31] *((const byte*) BORDERCOL) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta BORDERCOL
    // [32] (byte) loop::a#6 ← (byte) loop::angle#6 -- vbuz1=vbuz2 
    lda.z angle
    sta.z a
    // [33] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
    // [33] phi (byte) loop::i#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // [33] phi (byte) loop::a#2 = (byte) loop::a#6 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [33] phi (signed byte) loop::r#2 = (signed byte) $1e [phi:loop::@3->loop::@4#2] -- vbsz1=vbsc1 
    lda #$1e
    sta.z r
    // [33] phi from loop::@12 to loop::@4 [phi:loop::@12->loop::@4]
    // [33] phi (byte) loop::i#2 = (byte) loop::i#1 [phi:loop::@12->loop::@4#0] -- register_copy 
    // [33] phi (byte) loop::a#2 = (byte) loop::a#1 [phi:loop::@12->loop::@4#1] -- register_copy 
    // [33] phi (signed byte) loop::r#2 = (signed byte) loop::r#1 [phi:loop::@12->loop::@4#2] -- register_copy 
    // loop::@4
  __b4:
    // *BORDERCOL = 6
    // [34] *((const byte*) BORDERCOL) ← (byte) 6 -- _deref_pbuc1=vbuc2 
    //kickasm {{ .break }}
    lda #6
    sta BORDERCOL
    // mulf8s(r, COS[a])
    // [35] (signed byte) mulf8s::a#0 ← (signed byte) loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [36] (signed byte) mulf8s::b#0 ← *((const signed byte*) COS + (byte) loop::a#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx COS,y
    // [37] call mulf8s 
    // [124] phi from loop::@4 to mulf8s [phi:loop::@4->mulf8s]
    // [124] phi (signed byte) mulf8s::b#2 = (signed byte) mulf8s::b#0 [phi:loop::@4->mulf8s#0] -- register_copy 
    // [124] phi (signed byte) mulf8s::mulf8s_prepare1_a#0 = (signed byte) mulf8s::a#0 [phi:loop::@4->mulf8s#1] -- register_copy 
    jsr mulf8s
    // mulf8s(r, COS[a])
    // [38] (signed word) mulf8s::return#2 ← (signed word) mulf8s::return#0
    // loop::@11
    // [39] (signed word~) loop::$1 ← (signed word) mulf8s::return#2
    // mulf8s(r, COS[a])*2
    // [40] (signed word~) loop::$2 ← (signed word~) loop::$1 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl.z __2
    rol.z __2+1
    // x = mulf8s(r, COS[a])*2 + 125*0x100
    // [41] (signed word) loop::x#0 ← (signed word~) loop::$2 + (signed word)(number) $7d*(number) $100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z x
    adc #<$7d*$100
    sta.z x
    lda.z x+1
    adc #>$7d*$100
    sta.z x+1
    // >x
    // [42] (byte~) loop::$4 ← > (signed word) loop::x#0 -- vbuxx=_hi_vwsz1 
    tax
    // PLEX_XPOS[i] = >x
    // [43] (byte~) loop::$20 ← (byte) loop::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [44] *((const word*) PLEX_XPOS + (byte~) loop::$20) ← (byte~) loop::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    // mulf8s(r, SIN[a])
    // [45] (signed byte) mulf8s::a#1 ← (signed byte) loop::r#2 -- vbsaa=vbsz1 
    lda.z r
    // [46] (signed byte) mulf8s::b#1 ← *((const signed byte*) SIN + (byte) loop::a#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy.z a
    ldx SIN,y
    // [47] call mulf8s 
    // [124] phi from loop::@11 to mulf8s [phi:loop::@11->mulf8s]
    // [124] phi (signed byte) mulf8s::b#2 = (signed byte) mulf8s::b#1 [phi:loop::@11->mulf8s#0] -- register_copy 
    // [124] phi (signed byte) mulf8s::mulf8s_prepare1_a#0 = (signed byte) mulf8s::a#1 [phi:loop::@11->mulf8s#1] -- register_copy 
    jsr mulf8s
    // mulf8s(r, SIN[a])
    // [48] (signed word) mulf8s::return#3 ← (signed word) mulf8s::return#0
    // loop::@12
    // [49] (signed word~) loop::$5 ← (signed word) mulf8s::return#3
    // mulf8s(r, SIN[a])*2
    // [50] (signed word~) loop::$6 ← (signed word~) loop::$5 << (byte) 1 -- vwsz1=vwsz1_rol_1 
    asl.z __6
    rol.z __6+1
    // y = mulf8s(r, SIN[a])*2 + 125*0x100
    // [51] (signed word) loop::y#0 ← (signed word~) loop::$6 + (signed word)(number) $7d*(number) $100 -- vwsz1=vwsz1_plus_vwsc1 
    clc
    lda.z y
    adc #<$7d*$100
    sta.z y
    lda.z y+1
    adc #>$7d*$100
    sta.z y+1
    // >y
    // [52] (byte~) loop::$8 ← > (signed word) loop::y#0 -- vbuaa=_hi_vwsz1 
    // PLEX_YPOS[i] = >y
    // [53] *((const byte*) PLEX_YPOS + (byte) loop::i#2) ← (byte~) loop::$8 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // a += 98
    // [54] (byte) loop::a#1 ← (byte) loop::a#2 + (byte) $62 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z a
    axs #-[$62]
    stx.z a
    // r += 3
    // [55] (signed byte) loop::r#1 ← (signed byte) loop::r#2 + (signed byte) 3 -- vbsz1=vbsz1_plus_vbsc1 
    lax.z r
    axs #-[3]
    stx.z r
    // for(char i: 0..NUM_BOBS-1)
    // [56] (byte) loop::i#1 ← ++ (byte) loop::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [57] if((byte) loop::i#1!=(const byte) NUM_BOBS-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #NUM_BOBS-1+1
    cmp.z i
    bne __b4
    // loop::@5
    // *BORDERCOL = 3
    // [58] *((const byte*) BORDERCOL) ← (byte) 3 -- _deref_pbuc1=vbuc2 
    lda #3
    sta BORDERCOL
    // plexSort()
    // [59] call plexSort 
    // [103] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
    // loop::@13
    // angle += 3
    // [60] (byte) loop::angle#1 ← (byte) loop::angle#6 + (byte) 3 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z angle
    axs #-[3]
    stx.z angle
    // *BORDERCOL = BLACK
    // [61] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
  // Sort the sprites by y-position
    // loop::@6
  __b6:
    // *D011&VIC_RST8
    // [62] (byte~) loop::$11 ← *((const byte*) D011) & (const byte) VIC_RST8 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    // while((*D011&VIC_RST8)!=0)
    // [63] if((byte~) loop::$11!=(byte) 0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b6
    // [64] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
    // [64] phi (byte) loop::i1#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i1
    // [64] phi (byte) plex_sprite_msb#43 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [64] phi (byte) plex_show_idx#43 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [64] phi (byte) plex_sprite_idx#43 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // [64] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    sta.z plex_free_next
  // Show the sprites
    // [64] phi from loop::@14 to loop::@7 [phi:loop::@14->loop::@7]
    // [64] phi (byte) loop::i1#5 = (byte) loop::i1#1 [phi:loop::@14->loop::@7#0] -- register_copy 
    // [64] phi (byte) plex_sprite_msb#43 = (byte) plex_sprite_msb#16 [phi:loop::@14->loop::@7#1] -- register_copy 
    // [64] phi (byte) plex_show_idx#43 = (byte) plex_show_idx#15 [phi:loop::@14->loop::@7#2] -- register_copy 
    // [64] phi (byte) plex_sprite_idx#43 = (byte) plex_sprite_idx#15 [phi:loop::@14->loop::@7#3] -- register_copy 
    // [64] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@14->loop::@7#4] -- register_copy 
    // loop::@7
  __b7:
    // *BORDERCOL = BLACK
    // [65] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // loop::plexFreeNextYpos1
    // return PLEX_FREE_YPOS[plex_free_next];
    // [66] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    // loop::@8
  __b8:
    // while(*RASTER<rasterY)
    // [67] if(*((const byte*) RASTER)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc __b8
    // loop::@9
    // (*BORDERCOL)++;
    // [68] *((const byte*) BORDERCOL) ← ++ *((const byte*) BORDERCOL) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // plexShowSprite()
    // [69] call plexShowSprite 
    jsr plexShowSprite
    // loop::@14
    // for( char i: 0..PLEX_COUNT-1)
    // [70] (byte) loop::i1#1 ← ++ (byte) loop::i1#5 -- vbuz1=_inc_vbuz1 
    inc.z i1
    // [71] if((byte) loop::i1#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i1
    bne __b7
    // loop::@10
    // *BORDERCOL = BLACK
    // [72] *((const byte*) BORDERCOL) ← (const byte) BLACK -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // keyboard_key_pressed(KEY_SPACE)
    // [73] call keyboard_key_pressed 
    // [19] phi from loop::@10 to keyboard_key_pressed [phi:loop::@10->keyboard_key_pressed]
    jsr keyboard_key_pressed
    // keyboard_key_pressed(KEY_SPACE)
    // [74] (byte) keyboard_key_pressed::return#3 ← (byte) keyboard_key_pressed::return#0
    // loop::@15
    // [75] (byte~) loop::$18 ← (byte) keyboard_key_pressed::return#3
    // if(keyboard_key_pressed(KEY_SPACE))
    // [76] if((byte) 0!=(byte~) loop::$18) goto loop::@return -- vbuc1_neq_vbuaa_then_la1 
    cmp #0
    bne __breturn
    // [29] phi from loop::@15 to loop::@1 [phi:loop::@15->loop::@1]
    // [29] phi (byte) loop::angle#6 = (byte) loop::angle#1 [phi:loop::@15->loop::@1#0] -- register_copy 
    jmp __b2
    // loop::@return
  __breturn:
    // }
    // [77] return 
    rts
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = $13
    // plex_sprite_idx2 = plex_sprite_idx*2
    // [78] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#43 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // ypos = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
    // [79] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // SPRITES_YPOS[plex_sprite_idx2] = ypos
    // [80] *((const byte*) SPRITES_YPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    // plexShowSprite::plexFreeAdd1
    // ypos+21
    // [81] (byte~) plexShowSprite::plexFreeAdd1_$0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // PLEX_FREE_YPOS[plex_free_next] =  ypos+21
    // [82] *((const byte*) PLEX_FREE_YPOS + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // plex_free_next+1
    // [83] (byte~) plexShowSprite::plexFreeAdd1_$1 ← (byte) plex_free_next#17 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // plex_free_next = (plex_free_next+1)&7
    // [84] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_free_next
    // plexShowSprite::@4
    // PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
    // [85] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#43) ← *((const byte*) PLEX_PTR + *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // xpos_idx = PLEX_SORTED_IDX[plex_show_idx]
    // [86] (byte) plexShowSprite::xpos_idx#0 ← *((const byte*) PLEX_SORTED_IDX + (byte) plex_show_idx#43) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // <PLEX_XPOS[xpos_idx]
    // [87] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [88] (byte~) plexShowSprite::$2 ← < *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // SPRITES_XPOS[plex_sprite_idx2] = <PLEX_XPOS[xpos_idx]
    // [89] *((const byte*) SPRITES_XPOS + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // >PLEX_XPOS[xpos_idx]
    // [90] (byte~) plexShowSprite::$3 ← > *((const word*) PLEX_XPOS + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // if(>PLEX_XPOS[xpos_idx]!=0)
    // [91] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b1
    // plexShowSprite::@3
    // $ff^plex_sprite_msb
    // [92] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#43 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // *SPRITES_XMSB &= ($ff^plex_sprite_msb)
    // [93] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    // plexShowSprite::@2
  __b2:
    // plex_sprite_idx+1
    // [94] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#43 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // plex_sprite_idx = (plex_sprite_idx+1)&7
    // [95] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_sprite_idx
    // plex_show_idx++;
    // [96] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#43 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // plex_sprite_msb *=2
    // [97] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#43 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // if(plex_sprite_msb==0)
    // [98] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne __b5
    // [100] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
    // [100] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    rts
    // [99] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
    // plexShowSprite::@5
  __b5:
    // [100] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
    // [100] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    // plexShowSprite::@return
    // }
    // [101] return 
    rts
    // plexShowSprite::@1
  __b1:
    // *SPRITES_XMSB |= plex_sprite_msb
    // [102] *((const byte*) SPRITES_XMSB) ← *((const byte*) SPRITES_XMSB) | (byte) plex_sprite_msb#43 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp __b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $13
    .label nxt_y = $14
    .label m = $12
    // [104] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
    // [104] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    // [104] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
    // [104] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    // plexSort::@1
  __b1:
    // nxt_idx = PLEX_SORTED_IDX[m+1]
    // [105] (byte) plexSort::nxt_idx#0 ← *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // nxt_y = PLEX_YPOS[nxt_idx]
    // [106] (byte) plexSort::nxt_y#0 ← *((const byte*) PLEX_YPOS + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta.z nxt_y
    // if(nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[m]])
    // [107] if((byte) plexSort::nxt_y#0>=*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs __b2
    // plexSort::@5
    // [108] (byte) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    // [109] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
    // [109] phi (byte) plexSort::s#3 = (byte) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    // plexSort::@3
  __b3:
    // PLEX_SORTED_IDX[s+1] = PLEX_SORTED_IDX[s]
    // [110] *((const byte*) PLEX_SORTED_IDX+(byte) 1 + (byte) plexSort::s#3) ← *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // s--;
    // [111] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // while((s!=$ff) && (nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[s]]))
    // [112] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq __b4
    // plexSort::@6
    // [113] if((byte) plexSort::nxt_y#0<*((const byte*) PLEX_YPOS + *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc __b3
    // plexSort::@4
  __b4:
    // s++;
    // [114] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // PLEX_SORTED_IDX[s] = nxt_idx
    // [115] *((const byte*) PLEX_SORTED_IDX + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    // plexSort::@2
  __b2:
    // for(byte m: 0..PLEX_COUNT-2)
    // [116] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [117] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne __b1
    // [118] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
    // plexSort::plexFreePrepare1
    // [119] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
    // [119] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [119] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
    // [119] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1___b1:
    // PLEX_FREE_YPOS[s] = 0
    // [120] *((const byte*) PLEX_FREE_YPOS + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // for( byte s: 0..7)
    // [121] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [122] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1___b1
    // plexSort::@return
    // }
    // [123] return 
    rts
}
  // mulf8s
// Fast multiply two signed bytes to a word result
// mulf8s(signed byte register(A) a, signed byte register(X) b)
mulf8s: {
    .label return = 7
    // mulf8s::mulf8s_prepare1
    // mulf8u_prepare((byte)a)
    // [125] (byte) mulf8u_prepare::a#0 ← (byte)(signed byte) mulf8s::mulf8s_prepare1_a#0
    // [126] call mulf8u_prepare 
    jsr mulf8u_prepare
    // mulf8s::@1
    // mulf8s_prepared(b)
    // [127] (signed byte) mulf8s_prepared::b#0 ← (signed byte) mulf8s::b#2 -- vbsz1=vbsxx 
    stx.z mulf8s_prepared.b
    // [128] call mulf8s_prepared 
    jsr mulf8s_prepared
    // mulf8s::@2
    // [129] (signed word) mulf8s::return#0 ← (signed word)(word) mulf8s_prepared::m#4
    // mulf8s::@return
    // }
    // [130] return 
    rts
}
  // mulf8s_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8s_prepare(byte a)
// mulf8s_prepared(signed byte zp($14) b)
mulf8s_prepared: {
    .label memA = $fd
    .label m = 7
    .label b = $14
    // mulf8u_prepared((byte) b)
    // [131] (byte) mulf8u_prepared::b#0 ← (byte)(signed byte) mulf8s_prepared::b#0 -- vbuaa=vbuz1 
    lda.z b
    // [132] call mulf8u_prepared 
    jsr mulf8u_prepared
    // [133] (word) mulf8u_prepared::return#2 ← (word) mulf8u_prepared::return#0
    // mulf8s_prepared::@5
    // m = mulf8u_prepared((byte) b)
    // [134] (word) mulf8s_prepared::m#0 ← (word) mulf8u_prepared::return#2
    // if(*memA<0)
    // [135] if(*((const signed byte*) mulf8s_prepared::memA)>=(signed byte) 0) goto mulf8s_prepared::@1 -- _deref_pbsc1_ge_0_then_la1 
    lda memA
    cmp #0
    bpl __b1
    // mulf8s_prepared::@3
    // >m
    // [136] (byte~) mulf8s_prepared::$8 ← > (word) mulf8s_prepared::m#0 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // >m = (>m)-(byte)b
    // [137] (byte~) mulf8s_prepared::$15 ← (byte~) mulf8s_prepared::$8 - (byte)(signed byte) mulf8s_prepared::b#0 -- vbuaa=vbuaa_minus_vbuz1 
    sec
    sbc.z b
    // [138] (word) mulf8s_prepared::m#1 ← (word) mulf8s_prepared::m#0 hi= (byte~) mulf8s_prepared::$15 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [139] phi from mulf8s_prepared::@3 mulf8s_prepared::@5 to mulf8s_prepared::@1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1]
    // [139] phi (word) mulf8s_prepared::m#5 = (word) mulf8s_prepared::m#1 [phi:mulf8s_prepared::@3/mulf8s_prepared::@5->mulf8s_prepared::@1#0] -- register_copy 
    // mulf8s_prepared::@1
  __b1:
    // if(b<0)
    // [140] if((signed byte) mulf8s_prepared::b#0>=(signed byte) 0) goto mulf8s_prepared::@2 -- vbsz1_ge_0_then_la1 
    lda.z b
    cmp #0
    bpl __b2
    // mulf8s_prepared::@4
    // >m
    // [141] (byte~) mulf8s_prepared::$12 ← > (word) mulf8s_prepared::m#5 -- vbuaa=_hi_vwuz1 
    lda.z m+1
    // >m = (>m)-(byte)*memA
    // [142] (byte~) mulf8s_prepared::$16 ← (byte~) mulf8s_prepared::$12 - (byte)*((const signed byte*) mulf8s_prepared::memA) -- vbuaa=vbuaa_minus__deref_pbuc1 
    sec
    sbc memA
    // [143] (word) mulf8s_prepared::m#2 ← (word) mulf8s_prepared::m#5 hi= (byte~) mulf8s_prepared::$16 -- vwuz1=vwuz1_sethi_vbuaa 
    sta.z m+1
    // [144] phi from mulf8s_prepared::@1 mulf8s_prepared::@4 to mulf8s_prepared::@2 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2]
    // [144] phi (word) mulf8s_prepared::m#4 = (word) mulf8s_prepared::m#5 [phi:mulf8s_prepared::@1/mulf8s_prepared::@4->mulf8s_prepared::@2#0] -- register_copy 
    // mulf8s_prepared::@2
  __b2:
    // mulf8s_prepared::@return
    // }
    // [145] return 
    rts
}
  // mulf8u_prepared
// Calculate fast multiply with a prepared unsigned byte to a word result
// The prepared number is set by calling mulf8u_prepare(byte a)
// mulf8u_prepared(byte register(A) b)
mulf8u_prepared: {
    .label resL = $fe
    .label memB = $ff
    .label return = 7
    // *memB = b
    // [146] *((const byte*) mulf8u_prepared::memB) ← (byte) mulf8u_prepared::b#0 -- _deref_pbuc1=vbuaa 
    sta memB
    // asm
    // asm { ldxmemB sec sm1: ldamulf_sqr1_lo,x sm2: sbcmulf_sqr2_lo,x staresL sm3: ldamulf_sqr1_hi,x sm4: sbcmulf_sqr2_hi,x stamemB  }
    tax
    sec
  sm1:
    lda mulf_sqr1_lo,x
  sm2:
    sbc mulf_sqr2_lo,x
    sta resL
  sm3:
    lda mulf_sqr1_hi,x
  sm4:
    sbc mulf_sqr2_hi,x
    sta memB
    // return { *memB, *resL };
    // [148] (word) mulf8u_prepared::return#0 ← *((const byte*) mulf8u_prepared::memB) w= *((const byte*) mulf8u_prepared::resL) -- vwuz1=_deref_pbuc1_word__deref_pbuc2 
    lda resL
    sta.z return
    lda memB
    sta.z return+1
    // mulf8u_prepared::@return
    // }
    // [149] return 
    rts
}
  // mulf8u_prepare
// Prepare for fast multiply with an unsigned byte to a word result
// mulf8u_prepare(byte register(A) a)
mulf8u_prepare: {
    .label memA = $fd
    // *memA = a
    // [150] *((const byte*) mulf8u_prepare::memA) ← (byte) mulf8u_prepare::a#0 -- _deref_pbuc1=vbuaa 
    sta memA
    // asm
    // asm { ldamemA stamulf8u_prepared.sm1+1 stamulf8u_prepared.sm3+1 eor#$ff stamulf8u_prepared.sm2+1 stamulf8u_prepared.sm4+1  }
    sta mulf8u_prepared.sm1+1
    sta mulf8u_prepared.sm3+1
    eor #$ff
    sta mulf8u_prepared.sm2+1
    sta mulf8u_prepared.sm4+1
    // mulf8u_prepare::@return
    // }
    // [152] return 
    rts
}
  // init
// Initialize the program
init: {
    .label i = 6
    // *D011 = VIC_DEN | VIC_RSEL | 3
    // [153] *((const byte*) D011) ← (const byte) VIC_DEN|(const byte) VIC_RSEL|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // plexInit(SCREEN)
    // [154] call plexInit 
  // Initialize the multiplexer
    // [212] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
    // [155] phi from init to init::@1 [phi:init->init::@1]
    // [155] phi (byte) init::i#2 = (byte) 0 [phi:init->init::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
  // Set the sprite pointers & initial positions
    // [155] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
    // [155] phi (byte) init::i#2 = (byte) init::i#1 [phi:init::@1->init::@1#0] -- register_copy 
    // init::@1
  __b1:
    // PLEX_PTR[i] = (char)(SPRITE/0x40)
    // [156] *((const byte*) PLEX_PTR + (byte) init::i#2) ← (byte)(const byte*) SPRITE/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #$ff&SPRITE/$40
    ldy.z i
    sta PLEX_PTR,y
    // i*5
    // [157] (byte~) init::$10 ← (byte) init::i#2 << (byte) 2 -- vbuaa=vbuz1_rol_2 
    tya
    asl
    asl
    // [158] (byte~) init::$3 ← (byte~) init::$10 + (byte) init::i#2 -- vbuaa=vbuaa_plus_vbuz1 
    clc
    adc.z i
    // 24+i*5
    // [159] (byte~) init::$4 ← (byte) $18 + (byte~) init::$3 -- vbuxx=vbuc1_plus_vbuaa 
    tax
    axs #-[$18]
    // PLEX_XPOS[i] = 24+i*5
    // [160] (byte~) init::$9 ← (byte) init::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    tya
    asl
    // [161] *((const word*) PLEX_XPOS + (byte~) init::$9) ← (byte~) init::$4 -- pwuc1_derefidx_vbuaa=vbuxx 
    tay
    txa
    sta PLEX_XPOS,y
    // i*8
    // [162] (byte~) init::$5 ← (byte) init::i#2 << (byte) 3 -- vbuaa=vbuz1_rol_3 
    lda.z i
    asl
    asl
    asl
    // 50+i*8
    // [163] (byte~) init::$6 ← (byte) $32 + (byte~) init::$5 -- vbuaa=vbuc1_plus_vbuaa 
    clc
    adc #$32
    // PLEX_YPOS[i] = 50+i*8
    // [164] *((const byte*) PLEX_YPOS + (byte) init::i#2) ← (byte~) init::$6 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z i
    sta PLEX_YPOS,y
    // for(char i: 0..PLEX_COUNT-1)
    // [165] (byte) init::i#1 ← ++ (byte) init::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [166] if((byte) init::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne __b1
    // init::@2
    // *SPRITES_ENABLE = 0xff
    // [167] *((const byte*) SPRITES_ENABLE) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [168] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
    // [168] phi (byte) init::i1#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // [168] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
    // [168] phi (byte) init::i1#2 = (byte) init::i1#1 [phi:init::@3->init::@3#0] -- register_copy 
    // init::@3
  __b3:
    // SPRITES_COLS[i] = GREEN
    // [169] *((const byte*) SPRITES_COLS + (byte) init::i1#2) ← (const byte) GREEN -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // for(char i: 0..7)
    // [170] (byte) init::i1#1 ← ++ (byte) init::i1#2 -- vbuxx=_inc_vbuxx 
    inx
    // [171] if((byte) init::i1#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne __b3
    // [172] phi from init::@3 to init::@4 [phi:init::@3->init::@4]
    // init::@4
    // mulf_init()
    // [173] call mulf_init 
    // [183] phi from init::@4 to mulf_init [phi:init::@4->mulf_init]
    jsr mulf_init
    // [174] phi from init::@4 to init::@5 [phi:init::@4->init::@5]
    // init::@5
    // memset(SCREEN, ' ', 1000)
    // [175] call memset 
  // Clear screen
    // [177] phi from init::@5 to memset [phi:init::@5->memset]
    jsr memset
    // init::@return
    // }
    // [176] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .label str = SCREEN
    .const c = ' '
    .const num = $3e8
    .label end = str+num
    .label dst = 7
    // [178] phi from memset to memset::@1 [phi:memset->memset::@1]
    // [178] phi (byte*) memset::dst#2 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@1#0] -- pbuz1=pbuc1 
    lda #<str
    sta.z dst
    lda #>str
    sta.z dst+1
    // memset::@1
  __b1:
    // for(char* dst = str; dst!=end; dst++)
    // [179] if((byte*) memset::dst#2!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z dst+1
    cmp #>end
    bne __b2
    lda.z dst
    cmp #<end
    bne __b2
    // memset::@return
    // }
    // [180] return 
    rts
    // memset::@2
  __b2:
    // *dst = c
    // [181] *((byte*) memset::dst#2) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [182] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#2 -- pbuz1=_inc_pbuz1 
    inc.z dst
    bne !+
    inc.z dst+1
  !:
    // [178] phi from memset::@2 to memset::@1 [phi:memset::@2->memset::@1]
    // [178] phi (byte*) memset::dst#2 = (byte*) memset::dst#1 [phi:memset::@2->memset::@1#0] -- register_copy 
    jmp __b1
}
  // mulf_init
// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/4)
mulf_init: {
    // x/2
    .label c = 9
    // Counter used for determining x%2==0
    .label sqr1_hi = $a
    // Fill mulf_sqr1 = f(x) = int(x*x/4): If f(x) = x*x/4 then f(x+1) = f(x) + x/2 + 1/4
    .label sqr = $10
    .label sqr1_lo = 7
    // Decrease or increase x_255 - initially we decrease
    .label sqr2_hi = $e
    .label sqr2_lo = $c
    //Start with g(0)=f(255)
    .label dir = $12
    // [184] phi from mulf_init to mulf_init::@1 [phi:mulf_init->mulf_init::@1]
    // [184] phi (byte) mulf_init::x_2#3 = (byte) 0 [phi:mulf_init->mulf_init::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [184] phi (byte*) mulf_init::sqr1_hi#2 = (const byte*) mulf_sqr1_hi+(byte) 1 [phi:mulf_init->mulf_init::@1#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_hi+1
    sta.z sqr1_hi
    lda #>mulf_sqr1_hi+1
    sta.z sqr1_hi+1
    // [184] phi (word) mulf_init::sqr#4 = (word) 0 [phi:mulf_init->mulf_init::@1#2] -- vwuz1=vwuc1 
    txa
    sta.z sqr
    sta.z sqr+1
    // [184] phi (byte) mulf_init::c#2 = (byte) 0 [phi:mulf_init->mulf_init::@1#3] -- vbuz1=vbuc1 
    sta.z c
    // [184] phi (byte*) mulf_init::sqr1_lo#2 = (const byte*) mulf_sqr1_lo+(byte) 1 [phi:mulf_init->mulf_init::@1#4] -- pbuz1=pbuc1 
    lda #<mulf_sqr1_lo+1
    sta.z sqr1_lo
    lda #>mulf_sqr1_lo+1
    sta.z sqr1_lo+1
    // mulf_init::@1
  __b1:
    // for(byte* sqr1_lo = mulf_sqr1_lo+1; sqr1_lo!=mulf_sqr1_lo+512; sqr1_lo++)
    // [185] if((byte*) mulf_init::sqr1_lo#2!=(const byte*) mulf_sqr1_lo+(word) $200) goto mulf_init::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr1_lo+1
    cmp #>mulf_sqr1_lo+$200
    bne __b2
    lda.z sqr1_lo
    cmp #<mulf_sqr1_lo+$200
    bne __b2
    // [186] phi from mulf_init::@1 to mulf_init::@5 [phi:mulf_init::@1->mulf_init::@5]
    // [186] phi (byte) mulf_init::dir#2 = (byte) $ff [phi:mulf_init::@1->mulf_init::@5#0] -- vbuz1=vbuc1 
    lda #$ff
    sta.z dir
    // [186] phi (byte*) mulf_init::sqr2_hi#2 = (const byte*) mulf_sqr2_hi [phi:mulf_init::@1->mulf_init::@5#1] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_hi
    sta.z sqr2_hi
    lda #>mulf_sqr2_hi
    sta.z sqr2_hi+1
    // [186] phi (byte) mulf_init::x_255#2 = (byte) -1 [phi:mulf_init::@1->mulf_init::@5#2] -- vbuxx=vbuc1 
    ldx #-1
    // [186] phi (byte*) mulf_init::sqr2_lo#2 = (const byte*) mulf_sqr2_lo [phi:mulf_init::@1->mulf_init::@5#3] -- pbuz1=pbuc1 
    lda #<mulf_sqr2_lo
    sta.z sqr2_lo
    lda #>mulf_sqr2_lo
    sta.z sqr2_lo+1
    // mulf_init::@5
  __b5:
    // for(byte* sqr2_lo = mulf_sqr2_lo; sqr2_lo!=mulf_sqr2_lo+511; sqr2_lo++)
    // [187] if((byte*) mulf_init::sqr2_lo#2!=(const byte*) mulf_sqr2_lo+(word) $1ff) goto mulf_init::@6 -- pbuz1_neq_pbuc1_then_la1 
    lda.z sqr2_lo+1
    cmp #>mulf_sqr2_lo+$1ff
    bne __b6
    lda.z sqr2_lo
    cmp #<mulf_sqr2_lo+$1ff
    bne __b6
    // mulf_init::@7
    // *(mulf_sqr2_lo+511) = *(mulf_sqr1_lo+256)
    // [188] *((const byte*) mulf_sqr2_lo+(word) $1ff) ← *((const byte*) mulf_sqr1_lo+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    // Set the very last value g(511) = f(256)
    lda mulf_sqr1_lo+$100
    sta mulf_sqr2_lo+$1ff
    // *(mulf_sqr2_hi+511) = *(mulf_sqr1_hi+256)
    // [189] *((const byte*) mulf_sqr2_hi+(word) $1ff) ← *((const byte*) mulf_sqr1_hi+(word) $100) -- _deref_pbuc1=_deref_pbuc2 
    lda mulf_sqr1_hi+$100
    sta mulf_sqr2_hi+$1ff
    // mulf_init::@return
    // }
    // [190] return 
    rts
    // mulf_init::@6
  __b6:
    // *sqr2_lo = mulf_sqr1_lo[x_255]
    // [191] *((byte*) mulf_init::sqr2_lo#2) ← *((const byte*) mulf_sqr1_lo + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_lo,x
    ldy #0
    sta (sqr2_lo),y
    // *sqr2_hi++ = mulf_sqr1_hi[x_255]
    // [192] *((byte*) mulf_init::sqr2_hi#2) ← *((const byte*) mulf_sqr1_hi + (byte) mulf_init::x_255#2) -- _deref_pbuz1=pbuc1_derefidx_vbuxx 
    lda mulf_sqr1_hi,x
    sta (sqr2_hi),y
    // *sqr2_hi++ = mulf_sqr1_hi[x_255];
    // [193] (byte*) mulf_init::sqr2_hi#1 ← ++ (byte*) mulf_init::sqr2_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_hi
    bne !+
    inc.z sqr2_hi+1
  !:
    // x_255 = x_255 + dir
    // [194] (byte) mulf_init::x_255#1 ← (byte) mulf_init::x_255#2 + (byte) mulf_init::dir#2 -- vbuxx=vbuxx_plus_vbuz1 
    txa
    clc
    adc.z dir
    tax
    // if(x_255==0)
    // [195] if((byte) mulf_init::x_255#1!=(byte) 0) goto mulf_init::@9 -- vbuxx_neq_0_then_la1 
    cpx #0
    bne __b8
    // [197] phi from mulf_init::@6 to mulf_init::@8 [phi:mulf_init::@6->mulf_init::@8]
    // [197] phi (byte) mulf_init::dir#4 = (byte) 1 [phi:mulf_init::@6->mulf_init::@8#0] -- vbuz1=vbuc1 
    lda #1
    sta.z dir
    // [196] phi from mulf_init::@6 to mulf_init::@9 [phi:mulf_init::@6->mulf_init::@9]
    // mulf_init::@9
    // [197] phi from mulf_init::@9 to mulf_init::@8 [phi:mulf_init::@9->mulf_init::@8]
    // [197] phi (byte) mulf_init::dir#4 = (byte) mulf_init::dir#2 [phi:mulf_init::@9->mulf_init::@8#0] -- register_copy 
    // mulf_init::@8
  __b8:
    // for(byte* sqr2_lo = mulf_sqr2_lo; sqr2_lo!=mulf_sqr2_lo+511; sqr2_lo++)
    // [198] (byte*) mulf_init::sqr2_lo#1 ← ++ (byte*) mulf_init::sqr2_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr2_lo
    bne !+
    inc.z sqr2_lo+1
  !:
    // [186] phi from mulf_init::@8 to mulf_init::@5 [phi:mulf_init::@8->mulf_init::@5]
    // [186] phi (byte) mulf_init::dir#2 = (byte) mulf_init::dir#4 [phi:mulf_init::@8->mulf_init::@5#0] -- register_copy 
    // [186] phi (byte*) mulf_init::sqr2_hi#2 = (byte*) mulf_init::sqr2_hi#1 [phi:mulf_init::@8->mulf_init::@5#1] -- register_copy 
    // [186] phi (byte) mulf_init::x_255#2 = (byte) mulf_init::x_255#1 [phi:mulf_init::@8->mulf_init::@5#2] -- register_copy 
    // [186] phi (byte*) mulf_init::sqr2_lo#2 = (byte*) mulf_init::sqr2_lo#1 [phi:mulf_init::@8->mulf_init::@5#3] -- register_copy 
    jmp __b5
    // mulf_init::@2
  __b2:
    // if((++c&1)==0)
    // [199] (byte) mulf_init::c#1 ← ++ (byte) mulf_init::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // ++c&1
    // [200] (byte~) mulf_init::$1 ← (byte) mulf_init::c#1 & (byte) 1 -- vbuaa=vbuz1_band_vbuc1 
    lda #1
    and.z c
    // if((++c&1)==0)
    // [201] if((byte~) mulf_init::$1!=(byte) 0) goto mulf_init::@3 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne __b3
    // mulf_init::@4
    // x_2++;
    // [202] (byte) mulf_init::x_2#1 ← ++ (byte) mulf_init::x_2#3 -- vbuxx=_inc_vbuxx 
    inx
    // sqr++;
    // [203] (word) mulf_init::sqr#2 ← ++ (word) mulf_init::sqr#4 -- vwuz1=_inc_vwuz1 
    inc.z sqr
    bne !+
    inc.z sqr+1
  !:
    // [204] phi from mulf_init::@2 mulf_init::@4 to mulf_init::@3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3]
    // [204] phi (byte) mulf_init::x_2#2 = (byte) mulf_init::x_2#3 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#0] -- register_copy 
    // [204] phi (word) mulf_init::sqr#3 = (word) mulf_init::sqr#4 [phi:mulf_init::@2/mulf_init::@4->mulf_init::@3#1] -- register_copy 
    // mulf_init::@3
  __b3:
    // <sqr
    // [205] (byte~) mulf_init::$4 ← < (word) mulf_init::sqr#3 -- vbuaa=_lo_vwuz1 
    lda.z sqr
    // *sqr1_lo = <sqr
    // [206] *((byte*) mulf_init::sqr1_lo#2) ← (byte~) mulf_init::$4 -- _deref_pbuz1=vbuaa 
    ldy #0
    sta (sqr1_lo),y
    // >sqr
    // [207] (byte~) mulf_init::$5 ← > (word) mulf_init::sqr#3 -- vbuaa=_hi_vwuz1 
    lda.z sqr+1
    // *sqr1_hi++ = >sqr
    // [208] *((byte*) mulf_init::sqr1_hi#2) ← (byte~) mulf_init::$5 -- _deref_pbuz1=vbuaa 
    sta (sqr1_hi),y
    // *sqr1_hi++ = >sqr;
    // [209] (byte*) mulf_init::sqr1_hi#1 ← ++ (byte*) mulf_init::sqr1_hi#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_hi
    bne !+
    inc.z sqr1_hi+1
  !:
    // sqr = sqr + x_2
    // [210] (word) mulf_init::sqr#1 ← (word) mulf_init::sqr#3 + (byte) mulf_init::x_2#2 -- vwuz1=vwuz1_plus_vbuxx 
    txa
    clc
    adc.z sqr
    sta.z sqr
    bcc !+
    inc.z sqr+1
  !:
    // for(byte* sqr1_lo = mulf_sqr1_lo+1; sqr1_lo!=mulf_sqr1_lo+512; sqr1_lo++)
    // [211] (byte*) mulf_init::sqr1_lo#1 ← ++ (byte*) mulf_init::sqr1_lo#2 -- pbuz1=_inc_pbuz1 
    inc.z sqr1_lo
    bne !+
    inc.z sqr1_lo+1
  !:
    // [184] phi from mulf_init::@3 to mulf_init::@1 [phi:mulf_init::@3->mulf_init::@1]
    // [184] phi (byte) mulf_init::x_2#3 = (byte) mulf_init::x_2#2 [phi:mulf_init::@3->mulf_init::@1#0] -- register_copy 
    // [184] phi (byte*) mulf_init::sqr1_hi#2 = (byte*) mulf_init::sqr1_hi#1 [phi:mulf_init::@3->mulf_init::@1#1] -- register_copy 
    // [184] phi (word) mulf_init::sqr#4 = (word) mulf_init::sqr#1 [phi:mulf_init::@3->mulf_init::@1#2] -- register_copy 
    // [184] phi (byte) mulf_init::c#2 = (byte) mulf_init::c#1 [phi:mulf_init::@3->mulf_init::@1#3] -- register_copy 
    // [184] phi (byte*) mulf_init::sqr1_lo#2 = (byte*) mulf_init::sqr1_lo#1 [phi:mulf_init::@3->mulf_init::@1#4] -- register_copy 
    jmp __b1
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // [213] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
    // plexInit::plexSetScreen1
    // [214] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
    // [214] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [214] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
    // [214] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    // plexInit::@1
  __b1:
    // PLEX_SORTED_IDX[i] = i
    // [215] *((const byte*) PLEX_SORTED_IDX + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // for(byte i: 0..PLEX_COUNT-1)
    // [216] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [217] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne __b1
    // plexInit::@return
    // }
    // [218] return 
    rts
}
  // File Data
  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  // mulf_sqr tables will contain f(x)=int(x*x/4) and g(x) = f(x-255).
  // <f(x) = <(( x * x )/4)
  .align $100
  mulf_sqr1_lo: .fill $200, 0
  // >f(x) = >(( x * x )/4)
  .align $100
  mulf_sqr1_hi: .fill $200, 0
  // <g(x) =  <((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_lo: .fill $200, 0
  // >g(x) = >((( x - 255) * ( x - 255 ))/4)
  .align $100
  mulf_sqr2_hi: .fill $200, 0
  // Keyboard row bitmask as expected by CIA#1 Port A when reading a specific keyboard matrix row (rows are numbered 0-7)
  keyboard_matrix_row_bitmask: .byte $fe, $fd, $fb, $f7, $ef, $df, $bf, $7f
  // Keyboard matrix column bitmasks for a specific keybooard matrix column when reading the keyboard. (columns are numbered 0-7)
  keyboard_matrix_col_bitmask: .byte 1, 2, 4, 8, $10, $20, $40, $80
  // The BOB sprite
  .align $1000
SPRITE:
.var pic = LoadPicture("smiley.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)

  // Sine and Cosine tables
  // Angles: $00=0, $80=PI,$100=2*PI
  // Sine/Cosine: signed fixed [-$7f,$7f]
  .align $40
SIN:
.for(var i=0;i<$140;i++)
        .byte >round($7fff*sin(i*2*PI/256))


