// Implementation of the games play logic

import "tetris-data"
import "tetris-pieces"

// Pointers to the playfield address for each playfield line
byte*[PLAYFIELD_LINES] playfield_lines;

// Indixes into the playfield  for each playfield line
byte[PLAYFIELD_LINES+1] playfield_lines_idx;

// The current moving piece. Points to the start of the piece definition.
byte* current_piece = 0;

// The curent piece orientation - each piece have 4 orientations (00/$10/$20/$30).
// The orientation chooses one of the 4 sub-graphics of the piece.
byte current_orientation = 0;

// The rate of moving down the current piece (number of frames between moves if movedown is  not forced)
const byte current_movedown_slow = 50;

// The rate of moving down the current piece fast (number of frames between moves if movedown is not forced)
const byte current_movedown_fast = 5;

// Counts up to the next movedown of current piece
byte current_movedown_counter = 0;

// Move down the current piece
// Return non-zero if a render is needed
byte play_move_down(byte key_event) {
		// Handle moving down current piece
		++current_movedown_counter;
		byte movedown = 0;
		// As soon as space is pressed move down once
		if(key_event==KEY_SPACE) {
			movedown++;
		}
		// While space is held down move down faster
		if(keyboard_event_pressed(KEY_SPACE)!=0) {
			if(current_movedown_counter>=current_movedown_fast) {
				movedown++;
			}
		}
		// Move down slowly otherwise
		if(current_movedown_counter>=current_movedown_slow) {
			movedown++;
		}
		// Attempt movedown
		if(movedown!=0) {
			if(play_collision(current_xpos,current_ypos+1,current_orientation)==COLLISION_NONE) {
				// Move current piece down
				current_ypos++;
			} else {
				// Lock current piece
				play_lock_current();
				// Check for any lines and remove them
				play_remove_lines();
				// Spawn a new piece
				play_spawn_current();
			}
			current_movedown_counter = 0;
			return 1;
		}
		return 0;
}

// Move left/right or rotate the current piece
// Return non-zero if a render is needed
byte play_move_leftright(byte key_event) {
		// Handle keyboard events
		if(key_event==KEY_COMMA) {
			if(play_collision(current_xpos-1,current_ypos,current_orientation)==COLLISION_NONE) {
				current_xpos--;
				return 1;
			}
		} else if(key_event==KEY_DOT) {
			if(play_collision(current_xpos+1,current_ypos,current_orientation)==COLLISION_NONE) {
				current_xpos++;
				return 1;
			}
		}
		return 0;
}

// Rotate the current piece  based on key-presses
// Return non-zero if a render is needed
byte play_move_rotate(byte key_event) {
	// Handle keyboard events
	byte orientation = $80;
	if(key_event==KEY_Z) {
		orientation = (current_orientation-$10)&$3f;
	} else if(key_event==KEY_X) {
		orientation = (current_orientation+$10)&$3f;
	} else {
		return 0;
	}
	if(play_collision(current_xpos, current_ypos, orientation) == COLLISION_NONE) {
		current_orientation = orientation;
		current_piece_gfx = current_piece + current_orientation;
		return 1;
	}
	return 0;
}

// No collision
const byte COLLISION_NONE = 0;
// Playfield piece collision (cell on top of other cell on the playfield)
const byte COLLISION_PLAYFIELD = 1;
// Bottom collision (cell below bottom of the playfield)
const byte COLLISION_BOTTOM = 2;
// Left side collision (cell beyond the left side of the playfield)
const byte COLLISION_LEFT = 4;
// Right side collision (cell beyond the right side of the playfield)
const byte COLLISION_RIGHT = 8;

// Test if there is a collision between the current piece moved to (x, y) and anything on the playfield or the playfield boundaries
// Returns information about the type of the collision detected
byte play_collision(byte xpos, byte ypos, byte orientation) {
	byte* piece_gfx = current_piece + orientation;
	byte i = 0;
	byte ypos2 = ypos<<1;
	for(byte l:0..3) {
		byte* playfield_line = playfield_lines[ypos2];
		byte col = xpos;
		for(byte c:0..3) {
			if(piece_gfx[i++]!=0) {
				if(ypos2>=2*PLAYFIELD_LINES) {
					// Below the playfield bottom
					return COLLISION_BOTTOM;
				}
				if((col&$80)!=0) {
					// Beyond left side of the playfield
					return COLLISION_LEFT;
				}
				if(col>=PLAYFIELD_COLS) {
					// Beyond left side of the playfield
					return COLLISION_RIGHT;
				}
				if(playfield_line[col]!=0) {
					// Collision with a playfield cell
					return COLLISION_PLAYFIELD;
				}
			}
			col++;
		}
		ypos2 += 2;
	}
	return COLLISION_NONE;
}

// Lock the current piece onto the playfield
void play_lock_current() {
	byte i = 0;
	byte ypos2 = current_ypos<<1;
	for(byte l:0..3) {
		byte* playfield_line = playfield_lines[ypos2];
		byte col = current_xpos;
		for(byte c:0..3) {
			if(current_piece_gfx[i++]!=0) {
				playfield_line[col] = current_piece_char;
			}
			col++;
		}
		ypos2 += 2;
	}
}

// Spawn a new piece
void play_spawn_current() {
	// Pick a random piece (0-6)
	byte piece_idx = 7;
	while(piece_idx==7) {
		piece_idx = sid_rnd()&7;
	}
	current_piece = PIECES[piece_idx<<1];
	current_orientation = 0;
	current_piece_gfx = current_piece + current_orientation;
	current_xpos = 3;
	current_ypos = 0;
	current_piece_char = PIECES_CHARS[piece_idx];
}

// Look through the playfield for lines - and remove any lines found
// Utilizes two cursors on the playfield - one reading cells and one writing cells
// Whenever a full line is detected the writing cursor is instructed to write to the same line once more.
void play_remove_lines() {
	// Start both cursors at the end of the playfield
	byte r = PLAYFIELD_LINES*PLAYFIELD_COLS-1;
	byte w = PLAYFIELD_LINES*PLAYFIELD_COLS-1;

	// Read all lines and rewrite them
	for(byte y:0..PLAYFIELD_LINES-1) {
		byte full = 1;
		for(byte x:0..PLAYFIELD_COLS-1) {
			byte c = playfield[r--];
			if(c==0) {
				full = 0;
			}
			playfield[w--] = c;
		}
		// If the line is full then re-write it.
		if(full==1) {
			w = w + PLAYFIELD_COLS;
		}
	}

	// Write zeros in the rest of the lines
	while(w!=$ff) {
		playfield[w--] = 0;
	}
}

// Initialize data tables
void play_init() {
	// Initialize the playfield line pointers;
	byte idx = 0;
	byte* pli = playfield;
	for(byte j:0..PLAYFIELD_LINES-1) {
		playfield_lines[j<<1] = pli;
		playfield_lines_idx[j] = idx;
		pli += PLAYFIELD_COLS;
		idx += PLAYFIELD_COLS;
	}
	playfield_lines_idx[PLAYFIELD_LINES] = PLAYFIELD_COLS*PLAYFIELD_LINES;
}
