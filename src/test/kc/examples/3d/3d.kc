// 3D Rotation using a Rotation Matrix
// Based on: 
// - C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
// - Codebase64 Article http://codebase64.org/doku.php?id=base:3d_rotation  

import "c64"

byte* SCREEN = $400;

// A single sprite
byte* SPRITE = $3000;
kickasm(pc SPRITE, resource "balloon.png") {{
    .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
}}

// Sine and Cosine Tables   
// Angles: $00=0, $80=PI,$100=2*PI
// Half Sine/Cosine: signed fixed [-$1f,$1f]
signed byte* COSH = $2000;
signed byte* SINH = COSH+$40; // sin(x) = cos(x+PI/2)
// Quarter Sine/Cosine: signed fixed [-$0f,$0f]
signed byte* COSQ = $2200;
signed byte* SINQ = COSQ+$40; // sin(x) = cos(x+PI/2)
kickasm(pc COSH) {{
    {
    .var min = -$1fff
    .var max = $1fff
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte >round(min+(ampl/2)+(ampl/2)*cos(rad))
    }
    }
}}
kickasm(pc COSQ) {{
    {
    .var min = -$0fff
    .var max = $0fff
    .var ampl = max-min;
    .for(var i=0;i<$140;i++) {
        .var rad = i*2*PI/256;
        .byte >round(min+(ampl/2)+(ampl/2)*cos(rad))
    }
    }
}}

// mulf_sqr tables will contain f(x)=int(x*x/2) and g(x) = f(1-x).
// f(x) = >(( x * x )/2)
byte[512] align($100) mulf_sqr1;
// g(x) =  >((( 1 - x ) * ( 1 - x ))/2)
byte[512] align($100) mulf_sqr2;

// Initialize the mulf_sqr multiplication tables with f(x)=int(x*x/2) and g(x) = f(1-x) 
void mulf_init() {
	signed word sqr1 = 0;	
	signed word add = 1;
	for( byte i:0..128) {
		mulf_sqr1[i] = >sqr1;
		(mulf_sqr1+$100)[i] = >sqr1;
		mulf_sqr1[-i] = >sqr1;
		(mulf_sqr1+$100)[-i] = >sqr1;
		mulf_sqr2[i+1] = >sqr1;
		(mulf_sqr2+$100)[i+1] = >sqr1;
		mulf_sqr2[1-i] = >sqr1;
		(mulf_sqr2+$100)[1-i] = >sqr1;
		sqr1 += add;
		add +=2;
	}
}

// Initialize sprites
void sprites_init() {
    *SPRITES_ENABLE = %11111111;
    byte* sprites_ptr = SCREEN+$3f8;
    for(byte i: 0..7) {
    	sprites_ptr[i] = (byte)(SPRITE/$40);
        SPRITES_COLS[i] = GREEN;
    }
}

// Positions to rotate (a cube)
signed byte[8] xs = { -63, -63, -63, -63,  63,  63,  63,  63};
signed byte[8] ys = { -63, -63,  63,  63, -63, -63,  63,  63};
signed byte[8] zs = { -63,  63, -63,  63, -63,  63, -63,  63};

// The rotated point - updated by calling rotate()
signed byte* xr = $f0;
signed byte* yr = $f1;
signed byte* zr = $f2;

void main() {
	asm { sei }
	sprites_init();
	mulf_init();
	signed byte sx = 0;
	signed byte sy = 0;
	signed byte sz = 0;
	while(true) {
		while(*RASTER!=$ff) {}
        (*BORDERCOL)++; 
    	prepare_matrix(sx,sy--,sz++);
    	if((sy&1)==0) sx++;
        for(byte i: 0..7) {
            (*BORDERCOL)++;
            rotate(xs[i], ys[i], zs[i]);
            byte i2 = i<<1;
       	    SPRITES_XPOS[i2] = $80+(byte)(*xr>>1);
       	    SPRITES_YPOS[i2] = $80+(byte)(*yr>>1);
        }
        *BORDERCOL = LIGHT_BLUE;
	}	
}

// The rotation matrix
signed byte[9] rotation_matrix;

// Prepare the rotation matrix [ [A,B,C],[D,E,F],[G,H,I]]
// Angles sx, sy, sz are based on 2*PI=$100 
// Method described in C= Hacking Magazine Issue 8. http://www.ffd2.com/fridge/chacking/c=hacking8.txt
void prepare_matrix(signed byte sx, signed byte sy, signed byte sz) {
	signed byte t1 = sy-sz;
	signed byte t2 = sy+sz;
	signed byte t3 = sx+sz;
	signed byte t4 = sx-sz;
	signed byte t5 = sx+t2; // = sx+sy+sz
	signed byte t6 = sx-t1; // = sx-sy+sz
	signed byte t7 = sx+t1; // = sx+sy-sz
	signed byte t8 = t2-sx; //  = sy+sz-sx
	signed byte t9 = sy-sx;
	signed byte t10 = sy+sx;
	rotation_matrix[0] = COSH[t1]+COSH[t2];
	rotation_matrix[1] = SINH[t1]-SINH[t2];
	rotation_matrix[2] = SINH[sy]+SINH[sy];
	rotation_matrix[3] = SINH[t3]-SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t8]-COSQ[t7];
	rotation_matrix[4] = COSH[t3]+COSH[t4] + SINQ[t5]-SINQ[t6]-SINQ[t7]-SINQ[t8];
	rotation_matrix[5] = SINH[t9]-SINH[t10];
	rotation_matrix[6] = COSH[t4]-COSH[t3] + SINQ[t6]-SINQ[t5]-SINQ[t8]-SINQ[t7];
	rotation_matrix[7] = SINH[t3]+SINH[t4] + COSQ[t6]-COSQ[t5]+COSQ[t7]-COSQ[t8];
	rotation_matrix[8] = COSH[t9]+COSH[t10];
	asm {
		lda rotation_matrix+0
		sta rotate.A1+1
		eor #$ff
		sta rotate.A2+1
		lda rotation_matrix+1
		sta rotate.B1+1
		eor #$ff
		sta rotate.B2+1
		lda rotation_matrix+2
		sta rotate.C1+1
		eor #$ff
		sta rotate.C2+1
		lda rotation_matrix+3
		sta rotate.D1+1
		eor #$ff
		sta rotate.D2+1
		lda rotation_matrix+4
		sta rotate.E1+1
		eor #$ff
		sta rotate.E2+1
		lda rotation_matrix+5
		sta rotate.F1+1
		eor #$ff
		sta rotate.F2+1
		lda rotation_matrix+6
		sta rotate.G1+1
		eor #$ff
		sta rotate.G2+1
		lda rotation_matrix+7
		sta rotate.H1+1
		eor #$ff
		sta rotate.H2+1
		lda rotation_matrix+8
		sta rotate.I1+1
		eor #$ff
		sta rotate.I2+1
	}
}


// Rotate a 3D point (x,y,z) using the rotation matrix
// The rotation matrix is prepared by calling prepare_matrix() 
// The passed points must be in the interval [-$3f;$3f].
// Implemented in assembler to utilize seriously fast multiplication 
void rotate(signed byte x, signed byte y, signed byte z) {
	*xr = x;
	*yr = y;
	*zr = z;
	asm {
			clc
			ldx zr //z
			// C*z 
			lda #$0
		C1:	adc mulf_sqr1,x
		C2: sbc mulf_sqr2,x
			sta C3+1
			// F*z 
			lda #0
		F1:	adc mulf_sqr1,x
		F2: sbc mulf_sqr2,x
			sta F3+1
			// I*z 
			lda #0
		I1:	adc mulf_sqr1,x
		I2: sbc mulf_sqr2,x
			sta I3+1
			ldx xr //x
			ldy yr //y
		C3: lda #0 // C*z
		A1:	adc mulf_sqr1,x
		A2: sbc mulf_sqr2,x
		B1:	adc mulf_sqr1,y
		B2: sbc mulf_sqr2,y
			sta xr
		F3: lda #0 // F*z
		D1:	adc mulf_sqr1,x
		D2: sbc mulf_sqr2,x
		E1:	adc mulf_sqr1,y
		E2: sbc mulf_sqr2,y
			sta yr
		I3: lda #0 // I*z
		G1:	adc mulf_sqr1,x
		G2: sbc mulf_sqr2,x
		H1:	adc mulf_sqr1,y
		H2: sbc mulf_sqr2,y		
			sta zr
	}
}

