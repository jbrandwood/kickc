
CONTROL FLOW GRAPH SSA

(void()) main()
main: scope:[main]  from __start
  asm { sei  }
  to:main::@1
main::@1: scope:[main]  from main main::@6
  (bool~) main::$10 ← (number) 0 != (number) 1
  if((bool~) main::$10) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1 main::@2
  (bool~) main::$0 ← *((const nomodify byte*) VIC_RASTER) != (number) $ff
  if((bool~) main::$0) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@2
  *((const nomodify byte*) VIC_BG_COLOR) ← (number) 0
  (byte*) main::line#0 ← (const nomodify byte*) SCREEN
  (byte) main::i#0 ← (byte) 0
  to:main::@4
main::@4: scope:[main]  from main::@3 main::@7
  (byte*) main::line#4 ← phi( main::@3/(byte*) main::line#0 main::@7/(byte*) main::line#1 )
  (byte) main::i#2 ← phi( main::@3/(byte) main::i#0 main::@7/(byte) main::i#1 )
  (bool~) main::$1 ← (byte) main::i#2 < (number) $19
  if((bool~) main::$1) goto main::@5
  to:main::@6
main::@5: scope:[main]  from main::@4
  (byte*) main::line#2 ← phi( main::@4/(byte*) main::line#4 )
  (byte) main::i#3 ← phi( main::@4/(byte) main::i#2 )
  (byte~) main::$4 ← (byte) main::i#3 * (const byte) SIZEOF_WORD
  (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$4)
  *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' '
  (byte~) main::$5 ← (byte) main::i#3 * (const byte) SIZEOF_WORD
  *((const word*) entities + (byte~) main::$5) ← *((const word*) entities + (byte~) main::$5) + (number) 1
  (byte~) main::$6 ← (byte) main::i#3 * (const byte) SIZEOF_WORD
  (bool~) main::$2 ← *((const word*) entities + (byte~) main::$6) > (number) $27
  (bool~) main::$3 ← ! (bool~) main::$2
  if((bool~) main::$3) goto main::@7
  to:main::@8
main::@6: scope:[main]  from main::@4
  *((const nomodify byte*) VIC_BG_COLOR) ← (number) $f
  to:main::@1
main::@7: scope:[main]  from main::@5 main::@8
  (byte*) main::line#3 ← phi( main::@5/(byte*) main::line#2 main::@8/(byte*) main::line#5 )
  (byte) main::i#4 ← phi( main::@5/(byte) main::i#3 main::@8/(byte) main::i#5 )
  (byte~) main::$7 ← (byte) main::i#4 * (const byte) SIZEOF_WORD
  *((byte*) main::line#3 + *((const word*) entities + (byte~) main::$7)) ← (byte) '*'
  (byte*) main::line#1 ← (byte*) main::line#3 + (number) $28
  (byte) main::i#1 ← ++ (byte) main::i#4
  to:main::@4
main::@8: scope:[main]  from main::@5
  (byte*) main::line#5 ← phi( main::@5/(byte*) main::line#2 )
  (byte) main::i#5 ← phi( main::@5/(byte) main::i#3 )
  (byte~) main::$8 ← (byte) main::i#5 * (const byte) SIZEOF_WORD
  *((const word*) entities + (byte~) main::$8) ← (number) 0
  to:main::@7
main::@return: scope:[main]  from main::@1
  return 
  to:@return

(void()) __start()
__start: scope:[__start]  from
  call main 
  to:__start::@1
__start::@1: scope:[__start]  from __start
  to:__start::@return
__start::@return: scope:[__start]  from __start::@1
  return 
  to:@return

SYMBOL TABLE SSA
(const nomodify byte*) SCREEN = (byte*)(number) $400
(const byte) SIZEOF_WORD = (byte) 2
(const nomodify byte*) VIC_BG_COLOR = (byte*)(number) $d020
(const nomodify byte*) VIC_RASTER = (byte*)(number) $d012
(void()) __start()
(label) __start::@1
(label) __start::@return
(const word*) entities[(number) $19]  = { fill( $19, 0) }
(void()) main()
(bool~) main::$0
(bool~) main::$1
(bool~) main::$10
(bool~) main::$2
(bool~) main::$3
(byte~) main::$4
(byte~) main::$5
(byte~) main::$6
(byte~) main::$7
(byte~) main::$8
(byte~) main::$9
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@return
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(byte) main::i#5
(byte*) main::line
(byte*) main::line#0
(byte*) main::line#1
(byte*) main::line#2
(byte*) main::line#3
(byte*) main::line#4
(byte*) main::line#5

Adding number conversion cast (unumber) $ff in (bool~) main::$0 ← *((const nomodify byte*) VIC_RASTER) != (number) $ff
Adding number conversion cast (unumber) 0 in *((const nomodify byte*) VIC_BG_COLOR) ← (number) 0
Adding number conversion cast (unumber) $19 in (bool~) main::$1 ← (byte) main::i#2 < (number) $19
Adding number conversion cast (unumber) 1 in *((const word*) entities + (byte~) main::$5) ← *((const word*) entities + (byte~) main::$5) + (number) 1
Adding number conversion cast (unumber) $27 in (bool~) main::$2 ← *((const word*) entities + (byte~) main::$6) > (number) $27
Adding number conversion cast (unumber) $f in *((const nomodify byte*) VIC_BG_COLOR) ← (number) $f
Adding number conversion cast (unumber) $28 in (byte*) main::line#1 ← (byte*) main::line#3 + (number) $28
Adding number conversion cast (unumber) 0 in *((const word*) entities + (byte~) main::$8) ← (number) 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((const nomodify byte*) VIC_BG_COLOR) ← (unumber)(number) 0
Inlining cast *((const nomodify byte*) VIC_BG_COLOR) ← (unumber)(number) $f
Inlining cast *((const word*) entities + (byte~) main::$8) ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $19
Simplifying constant integer cast 1
Simplifying constant integer cast $27
Simplifying constant integer cast $f
Simplifying constant integer cast $28
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $19
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $27
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inversing boolean not [19] (bool~) main::$3 ← *((const word*) entities + (byte~) main::$6) <= (byte) $27 from [18] (bool~) main::$2 ← *((const word*) entities + (byte~) main::$6) > (byte) $27
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::i#2 = main::i#3 main::i#5 
Alias main::line#2 = main::line#4 main::line#5 
Successful SSA optimization Pass2AliasElimination
Alias main::i#2 = main::i#4 
Alias main::line#2 = main::line#3 
Successful SSA optimization Pass2AliasElimination
Identified duplicate assignment right side [15] (byte~) main::$5 ← (byte) main::i#2 * (const byte) SIZEOF_WORD
Identified duplicate assignment right side [17] (byte~) main::$6 ← (byte) main::i#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) main::$10 [2] if((number) 0!=(number) 1) goto main::@2
Simple Condition (bool~) main::$0 [4] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@2
Simple Condition (bool~) main::$1 [10] if((byte) main::i#2<(byte) $19) goto main::@5
Simple Condition (bool~) main::$3 [18] if(*((const word*) entities + (byte~) main::$6)<=(byte) $27) goto main::@7
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant (const byte*) main::line#0 = SCREEN
Constant (const byte) main::i#0 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [2] if((number) 0!=(number) 1) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Rewriting conditional comparison [18] if(*((const word*) entities + (byte~) main::$6)<=(byte) $27) goto main::@7
De-inlining pointer[w] to *(pointer+w)   [21] *((byte*) main::line#2 + *((const word*) entities + (byte~) main::$7)) ← (byte) '*'
Successful SSA optimization Pass2DeInlineWordDerefIdx
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::@1
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) $27+1 in [11] if(*((const word*) entities + (byte~) main::$6)<(byte) $27+(number) 1) goto main::@7
Adding number conversion cast (unumber) 1 in [11] if(*((const word*) entities + (byte~) main::$6)<(unumber)(byte) $27+(number) 1) goto main::@7
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (byte) $27+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias main::$5 = main::$4 main::$6 
Successful SSA optimization Pass2AliasElimination
Rewriting multiplication to use shift [5] (byte~) main::$5 ← (byte) main::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [11] (byte~) main::$7 ← (byte) main::i#2 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [16] (byte~) main::$8 ← (byte) main::i#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte*) main::line#0
Inlining constant with var siblings (const byte) main::i#0
Constant inlined main::line#0 = (const nomodify byte*) SCREEN
Constant inlined main::i#0 = (byte) 0
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Adding NOP phi() at start of main::@1
CALL GRAPH

Created 2 initial phi equivalence classes
Coalesced [19] main::i#6 ← main::i#1
Coalesced [20] main::line#6 ← main::line#1
Coalesced down to 2 phi equivalence classes
Culled Empty Block (label) main::@1
Renumbering block main::@2 to main::@1
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@6 to main::@5
Renumbering block main::@7 to main::@6
Renumbering block main::@8 to main::@7

FINAL CONTROL FLOW GRAPH

(void()) main()
main: scope:[main]  from
  asm { sei  }
  to:main::@1
main::@1: scope:[main]  from main main::@1 main::@5
  [1] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@1
  [2] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@6
  [3] (byte*) main::line#2 ← phi( main::@2/(const nomodify byte*) SCREEN main::@6/(byte*) main::line#1 )
  [3] (byte) main::i#2 ← phi( main::@2/(byte) 0 main::@6/(byte) main::i#1 )
  [4] if((byte) main::i#2<(byte) $19) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [5] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) $f
  to:main::@1
main::@4: scope:[main]  from main::@3
  [6] (byte~) main::$5 ← (byte) main::i#2 << (byte) 1
  [7] (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$5)
  [8] *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' '
  [9] *((const word*) entities + (byte~) main::$5) ← *((const word*) entities + (byte~) main::$5) + (byte) 1
  [10] if(*((const word*) entities + (byte~) main::$5)<(byte) $27+(byte) 1) goto main::@6
  to:main::@7
main::@7: scope:[main]  from main::@4
  [11] (byte~) main::$8 ← (byte) main::i#2 << (byte) 1
  [12] *((const word*) entities + (byte~) main::$8) ← (byte) 0
  to:main::@6
main::@6: scope:[main]  from main::@4 main::@7
  [13] (byte~) main::$7 ← (byte) main::i#2 << (byte) 1
  [14] (byte*~) main::$11 ← (byte*) main::line#2 + *((const word*) entities + (byte~) main::$7)
  [15] *((byte*~) main::$11) ← (byte) '*'
  [16] (byte*) main::line#1 ← (byte*) main::line#2 + (byte) $28
  [17] (byte) main::i#1 ← ++ (byte) main::i#2
  to:main::@3


VARIABLE REGISTER WEIGHTS
(void()) main()
(byte*~) main::$11 202.0
(byte~) main::$5 101.0
(byte~) main::$7 202.0
(byte~) main::$8 202.0
(byte~) main::$9 202.0
(byte) main::i
(byte) main::i#1 202.0
(byte) main::i#2 46.61538461538461
(byte*) main::line
(byte*) main::line#1 101.0
(byte*) main::line#2 33.666666666666664

Initial phi equivalence classes
[ main::i#2 main::i#1 ]
[ main::line#2 main::line#1 ]
Added variable main::$5 to live range equivalence class [ main::$5 ]
Added variable main::$9 to live range equivalence class [ main::$9 ]
Added variable main::$8 to live range equivalence class [ main::$8 ]
Added variable main::$7 to live range equivalence class [ main::$7 ]
Added variable main::$11 to live range equivalence class [ main::$11 ]
Complete equivalence classes
[ main::i#2 main::i#1 ]
[ main::line#2 main::line#1 ]
[ main::$5 ]
[ main::$9 ]
[ main::$8 ]
[ main::$7 ]
[ main::$11 ]
Allocated zp[1]:2 [ main::i#2 main::i#1 ]
Allocated zp[2]:3 [ main::line#2 main::line#1 ]
Allocated zp[1]:5 [ main::$5 ]
Allocated zp[1]:6 [ main::$9 ]
Allocated zp[1]:7 [ main::$8 ]
Allocated zp[1]:8 [ main::$7 ]
Allocated zp[2]:9 [ main::$11 ]

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
// Test that the multiplication of a idx*sizeof(element) is reused inside loops
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_RASTER = $d012
  .label VIC_BG_COLOR = $d020
  .label SCREEN = $400
  // main
main: {
    .label __5 = 5
    .label __7 = 8
    .label __8 = 7
    .label __9 = 6
    // Move the entities
    .label line = 3
    .label i = 2
    .label __11 = 9
    // asm { sei  }
    sei
    jmp __b1
  // Wait for raster refresh
    // main::@1
  __b1:
    // [1] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp VIC_RASTER
    bne __b1
    jmp __b2
    // main::@2
  __b2:
    // [2] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VIC_BG_COLOR
    // [3] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [3] phi (byte*) main::line#2 = (const nomodify byte*) SCREEN [phi:main::@2->main::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z line
    lda #>SCREEN
    sta.z line+1
    // [3] phi (byte) main::i#2 = (byte) 0 [phi:main::@2->main::@3#1] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b3
    // main::@3
  __b3:
    // [4] if((byte) main::i#2<(byte) $19) goto main::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$19
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [5] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta VIC_BG_COLOR
    jmp __b1
    // main::@4
  __b4:
    // [6] (byte~) main::$5 ← (byte) main::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __5
    // [7] (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$5) -- vbuz1=_byte_pwuc1_derefidx_vbuz2 
    ldy.z __5
    lda entities,y
    sta.z __9
    // [8] *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' ' -- pbuz1_derefidx_vbuz2=vbuc1 
    // Delete old symbol
    lda #' '
    ldy.z __9
    sta (line),y
    // [9] *((const word*) entities + (byte~) main::$5) ← *((const word*) entities + (byte~) main::$5) + (byte) 1 -- pwuc1_derefidx_vbuz1=pwuc1_derefidx_vbuz1_plus_1 
    // Move by velocity
    ldx.z __5
    inc entities,x
    bne !+
    inc entities+1,x
  !:
    // [10] if(*((const word*) entities + (byte~) main::$5)<(byte) $27+(byte) 1) goto main::@6 -- pwuc1_derefidx_vbuz1_lt_vbuc2_then_la1 
    ldy.z __5
    lda entities+1,y
    bne !+
    lda entities,y
    cmp #$27+1
    bcc __b6
  !:
    jmp __b7
    // main::@7
  __b7:
    // [11] (byte~) main::$8 ← (byte) main::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __8
    // [12] *((const word*) entities + (byte~) main::$8) ← (byte) 0 -- pwuc1_derefidx_vbuz1=vbuc2 
    lda.z __8
    ldx #0
    tay
    txa
    sta entities,y
    jmp __b6
    // main::@6
  __b6:
    // [13] (byte~) main::$7 ← (byte) main::i#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z i
    asl
    sta.z __7
    // [14] (byte*~) main::$11 ← (byte*) main::line#2 + *((const word*) entities + (byte~) main::$7) -- pbuz1=pbuz2_plus_pwuc1_derefidx_vbuz3 
    ldy.z __7
    clc
    lda.z line
    adc entities,y
    sta.z __11
    lda.z line+1
    adc entities+1,y
    sta.z __11+1
    // [15] *((byte*~) main::$11) ← (byte) '*' -- _deref_pbuz1=vbuc1 
    // Draw symbol
    lda #'*'
    ldy #0
    sta (__11),y
    // [16] (byte*) main::line#1 ← (byte*) main::line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    // Next line
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    // [17] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [3] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  __b3_from___b6:
    // [3] phi (byte*) main::line#2 = (byte*) main::line#1 [phi:main::@6->main::@3#0] -- register_copy 
    // [3] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@6->main::@3#1] -- register_copy 
    jmp __b3
}
  // File Data
  entities: .fill 2*$19, 0

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [1] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) $f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] (byte~) main::$5 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::line#2 main::$5 ] (  [ main::i#2 main::line#2 main::$5 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement [7] (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$5) [ main::i#2 main::line#2 main::$5 main::$9 ] (  [ main::i#2 main::line#2 main::$5 main::$9 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ main::$5 ]
Statement [8] *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' ' [ main::i#2 main::line#2 main::$5 ] (  [ main::i#2 main::line#2 main::$5 ] { }  ) always clobbers reg byte a 
Statement [10] if(*((const word*) entities + (byte~) main::$5)<(byte) $27+(byte) 1) goto main::@6 [ main::i#2 main::line#2 ] (  [ main::i#2 main::line#2 ] { }  ) always clobbers reg byte a 
Statement [11] (byte~) main::$8 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::line#2 main::$8 ] (  [ main::i#2 main::line#2 main::$8 ] { }  ) always clobbers reg byte a 
Statement [12] *((const word*) entities + (byte~) main::$8) ← (byte) 0 [ main::i#2 main::line#2 ] (  [ main::i#2 main::line#2 ] { }  ) always clobbers reg byte a 
Statement [13] (byte~) main::$7 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::line#2 main::$7 ] (  [ main::i#2 main::line#2 main::$7 ] { }  ) always clobbers reg byte a 
Statement [14] (byte*~) main::$11 ← (byte*) main::line#2 + *((const word*) entities + (byte~) main::$7) [ main::i#2 main::line#2 main::$11 ] (  [ main::i#2 main::line#2 main::$11 ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*~) main::$11) ← (byte) '*' [ main::i#2 main::line#2 ] (  [ main::i#2 main::line#2 ] { }  ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte y as potential for zp[1]:2 [ main::i#2 main::i#1 ]
Statement [16] (byte*) main::line#1 ← (byte*) main::line#2 + (byte) $28 [ main::i#2 main::line#1 ] (  [ main::i#2 main::line#1 ] { }  ) always clobbers reg byte a 
Statement [1] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@1 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) 0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) $f [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [6] (byte~) main::$5 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::line#2 main::$5 ] (  [ main::i#2 main::line#2 main::$5 ] { }  ) always clobbers reg byte a 
Statement [7] (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$5) [ main::i#2 main::line#2 main::$5 main::$9 ] (  [ main::i#2 main::line#2 main::$5 main::$9 ] { }  ) always clobbers reg byte a 
Statement [8] *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' ' [ main::i#2 main::line#2 main::$5 ] (  [ main::i#2 main::line#2 main::$5 ] { }  ) always clobbers reg byte a 
Statement [10] if(*((const word*) entities + (byte~) main::$5)<(byte) $27+(byte) 1) goto main::@6 [ main::i#2 main::line#2 ] (  [ main::i#2 main::line#2 ] { }  ) always clobbers reg byte a 
Statement [11] (byte~) main::$8 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::line#2 main::$8 ] (  [ main::i#2 main::line#2 main::$8 ] { }  ) always clobbers reg byte a 
Statement [12] *((const word*) entities + (byte~) main::$8) ← (byte) 0 [ main::i#2 main::line#2 ] (  [ main::i#2 main::line#2 ] { }  ) always clobbers reg byte a 
Statement [13] (byte~) main::$7 ← (byte) main::i#2 << (byte) 1 [ main::i#2 main::line#2 main::$7 ] (  [ main::i#2 main::line#2 main::$7 ] { }  ) always clobbers reg byte a 
Statement [14] (byte*~) main::$11 ← (byte*) main::line#2 + *((const word*) entities + (byte~) main::$7) [ main::i#2 main::line#2 main::$11 ] (  [ main::i#2 main::line#2 main::$11 ] { }  ) always clobbers reg byte a 
Statement [15] *((byte*~) main::$11) ← (byte) '*' [ main::i#2 main::line#2 ] (  [ main::i#2 main::line#2 ] { }  ) always clobbers reg byte a reg byte y 
Statement [16] (byte*) main::line#1 ← (byte*) main::line#2 + (byte) $28 [ main::i#2 main::line#1 ] (  [ main::i#2 main::line#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::i#2 main::i#1 ] : zp[1]:2 , reg byte x , 
Potential registers zp[2]:3 [ main::line#2 main::line#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ main::$5 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ main::$9 ] : zp[1]:6 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ main::$8 ] : zp[1]:7 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:8 [ main::$7 ] : zp[1]:8 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[2]:9 [ main::$11 ] : zp[2]:9 , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 248.62: zp[1]:2 [ main::i#2 main::i#1 ] 202: zp[1]:6 [ main::$9 ] 202: zp[1]:7 [ main::$8 ] 202: zp[1]:8 [ main::$7 ] 202: zp[2]:9 [ main::$11 ] 134.67: zp[2]:3 [ main::line#2 main::line#1 ] 101: zp[1]:5 [ main::$5 ] 
Uplift Scope [] 

Uplifting [main] best 19305 combination zp[1]:2 [ main::i#2 main::i#1 ] reg byte a [ main::$9 ] reg byte a [ main::$8 ] reg byte a [ main::$7 ] zp[2]:9 [ main::$11 ] zp[2]:3 [ main::line#2 main::line#1 ] zp[1]:5 [ main::$5 ] 
Limited combination testing to 100 combinations of 384 possible.
Uplifting [] best 19305 combination 
Attempting to uplift remaining variables inzp[1]:2 [ main::i#2 main::i#1 ]
Uplifting [main] best 19305 combination zp[1]:2 [ main::i#2 main::i#1 ] 
Attempting to uplift remaining variables inzp[1]:5 [ main::$5 ]
Uplifting [main] best 18305 combination reg byte x [ main::$5 ] 
Allocated (was zp[2]:9) zp[2]:5 [ main::$11 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Test that the multiplication of a idx*sizeof(element) is reused inside loops
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_RASTER = $d012
  .label VIC_BG_COLOR = $d020
  .label SCREEN = $400
  // main
main: {
    // Move the entities
    .label line = 3
    .label i = 2
    .label __11 = 5
    // asm { sei  }
    sei
    jmp __b1
  // Wait for raster refresh
    // main::@1
  __b1:
    // [1] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp VIC_RASTER
    bne __b1
    jmp __b2
    // main::@2
  __b2:
    // [2] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VIC_BG_COLOR
    // [3] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [3] phi (byte*) main::line#2 = (const nomodify byte*) SCREEN [phi:main::@2->main::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z line
    lda #>SCREEN
    sta.z line+1
    // [3] phi (byte) main::i#2 = (byte) 0 [phi:main::@2->main::@3#1] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp __b3
    // main::@3
  __b3:
    // [4] if((byte) main::i#2<(byte) $19) goto main::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$19
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [5] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta VIC_BG_COLOR
    jmp __b1
    // main::@4
  __b4:
    // [6] (byte~) main::$5 ← (byte) main::i#2 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z i
    asl
    tax
    // [7] (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$5) -- vbuaa=_byte_pwuc1_derefidx_vbuxx 
    lda entities,x
    // [8] *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' ' -- pbuz1_derefidx_vbuaa=vbuc1 
    // Delete old symbol
    tay
    lda #' '
    sta (line),y
    // [9] *((const word*) entities + (byte~) main::$5) ← *((const word*) entities + (byte~) main::$5) + (byte) 1 -- pwuc1_derefidx_vbuxx=pwuc1_derefidx_vbuxx_plus_1 
    // Move by velocity
    inc entities,x
    bne !+
    inc entities+1,x
  !:
    // [10] if(*((const word*) entities + (byte~) main::$5)<(byte) $27+(byte) 1) goto main::@6 -- pwuc1_derefidx_vbuxx_lt_vbuc2_then_la1 
    lda entities+1,x
    bne !+
    lda entities,x
    cmp #$27+1
    bcc __b6
  !:
    jmp __b7
    // main::@7
  __b7:
    // [11] (byte~) main::$8 ← (byte) main::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [12] *((const word*) entities + (byte~) main::$8) ← (byte) 0 -- pwuc1_derefidx_vbuaa=vbuc2 
    ldx #0
    tay
    txa
    sta entities,y
    jmp __b6
    // main::@6
  __b6:
    // [13] (byte~) main::$7 ← (byte) main::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [14] (byte*~) main::$11 ← (byte*) main::line#2 + *((const word*) entities + (byte~) main::$7) -- pbuz1=pbuz2_plus_pwuc1_derefidx_vbuaa 
    tay
    clc
    lda.z line
    adc entities,y
    sta.z __11
    lda.z line+1
    adc entities+1,y
    sta.z __11+1
    // [15] *((byte*~) main::$11) ← (byte) '*' -- _deref_pbuz1=vbuc1 
    // Draw symbol
    lda #'*'
    ldy #0
    sta (__11),y
    // [16] (byte*) main::line#1 ← (byte*) main::line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    // Next line
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    // [17] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [3] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  __b3_from___b6:
    // [3] phi (byte*) main::line#2 = (byte*) main::line#1 [phi:main::@6->main::@3#0] -- register_copy 
    // [3] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@6->main::@3#1] -- register_copy 
    jmp __b3
}
  // File Data
  entities: .fill 2*$19, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b7
Removing instruction jmp __b6
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction __b2:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b7:
Removing instruction __b3_from___b6:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(const nomodify byte*) SCREEN = (byte*) 1024
(const nomodify byte*) VIC_BG_COLOR = (byte*) 53280
(const nomodify byte*) VIC_RASTER = (byte*) 53266
(const word*) entities[(number) $19]  = { fill( $19, 0) }
(void()) main()
(byte*~) main::$11 zp[2]:5 202.0
(byte~) main::$5 reg byte x 101.0
(byte~) main::$7 reg byte a 202.0
(byte~) main::$8 reg byte a 202.0
(byte~) main::$9 reg byte a 202.0
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(byte) main::i
(byte) main::i#1 i zp[1]:2 202.0
(byte) main::i#2 i zp[1]:2 46.61538461538461
(byte*) main::line
(byte*) main::line#1 line zp[2]:3 101.0
(byte*) main::line#2 line zp[2]:3 33.666666666666664

zp[1]:2 [ main::i#2 main::i#1 ]
zp[2]:3 [ main::line#2 main::line#1 ]
reg byte x [ main::$5 ]
reg byte a [ main::$9 ]
reg byte a [ main::$8 ]
reg byte a [ main::$7 ]
zp[2]:5 [ main::$11 ]


FINAL ASSEMBLER
Score: 16802

  // File Comments
// Test that the multiplication of a idx*sizeof(element) is reused inside loops
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label VIC_RASTER = $d012
  .label VIC_BG_COLOR = $d020
  .label SCREEN = $400
  // main
main: {
    // Move the entities
    .label line = 3
    .label i = 2
    .label __11 = 5
    // asm
    // asm { sei  }
    sei
  // Wait for raster refresh
    // main::@1
  __b1:
    // while(*VIC_RASTER!=0xff)
    // [1] if(*((const nomodify byte*) VIC_RASTER)!=(byte) $ff) goto main::@1 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp VIC_RASTER
    bne __b1
    // main::@2
    // *VIC_BG_COLOR = 0
    // [2] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta VIC_BG_COLOR
    // [3] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [3] phi (byte*) main::line#2 = (const nomodify byte*) SCREEN [phi:main::@2->main::@3#0] -- pbuz1=pbuc1 
    lda #<SCREEN
    sta.z line
    lda #>SCREEN
    sta.z line+1
    // [3] phi (byte) main::i#2 = (byte) 0 [phi:main::@2->main::@3#1] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    // main::@3
  __b3:
    // for(char i=0;i<NUM_ENTITIES;i++)
    // [4] if((byte) main::i#2<(byte) $19) goto main::@4 -- vbuz1_lt_vbuc1_then_la1 
    lda.z i
    cmp #$19
    bcc __b4
    // main::@5
    // *VIC_BG_COLOR = 15
    // [5] *((const nomodify byte*) VIC_BG_COLOR) ← (byte) $f -- _deref_pbuc1=vbuc2 
    lda #$f
    sta VIC_BG_COLOR
    jmp __b1
    // main::@4
  __b4:
    // line[(char)entities[i]] = ' '
    // [6] (byte~) main::$5 ← (byte) main::i#2 << (byte) 1 -- vbuxx=vbuz1_rol_1 
    lda.z i
    asl
    tax
    // [7] (byte~) main::$9 ← (byte)*((const word*) entities + (byte~) main::$5) -- vbuaa=_byte_pwuc1_derefidx_vbuxx 
    lda entities,x
    // [8] *((byte*) main::line#2 + (byte~) main::$9) ← (byte) ' ' -- pbuz1_derefidx_vbuaa=vbuc1 
    // Delete old symbol
    tay
    lda #' '
    sta (line),y
    // entities[i] += 1
    // [9] *((const word*) entities + (byte~) main::$5) ← *((const word*) entities + (byte~) main::$5) + (byte) 1 -- pwuc1_derefidx_vbuxx=pwuc1_derefidx_vbuxx_plus_1 
    // Move by velocity
    inc entities,x
    bne !+
    inc entities+1,x
  !:
    // if(entities[i]>39)
    // [10] if(*((const word*) entities + (byte~) main::$5)<(byte) $27+(byte) 1) goto main::@6 -- pwuc1_derefidx_vbuxx_lt_vbuc2_then_la1 
    lda entities+1,x
    bne !+
    lda entities,x
    cmp #$27+1
    bcc __b6
  !:
    // main::@7
    // entities[i] =0
    // [11] (byte~) main::$8 ← (byte) main::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [12] *((const word*) entities + (byte~) main::$8) ← (byte) 0 -- pwuc1_derefidx_vbuaa=vbuc2 
    ldx #0
    tay
    txa
    sta entities,y
    // main::@6
  __b6:
    // line[entities[i]] = '*'
    // [13] (byte~) main::$7 ← (byte) main::i#2 << (byte) 1 -- vbuaa=vbuz1_rol_1 
    lda.z i
    asl
    // [14] (byte*~) main::$11 ← (byte*) main::line#2 + *((const word*) entities + (byte~) main::$7) -- pbuz1=pbuz2_plus_pwuc1_derefidx_vbuaa 
    tay
    clc
    lda.z line
    adc entities,y
    sta.z __11
    lda.z line+1
    adc entities+1,y
    sta.z __11+1
    // [15] *((byte*~) main::$11) ← (byte) '*' -- _deref_pbuz1=vbuc1 
    // Draw symbol
    lda #'*'
    ldy #0
    sta (__11),y
    // line +=40
    // [16] (byte*) main::line#1 ← (byte*) main::line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    // Next line
    lda #$28
    clc
    adc.z line
    sta.z line
    bcc !+
    inc.z line+1
  !:
    // for(char i=0;i<NUM_ENTITIES;i++)
    // [17] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [3] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
    // [3] phi (byte*) main::line#2 = (byte*) main::line#1 [phi:main::@6->main::@3#0] -- register_copy 
    // [3] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@6->main::@3#1] -- register_copy 
    jmp __b3
}
  // File Data
  entities: .fill 2*$19, 0

