Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) plexShowSprite::xpos_idx)
Fixing pointer array-indexing *((word[PLEX_COUNT]) PLEX_XPOS + (byte) init::sx)
Identified constant variable (byte*) SCREEN
Identified constant variable (byte*) SPRITE
Inlined call (byte~) vicSelectGfxBank::$0 ← call toDd00 (byte*) vicSelectGfxBank::gfx 
Inlined call call plexSetScreen (byte*) plexInit::screen 
Inlined call call plexFreePrepare 
Inlined call call plexFreeAdd (byte) plexShowSprite::ypos 
Inlined call (byte~) loop::$9 ← call plexFreeNextYpos 
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) @3
Culled Empty Block (label) plexInit::plexSetScreen1_@return
Culled Empty Block (label) plexInit::@2
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) plexSort::plexFreePrepare1_@return
Culled Empty Block (label) plexSort::@7
Culled Empty Block (label) @7
Culled Empty Block (label) plexShowSprite::plexFreeAdd1_@return
Culled Empty Block (label) plexShowSprite::@5
Culled Empty Block (label) plexShowSprite::@3
Culled Empty Block (label) @8
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @13
Culled Empty Block (label) init::@4
Culled Empty Block (label) @14
Culled Empty Block (label) loop::@2
Culled Empty Block (label) loop::@27
Culled Empty Block (label) loop::@3
Culled Empty Block (label) loop::@28
Culled Empty Block (label) loop::@5
Culled Empty Block (label) loop::@7
Culled Empty Block (label) loop::@8
Culled Empty Block (label) loop::@9
Culled Empty Block (label) loop::@13
Culled Empty Block (label) loop::@15
Culled Empty Block (label) loop::@16
Culled Empty Block (label) loop::@17
Culled Empty Block (label) loop::plexFreeNextYpos1_@1
Culled Empty Block (label) loop::@20
Culled Empty Block (label) loop::@22
Culled Empty Block (label) loop::@23
Culled Empty Block (label) loop::@24
Culled Empty Block (label) loop::@26

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  (byte*) SPRITES_XPOS#0 ← ((byte*)) (number) $d000
  (byte*) SPRITES_YPOS#0 ← ((byte*)) (number) $d001
  (byte*) SPRITES_XMSB#0 ← ((byte*)) (number) $d010
  (byte*) RASTER#0 ← ((byte*)) (number) $d012
  (byte*) SPRITES_ENABLE#0 ← ((byte*)) (number) $d015
  (byte*) BORDERCOL#0 ← ((byte*)) (number) $d020
  (byte*) SPRITES_COLS#0 ← ((byte*)) (number) $d027
  (byte*) D011#0 ← ((byte*)) (number) $d011
  (byte) VIC_RST8#0 ← (number) $80
  (byte) VIC_DEN#0 ← (number) $10
  (byte) VIC_RSEL#0 ← (number) 8
  (byte) BLACK#0 ← (number) 0
  (byte) GREEN#0 ← (number) 5
  to:@4
@4: scope:[]  from @begin
  (byte) PLEX_COUNT#0 ← (number) $20
  (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte*) PLEX_SCREEN_PTR#0 ← ((byte*)) (number) $400+(number) $3f8
  (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
  (byte) plex_show_idx#0 ← (number) 0
  (byte) plex_sprite_idx#0 ← (number) 0
  (byte) plex_sprite_msb#0 ← (number) 1
  to:@9
plexInit: scope:[plexInit]  from init
  (byte*) plexInit::screen#1 ← phi( init/(byte*) plexInit::screen#0 )
  (byte*) plexInit::plexSetScreen1_screen#0 ← (byte*) plexInit::screen#1
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  (byte*) plexInit::plexSetScreen1_screen#1 ← phi( plexInit/(byte*) plexInit::plexSetScreen1_screen#0 )
  (byte*~) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
  (byte*) PLEX_SCREEN_PTR#1 ← (byte*~) plexInit::plexSetScreen1_$0#0
  to:plexInit::@3
plexInit::@3: scope:[plexInit]  from plexInit::plexSetScreen1
  (byte*) PLEX_SCREEN_PTR#22 ← phi( plexInit::plexSetScreen1/(byte*) PLEX_SCREEN_PTR#1 )
  (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) plexInit::i#0 ← (byte) 0
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::@3
  (byte*) PLEX_SCREEN_PTR#15 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 plexInit::@3/(byte*) PLEX_SCREEN_PTR#22 )
  (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::@3/(byte) plexInit::i#0 )
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  (byte) plexInit::i#1 ← (byte) plexInit::i#2 + rangenext(0,plexInit::$1)
  (bool~) plexInit::$2 ← (byte) plexInit::i#1 != rangelast(0,plexInit::$1)
  if((bool~) plexInit::$2) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  (byte*) PLEX_SCREEN_PTR#8 ← phi( plexInit::@1/(byte*) PLEX_SCREEN_PTR#15 )
  (byte*) PLEX_SCREEN_PTR#2 ← (byte*) PLEX_SCREEN_PTR#8
  return 
  to:@return
plexSort: scope:[plexSort]  from loop::@11
  (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (number) 2
  (byte) plexSort::m#0 ← (byte) 0
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  (byte) plexSort::m#2 ← phi( plexSort/(byte) plexSort::m#0 plexSort::@2/(byte) plexSort::m#1 )
  (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
  (byte) plexSort::nxt_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (number~) plexSort::$2)
  (byte) plexSort::nxt_y#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
  (bool~) plexSort::$4 ← ! (bool~) plexSort::$3
  if((bool~) plexSort::$4) goto plexSort::@2
  to:plexSort::@5
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  (byte) plexSort::m#3 ← phi( plexSort::@1/(byte) plexSort::m#2 plexSort::@4/(byte) plexSort::m#5 )
  (byte) plexSort::m#1 ← (byte) plexSort::m#3 + rangenext(0,plexSort::$1)
  (bool~) plexSort::$9 ← (byte) plexSort::m#1 != rangelast(0,plexSort::$1)
  if((bool~) plexSort::$9) goto plexSort::@1
  to:plexSort::@6
plexSort::@5: scope:[plexSort]  from plexSort::@1
  (byte) plexSort::nxt_idx#3 ← phi( plexSort::@1/(byte) plexSort::nxt_idx#0 )
  (byte) plexSort::nxt_y#2 ← phi( plexSort::@1/(byte) plexSort::nxt_y#0 )
  (byte) plexSort::m#4 ← phi( plexSort::@1/(byte) plexSort::m#2 )
  (byte) plexSort::s#0 ← (byte) plexSort::m#4
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@3 plexSort::@5
  (byte) plexSort::m#6 ← phi( plexSort::@3/(byte) plexSort::m#6 plexSort::@5/(byte) plexSort::m#4 )
  (byte) plexSort::nxt_idx#2 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 plexSort::@5/(byte) plexSort::nxt_idx#3 )
  (byte) plexSort::nxt_y#1 ← phi( plexSort::@3/(byte) plexSort::nxt_y#1 plexSort::@5/(byte) plexSort::nxt_y#2 )
  (byte) plexSort::s#3 ← phi( plexSort::@3/(byte) plexSort::s#1 plexSort::@5/(byte) plexSort::s#0 )
  (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (number~) plexSort::$5) ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
  (bool~) plexSort::$7 ← (byte) plexSort::nxt_y#1 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))
  (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
  if((bool~) plexSort::$8) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3
  (byte) plexSort::m#5 ← phi( plexSort::@3/(byte) plexSort::m#6 )
  (byte) plexSort::nxt_idx#1 ← phi( plexSort::@3/(byte) plexSort::nxt_idx#2 )
  (byte) plexSort::s#4 ← phi( plexSort::@3/(byte) plexSort::s#1 )
  (byte) plexSort::s#2 ← ++ (byte) plexSort::s#4
  *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#1
  to:plexSort::@2
plexSort::@6: scope:[plexSort]  from plexSort::@2
  (byte) plex_show_idx#1 ← (number) 0
  (byte) plex_sprite_idx#1 ← (number) 0
  (byte) plex_sprite_msb#1 ← (number) 1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@6
  (byte) plex_sprite_msb#38 ← phi( plexSort::@6/(byte) plex_sprite_msb#1 )
  (byte) plex_sprite_idx#39 ← phi( plexSort::@6/(byte) plex_sprite_idx#1 )
  (byte) plex_show_idx#39 ← phi( plexSort::@6/(byte) plex_show_idx#1 )
  (byte) plexSort::plexFreePrepare1_s#0 ← (byte) 0
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#30 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_msb#38 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#30 )
  (byte) plex_sprite_idx#32 ← phi( plexSort::plexFreePrepare1/(byte) plex_sprite_idx#39 plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#32 )
  (byte) plex_show_idx#32 ← phi( plexSort::plexFreePrepare1/(byte) plex_show_idx#39 plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#32 )
  (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) plexSort::plexFreePrepare1_s#0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
  (byte) plexSort::plexFreePrepare1_s#1 ← (byte) plexSort::plexFreePrepare1_s#2 + rangenext(0,7)
  (bool~) plexSort::plexFreePrepare1_$0#0 ← (byte) plexSort::plexFreePrepare1_s#1 != rangelast(0,7)
  if((bool~) plexSort::plexFreePrepare1_$0#0) goto plexSort::plexFreePrepare1_@1
  to:plexSort::plexFreePrepare1_@2
plexSort::plexFreePrepare1_@2: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  (byte) plex_sprite_msb#23 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_msb#30 )
  (byte) plex_sprite_idx#22 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_sprite_idx#32 )
  (byte) plex_show_idx#22 ← phi( plexSort::plexFreePrepare1_@1/(byte) plex_show_idx#32 )
  (byte) plex_free_next#0 ← (number) 0
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@2
  (byte) plex_free_next#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_free_next#0 )
  (byte) plex_sprite_msb#12 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_msb#23 )
  (byte) plex_sprite_idx#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_sprite_idx#22 )
  (byte) plex_show_idx#11 ← phi( plexSort::plexFreePrepare1_@2/(byte) plex_show_idx#22 )
  (byte) plex_show_idx#2 ← (byte) plex_show_idx#11
  (byte) plex_sprite_idx#2 ← (byte) plex_sprite_idx#11
  (byte) plex_sprite_msb#2 ← (byte) plex_sprite_msb#12
  (byte) plex_free_next#1 ← (byte) plex_free_next#11
  return 
  to:@return
plexShowSprite: scope:[plexShowSprite]  from loop::@21
  (byte) plex_sprite_msb#39 ← phi( loop::@21/(byte) plex_sprite_msb#27 )
  (byte*) PLEX_SCREEN_PTR#23 ← phi( loop::@21/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) plex_free_next#21 ← phi( loop::@21/(byte) plex_free_next#27 )
  (byte) plex_show_idx#12 ← phi( loop::@21/(byte) plex_show_idx#23 )
  (byte) plex_sprite_idx#12 ← phi( loop::@21/(byte) plex_sprite_idx#23 )
  (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (number) 2
  (byte) plexShowSprite::plex_sprite_idx2#0 ← (number~) plexShowSprite::$0
  (byte) plexShowSprite::ypos#0 ← *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#12))
  *((byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::ypos#0
  (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← (byte) plexShowSprite::ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  (byte) plex_sprite_msb#31 ← phi( plexShowSprite/(byte) plex_sprite_msb#39 )
  (byte) plexShowSprite::plex_sprite_idx2#2 ← phi( plexShowSprite/(byte) plexShowSprite::plex_sprite_idx2#0 )
  (byte) plex_sprite_idx#24 ← phi( plexShowSprite/(byte) plex_sprite_idx#12 )
  (byte*) PLEX_SCREEN_PTR#16 ← phi( plexShowSprite/(byte*) PLEX_SCREEN_PTR#23 )
  (byte) plex_show_idx#24 ← phi( plexShowSprite/(byte) plex_show_idx#12 )
  (byte) plex_free_next#12 ← phi( plexShowSprite/(byte) plex_free_next#21 )
  (byte) plexShowSprite::plexFreeAdd1_ypos#1 ← phi( plexShowSprite/(byte) plexShowSprite::plexFreeAdd1_ypos#0 )
  (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
  *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#12) ← (number~) plexShowSprite::plexFreeAdd1_$0#0
  (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (number) 1
  (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (number~) plexShowSprite::plexFreeAdd1_$1#0 & (number) 7
  (byte) plex_free_next#2 ← (number~) plexShowSprite::plexFreeAdd1_$2#0
  to:plexShowSprite::@7
plexShowSprite::@7: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  (byte) plex_free_next#39 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_free_next#2 )
  (byte) plex_sprite_msb#24 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_msb#31 )
  (byte) plexShowSprite::plex_sprite_idx2#1 ← phi( plexShowSprite::plexFreeAdd1/(byte) plexShowSprite::plex_sprite_idx2#2 )
  (byte) plex_sprite_idx#13 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_sprite_idx#24 )
  (byte*) PLEX_SCREEN_PTR#9 ← phi( plexShowSprite::plexFreeAdd1/(byte*) PLEX_SCREEN_PTR#16 )
  (byte) plex_show_idx#13 ← phi( plexShowSprite::plexFreeAdd1/(byte) plex_show_idx#24 )
  *((byte*) PLEX_SCREEN_PTR#9 + (byte) plex_sprite_idx#13) ← *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#13))
  (byte) plexShowSprite::xpos_idx#0 ← *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#13)
  (byte~) plexShowSprite::$10 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$2 ← < *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$10)
  *((byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#1) ← (byte~) plexShowSprite::$2
  (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
  (byte~) plexShowSprite::$3 ← > *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
  if((bool~) plexShowSprite::$4) goto plexShowSprite::@1
  to:plexShowSprite::@4
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#30 ← phi( plexShowSprite::@7/(byte) plex_free_next#39 )
  (byte) plex_show_idx#25 ← phi( plexShowSprite::@7/(byte) plex_show_idx#13 )
  (byte) plex_sprite_idx#25 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#13 )
  (byte) plex_sprite_msb#13 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#24 )
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#13
  to:plexShowSprite::@2
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::@7
  (byte) plex_free_next#31 ← phi( plexShowSprite::@7/(byte) plex_free_next#39 )
  (byte) plex_show_idx#26 ← phi( plexShowSprite::@7/(byte) plex_show_idx#13 )
  (byte) plex_sprite_idx#26 ← phi( plexShowSprite::@7/(byte) plex_sprite_idx#13 )
  (byte) plex_sprite_msb#14 ← phi( plexShowSprite::@7/(byte) plex_sprite_msb#24 )
  (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#14
  *((byte*) SPRITES_XMSB#0) ← *((byte*) SPRITES_XMSB#0) & (number~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@4
  (byte) plex_free_next#22 ← phi( plexShowSprite::@1/(byte) plex_free_next#30 plexShowSprite::@4/(byte) plex_free_next#31 )
  (byte) plex_sprite_msb#15 ← phi( plexShowSprite::@1/(byte) plex_sprite_msb#13 plexShowSprite::@4/(byte) plex_sprite_msb#14 )
  (byte) plex_show_idx#14 ← phi( plexShowSprite::@1/(byte) plex_show_idx#25 plexShowSprite::@4/(byte) plex_show_idx#26 )
  (byte) plex_sprite_idx#14 ← phi( plexShowSprite::@1/(byte) plex_sprite_idx#25 plexShowSprite::@4/(byte) plex_sprite_idx#26 )
  (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (number) 1
  (number~) plexShowSprite::$6 ← (number~) plexShowSprite::$5 & (number) 7
  (byte) plex_sprite_idx#3 ← (number~) plexShowSprite::$6
  (byte) plex_show_idx#3 ← ++ (byte) plex_show_idx#14
  (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#15 * (number) 2
  (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
  (bool~) plexShowSprite::$8 ← ! (bool~) plexShowSprite::$7
  if((bool~) plexShowSprite::$8) goto plexShowSprite::@return
  to:plexShowSprite::@6
plexShowSprite::@6: scope:[plexShowSprite]  from plexShowSprite::@2
  (byte) plex_show_idx#27 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 )
  (byte) plex_sprite_idx#27 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 )
  (byte) plex_free_next#23 ← phi( plexShowSprite::@2/(byte) plex_free_next#22 )
  (byte) plex_sprite_msb#4 ← (number) 1
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@6
  (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@2/(byte) plex_sprite_msb#3 plexShowSprite::@6/(byte) plex_sprite_msb#4 )
  (byte) plex_show_idx#15 ← phi( plexShowSprite::@2/(byte) plex_show_idx#3 plexShowSprite::@6/(byte) plex_show_idx#27 )
  (byte) plex_sprite_idx#15 ← phi( plexShowSprite::@2/(byte) plex_sprite_idx#3 plexShowSprite::@6/(byte) plex_sprite_idx#27 )
  (byte) plex_free_next#13 ← phi( plexShowSprite::@2/(byte) plex_free_next#22 plexShowSprite::@6/(byte) plex_free_next#23 )
  (byte) plex_free_next#3 ← (byte) plex_free_next#13
  (byte) plex_sprite_idx#4 ← (byte) plex_sprite_idx#15
  (byte) plex_show_idx#4 ← (byte) plex_show_idx#15
  (byte) plex_sprite_msb#5 ← (byte) plex_sprite_msb#16
  return 
  to:@return
@9: scope:[]  from @4
  (byte) plex_sprite_msb#40 ← phi( @4/(byte) plex_sprite_msb#0 )
  (byte) plex_sprite_idx#40 ← phi( @4/(byte) plex_sprite_idx#0 )
  (byte) plex_show_idx#40 ← phi( @4/(byte) plex_show_idx#0 )
  (byte*) PLEX_SCREEN_PTR#27 ← phi( @4/(byte*) PLEX_SCREEN_PTR#0 )
  (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
  (byte) plex_free_next#4 ← (number) 0
  to:@12
@12: scope:[]  from @9
  (byte) plex_free_next#38 ← phi( @9/(byte) plex_free_next#4 )
  (byte) plex_sprite_msb#37 ← phi( @9/(byte) plex_sprite_msb#40 )
  (byte) plex_sprite_idx#38 ← phi( @9/(byte) plex_sprite_idx#40 )
  (byte) plex_show_idx#38 ← phi( @9/(byte) plex_show_idx#40 )
  (byte*) PLEX_SCREEN_PTR#25 ← phi( @9/(byte*) PLEX_SCREEN_PTR#27 )
  (byte*) SCREEN#0 ← ((byte*)) (number) $400
  (byte[$100]) YSIN#0 ← kickasm {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
  (byte*) SPRITE#0 ← ((byte*)) (number) $2000
  kickasm(location (byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@15
main: scope:[main]  from @15
  (byte) plex_free_next#32 ← phi( @15/(byte) plex_free_next#29 )
  (byte) plex_sprite_msb#32 ← phi( @15/(byte) plex_sprite_msb#29 )
  (byte) plex_sprite_idx#33 ← phi( @15/(byte) plex_sprite_idx#31 )
  (byte) plex_show_idx#33 ← phi( @15/(byte) plex_show_idx#31 )
  (byte*) PLEX_SCREEN_PTR#17 ← phi( @15/(byte*) PLEX_SCREEN_PTR#21 )
  asm { sei  }
  call init 
  to:main::@1
main::@1: scope:[main]  from main
  (byte) plex_free_next#24 ← phi( main/(byte) plex_free_next#32 )
  (byte) plex_sprite_msb#25 ← phi( main/(byte) plex_sprite_msb#32 )
  (byte) plex_sprite_idx#28 ← phi( main/(byte) plex_sprite_idx#33 )
  (byte) plex_show_idx#28 ← phi( main/(byte) plex_show_idx#33 )
  (byte*) PLEX_SCREEN_PTR#10 ← phi( main/(byte*) PLEX_SCREEN_PTR#6 )
  (byte*) PLEX_SCREEN_PTR#3 ← (byte*) PLEX_SCREEN_PTR#10
  call loop 
  to:main::@2
main::@2: scope:[main]  from main::@1
  (byte*) PLEX_SCREEN_PTR#18 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (byte) plex_free_next#14 ← phi( main::@1/(byte) plex_free_next#9 )
  (byte) plex_sprite_msb#17 ← phi( main::@1/(byte) plex_sprite_msb#10 )
  (byte) plex_sprite_idx#16 ← phi( main::@1/(byte) plex_sprite_idx#9 )
  (byte) plex_show_idx#16 ← phi( main::@1/(byte) plex_show_idx#9 )
  (byte) plex_show_idx#5 ← (byte) plex_show_idx#16
  (byte) plex_sprite_idx#5 ← (byte) plex_sprite_idx#16
  (byte) plex_sprite_msb#6 ← (byte) plex_sprite_msb#17
  (byte) plex_free_next#5 ← (byte) plex_free_next#14
  to:main::@return
main::@return: scope:[main]  from main::@2
  (byte) plex_free_next#15 ← phi( main::@2/(byte) plex_free_next#5 )
  (byte) plex_sprite_msb#18 ← phi( main::@2/(byte) plex_sprite_msb#6 )
  (byte) plex_sprite_idx#17 ← phi( main::@2/(byte) plex_sprite_idx#5 )
  (byte) plex_show_idx#17 ← phi( main::@2/(byte) plex_show_idx#5 )
  (byte*) PLEX_SCREEN_PTR#11 ← phi( main::@2/(byte*) PLEX_SCREEN_PTR#18 )
  (byte*) PLEX_SCREEN_PTR#4 ← (byte*) PLEX_SCREEN_PTR#11
  (byte) plex_show_idx#6 ← (byte) plex_show_idx#17
  (byte) plex_sprite_idx#6 ← (byte) plex_sprite_idx#17
  (byte) plex_sprite_msb#7 ← (byte) plex_sprite_msb#18
  (byte) plex_free_next#6 ← (byte) plex_free_next#15
  return 
  to:@return
init: scope:[init]  from main
  (byte*) PLEX_SCREEN_PTR#19 ← phi( main/(byte*) PLEX_SCREEN_PTR#17 )
  (byte~) init::$0 ← (byte) VIC_DEN#0 | (byte) VIC_RSEL#0
  (number~) init::$1 ← (byte~) init::$0 | (number) 3
  *((byte*) D011#0) ← (number~) init::$1
  (byte*) plexInit::screen#0 ← (byte*) SCREEN#0
  call plexInit 
  to:init::@5
init::@5: scope:[init]  from init
  (byte*) PLEX_SCREEN_PTR#12 ← phi( init/(byte*) PLEX_SCREEN_PTR#2 )
  (byte*) PLEX_SCREEN_PTR#5 ← (byte*) PLEX_SCREEN_PTR#12
  (word) init::xp#0 ← (number) $20
  (number~) init::$3 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) init::sx#0 ← (byte) 0
  to:init::@1
init::@1: scope:[init]  from init::@1 init::@5
  (byte*) PLEX_SCREEN_PTR#28 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#28 init::@5/(byte*) PLEX_SCREEN_PTR#5 )
  (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init::@5/(word) init::xp#0 )
  (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init::@5/(byte) init::sx#0 )
  (byte*~) init::$4 ← (byte*) SPRITE#0 / (number) $40
  (byte~) init::$5 ← ((byte)) (byte*~) init::$4
  *((byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte~) init::$5
  (byte~) init::$8 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
  *((word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2
  (word) init::xp#1 ← (word) init::xp#2 + (number) 9
  (byte) init::sx#1 ← (byte) init::sx#2 + rangenext(0,init::$3)
  (bool~) init::$6 ← (byte) init::sx#1 != rangelast(0,init::$3)
  if((bool~) init::$6) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  (byte*) PLEX_SCREEN_PTR#24 ← phi( init::@1/(byte*) PLEX_SCREEN_PTR#28 )
  *((byte*) SPRITES_ENABLE#0) ← (number) $ff
  (byte) init::ss#0 ← (byte) 0
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  (byte*) PLEX_SCREEN_PTR#20 ← phi( init::@2/(byte*) PLEX_SCREEN_PTR#24 init::@3/(byte*) PLEX_SCREEN_PTR#20 )
  (byte) init::ss#2 ← phi( init::@2/(byte) init::ss#0 init::@3/(byte) init::ss#1 )
  *((byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (byte) GREEN#0
  (byte) init::ss#1 ← (byte) init::ss#2 + rangenext(0,7)
  (bool~) init::$7 ← (byte) init::ss#1 != rangelast(0,7)
  if((bool~) init::$7) goto init::@3
  to:init::@return
init::@return: scope:[init]  from init::@3
  (byte*) PLEX_SCREEN_PTR#13 ← phi( init::@3/(byte*) PLEX_SCREEN_PTR#20 )
  (byte*) PLEX_SCREEN_PTR#6 ← (byte*) PLEX_SCREEN_PTR#13
  return 
  to:@return
loop: scope:[loop]  from main::@1
  (byte*) PLEX_SCREEN_PTR#43 ← phi( main::@1/(byte*) PLEX_SCREEN_PTR#3 )
  (byte) plex_free_next#33 ← phi( main::@1/(byte) plex_free_next#24 )
  (byte) plex_sprite_msb#33 ← phi( main::@1/(byte) plex_sprite_msb#25 )
  (byte) plex_sprite_idx#34 ← phi( main::@1/(byte) plex_sprite_idx#28 )
  (byte) plex_show_idx#34 ← phi( main::@1/(byte) plex_show_idx#28 )
  (byte) loop::sin_idx#0 ← (number) 0
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@25
  (byte*) PLEX_SCREEN_PTR#42 ← phi( loop/(byte*) PLEX_SCREEN_PTR#43 loop::@25/(byte*) PLEX_SCREEN_PTR#44 )
  (byte) loop::sin_idx#6 ← phi( loop/(byte) loop::sin_idx#0 loop::@25/(byte) loop::sin_idx#7 )
  (byte) plex_free_next#28 ← phi( loop/(byte) plex_free_next#33 loop::@25/(byte) plex_free_next#34 )
  (byte) plex_sprite_msb#28 ← phi( loop/(byte) plex_sprite_msb#33 loop::@25/(byte) plex_sprite_msb#34 )
  (byte) plex_sprite_idx#30 ← phi( loop/(byte) plex_sprite_idx#34 loop::@25/(byte) plex_sprite_idx#35 )
  (byte) plex_show_idx#30 ← phi( loop/(byte) plex_show_idx#34 loop::@25/(byte) plex_show_idx#35 )
  if(true) goto loop::@4
  to:loop::@return
loop::@4: scope:[loop]  from loop::@1 loop::@4
  (byte*) PLEX_SCREEN_PTR#41 ← phi( loop::@1/(byte*) PLEX_SCREEN_PTR#42 loop::@4/(byte*) PLEX_SCREEN_PTR#41 )
  (byte) plex_free_next#43 ← phi( loop::@1/(byte) plex_free_next#28 loop::@4/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#43 ← phi( loop::@1/(byte) plex_sprite_msb#28 loop::@4/(byte) plex_sprite_msb#43 )
  (byte) plex_sprite_idx#43 ← phi( loop::@1/(byte) plex_sprite_idx#30 loop::@4/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#43 ← phi( loop::@1/(byte) plex_show_idx#30 loop::@4/(byte) plex_show_idx#43 )
  (byte) loop::sin_idx#4 ← phi( loop::@1/(byte) loop::sin_idx#6 loop::@4/(byte) loop::sin_idx#4 )
  (bool~) loop::$0 ← *((byte*) RASTER#0) != (number) $ff
  if((bool~) loop::$0) goto loop::@4
  to:loop::@6
loop::@6: scope:[loop]  from loop::@4
  (byte*) PLEX_SCREEN_PTR#40 ← phi( loop::@4/(byte*) PLEX_SCREEN_PTR#41 )
  (byte) plex_free_next#40 ← phi( loop::@4/(byte) plex_free_next#43 )
  (byte) plex_sprite_msb#41 ← phi( loop::@4/(byte) plex_sprite_msb#43 )
  (byte) plex_sprite_idx#41 ← phi( loop::@4/(byte) plex_sprite_idx#43 )
  (byte) plex_show_idx#41 ← phi( loop::@4/(byte) plex_show_idx#43 )
  (byte) loop::sin_idx#2 ← phi( loop::@4/(byte) loop::sin_idx#4 )
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  (byte) loop::y_idx#0 ← (byte) loop::sin_idx#2
  (number~) loop::$2 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) loop::sy#0 ← (byte) 0
  to:loop::@10
loop::@10: scope:[loop]  from loop::@10 loop::@6
  (byte*) PLEX_SCREEN_PTR#39 ← phi( loop::@10/(byte*) PLEX_SCREEN_PTR#39 loop::@6/(byte*) PLEX_SCREEN_PTR#40 )
  (byte) plex_free_next#35 ← phi( loop::@10/(byte) plex_free_next#35 loop::@6/(byte) plex_free_next#40 )
  (byte) plex_sprite_msb#35 ← phi( loop::@10/(byte) plex_sprite_msb#35 loop::@6/(byte) plex_sprite_msb#41 )
  (byte) plex_sprite_idx#36 ← phi( loop::@10/(byte) plex_sprite_idx#36 loop::@6/(byte) plex_sprite_idx#41 )
  (byte) plex_show_idx#36 ← phi( loop::@10/(byte) plex_show_idx#36 loop::@6/(byte) plex_show_idx#41 )
  (byte) loop::sin_idx#5 ← phi( loop::@10/(byte) loop::sin_idx#5 loop::@6/(byte) loop::sin_idx#2 )
  (byte) loop::sy#2 ← phi( loop::@10/(byte) loop::sy#1 loop::@6/(byte) loop::sy#0 )
  (byte) loop::y_idx#2 ← phi( loop::@10/(byte) loop::y_idx#1 loop::@6/(byte) loop::y_idx#0 )
  *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((byte[$100]) YSIN#0 + (byte) loop::y_idx#2)
  (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
  (byte) loop::sy#1 ← (byte) loop::sy#2 + rangenext(0,loop::$2)
  (bool~) loop::$3 ← (byte) loop::sy#1 != rangelast(0,loop::$2)
  if((bool~) loop::$3) goto loop::@10
  to:loop::@11
loop::@11: scope:[loop]  from loop::@10
  (byte*) PLEX_SCREEN_PTR#38 ← phi( loop::@10/(byte*) PLEX_SCREEN_PTR#39 )
  (byte) plex_free_next#25 ← phi( loop::@10/(byte) plex_free_next#35 )
  (byte) plex_sprite_msb#26 ← phi( loop::@10/(byte) plex_sprite_msb#35 )
  (byte) plex_sprite_idx#29 ← phi( loop::@10/(byte) plex_sprite_idx#36 )
  (byte) plex_show_idx#29 ← phi( loop::@10/(byte) plex_show_idx#36 )
  (byte) loop::sin_idx#3 ← phi( loop::@10/(byte) loop::sin_idx#5 )
  (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call plexSort 
  to:loop::@30
loop::@30: scope:[loop]  from loop::@11
  (byte) loop::sin_idx#17 ← phi( loop::@11/(byte) loop::sin_idx#1 )
  (byte*) PLEX_SCREEN_PTR#37 ← phi( loop::@11/(byte*) PLEX_SCREEN_PTR#38 )
  (byte) plex_free_next#16 ← phi( loop::@11/(byte) plex_free_next#1 )
  (byte) plex_sprite_msb#19 ← phi( loop::@11/(byte) plex_sprite_msb#2 )
  (byte) plex_sprite_idx#18 ← phi( loop::@11/(byte) plex_sprite_idx#2 )
  (byte) plex_show_idx#18 ← phi( loop::@11/(byte) plex_show_idx#2 )
  (byte) plex_show_idx#7 ← (byte) plex_show_idx#18
  (byte) plex_sprite_idx#7 ← (byte) plex_sprite_idx#18
  (byte) plex_sprite_msb#8 ← (byte) plex_sprite_msb#19
  (byte) plex_free_next#7 ← (byte) plex_free_next#16
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  to:loop::@12
loop::@12: scope:[loop]  from loop::@12 loop::@30
  (byte) loop::sin_idx#16 ← phi( loop::@12/(byte) loop::sin_idx#16 loop::@30/(byte) loop::sin_idx#17 )
  (byte*) PLEX_SCREEN_PTR#36 ← phi( loop::@12/(byte*) PLEX_SCREEN_PTR#36 loop::@30/(byte*) PLEX_SCREEN_PTR#37 )
  (byte) plex_sprite_msb#48 ← phi( loop::@12/(byte) plex_sprite_msb#48 loop::@30/(byte) plex_sprite_msb#8 )
  (byte) plex_show_idx#48 ← phi( loop::@12/(byte) plex_show_idx#48 loop::@30/(byte) plex_show_idx#7 )
  (byte) plex_sprite_idx#48 ← phi( loop::@12/(byte) plex_sprite_idx#48 loop::@30/(byte) plex_sprite_idx#7 )
  (byte) plex_free_next#41 ← phi( loop::@12/(byte) plex_free_next#41 loop::@30/(byte) plex_free_next#7 )
  (byte~) loop::$6 ← *((byte*) D011#0) & (byte) VIC_RST8#0
  (bool~) loop::$7 ← (byte~) loop::$6 != (number) 0
  if((bool~) loop::$7) goto loop::@12
  to:loop::@14
loop::@14: scope:[loop]  from loop::@12
  (byte) loop::sin_idx#15 ← phi( loop::@12/(byte) loop::sin_idx#16 )
  (byte*) PLEX_SCREEN_PTR#34 ← phi( loop::@12/(byte*) PLEX_SCREEN_PTR#36 )
  (byte) plex_sprite_msb#47 ← phi( loop::@12/(byte) plex_sprite_msb#48 )
  (byte) plex_show_idx#47 ← phi( loop::@12/(byte) plex_show_idx#48 )
  (byte) plex_sprite_idx#47 ← phi( loop::@12/(byte) plex_sprite_idx#48 )
  (byte) plex_free_next#36 ← phi( loop::@12/(byte) plex_free_next#41 )
  (number~) loop::$8 ← (byte) PLEX_COUNT#0 - (number) 1
  (byte) loop::ss#0 ← (byte) 0
  to:loop::@18
loop::@18: scope:[loop]  from loop::@14 loop::@31
  (byte) loop::sin_idx#14 ← phi( loop::@14/(byte) loop::sin_idx#15 loop::@31/(byte) loop::sin_idx#8 )
  (byte*) PLEX_SCREEN_PTR#33 ← phi( loop::@14/(byte*) PLEX_SCREEN_PTR#34 loop::@31/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) loop::ss#8 ← phi( loop::@14/(byte) loop::ss#0 loop::@31/(byte) loop::ss#1 )
  (byte) plex_sprite_msb#46 ← phi( loop::@14/(byte) plex_sprite_msb#47 loop::@31/(byte) plex_sprite_msb#9 )
  (byte) plex_show_idx#46 ← phi( loop::@14/(byte) plex_show_idx#47 loop::@31/(byte) plex_show_idx#8 )
  (byte) plex_sprite_idx#46 ← phi( loop::@14/(byte) plex_sprite_idx#47 loop::@31/(byte) plex_sprite_idx#8 )
  (byte) plex_free_next#26 ← phi( loop::@14/(byte) plex_free_next#36 loop::@31/(byte) plex_free_next#8 )
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@18
  (byte) loop::sin_idx#13 ← phi( loop::@18/(byte) loop::sin_idx#14 )
  (byte*) PLEX_SCREEN_PTR#32 ← phi( loop::@18/(byte*) PLEX_SCREEN_PTR#33 )
  (byte) loop::ss#7 ← phi( loop::@18/(byte) loop::ss#8 )
  (byte) plex_sprite_msb#45 ← phi( loop::@18/(byte) plex_sprite_msb#46 )
  (byte) plex_show_idx#45 ← phi( loop::@18/(byte) plex_show_idx#46 )
  (byte) plex_sprite_idx#45 ← phi( loop::@18/(byte) plex_sprite_idx#46 )
  (byte) plex_free_next#17 ← phi( loop::@18/(byte) plex_free_next#26 )
  (byte) loop::plexFreeNextYpos1_return#0 ← *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17)
  to:loop::plexFreeNextYpos1_@return
loop::plexFreeNextYpos1_@return: scope:[loop]  from loop::plexFreeNextYpos1
  (byte) loop::sin_idx#12 ← phi( loop::plexFreeNextYpos1/(byte) loop::sin_idx#13 )
  (byte*) PLEX_SCREEN_PTR#31 ← phi( loop::plexFreeNextYpos1/(byte*) PLEX_SCREEN_PTR#32 )
  (byte) loop::ss#6 ← phi( loop::plexFreeNextYpos1/(byte) loop::ss#7 )
  (byte) plex_sprite_msb#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_sprite_msb#45 )
  (byte) plex_free_next#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_free_next#17 )
  (byte) plex_show_idx#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_show_idx#45 )
  (byte) plex_sprite_idx#44 ← phi( loop::plexFreeNextYpos1/(byte) plex_sprite_idx#45 )
  (byte) loop::plexFreeNextYpos1_return#2 ← phi( loop::plexFreeNextYpos1/(byte) loop::plexFreeNextYpos1_return#0 )
  (byte) loop::plexFreeNextYpos1_return#1 ← (byte) loop::plexFreeNextYpos1_return#2
  to:loop::@29
loop::@29: scope:[loop]  from loop::plexFreeNextYpos1_@return
  (byte) loop::sin_idx#11 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::sin_idx#12 )
  (byte*) PLEX_SCREEN_PTR#30 ← phi( loop::plexFreeNextYpos1_@return/(byte*) PLEX_SCREEN_PTR#31 )
  (byte) loop::ss#5 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::ss#6 )
  (byte) plex_sprite_msb#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_sprite_msb#44 )
  (byte) plex_free_next#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_free_next#44 )
  (byte) plex_show_idx#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_show_idx#44 )
  (byte) plex_sprite_idx#42 ← phi( loop::plexFreeNextYpos1_@return/(byte) plex_sprite_idx#44 )
  (byte) loop::plexFreeNextYpos1_return#3 ← phi( loop::plexFreeNextYpos1_@return/(byte) loop::plexFreeNextYpos1_return#1 )
  (byte~) loop::$9 ← (byte) loop::plexFreeNextYpos1_return#3
  (byte) loop::rasterY#0 ← (byte~) loop::$9
  to:loop::@19
loop::@19: scope:[loop]  from loop::@19 loop::@29
  (byte) loop::sin_idx#10 ← phi( loop::@19/(byte) loop::sin_idx#10 loop::@29/(byte) loop::sin_idx#11 )
  (byte*) PLEX_SCREEN_PTR#29 ← phi( loop::@19/(byte*) PLEX_SCREEN_PTR#29 loop::@29/(byte*) PLEX_SCREEN_PTR#30 )
  (byte) loop::ss#4 ← phi( loop::@19/(byte) loop::ss#4 loop::@29/(byte) loop::ss#5 )
  (byte) plex_sprite_msb#36 ← phi( loop::@19/(byte) plex_sprite_msb#36 loop::@29/(byte) plex_sprite_msb#42 )
  (byte) plex_free_next#37 ← phi( loop::@19/(byte) plex_free_next#37 loop::@29/(byte) plex_free_next#42 )
  (byte) plex_show_idx#37 ← phi( loop::@19/(byte) plex_show_idx#37 loop::@29/(byte) plex_show_idx#42 )
  (byte) plex_sprite_idx#37 ← phi( loop::@19/(byte) plex_sprite_idx#37 loop::@29/(byte) plex_sprite_idx#42 )
  (byte) loop::rasterY#1 ← phi( loop::@19/(byte) loop::rasterY#1 loop::@29/(byte) loop::rasterY#0 )
  (bool~) loop::$10 ← *((byte*) RASTER#0) < (byte) loop::rasterY#1
  if((bool~) loop::$10) goto loop::@19
  to:loop::@21
loop::@21: scope:[loop]  from loop::@19
  (byte) loop::sin_idx#9 ← phi( loop::@19/(byte) loop::sin_idx#10 )
  (byte*) PLEX_SCREEN_PTR#26 ← phi( loop::@19/(byte*) PLEX_SCREEN_PTR#29 )
  (byte) loop::ss#3 ← phi( loop::@19/(byte) loop::ss#4 )
  (byte) plex_sprite_msb#27 ← phi( loop::@19/(byte) plex_sprite_msb#36 )
  (byte) plex_free_next#27 ← phi( loop::@19/(byte) plex_free_next#37 )
  (byte) plex_show_idx#23 ← phi( loop::@19/(byte) plex_show_idx#37 )
  (byte) plex_sprite_idx#23 ← phi( loop::@19/(byte) plex_sprite_idx#37 )
  *((byte*) BORDERCOL#0) ← ++ *((byte*) BORDERCOL#0)
  call plexShowSprite 
  to:loop::@31
loop::@31: scope:[loop]  from loop::@21
  (byte*) PLEX_SCREEN_PTR#35 ← phi( loop::@21/(byte*) PLEX_SCREEN_PTR#26 )
  (byte) loop::sin_idx#8 ← phi( loop::@21/(byte) loop::sin_idx#9 )
  (byte) loop::ss#2 ← phi( loop::@21/(byte) loop::ss#3 )
  (byte) plex_sprite_msb#20 ← phi( loop::@21/(byte) plex_sprite_msb#5 )
  (byte) plex_show_idx#19 ← phi( loop::@21/(byte) plex_show_idx#4 )
  (byte) plex_sprite_idx#19 ← phi( loop::@21/(byte) plex_sprite_idx#4 )
  (byte) plex_free_next#18 ← phi( loop::@21/(byte) plex_free_next#3 )
  (byte) plex_free_next#8 ← (byte) plex_free_next#18
  (byte) plex_sprite_idx#8 ← (byte) plex_sprite_idx#19
  (byte) plex_show_idx#8 ← (byte) plex_show_idx#19
  (byte) plex_sprite_msb#9 ← (byte) plex_sprite_msb#20
  (byte) loop::ss#1 ← (byte) loop::ss#2 + rangenext(0,loop::$8)
  (bool~) loop::$13 ← (byte) loop::ss#1 != rangelast(0,loop::$8)
  if((bool~) loop::$13) goto loop::@18
  to:loop::@25
loop::@25: scope:[loop]  from loop::@31
  (byte*) PLEX_SCREEN_PTR#44 ← phi( loop::@31/(byte*) PLEX_SCREEN_PTR#35 )
  (byte) loop::sin_idx#7 ← phi( loop::@31/(byte) loop::sin_idx#8 )
  (byte) plex_free_next#34 ← phi( loop::@31/(byte) plex_free_next#8 )
  (byte) plex_sprite_msb#34 ← phi( loop::@31/(byte) plex_sprite_msb#9 )
  (byte) plex_sprite_idx#35 ← phi( loop::@31/(byte) plex_sprite_idx#8 )
  (byte) plex_show_idx#35 ← phi( loop::@31/(byte) plex_show_idx#8 )
  *((byte*) BORDERCOL#0) ← (byte) BLACK#0
  to:loop::@1
loop::@return: scope:[loop]  from loop::@1
  (byte) plex_free_next#19 ← phi( loop::@1/(byte) plex_free_next#28 )
  (byte) plex_sprite_msb#21 ← phi( loop::@1/(byte) plex_sprite_msb#28 )
  (byte) plex_sprite_idx#20 ← phi( loop::@1/(byte) plex_sprite_idx#30 )
  (byte) plex_show_idx#20 ← phi( loop::@1/(byte) plex_show_idx#30 )
  (byte) plex_show_idx#9 ← (byte) plex_show_idx#20
  (byte) plex_sprite_idx#9 ← (byte) plex_sprite_idx#20
  (byte) plex_sprite_msb#10 ← (byte) plex_sprite_msb#21
  (byte) plex_free_next#9 ← (byte) plex_free_next#19
  return 
  to:@return
@15: scope:[]  from @12
  (byte) plex_free_next#29 ← phi( @12/(byte) plex_free_next#38 )
  (byte) plex_sprite_msb#29 ← phi( @12/(byte) plex_sprite_msb#37 )
  (byte) plex_sprite_idx#31 ← phi( @12/(byte) plex_sprite_idx#38 )
  (byte) plex_show_idx#31 ← phi( @12/(byte) plex_show_idx#38 )
  (byte*) PLEX_SCREEN_PTR#21 ← phi( @12/(byte*) PLEX_SCREEN_PTR#25 )
  call main 
  to:@16
@16: scope:[]  from @15
  (byte) plex_free_next#20 ← phi( @15/(byte) plex_free_next#6 )
  (byte) plex_sprite_msb#22 ← phi( @15/(byte) plex_sprite_msb#7 )
  (byte) plex_sprite_idx#21 ← phi( @15/(byte) plex_sprite_idx#6 )
  (byte) plex_show_idx#21 ← phi( @15/(byte) plex_show_idx#6 )
  (byte*) PLEX_SCREEN_PTR#14 ← phi( @15/(byte*) PLEX_SCREEN_PTR#4 )
  (byte*) PLEX_SCREEN_PTR#7 ← (byte*) PLEX_SCREEN_PTR#14
  (byte) plex_show_idx#10 ← (byte) plex_show_idx#21
  (byte) plex_sprite_idx#10 ← (byte) plex_sprite_idx#21
  (byte) plex_sprite_msb#11 ← (byte) plex_sprite_msb#22
  (byte) plex_free_next#10 ← (byte) plex_free_next#20
  to:@end
@end: scope:[]  from @16

SYMBOL TABLE SSA
(label) @12
(label) @15
(label) @16
(label) @4
(label) @9
(label) @begin
(label) @end
(byte) BLACK
(byte) BLACK#0
(byte*) BORDERCOL
(byte*) BORDERCOL#0
(byte*) D011
(byte*) D011#0
(byte) GREEN
(byte) GREEN#0
(byte) PLEX_COUNT
(byte) PLEX_COUNT#0
(byte[8]) PLEX_FREE_YPOS
(byte[8]) PLEX_FREE_YPOS#0
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte[PLEX_COUNT#0]) PLEX_PTR#0
(byte*) PLEX_SCREEN_PTR
(byte*) PLEX_SCREEN_PTR#0
(byte*) PLEX_SCREEN_PTR#1
(byte*) PLEX_SCREEN_PTR#10
(byte*) PLEX_SCREEN_PTR#11
(byte*) PLEX_SCREEN_PTR#12
(byte*) PLEX_SCREEN_PTR#13
(byte*) PLEX_SCREEN_PTR#14
(byte*) PLEX_SCREEN_PTR#15
(byte*) PLEX_SCREEN_PTR#16
(byte*) PLEX_SCREEN_PTR#17
(byte*) PLEX_SCREEN_PTR#18
(byte*) PLEX_SCREEN_PTR#19
(byte*) PLEX_SCREEN_PTR#2
(byte*) PLEX_SCREEN_PTR#20
(byte*) PLEX_SCREEN_PTR#21
(byte*) PLEX_SCREEN_PTR#22
(byte*) PLEX_SCREEN_PTR#23
(byte*) PLEX_SCREEN_PTR#24
(byte*) PLEX_SCREEN_PTR#25
(byte*) PLEX_SCREEN_PTR#26
(byte*) PLEX_SCREEN_PTR#27
(byte*) PLEX_SCREEN_PTR#28
(byte*) PLEX_SCREEN_PTR#29
(byte*) PLEX_SCREEN_PTR#3
(byte*) PLEX_SCREEN_PTR#30
(byte*) PLEX_SCREEN_PTR#31
(byte*) PLEX_SCREEN_PTR#32
(byte*) PLEX_SCREEN_PTR#33
(byte*) PLEX_SCREEN_PTR#34
(byte*) PLEX_SCREEN_PTR#35
(byte*) PLEX_SCREEN_PTR#36
(byte*) PLEX_SCREEN_PTR#37
(byte*) PLEX_SCREEN_PTR#38
(byte*) PLEX_SCREEN_PTR#39
(byte*) PLEX_SCREEN_PTR#4
(byte*) PLEX_SCREEN_PTR#40
(byte*) PLEX_SCREEN_PTR#41
(byte*) PLEX_SCREEN_PTR#42
(byte*) PLEX_SCREEN_PTR#43
(byte*) PLEX_SCREEN_PTR#44
(byte*) PLEX_SCREEN_PTR#5
(byte*) PLEX_SCREEN_PTR#6
(byte*) PLEX_SCREEN_PTR#7
(byte*) PLEX_SCREEN_PTR#8
(byte*) PLEX_SCREEN_PTR#9
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0
(word[PLEX_COUNT#0]) PLEX_XPOS
(word[PLEX_COUNT#0]) PLEX_XPOS#0
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS#0
(byte*) RASTER
(byte*) RASTER#0
(byte*) SCREEN
(byte*) SCREEN#0
(const byte) SIZEOF_WORD = (byte) 2
(byte*) SPRITE
(byte*) SPRITE#0
(byte*) SPRITES_COLS
(byte*) SPRITES_COLS#0
(byte*) SPRITES_ENABLE
(byte*) SPRITES_ENABLE#0
(byte*) SPRITES_XMSB
(byte*) SPRITES_XMSB#0
(byte*) SPRITES_XPOS
(byte*) SPRITES_XPOS#0
(byte*) SPRITES_YPOS
(byte*) SPRITES_YPOS#0
(byte) VIC_DEN
(byte) VIC_DEN#0
(byte) VIC_RSEL
(byte) VIC_RSEL#0
(byte) VIC_RST8
(byte) VIC_RST8#0
(byte[$100]) YSIN
(byte[$100]) YSIN#0
(void()) init()
(byte~) init::$0
(number~) init::$1
(number~) init::$3
(byte*~) init::$4
(byte~) init::$5
(bool~) init::$6
(bool~) init::$7
(byte~) init::$8
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@5
(label) init::@return
(byte) init::ss
(byte) init::ss#0
(byte) init::ss#1
(byte) init::ss#2
(byte) init::sx
(byte) init::sx#0
(byte) init::sx#1
(byte) init::sx#2
(word) init::xp
(word) init::xp#0
(word) init::xp#1
(word) init::xp#2
(void()) loop()
(bool~) loop::$0
(bool~) loop::$10
(bool~) loop::$13
(number~) loop::$2
(bool~) loop::$3
(byte~) loop::$6
(bool~) loop::$7
(number~) loop::$8
(byte~) loop::$9
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@12
(label) loop::@14
(label) loop::@18
(label) loop::@19
(label) loop::@21
(label) loop::@25
(label) loop::@29
(label) loop::@30
(label) loop::@31
(label) loop::@4
(label) loop::@6
(label) loop::@return
(label) loop::plexFreeNextYpos1
(label) loop::plexFreeNextYpos1_@return
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0
(byte) loop::plexFreeNextYpos1_return#1
(byte) loop::plexFreeNextYpos1_return#2
(byte) loop::plexFreeNextYpos1_return#3
(byte) loop::rasterY
(byte) loop::rasterY#0
(byte) loop::rasterY#1
(byte) loop::sin_idx
(byte) loop::sin_idx#0
(byte) loop::sin_idx#1
(byte) loop::sin_idx#10
(byte) loop::sin_idx#11
(byte) loop::sin_idx#12
(byte) loop::sin_idx#13
(byte) loop::sin_idx#14
(byte) loop::sin_idx#15
(byte) loop::sin_idx#16
(byte) loop::sin_idx#17
(byte) loop::sin_idx#2
(byte) loop::sin_idx#3
(byte) loop::sin_idx#4
(byte) loop::sin_idx#5
(byte) loop::sin_idx#6
(byte) loop::sin_idx#7
(byte) loop::sin_idx#8
(byte) loop::sin_idx#9
(byte) loop::ss
(byte) loop::ss#0
(byte) loop::ss#1
(byte) loop::ss#2
(byte) loop::ss#3
(byte) loop::ss#4
(byte) loop::ss#5
(byte) loop::ss#6
(byte) loop::ss#7
(byte) loop::ss#8
(byte) loop::sy
(byte) loop::sy#0
(byte) loop::sy#1
(byte) loop::sy#2
(byte) loop::y_idx
(byte) loop::y_idx#0
(byte) loop::y_idx#1
(byte) loop::y_idx#2
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(number~) plexInit::$1
(bool~) plexInit::$2
(label) plexInit::@1
(label) plexInit::@3
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#0
(byte) plexInit::i#1
(byte) plexInit::i#2
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*~) plexInit::plexSetScreen1_$0#0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::plexSetScreen1_screen#0
(byte*) plexInit::plexSetScreen1_screen#1
(byte*) plexInit::screen
(byte*) plexInit::screen#0
(byte*) plexInit::screen#1
(void()) plexShowSprite()
(number~) plexShowSprite::$0
(byte~) plexShowSprite::$10
(byte~) plexShowSprite::$11
(byte~) plexShowSprite::$2
(byte~) plexShowSprite::$3
(bool~) plexShowSprite::$4
(number~) plexShowSprite::$5
(number~) plexShowSprite::$6
(bool~) plexShowSprite::$7
(bool~) plexShowSprite::$8
(number~) plexShowSprite::$9
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@4
(label) plexShowSprite::@6
(label) plexShowSprite::@7
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(number~) plexShowSprite::plexFreeAdd1_$0#0
(number~) plexShowSprite::plexFreeAdd1_$1
(number~) plexShowSprite::plexFreeAdd1_$1#0
(number~) plexShowSprite::plexFreeAdd1_$2
(number~) plexShowSprite::plexFreeAdd1_$2#0
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0
(byte) plexShowSprite::plexFreeAdd1_ypos#1
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0
(byte) plexShowSprite::plex_sprite_idx2#1
(byte) plexShowSprite::plex_sprite_idx2#2
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0
(byte) plexShowSprite::ypos
(byte) plexShowSprite::ypos#0
(void()) plexSort()
(number~) plexSort::$1
(number~) plexSort::$2
(bool~) plexSort::$3
(bool~) plexSort::$4
(number~) plexSort::$5
(bool~) plexSort::$6
(bool~) plexSort::$7
(bool~) plexSort::$8
(bool~) plexSort::$9
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#0
(byte) plexSort::m#1
(byte) plexSort::m#2
(byte) plexSort::m#3
(byte) plexSort::m#4
(byte) plexSort::m#5
(byte) plexSort::m#6
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0
(byte) plexSort::nxt_idx#1
(byte) plexSort::nxt_idx#2
(byte) plexSort::nxt_idx#3
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0
(byte) plexSort::nxt_y#1
(byte) plexSort::nxt_y#2
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(bool~) plexSort::plexFreePrepare1_$0#0
(label) plexSort::plexFreePrepare1_@1
(label) plexSort::plexFreePrepare1_@2
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#0
(byte) plexSort::plexFreePrepare1_s#1
(byte) plexSort::plexFreePrepare1_s#2
(byte) plexSort::s
(byte) plexSort::s#0
(byte) plexSort::s#1
(byte) plexSort::s#2
(byte) plexSort::s#3
(byte) plexSort::s#4
(byte) plex_free_next
(byte) plex_free_next#0
(byte) plex_free_next#1
(byte) plex_free_next#10
(byte) plex_free_next#11
(byte) plex_free_next#12
(byte) plex_free_next#13
(byte) plex_free_next#14
(byte) plex_free_next#15
(byte) plex_free_next#16
(byte) plex_free_next#17
(byte) plex_free_next#18
(byte) plex_free_next#19
(byte) plex_free_next#2
(byte) plex_free_next#20
(byte) plex_free_next#21
(byte) plex_free_next#22
(byte) plex_free_next#23
(byte) plex_free_next#24
(byte) plex_free_next#25
(byte) plex_free_next#26
(byte) plex_free_next#27
(byte) plex_free_next#28
(byte) plex_free_next#29
(byte) plex_free_next#3
(byte) plex_free_next#30
(byte) plex_free_next#31
(byte) plex_free_next#32
(byte) plex_free_next#33
(byte) plex_free_next#34
(byte) plex_free_next#35
(byte) plex_free_next#36
(byte) plex_free_next#37
(byte) plex_free_next#38
(byte) plex_free_next#39
(byte) plex_free_next#4
(byte) plex_free_next#40
(byte) plex_free_next#41
(byte) plex_free_next#42
(byte) plex_free_next#43
(byte) plex_free_next#44
(byte) plex_free_next#5
(byte) plex_free_next#6
(byte) plex_free_next#7
(byte) plex_free_next#8
(byte) plex_free_next#9
(byte) plex_show_idx
(byte) plex_show_idx#0
(byte) plex_show_idx#1
(byte) plex_show_idx#10
(byte) plex_show_idx#11
(byte) plex_show_idx#12
(byte) plex_show_idx#13
(byte) plex_show_idx#14
(byte) plex_show_idx#15
(byte) plex_show_idx#16
(byte) plex_show_idx#17
(byte) plex_show_idx#18
(byte) plex_show_idx#19
(byte) plex_show_idx#2
(byte) plex_show_idx#20
(byte) plex_show_idx#21
(byte) plex_show_idx#22
(byte) plex_show_idx#23
(byte) plex_show_idx#24
(byte) plex_show_idx#25
(byte) plex_show_idx#26
(byte) plex_show_idx#27
(byte) plex_show_idx#28
(byte) plex_show_idx#29
(byte) plex_show_idx#3
(byte) plex_show_idx#30
(byte) plex_show_idx#31
(byte) plex_show_idx#32
(byte) plex_show_idx#33
(byte) plex_show_idx#34
(byte) plex_show_idx#35
(byte) plex_show_idx#36
(byte) plex_show_idx#37
(byte) plex_show_idx#38
(byte) plex_show_idx#39
(byte) plex_show_idx#4
(byte) plex_show_idx#40
(byte) plex_show_idx#41
(byte) plex_show_idx#42
(byte) plex_show_idx#43
(byte) plex_show_idx#44
(byte) plex_show_idx#45
(byte) plex_show_idx#46
(byte) plex_show_idx#47
(byte) plex_show_idx#48
(byte) plex_show_idx#5
(byte) plex_show_idx#6
(byte) plex_show_idx#7
(byte) plex_show_idx#8
(byte) plex_show_idx#9
(byte) plex_sprite_idx
(byte) plex_sprite_idx#0
(byte) plex_sprite_idx#1
(byte) plex_sprite_idx#10
(byte) plex_sprite_idx#11
(byte) plex_sprite_idx#12
(byte) plex_sprite_idx#13
(byte) plex_sprite_idx#14
(byte) plex_sprite_idx#15
(byte) plex_sprite_idx#16
(byte) plex_sprite_idx#17
(byte) plex_sprite_idx#18
(byte) plex_sprite_idx#19
(byte) plex_sprite_idx#2
(byte) plex_sprite_idx#20
(byte) plex_sprite_idx#21
(byte) plex_sprite_idx#22
(byte) plex_sprite_idx#23
(byte) plex_sprite_idx#24
(byte) plex_sprite_idx#25
(byte) plex_sprite_idx#26
(byte) plex_sprite_idx#27
(byte) plex_sprite_idx#28
(byte) plex_sprite_idx#29
(byte) plex_sprite_idx#3
(byte) plex_sprite_idx#30
(byte) plex_sprite_idx#31
(byte) plex_sprite_idx#32
(byte) plex_sprite_idx#33
(byte) plex_sprite_idx#34
(byte) plex_sprite_idx#35
(byte) plex_sprite_idx#36
(byte) plex_sprite_idx#37
(byte) plex_sprite_idx#38
(byte) plex_sprite_idx#39
(byte) plex_sprite_idx#4
(byte) plex_sprite_idx#40
(byte) plex_sprite_idx#41
(byte) plex_sprite_idx#42
(byte) plex_sprite_idx#43
(byte) plex_sprite_idx#44
(byte) plex_sprite_idx#45
(byte) plex_sprite_idx#46
(byte) plex_sprite_idx#47
(byte) plex_sprite_idx#48
(byte) plex_sprite_idx#5
(byte) plex_sprite_idx#6
(byte) plex_sprite_idx#7
(byte) plex_sprite_idx#8
(byte) plex_sprite_idx#9
(byte) plex_sprite_msb
(byte) plex_sprite_msb#0
(byte) plex_sprite_msb#1
(byte) plex_sprite_msb#10
(byte) plex_sprite_msb#11
(byte) plex_sprite_msb#12
(byte) plex_sprite_msb#13
(byte) plex_sprite_msb#14
(byte) plex_sprite_msb#15
(byte) plex_sprite_msb#16
(byte) plex_sprite_msb#17
(byte) plex_sprite_msb#18
(byte) plex_sprite_msb#19
(byte) plex_sprite_msb#2
(byte) plex_sprite_msb#20
(byte) plex_sprite_msb#21
(byte) plex_sprite_msb#22
(byte) plex_sprite_msb#23
(byte) plex_sprite_msb#24
(byte) plex_sprite_msb#25
(byte) plex_sprite_msb#26
(byte) plex_sprite_msb#27
(byte) plex_sprite_msb#28
(byte) plex_sprite_msb#29
(byte) plex_sprite_msb#3
(byte) plex_sprite_msb#30
(byte) plex_sprite_msb#31
(byte) plex_sprite_msb#32
(byte) plex_sprite_msb#33
(byte) plex_sprite_msb#34
(byte) plex_sprite_msb#35
(byte) plex_sprite_msb#36
(byte) plex_sprite_msb#37
(byte) plex_sprite_msb#38
(byte) plex_sprite_msb#39
(byte) plex_sprite_msb#4
(byte) plex_sprite_msb#40
(byte) plex_sprite_msb#41
(byte) plex_sprite_msb#42
(byte) plex_sprite_msb#43
(byte) plex_sprite_msb#44
(byte) plex_sprite_msb#45
(byte) plex_sprite_msb#46
(byte) plex_sprite_msb#47
(byte) plex_sprite_msb#48
(byte) plex_sprite_msb#5
(byte) plex_sprite_msb#6
(byte) plex_sprite_msb#7
(byte) plex_sprite_msb#8
(byte) plex_sprite_msb#9

Adding number conversion cast (unumber) $80 in (byte) VIC_RST8#0 ← (number) $80
Adding number conversion cast (unumber) $10 in (byte) VIC_DEN#0 ← (number) $10
Adding number conversion cast (unumber) 8 in (byte) VIC_RSEL#0 ← (number) 8
Adding number conversion cast (unumber) 0 in (byte) BLACK#0 ← (number) 0
Adding number conversion cast (unumber) 5 in (byte) GREEN#0 ← (number) 5
Adding number conversion cast (unumber) $20 in (byte) PLEX_COUNT#0 ← (number) $20
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#0 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#0 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#0 ← (number) 1
Adding number conversion cast (unumber) $3f8 in (byte*~) plexInit::plexSetScreen1_$0#0 ← (byte*) plexInit::plexSetScreen1_screen#1 + (number) $3f8
Adding number conversion cast (unumber) 1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) plexInit::$1 in (number~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 2 in (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (number) 2
Adding number conversion cast (unumber) plexSort::$1 in (number~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (unumber)(number) 2
Adding number conversion cast (unumber) 1 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (number) 1
Adding number conversion cast (unumber) plexSort::$2 in (number~) plexSort::$2 ← (byte) plexSort::m#2 + (unumber)(number) 1
Adding number conversion cast (unumber) 1 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (number) 1
Adding number conversion cast (unumber) plexSort::$5 in (number~) plexSort::$5 ← (byte) plexSort::s#3 + (unumber)(number) 1
Adding number conversion cast (unumber) $ff in (bool~) plexSort::$6 ← (byte) plexSort::s#1 != (number) $ff
Adding number conversion cast (unumber) 0 in (byte) plex_show_idx#1 ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_sprite_idx#1 ← (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#1 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (number) 0
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#0 ← (number) 0
Adding number conversion cast (unumber) 2 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (number) 2
Adding number conversion cast (unumber) plexShowSprite::$0 in (number~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (unumber)(number) 2
Adding number conversion cast (unumber) $15 in (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (number) $15
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$0#0 in (number~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (unumber)(number) $15
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$1#0 in (number~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (unumber~) plexShowSprite::plexFreeAdd1_$1#0 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::plexFreeAdd1_$2#0 in (number~) plexShowSprite::plexFreeAdd1_$2#0 ← (unumber~) plexShowSprite::plexFreeAdd1_$1#0 & (unumber)(number) 7
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$4 ← (byte~) plexShowSprite::$3 != (number) 0
Adding number conversion cast (unumber) $ff in (number~) plexShowSprite::$9 ← (number) $ff ^ (byte) plex_sprite_msb#14
Adding number conversion cast (unumber) plexShowSprite::$9 in (number~) plexShowSprite::$9 ← (unumber)(number) $ff ^ (byte) plex_sprite_msb#14
Adding number conversion cast (unumber) 1 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (number) 1
Adding number conversion cast (unumber) plexShowSprite::$5 in (number~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (unumber)(number) 1
Adding number conversion cast (unumber) 7 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (number) 7
Adding number conversion cast (unumber) plexShowSprite::$6 in (number~) plexShowSprite::$6 ← (unumber~) plexShowSprite::$5 & (unumber)(number) 7
Adding number conversion cast (unumber) 2 in (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#15 * (number) 2
Adding number conversion cast (unumber) 0 in (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (number) 0
Adding number conversion cast (unumber) 1 in (byte) plex_sprite_msb#4 ← (number) 1
Adding number conversion cast (unumber) 0 in (byte) plex_free_next#4 ← (number) 0
Adding number conversion cast (unumber) 3 in (number~) init::$1 ← (byte~) init::$0 | (number) 3
Adding number conversion cast (unumber) init::$1 in (number~) init::$1 ← (byte~) init::$0 | (unumber)(number) 3
Adding number conversion cast (unumber) $20 in (word) init::xp#0 ← (number) $20
Adding number conversion cast (unumber) 1 in (number~) init::$3 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) init::$3 in (number~) init::$3 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) $40 in (byte*~) init::$4 ← (byte*) SPRITE#0 / (number) $40
Adding number conversion cast (unumber) 9 in (word) init::xp#1 ← (word) init::xp#2 + (number) 9
Adding number conversion cast (unumber) $ff in *((byte*) SPRITES_ENABLE#0) ← (number) $ff
Adding number conversion cast (unumber) 0 in (byte) loop::sin_idx#0 ← (number) 0
Adding number conversion cast (unumber) $ff in (bool~) loop::$0 ← *((byte*) RASTER#0) != (number) $ff
Adding number conversion cast (unumber) 1 in (number~) loop::$2 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) loop::$2 in (number~) loop::$2 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Adding number conversion cast (unumber) 8 in (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (number) 8
Adding number conversion cast (unumber) 1 in (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#3 + (number) 1
Adding number conversion cast (unumber) 0 in (bool~) loop::$7 ← (byte~) loop::$6 != (number) 0
Adding number conversion cast (unumber) 1 in (number~) loop::$8 ← (byte) PLEX_COUNT#0 - (number) 1
Adding number conversion cast (unumber) loop::$8 in (number~) loop::$8 ← (byte) PLEX_COUNT#0 - (unumber)(number) 1
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (byte*) SPRITES_XPOS#0 ← (byte*)(number) $d000
Inlining cast (byte*) SPRITES_YPOS#0 ← (byte*)(number) $d001
Inlining cast (byte*) SPRITES_XMSB#0 ← (byte*)(number) $d010
Inlining cast (byte*) RASTER#0 ← (byte*)(number) $d012
Inlining cast (byte*) SPRITES_ENABLE#0 ← (byte*)(number) $d015
Inlining cast (byte*) BORDERCOL#0 ← (byte*)(number) $d020
Inlining cast (byte*) SPRITES_COLS#0 ← (byte*)(number) $d027
Inlining cast (byte*) D011#0 ← (byte*)(number) $d011
Inlining cast (byte) VIC_RST8#0 ← (unumber)(number) $80
Inlining cast (byte) VIC_DEN#0 ← (unumber)(number) $10
Inlining cast (byte) VIC_RSEL#0 ← (unumber)(number) 8
Inlining cast (byte) BLACK#0 ← (unumber)(number) 0
Inlining cast (byte) GREEN#0 ← (unumber)(number) 5
Inlining cast (byte) PLEX_COUNT#0 ← (unumber)(number) $20
Inlining cast (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number) $400+(number) $3f8
Inlining cast (byte) plex_show_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#0 ← (unumber)(number) 1
Inlining cast (byte) plex_show_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_idx#1 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#1 ← (unumber)(number) 1
Inlining cast *((byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (unumber)(number) 0
Inlining cast (byte) plex_free_next#0 ← (unumber)(number) 0
Inlining cast (byte) plex_sprite_msb#4 ← (unumber)(number) 1
Inlining cast (byte) plex_free_next#4 ← (unumber)(number) 0
Inlining cast (byte*) SCREEN#0 ← (byte*)(number) $400
Inlining cast (byte*) SPRITE#0 ← (byte*)(number) $2000
Inlining cast (word) init::xp#0 ← (unumber)(number) $20
Inlining cast (byte~) init::$5 ← (byte)(byte*~) init::$4
Inlining cast *((byte*) SPRITES_ENABLE#0) ← (unumber)(number) $ff
Inlining cast (byte) loop::sin_idx#0 ← (unumber)(number) 0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (byte*) 53248
Simplifying constant pointer cast (byte*) 53249
Simplifying constant pointer cast (byte*) 53264
Simplifying constant pointer cast (byte*) 53266
Simplifying constant pointer cast (byte*) 53269
Simplifying constant pointer cast (byte*) 53280
Simplifying constant pointer cast (byte*) 53287
Simplifying constant pointer cast (byte*) 53265
Simplifying constant integer cast $80
Simplifying constant integer cast $10
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 5
Simplifying constant integer cast $20
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast $3f8
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Simplifying constant integer cast 1
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast $15
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 7
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 8192
Simplifying constant integer cast 3
Simplifying constant integer cast $20
Simplifying constant integer cast 1
Simplifying constant integer cast $40
Simplifying constant integer cast 9
Simplifying constant integer cast $ff
Simplifying constant integer cast 0
Simplifying constant integer cast $ff
Simplifying constant integer cast 1
Simplifying constant integer cast 8
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) $10
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 5
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3f8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) $15
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 7
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $20
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) $40
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) $ff
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) plexInit::$1 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$1 ← (byte) PLEX_COUNT#0 - (byte) 2
Inferred type updated to byte in (unumber~) plexSort::$2 ← (byte) plexSort::m#2 + (byte) 1
Inferred type updated to byte in (unumber~) plexSort::$5 ← (byte) plexSort::s#3 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$0 ← (byte) plex_sprite_idx#12 * (byte) 2
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#1 + (byte) $15
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#12 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::plexFreeAdd1_$2#0 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7
Inferred type updated to byte in (unumber~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#14
Inferred type updated to byte in (unumber~) plexShowSprite::$5 ← (byte) plex_sprite_idx#14 + (byte) 1
Inferred type updated to byte in (unumber~) plexShowSprite::$6 ← (byte~) plexShowSprite::$5 & (byte) 7
Inferred type updated to byte in (unumber~) init::$1 ← (byte~) init::$0 | (byte) 3
Inferred type updated to byte in (unumber~) init::$3 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) loop::$2 ← (byte) PLEX_COUNT#0 - (byte) 1
Inferred type updated to byte in (unumber~) loop::$8 ← (byte) PLEX_COUNT#0 - (byte) 1
Inversing boolean not [45] (bool~) plexSort::$4 ← (byte) plexSort::nxt_y#0 >= *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2)) from [44] (bool~) plexSort::$3 ← (byte) plexSort::nxt_y#0 < *((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))
Inversing boolean not [116] (bool~) plexShowSprite::$8 ← (byte) plex_sprite_msb#3 != (byte) 0 from [115] (bool~) plexShowSprite::$7 ← (byte) plex_sprite_msb#3 == (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (byte*) plexInit::plexSetScreen1_screen#0 = (byte*) plexInit::screen#1 (byte*) plexInit::plexSetScreen1_screen#1 
Alias (byte*) PLEX_SCREEN_PTR#1 = (byte*~) plexInit::plexSetScreen1_$0#0 (byte*) PLEX_SCREEN_PTR#22 
Alias (byte*) PLEX_SCREEN_PTR#15 = (byte*) PLEX_SCREEN_PTR#8 (byte*) PLEX_SCREEN_PTR#2 
Alias (byte) plexSort::m#2 = (byte) plexSort::m#4 (byte) plexSort::s#0 
Alias (byte) plexSort::nxt_y#0 = (byte) plexSort::nxt_y#2 
Alias (byte) plexSort::nxt_idx#0 = (byte) plexSort::nxt_idx#3 
Alias (byte) plexSort::s#1 = (byte) plexSort::s#4 
Alias (byte) plexSort::nxt_idx#1 = (byte) plexSort::nxt_idx#2 
Alias (byte) plexSort::m#5 = (byte) plexSort::m#6 
Alias (byte) plex_show_idx#1 = (byte) plex_show_idx#39 
Alias (byte) plex_sprite_idx#1 = (byte) plex_sprite_idx#39 
Alias (byte) plex_sprite_msb#1 = (byte) plex_sprite_msb#38 
Alias (byte) plex_show_idx#11 = (byte) plex_show_idx#22 (byte) plex_show_idx#32 (byte) plex_show_idx#2 
Alias (byte) plex_sprite_idx#11 = (byte) plex_sprite_idx#22 (byte) plex_sprite_idx#32 (byte) plex_sprite_idx#2 
Alias (byte) plex_sprite_msb#12 = (byte) plex_sprite_msb#23 (byte) plex_sprite_msb#30 (byte) plex_sprite_msb#2 
Alias (byte) plex_free_next#0 = (byte) plex_free_next#11 (byte) plex_free_next#1 
Alias (byte) plexShowSprite::plex_sprite_idx2#0 = (byte~) plexShowSprite::$0 (byte) plexShowSprite::plex_sprite_idx2#2 (byte) plexShowSprite::plex_sprite_idx2#1 
Alias (byte) plexShowSprite::plexFreeAdd1_ypos#0 = (byte) plexShowSprite::ypos#0 (byte) plexShowSprite::plexFreeAdd1_ypos#1 
Alias (byte) plex_free_next#12 = (byte) plex_free_next#21 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#24 (byte) plex_show_idx#13 (byte) plex_show_idx#25 (byte) plex_show_idx#26 
Alias (byte*) PLEX_SCREEN_PTR#16 = (byte*) PLEX_SCREEN_PTR#23 (byte*) PLEX_SCREEN_PTR#9 
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#24 (byte) plex_sprite_idx#13 (byte) plex_sprite_idx#25 (byte) plex_sprite_idx#26 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#31 (byte) plex_sprite_msb#39 (byte) plex_sprite_msb#24 (byte) plex_sprite_msb#14 
Alias (byte) plex_free_next#2 = (byte~) plexShowSprite::plexFreeAdd1_$2#0 (byte) plex_free_next#39 (byte) plex_free_next#30 (byte) plex_free_next#31 
Alias (byte) plex_sprite_idx#27 = (byte) plex_sprite_idx#3 (byte~) plexShowSprite::$6 
Alias (byte) plex_free_next#22 = (byte) plex_free_next#23 
Alias (byte) plex_show_idx#27 = (byte) plex_show_idx#3 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#3 
Alias (byte) plex_sprite_idx#15 = (byte) plex_sprite_idx#4 
Alias (byte) plex_show_idx#15 = (byte) plex_show_idx#4 
Alias (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#5 
Alias (byte*) PLEX_SCREEN_PTR#0 = (byte*) PLEX_SCREEN_PTR#27 (byte*) PLEX_SCREEN_PTR#25 (byte*) PLEX_SCREEN_PTR#21 
Alias (byte) plex_show_idx#0 = (byte) plex_show_idx#40 (byte) plex_show_idx#38 (byte) plex_show_idx#31 
Alias (byte) plex_sprite_idx#0 = (byte) plex_sprite_idx#40 (byte) plex_sprite_idx#38 (byte) plex_sprite_idx#31 
Alias (byte) plex_sprite_msb#0 = (byte) plex_sprite_msb#40 (byte) plex_sprite_msb#37 (byte) plex_sprite_msb#29 
Alias (byte) plex_free_next#29 = (byte) plex_free_next#38 (byte) plex_free_next#4 
Alias (byte) plex_show_idx#28 = (byte) plex_show_idx#33 
Alias (byte) plex_sprite_idx#28 = (byte) plex_sprite_idx#33 
Alias (byte) plex_sprite_msb#25 = (byte) plex_sprite_msb#32 
Alias (byte) plex_free_next#24 = (byte) plex_free_next#32 
Alias (byte*) PLEX_SCREEN_PTR#10 = (byte*) PLEX_SCREEN_PTR#3 (byte*) PLEX_SCREEN_PTR#18 (byte*) PLEX_SCREEN_PTR#11 (byte*) PLEX_SCREEN_PTR#4 
Alias (byte) plex_show_idx#16 = (byte) plex_show_idx#5 (byte) plex_show_idx#17 (byte) plex_show_idx#6 
Alias (byte) plex_sprite_idx#16 = (byte) plex_sprite_idx#5 (byte) plex_sprite_idx#17 (byte) plex_sprite_idx#6 
Alias (byte) plex_sprite_msb#17 = (byte) plex_sprite_msb#6 (byte) plex_sprite_msb#18 (byte) plex_sprite_msb#7 
Alias (byte) plex_free_next#14 = (byte) plex_free_next#5 (byte) plex_free_next#15 (byte) plex_free_next#6 
Alias (byte*) PLEX_SCREEN_PTR#12 = (byte*) PLEX_SCREEN_PTR#5 
Alias (byte*) PLEX_SCREEN_PTR#24 = (byte*) PLEX_SCREEN_PTR#28 
Alias (byte*) PLEX_SCREEN_PTR#13 = (byte*) PLEX_SCREEN_PTR#20 (byte*) PLEX_SCREEN_PTR#6 
Alias (byte) loop::sin_idx#2 = (byte) loop::sin_idx#4 (byte) loop::y_idx#0 
Alias (byte) plex_show_idx#41 = (byte) plex_show_idx#43 
Alias (byte) plex_sprite_idx#41 = (byte) plex_sprite_idx#43 
Alias (byte) plex_sprite_msb#41 = (byte) plex_sprite_msb#43 
Alias (byte) plex_free_next#40 = (byte) plex_free_next#43 
Alias (byte*) PLEX_SCREEN_PTR#40 = (byte*) PLEX_SCREEN_PTR#41 
Alias (byte) loop::sin_idx#3 = (byte) loop::sin_idx#5 
Alias (byte) plex_show_idx#29 = (byte) plex_show_idx#36 
Alias (byte) plex_sprite_idx#29 = (byte) plex_sprite_idx#36 
Alias (byte) plex_sprite_msb#26 = (byte) plex_sprite_msb#35 
Alias (byte) plex_free_next#25 = (byte) plex_free_next#35 
Alias (byte*) PLEX_SCREEN_PTR#37 = (byte*) PLEX_SCREEN_PTR#38 (byte*) PLEX_SCREEN_PTR#39 
Alias (byte) loop::sin_idx#1 = (byte) loop::sin_idx#17 
Alias (byte) plex_show_idx#18 = (byte) plex_show_idx#7 
Alias (byte) plex_sprite_idx#18 = (byte) plex_sprite_idx#7 
Alias (byte) plex_sprite_msb#19 = (byte) plex_sprite_msb#8 
Alias (byte) plex_free_next#16 = (byte) plex_free_next#7 
Alias (byte) plex_free_next#36 = (byte) plex_free_next#41 
Alias (byte) plex_sprite_idx#47 = (byte) plex_sprite_idx#48 
Alias (byte) plex_show_idx#47 = (byte) plex_show_idx#48 
Alias (byte) plex_sprite_msb#47 = (byte) plex_sprite_msb#48 
Alias (byte*) PLEX_SCREEN_PTR#34 = (byte*) PLEX_SCREEN_PTR#36 
Alias (byte) loop::sin_idx#15 = (byte) loop::sin_idx#16 
Alias (byte) plex_free_next#17 = (byte) plex_free_next#26 (byte) plex_free_next#44 (byte) plex_free_next#42 
Alias (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#45 (byte) plex_sprite_idx#46 (byte) plex_sprite_idx#44 
Alias (byte) plex_show_idx#42 = (byte) plex_show_idx#45 (byte) plex_show_idx#46 (byte) plex_show_idx#44 
Alias (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#45 (byte) plex_sprite_msb#46 (byte) plex_sprite_msb#44 
Alias (byte) loop::ss#5 = (byte) loop::ss#7 (byte) loop::ss#8 (byte) loop::ss#6 
Alias (byte*) PLEX_SCREEN_PTR#30 = (byte*) PLEX_SCREEN_PTR#32 (byte*) PLEX_SCREEN_PTR#33 (byte*) PLEX_SCREEN_PTR#31 
Alias (byte) loop::sin_idx#11 = (byte) loop::sin_idx#13 (byte) loop::sin_idx#14 (byte) loop::sin_idx#12 
Alias (byte) loop::plexFreeNextYpos1_return#0 = (byte) loop::plexFreeNextYpos1_return#2 (byte) loop::plexFreeNextYpos1_return#1 (byte) loop::plexFreeNextYpos1_return#3 (byte~) loop::$9 (byte) loop::rasterY#0 
Alias (byte) plex_sprite_idx#23 = (byte) plex_sprite_idx#37 
Alias (byte) plex_show_idx#23 = (byte) plex_show_idx#37 
Alias (byte) plex_free_next#27 = (byte) plex_free_next#37 
Alias (byte) plex_sprite_msb#27 = (byte) plex_sprite_msb#36 
Alias (byte) loop::ss#2 = (byte) loop::ss#3 (byte) loop::ss#4 
Alias (byte*) PLEX_SCREEN_PTR#26 = (byte*) PLEX_SCREEN_PTR#29 (byte*) PLEX_SCREEN_PTR#35 (byte*) PLEX_SCREEN_PTR#44 
Alias (byte) loop::sin_idx#10 = (byte) loop::sin_idx#9 (byte) loop::sin_idx#8 (byte) loop::sin_idx#7 
Alias (byte) plex_free_next#18 = (byte) plex_free_next#8 (byte) plex_free_next#34 
Alias (byte) plex_sprite_idx#19 = (byte) plex_sprite_idx#8 (byte) plex_sprite_idx#35 
Alias (byte) plex_show_idx#19 = (byte) plex_show_idx#8 (byte) plex_show_idx#35 
Alias (byte) plex_sprite_msb#20 = (byte) plex_sprite_msb#9 (byte) plex_sprite_msb#34 
Alias (byte) plex_show_idx#20 = (byte) plex_show_idx#30 (byte) plex_show_idx#9 
Alias (byte) plex_sprite_idx#20 = (byte) plex_sprite_idx#30 (byte) plex_sprite_idx#9 
Alias (byte) plex_sprite_msb#10 = (byte) plex_sprite_msb#21 (byte) plex_sprite_msb#28 
Alias (byte) plex_free_next#19 = (byte) plex_free_next#28 (byte) plex_free_next#9 
Alias (byte*) PLEX_SCREEN_PTR#14 = (byte*) PLEX_SCREEN_PTR#7 
Alias (byte) plex_show_idx#10 = (byte) plex_show_idx#21 
Alias (byte) plex_sprite_idx#10 = (byte) plex_sprite_idx#21 
Alias (byte) plex_sprite_msb#11 = (byte) plex_sprite_msb#22 
Alias (byte) plex_free_next#10 = (byte) plex_free_next#20 
Successful SSA optimization Pass2AliasElimination
Alias (byte) plex_sprite_idx#12 = (byte) plex_sprite_idx#14 
Alias (byte) plex_show_idx#12 = (byte) plex_show_idx#14 
Alias (byte) plex_sprite_msb#13 = (byte) plex_sprite_msb#15 
Alias (byte) plex_free_next#13 = (byte) plex_free_next#22 (byte) plex_free_next#2 
Alias (byte) plex_sprite_idx#15 = (byte) plex_sprite_idx#27 
Alias (byte) plex_show_idx#15 = (byte) plex_show_idx#27 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) plexInit::plexSetScreen1_screen#0 (byte*) plexInit::screen#0
Identical Phi Values (byte*) PLEX_SCREEN_PTR#15 (byte*) PLEX_SCREEN_PTR#1
Identical Phi Values (byte) plexSort::nxt_y#1 (byte) plexSort::nxt_y#0
Identical Phi Values (byte) plexSort::nxt_idx#1 (byte) plexSort::nxt_idx#0
Identical Phi Values (byte) plexSort::m#5 (byte) plexSort::m#2
Identical Phi Values (byte) plex_show_idx#11 (byte) plex_show_idx#1
Identical Phi Values (byte) plex_sprite_idx#11 (byte) plex_sprite_idx#1
Identical Phi Values (byte) plex_sprite_msb#12 (byte) plex_sprite_msb#1
Identical Phi Values (byte) plex_sprite_idx#12 (byte) plex_sprite_idx#23
Identical Phi Values (byte) plex_show_idx#12 (byte) plex_show_idx#23
Identical Phi Values (byte) plex_free_next#12 (byte) plex_free_next#27
Identical Phi Values (byte*) PLEX_SCREEN_PTR#16 (byte*) PLEX_SCREEN_PTR#26
Identical Phi Values (byte) plex_sprite_msb#13 (byte) plex_sprite_msb#27
Identical Phi Values (byte*) PLEX_SCREEN_PTR#17 (byte*) PLEX_SCREEN_PTR#0
Identical Phi Values (byte) plex_show_idx#28 (byte) plex_show_idx#0
Identical Phi Values (byte) plex_sprite_idx#28 (byte) plex_sprite_idx#0
Identical Phi Values (byte) plex_sprite_msb#25 (byte) plex_sprite_msb#0
Identical Phi Values (byte) plex_free_next#24 (byte) plex_free_next#29
Identical Phi Values (byte*) PLEX_SCREEN_PTR#10 (byte*) PLEX_SCREEN_PTR#13
Identical Phi Values (byte) plex_show_idx#16 (byte) plex_show_idx#20
Identical Phi Values (byte) plex_sprite_idx#16 (byte) plex_sprite_idx#20
Identical Phi Values (byte) plex_sprite_msb#17 (byte) plex_sprite_msb#10
Identical Phi Values (byte) plex_free_next#14 (byte) plex_free_next#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#19 (byte*) PLEX_SCREEN_PTR#17
Identical Phi Values (byte*) PLEX_SCREEN_PTR#12 (byte*) PLEX_SCREEN_PTR#15
Identical Phi Values (byte*) PLEX_SCREEN_PTR#24 (byte*) PLEX_SCREEN_PTR#12
Identical Phi Values (byte*) PLEX_SCREEN_PTR#13 (byte*) PLEX_SCREEN_PTR#24
Identical Phi Values (byte) plex_show_idx#34 (byte) plex_show_idx#28
Identical Phi Values (byte) plex_sprite_idx#34 (byte) plex_sprite_idx#28
Identical Phi Values (byte) plex_sprite_msb#33 (byte) plex_sprite_msb#25
Identical Phi Values (byte) plex_free_next#33 (byte) plex_free_next#24
Identical Phi Values (byte*) PLEX_SCREEN_PTR#43 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) loop::sin_idx#2 (byte) loop::sin_idx#6
Identical Phi Values (byte) plex_show_idx#41 (byte) plex_show_idx#20
Identical Phi Values (byte) plex_sprite_idx#41 (byte) plex_sprite_idx#20
Identical Phi Values (byte) plex_sprite_msb#41 (byte) plex_sprite_msb#10
Identical Phi Values (byte) plex_free_next#40 (byte) plex_free_next#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#40 (byte*) PLEX_SCREEN_PTR#42
Identical Phi Values (byte) loop::sin_idx#3 (byte) loop::sin_idx#2
Identical Phi Values (byte) plex_show_idx#29 (byte) plex_show_idx#41
Identical Phi Values (byte) plex_sprite_idx#29 (byte) plex_sprite_idx#41
Identical Phi Values (byte) plex_sprite_msb#26 (byte) plex_sprite_msb#41
Identical Phi Values (byte) plex_free_next#25 (byte) plex_free_next#40
Identical Phi Values (byte*) PLEX_SCREEN_PTR#37 (byte*) PLEX_SCREEN_PTR#40
Identical Phi Values (byte) plex_show_idx#18 (byte) plex_show_idx#11
Identical Phi Values (byte) plex_sprite_idx#18 (byte) plex_sprite_idx#11
Identical Phi Values (byte) plex_sprite_msb#19 (byte) plex_sprite_msb#12
Identical Phi Values (byte) plex_free_next#16 (byte) plex_free_next#0
Identical Phi Values (byte) plex_free_next#36 (byte) plex_free_next#16
Identical Phi Values (byte) plex_sprite_idx#47 (byte) plex_sprite_idx#18
Identical Phi Values (byte) plex_show_idx#47 (byte) plex_show_idx#18
Identical Phi Values (byte) plex_sprite_msb#47 (byte) plex_sprite_msb#19
Identical Phi Values (byte*) PLEX_SCREEN_PTR#34 (byte*) PLEX_SCREEN_PTR#37
Identical Phi Values (byte) loop::sin_idx#15 (byte) loop::sin_idx#1
Identical Phi Values (byte) loop::rasterY#1 (byte) loop::plexFreeNextYpos1_return#0
Identical Phi Values (byte) plex_sprite_idx#23 (byte) plex_sprite_idx#42
Identical Phi Values (byte) plex_show_idx#23 (byte) plex_show_idx#42
Identical Phi Values (byte) plex_free_next#27 (byte) plex_free_next#17
Identical Phi Values (byte) plex_sprite_msb#27 (byte) plex_sprite_msb#42
Identical Phi Values (byte) loop::ss#2 (byte) loop::ss#5
Identical Phi Values (byte*) PLEX_SCREEN_PTR#26 (byte*) PLEX_SCREEN_PTR#30
Identical Phi Values (byte) loop::sin_idx#10 (byte) loop::sin_idx#11
Identical Phi Values (byte) plex_free_next#18 (byte) plex_free_next#13
Identical Phi Values (byte) plex_sprite_idx#19 (byte) plex_sprite_idx#15
Identical Phi Values (byte) plex_show_idx#19 (byte) plex_show_idx#15
Identical Phi Values (byte) plex_sprite_msb#20 (byte) plex_sprite_msb#16
Identical Phi Values (byte*) PLEX_SCREEN_PTR#14 (byte*) PLEX_SCREEN_PTR#10
Identical Phi Values (byte) plex_show_idx#10 (byte) plex_show_idx#16
Identical Phi Values (byte) plex_sprite_idx#10 (byte) plex_sprite_idx#16
Identical Phi Values (byte) plex_sprite_msb#11 (byte) plex_sprite_msb#17
Identical Phi Values (byte) plex_free_next#10 (byte) plex_free_next#14
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte) plexSort::m#3 (byte) plexSort::m#2
Identical Phi Values (byte*) PLEX_SCREEN_PTR#30 (byte*) PLEX_SCREEN_PTR#42
Identical Phi Values (byte) loop::sin_idx#11 (byte) loop::sin_idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (byte*) PLEX_SCREEN_PTR#42 (byte*) PLEX_SCREEN_PTR#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [100] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition (bool~) plexInit::$2 [34] if((byte) plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1
Simple Condition (bool~) plexSort::$4 [46] if((byte) plexSort::nxt_y#0>=*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
Simple Condition (bool~) plexSort::$9 [50] if((byte) plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1
Simple Condition (bool~) plexSort::plexFreePrepare1_$0#0 [73] if((byte) plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1
Simple Condition (bool~) plexShowSprite::$4 [103] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
Simple Condition (bool~) plexShowSprite::$8 [117] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@return
Simple Condition (bool~) init::$6 [172] if((byte) init::sx#1!=rangelast(0,init::$3)) goto init::@1
Simple Condition (bool~) init::$7 [180] if((byte) init::ss#1!=rangelast(0,7)) goto init::@3
Simple Condition (bool~) loop::$0 [190] if(*((byte*) RASTER#0)!=(byte) $ff) goto loop::@4
Simple Condition (bool~) loop::$3 [201] if((byte) loop::sy#1!=rangelast(0,loop::$2)) goto loop::@10
Simple Condition (bool~) loop::$7 [215] if((byte~) loop::$6!=(byte) 0) goto loop::@12
Simple Condition (bool~) loop::$10 [230] if(*((byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@19
Simple Condition (bool~) loop::$13 [241] if((byte) loop::ss#1!=rangelast(0,loop::$8)) goto loop::@18
Successful SSA optimization Pass2ConditionalJumpSimplification
Rewriting && if()-condition to two if()s [59] (bool~) plexSort::$8 ← (bool~) plexSort::$6 && (bool~) plexSort::$7
Successful SSA optimization Pass2ConditionalAndOrRewriting
Constant right-side identified [17] (byte*) PLEX_SCREEN_PTR#0 ← (byte*)(number) $400+(number) $3f8
Constant right-side identified [127] (byte[8]) PLEX_FREE_YPOS#0 ← { fill( 8, 0) }
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) SPRITES_XPOS#0 = (byte*) 53248
Constant (const byte*) SPRITES_YPOS#0 = (byte*) 53249
Constant (const byte*) SPRITES_XMSB#0 = (byte*) 53264
Constant (const byte*) RASTER#0 = (byte*) 53266
Constant (const byte*) SPRITES_ENABLE#0 = (byte*) 53269
Constant (const byte*) BORDERCOL#0 = (byte*) 53280
Constant (const byte*) SPRITES_COLS#0 = (byte*) 53287
Constant (const byte*) D011#0 = (byte*) 53265
Constant (const byte) VIC_RST8#0 = $80
Constant (const byte) VIC_DEN#0 = $10
Constant (const byte) VIC_RSEL#0 = 8
Constant (const byte) BLACK#0 = 0
Constant (const byte) GREEN#0 = 5
Constant (const byte) PLEX_COUNT#0 = $20
Constant (const byte*) PLEX_SCREEN_PTR#0 = (byte*)$400+$3f8
Constant (const byte) plex_show_idx#0 = 0
Constant (const byte) plex_sprite_idx#0 = 0
Constant (const byte) plex_sprite_msb#0 = 1
Constant (const byte) plexInit::i#0 = 0
Constant (const byte) plexSort::m#0 = 0
Constant (const byte) plex_show_idx#1 = 0
Constant (const byte) plex_sprite_idx#1 = 0
Constant (const byte) plex_sprite_msb#1 = 1
Constant (const byte) plexSort::plexFreePrepare1_s#0 = 0
Constant (const byte) plex_free_next#0 = 0
Constant (const byte) plex_sprite_msb#4 = 1
Constant (const byte[8]) PLEX_FREE_YPOS#0 = { fill( 8, 0) }
Constant (const byte) plex_free_next#29 = 0
Constant (const byte*) SCREEN#0 = (byte*) 1024
Constant (const byte[$100]) YSIN#0 = kickasm {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
Constant (const byte*) SPRITE#0 = (byte*) 8192
Constant (const word) init::xp#0 = $20
Constant (const byte) init::sx#0 = 0
Constant (const byte) init::ss#0 = 0
Constant (const byte) loop::sin_idx#0 = 0
Constant (const byte) loop::sy#0 = 0
Constant (const byte) loop::ss#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Constant (const byte*) plexInit::screen#0 = SCREEN#0
Successful SSA optimization Pass2ConstantIdentification
Constant value identified { fill( PLEX_COUNT#0, 0) } in [14] (word[PLEX_COUNT#0]) PLEX_XPOS#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [15] (byte[PLEX_COUNT#0]) PLEX_YPOS#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [16] (byte[PLEX_COUNT#0]) PLEX_PTR#0 ← { fill( PLEX_COUNT#0, 0) }
Constant value identified { fill( PLEX_COUNT#0, 0) } in [18] (byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 ← { fill( PLEX_COUNT#0, 0) }
Successful SSA optimization Pass2ConstantValues
if() condition always true - replacing block destination [187] if(true) goto loop::@4
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [71] plexSort::plexFreePrepare1_s#1 ← ++ plexSort::plexFreePrepare1_s#2 to ++
Resolved ranged comparison value [73] if(plexSort::plexFreePrepare1_s#1!=rangelast(0,7)) goto plexSort::plexFreePrepare1_@1 to (number) 8
Resolved ranged next value [178] init::ss#1 ← ++ init::ss#2 to ++
Resolved ranged comparison value [180] if(init::ss#1!=rangelast(0,7)) goto init::@3 to (number) 8
Eliminating unused variable - keeping the phi block (byte) plex_show_idx#20
Eliminating unused variable - keeping the phi block (byte) plex_sprite_idx#20
Eliminating unused variable - keeping the phi block (byte) plex_sprite_msb#10
Eliminating unused variable - keeping the phi block (byte) plex_free_next#19
Eliminating unused constant (const byte*) PLEX_SCREEN_PTR#0
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant (const byte) plex_show_idx#0
Eliminating unused constant (const byte) plex_sprite_idx#0
Eliminating unused constant (const byte) plex_sprite_msb#0
Eliminating unused constant (const byte) plex_free_next#29
Successful SSA optimization PassNEliminateUnusedVars
Removing unused block loop::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Adding number conversion cast (unumber) 8 in if((byte) plexSort::plexFreePrepare1_s#1!=(number) 8) goto plexSort::plexFreePrepare1_@1
Adding number conversion cast (unumber) 8 in if((byte) init::ss#1!=(number) 8) goto init::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 8
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias (byte~) plexShowSprite::$11 = (byte~) plexShowSprite::$10 
Successful SSA optimization Pass2AliasElimination
Simple Condition (bool~) plexSort::$6 [25] if((byte) plexSort::s#1!=(byte) $ff) goto plexSort::@8
Simple Condition (bool~) plexSort::$7 [109] if((byte) plexSort::nxt_y#0<*((byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Negating conditional jump and destination [25] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
Successful SSA optimization Pass2ConditionalJumpSequenceImprovement
Constant right-side identified [4] (byte*) PLEX_SCREEN_PTR#1 ← (const byte*) plexInit::screen#0 + (word) $3f8
Constant right-side identified [5] (byte~) plexInit::$1 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [11] (byte~) plexSort::$1 ← (const byte) PLEX_COUNT#0 - (byte) 2
Constant right-side identified [63] (byte~) init::$0 ← (const byte) VIC_DEN#0 | (const byte) VIC_RSEL#0
Constant right-side identified [67] (byte~) init::$3 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [69] (byte*~) init::$4 ← (const byte*) SPRITE#0 / (byte) $40
Constant right-side identified [86] (byte~) loop::$2 ← (const byte) PLEX_COUNT#0 - (byte) 1
Constant right-side identified [98] (byte~) loop::$8 ← (const byte) PLEX_COUNT#0 - (byte) 1
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const word[PLEX_COUNT#0]) PLEX_XPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_YPOS#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_PTR#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 = { fill( PLEX_COUNT#0, 0) }
Constant (const byte*) PLEX_SCREEN_PTR#1 = plexInit::screen#0+$3f8
Constant (const byte) plexInit::$1 = PLEX_COUNT#0-1
Constant (const byte) plexSort::$1 = PLEX_COUNT#0-2
Constant (const byte) init::$0 = VIC_DEN#0|VIC_RSEL#0
Constant (const byte) init::$3 = PLEX_COUNT#0-1
Constant (const byte*) init::$4 = SPRITE#0/$40
Constant (const byte) loop::$2 = PLEX_COUNT#0-1
Constant (const byte) loop::$8 = PLEX_COUNT#0-1
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)init::$4 in [70] (byte~) init::$5 ← (byte)(const byte*) init::$4
Successful SSA optimization Pass2ConstantValues
Resolved ranged next value [8] plexInit::i#1 ← ++ plexInit::i#2 to ++
Resolved ranged comparison value [9] if(plexInit::i#1!=rangelast(0,plexInit::$1)) goto plexInit::@1 to (const byte) plexInit::$1+(number) 1
Resolved ranged next value [17] plexSort::m#1 ← ++ plexSort::m#2 to ++
Resolved ranged comparison value [18] if(plexSort::m#1!=rangelast(0,plexSort::$1)) goto plexSort::@1 to (const byte) plexSort::$1+(number) 1
Resolved ranged next value [75] init::sx#1 ← ++ init::sx#2 to ++
Resolved ranged comparison value [76] if(init::sx#1!=rangelast(0,init::$3)) goto init::@1 to (const byte) init::$3+(number) 1
Resolved ranged next value [90] loop::sy#1 ← ++ loop::sy#2 to ++
Resolved ranged comparison value [91] if(loop::sy#1!=rangelast(0,loop::$2)) goto loop::@10 to (const byte) loop::$2+(number) 1
Resolved ranged next value [105] loop::ss#1 ← ++ loop::ss#5 to ++
Resolved ranged comparison value [106] if(loop::ss#1!=rangelast(0,loop::$8)) goto loop::@18 to (const byte) loop::$8+(number) 1
Adding number conversion cast (unumber) plexInit::$1+1 in if((byte) plexInit::i#1!=(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) 1 in if((byte) plexInit::i#1!=(unumber)(const byte) plexInit::$1+(number) 1) goto plexInit::@1
Adding number conversion cast (unumber) plexSort::$1+1 in if((byte) plexSort::m#1!=(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) 1 in if((byte) plexSort::m#1!=(unumber)(const byte) plexSort::$1+(number) 1) goto plexSort::@1
Adding number conversion cast (unumber) init::$3+1 in if((byte) init::sx#1!=(const byte) init::$3+(number) 1) goto init::@1
Adding number conversion cast (unumber) 1 in if((byte) init::sx#1!=(unumber)(const byte) init::$3+(number) 1) goto init::@1
Adding number conversion cast (unumber) loop::$2+1 in if((byte) loop::sy#1!=(const byte) loop::$2+(number) 1) goto loop::@10
Adding number conversion cast (unumber) 1 in if((byte) loop::sy#1!=(unumber)(const byte) loop::$2+(number) 1) goto loop::@10
Adding number conversion cast (unumber) loop::$8+1 in if((byte) loop::ss#1!=(const byte) loop::$8+(number) 1) goto loop::@18
Adding number conversion cast (unumber) 1 in if((byte) loop::ss#1!=(unumber)(const byte) loop::$8+(number) 1) goto loop::@18
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const byte) plexInit::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) plexSort::$1+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) init::$3+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) loop::$2+(unumber)(number) 1
Simplifying constant integer cast 1
Simplifying constant integer cast (const byte) loop::$8+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [53] (byte~) init::$1 ← (const byte) init::$0 | (byte) 3
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte) init::$1 = init::$0|3
Constant (const byte) init::$5 = (byte)init::$4
Successful SSA optimization Pass2ConstantIdentification
Rewriting multiplication to use shift [24] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 * (byte) 2
Rewriting multiplication to use shift [33] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 * (const byte) SIZEOF_WORD
Rewriting multiplication to use shift [44] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 * (byte) 2
Rewriting multiplication to use shift [57] (byte~) init::$8 ← (byte) init::sx#2 * (const byte) SIZEOF_WORD
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings (const byte) plexInit::i#0
Inlining constant with var siblings (const byte) plexSort::m#0
Inlining constant with var siblings (const byte) plexSort::plexFreePrepare1_s#0
Inlining constant with var siblings (const word) init::xp#0
Inlining constant with var siblings (const byte) init::sx#0
Inlining constant with var siblings (const byte) init::ss#0
Inlining constant with var siblings (const byte) loop::sin_idx#0
Inlining constant with var siblings (const byte) loop::sy#0
Inlining constant with var siblings (const byte) loop::ss#0
Inlining constant with var siblings (const byte) plex_show_idx#1
Inlining constant with var siblings (const byte) plex_sprite_idx#1
Inlining constant with var siblings (const byte) plex_sprite_msb#1
Inlining constant with var siblings (const byte) plex_free_next#0
Inlining constant with var siblings (const byte) plex_sprite_msb#4
Constant inlined init::xp#0 = (byte) $20
Constant inlined plexInit::$1 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined plexSort::$1 = (const byte) PLEX_COUNT#0-(byte) 2
Constant inlined plexSort::plexFreePrepare1_s#0 = (byte) 0
Constant inlined init::ss#0 = (byte) 0
Constant inlined plexInit::i#0 = (byte) 0
Constant inlined plexSort::m#0 = (byte) 0
Constant inlined init::$3 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined init::$1 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
Constant inlined loop::sin_idx#0 = (byte) 0
Constant inlined init::$0 = (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0
Constant inlined plexInit::screen#0 = (const byte*) SCREEN#0
Constant inlined loop::$2 = (const byte) PLEX_COUNT#0-(byte) 1
Constant inlined plex_sprite_msb#4 = (byte) 1
Constant inlined init::$5 = (byte)(const byte*) SPRITE#0/(byte) $40
Constant inlined plex_show_idx#1 = (byte) 0
Constant inlined plex_sprite_idx#1 = (byte) 0
Constant inlined plex_sprite_msb#1 = (byte) 1
Constant inlined init::$4 = (const byte*) SPRITE#0/(byte) $40
Constant inlined loop::sy#0 = (byte) 0
Constant inlined plex_free_next#0 = (byte) 0
Constant inlined loop::ss#0 = (byte) 0
Constant inlined init::sx#0 = (byte) 0
Constant inlined loop::$8 = (const byte) PLEX_COUNT#0-(byte) 1
Successful SSA optimization Pass2ConstantInlining
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$2)
Consolidated array index constant in assignment *(PLEX_SORTED_IDX#0+1 + plexSort::$5)
Successful SSA optimization Pass2ConstantAdditionElimination
Alias (byte) plexSort::m#2 = (byte~) plexSort::$2 
Alias (byte) plexSort::s#3 = (byte~) plexSort::$5 
Successful SSA optimization Pass2AliasElimination
Eliminating unused constant (const byte) SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting plexInit::@4(between plexInit::@1 and plexInit::@1)
Added new block during phi lifting plexSort::@9(between plexSort::@2 and plexSort::@1)
Added new block during phi lifting plexSort::@10(between plexSort::@8 and plexSort::@3)
Added new block during phi lifting plexSort::@11(between plexSort::plexFreePrepare1_@1 and plexSort::plexFreePrepare1_@1)
Added new block during phi lifting plexShowSprite::@8(between plexShowSprite::@2 and plexShowSprite::@return)
Added new block during phi lifting init::@6(between init::@1 and init::@1)
Added new block during phi lifting init::@7(between init::@3 and init::@3)
Added new block during phi lifting loop::@32(between loop::@10 and loop::@10)
Added new block during phi lifting loop::@33(between loop::@31 and loop::@18)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @4
Adding NOP phi() at start of @9
Adding NOP phi() at start of @15
Adding NOP phi() at start of @16
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of loop
Adding NOP phi() at start of loop::@14
Adding NOP phi() at start of loop::plexFreeNextYpos1_@return
Adding NOP phi() at start of loop::@29
Adding NOP phi() at start of plexShowSprite::@6
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::@6
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexSort::plexFreePrepare1_@2
Adding NOP phi() at start of init::@5
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1
Adding NOP phi() at start of plexInit::@3
CALL GRAPH
Calls in [] to main:5 
Calls in [main] to init:9 loop:11 
Calls in [loop] to plexSort:26 plexShowSprite:38 
Calls in [init] to plexInit:103 

Created 16 initial phi equivalence classes
Not coalescing [18] loop::y_idx#4 ← loop::sin_idx#6
Coalesced [42] loop::sin_idx#18 ← loop::sin_idx#1
Coalesced [43] plex_free_next#45 ← plex_free_next#13
Coalesced [44] plex_sprite_idx#49 ← plex_sprite_idx#15
Coalesced [45] plex_show_idx#49 ← plex_show_idx#15
Coalesced [46] plex_sprite_msb#50 ← plex_sprite_msb#16
Coalesced [47] loop::ss#9 ← loop::ss#1
Coalesced [48] loop::y_idx#3 ← loop::y_idx#1
Coalesced [49] loop::sy#3 ← loop::sy#1
Coalesced [74] plex_sprite_msb#49 ← plex_sprite_msb#3
Not coalescing [81] plexSort::s#6 ← plexSort::m#2
Coalesced [99] plexSort::plexFreePrepare1_s#3 ← plexSort::plexFreePrepare1_s#1
Coalesced [100] plexSort::m#7 ← plexSort::m#1
Coalesced [101] plexSort::s#5 ← plexSort::s#1
Coalesced [118] init::ss#3 ← init::ss#1
Coalesced [119] init::sx#3 ← init::sx#1
Coalesced [120] init::xp#3 ← init::xp#1
Coalesced [129] plexInit::i#3 ← plexInit::i#1
Coalesced down to 15 phi equivalence classes
Culled Empty Block (label) @4
Culled Empty Block (label) @9
Culled Empty Block (label) @16
Culled Empty Block (label) main::@2
Culled Empty Block (label) loop::@14
Culled Empty Block (label) loop::plexFreeNextYpos1_@return
Culled Empty Block (label) loop::@29
Culled Empty Block (label) loop::@33
Culled Empty Block (label) loop::@32
Culled Empty Block (label) plexShowSprite::@6
Culled Empty Block (label) plexSort::@6
Culled Empty Block (label) plexSort::plexFreePrepare1_@2
Culled Empty Block (label) plexSort::@11
Culled Empty Block (label) plexSort::@9
Culled Empty Block (label) plexSort::@10
Culled Empty Block (label) init::@5
Culled Empty Block (label) init::@7
Culled Empty Block (label) init::@6
Culled Empty Block (label) plexInit::@3
Culled Empty Block (label) plexInit::@4
Renumbering block @12 to @1
Renumbering block @15 to @2
Renumbering block plexSort::@8 to plexSort::@6
Renumbering block plexShowSprite::@4 to plexShowSprite::@3
Renumbering block plexShowSprite::@7 to plexShowSprite::@4
Renumbering block plexShowSprite::@8 to plexShowSprite::@5
Renumbering block loop::@4 to loop::@2
Renumbering block loop::@6 to loop::@3
Renumbering block loop::@10 to loop::@4
Renumbering block loop::@11 to loop::@5
Renumbering block loop::@12 to loop::@6
Renumbering block loop::@18 to loop::@7
Renumbering block loop::@19 to loop::@8
Renumbering block loop::@21 to loop::@9
Renumbering block loop::@25 to loop::@10
Renumbering block loop::@30 to loop::@11
Renumbering block loop::@31 to loop::@12
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @end
Adding NOP phi() at start of main::@1
Adding NOP phi() at start of loop
Adding NOP phi() at start of plexShowSprite::@5
Adding NOP phi() at start of plexSort
Adding NOP phi() at start of plexSort::plexFreePrepare1
Adding NOP phi() at start of plexInit
Adding NOP phi() at start of plexInit::plexSetScreen1

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)
 }}
  to:@2
@2: scope:[]  from @1
  [2] phi()
  [3] call main 
  to:@end
@end: scope:[]  from @2
  [4] phi()
main: scope:[main]  from @2
  asm { sei  }
  [6] call init 
  to:main::@1
main::@1: scope:[main]  from main
  [7] phi()
  [8] call loop 
  to:main::@return
main::@return: scope:[main]  from main::@1
  [9] return 
  to:@return
loop: scope:[loop]  from main::@1
  [10] phi()
  to:loop::@1
loop::@1: scope:[loop]  from loop loop::@10
  [11] (byte) loop::sin_idx#6 ← phi( loop/(byte) 0 loop::@10/(byte) loop::sin_idx#1 )
  to:loop::@2
loop::@2: scope:[loop]  from loop::@1 loop::@2
  [12] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2
  to:loop::@3
loop::@3: scope:[loop]  from loop::@2
  [13] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [14] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6
  to:loop::@4
loop::@4: scope:[loop]  from loop::@3 loop::@4
  [15] (byte) loop::sy#2 ← phi( loop::@4/(byte) loop::sy#1 loop::@3/(byte) 0 )
  [15] (byte) loop::y_idx#2 ← phi( loop::@4/(byte) loop::y_idx#1 loop::@3/(byte~) loop::y_idx#4 )
  [16] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte[$100]) YSIN#0 + (byte) loop::y_idx#2)
  [17] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8
  [18] (byte) loop::sy#1 ← ++ (byte) loop::sy#2
  [19] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4
  to:loop::@5
loop::@5: scope:[loop]  from loop::@4
  [20] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1
  [21] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [22] call plexSort 
  to:loop::@11
loop::@11: scope:[loop]  from loop::@5
  [23] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  to:loop::@6
loop::@6: scope:[loop]  from loop::@11 loop::@6
  [24] (byte~) loop::$6 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0
  [25] if((byte~) loop::$6!=(byte) 0) goto loop::@6
  to:loop::@7
loop::@7: scope:[loop]  from loop::@12 loop::@6
  [26] (byte) loop::ss#5 ← phi( loop::@6/(byte) 0 loop::@12/(byte) loop::ss#1 )
  [26] (byte) plex_sprite_msb#42 ← phi( loop::@6/(byte) 1 loop::@12/(byte) plex_sprite_msb#16 )
  [26] (byte) plex_show_idx#42 ← phi( loop::@6/(byte) 0 loop::@12/(byte) plex_show_idx#15 )
  [26] (byte) plex_sprite_idx#42 ← phi( loop::@6/(byte) 0 loop::@12/(byte) plex_sprite_idx#15 )
  [26] (byte) plex_free_next#17 ← phi( loop::@6/(byte) 0 loop::@12/(byte) plex_free_next#13 )
  [27] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  to:loop::plexFreeNextYpos1
loop::plexFreeNextYpos1: scope:[loop]  from loop::@7
  [28] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17)
  to:loop::@8
loop::@8: scope:[loop]  from loop::@8 loop::plexFreeNextYpos1
  [29] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8
  to:loop::@9
loop::@9: scope:[loop]  from loop::@8
  [30] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0)
  [31] call plexShowSprite 
  to:loop::@12
loop::@12: scope:[loop]  from loop::@9
  [32] (byte) loop::ss#1 ← ++ (byte) loop::ss#5
  [33] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7
  to:loop::@10
loop::@10: scope:[loop]  from loop::@12
  [34] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0
  to:loop::@1
plexShowSprite: scope:[plexShowSprite]  from loop::@9
  [35] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1
  [36] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42))
  [37] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0
  to:plexShowSprite::plexFreeAdd1
plexShowSprite::plexFreeAdd1: scope:[plexShowSprite]  from plexShowSprite
  [38] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15
  [39] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0
  [40] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1
  [41] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7
  to:plexShowSprite::@4
plexShowSprite::@4: scope:[plexShowSprite]  from plexShowSprite::plexFreeAdd1
  [42] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42))
  [43] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)
  [44] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1
  [45] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  [46] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2
  [47] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11)
  [48] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1
  to:plexShowSprite::@3
plexShowSprite::@3: scope:[plexShowSprite]  from plexShowSprite::@4
  [49] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42
  [50] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9
  to:plexShowSprite::@2
plexShowSprite::@2: scope:[plexShowSprite]  from plexShowSprite::@1 plexShowSprite::@3
  [51] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1
  [52] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7
  [53] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42
  [54] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1
  [55] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5
  to:plexShowSprite::@return
plexShowSprite::@5: scope:[plexShowSprite]  from plexShowSprite::@2
  [56] phi()
  to:plexShowSprite::@return
plexShowSprite::@return: scope:[plexShowSprite]  from plexShowSprite::@2 plexShowSprite::@5
  [57] (byte) plex_sprite_msb#16 ← phi( plexShowSprite::@5/(byte) plex_sprite_msb#3 plexShowSprite::@2/(byte) 1 )
  [58] return 
  to:@return
plexShowSprite::@1: scope:[plexShowSprite]  from plexShowSprite::@4
  [59] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42
  to:plexShowSprite::@2
plexSort: scope:[plexSort]  from loop::@5
  [60] phi()
  to:plexSort::@1
plexSort::@1: scope:[plexSort]  from plexSort plexSort::@2
  [61] (byte) plexSort::m#2 ← phi( plexSort/(byte) 0 plexSort::@2/(byte) plexSort::m#1 )
  [62] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2)
  [63] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0)
  [64] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2
  to:plexSort::@5
plexSort::@5: scope:[plexSort]  from plexSort::@1
  [65] (byte~) plexSort::s#6 ← (byte) plexSort::m#2
  to:plexSort::@3
plexSort::@3: scope:[plexSort]  from plexSort::@5 plexSort::@6
  [66] (byte) plexSort::s#3 ← phi( plexSort::@6/(byte) plexSort::s#1 plexSort::@5/(byte~) plexSort::s#6 )
  [67] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3)
  [68] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3
  [69] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4
  to:plexSort::@6
plexSort::@6: scope:[plexSort]  from plexSort::@3
  [70] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3
  to:plexSort::@4
plexSort::@4: scope:[plexSort]  from plexSort::@3 plexSort::@6
  [71] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1
  [72] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0
  to:plexSort::@2
plexSort::@2: scope:[plexSort]  from plexSort::@1 plexSort::@4
  [73] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2
  [74] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1
  to:plexSort::plexFreePrepare1
plexSort::plexFreePrepare1: scope:[plexSort]  from plexSort::@2
  [75] phi()
  to:plexSort::plexFreePrepare1_@1
plexSort::plexFreePrepare1_@1: scope:[plexSort]  from plexSort::plexFreePrepare1 plexSort::plexFreePrepare1_@1
  [76] (byte) plexSort::plexFreePrepare1_s#2 ← phi( plexSort::plexFreePrepare1/(byte) 0 plexSort::plexFreePrepare1_@1/(byte) plexSort::plexFreePrepare1_s#1 )
  [77] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0
  [78] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2
  [79] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1
  to:plexSort::@return
plexSort::@return: scope:[plexSort]  from plexSort::plexFreePrepare1_@1
  [80] return 
  to:@return
init: scope:[init]  from main
  [81] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3
  [82] call plexInit 
  to:init::@1
init::@1: scope:[init]  from init init::@1
  [83] (word) init::xp#2 ← phi( init::@1/(word) init::xp#1 init/(byte) $20 )
  [83] (byte) init::sx#2 ← phi( init::@1/(byte) init::sx#1 init/(byte) 0 )
  [84] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40
  [85] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1
  [86] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2
  [87] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9
  [88] (byte) init::sx#1 ← ++ (byte) init::sx#2
  [89] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1
  to:init::@2
init::@2: scope:[init]  from init::@1
  [90] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff
  to:init::@3
init::@3: scope:[init]  from init::@2 init::@3
  [91] (byte) init::ss#2 ← phi( init::@2/(byte) 0 init::@3/(byte) init::ss#1 )
  [92] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0
  [93] (byte) init::ss#1 ← ++ (byte) init::ss#2
  [94] if((byte) init::ss#1!=(byte) 8) goto init::@3
  to:init::@return
init::@return: scope:[init]  from init::@3
  [95] return 
  to:@return
plexInit: scope:[plexInit]  from init
  [96] phi()
  to:plexInit::plexSetScreen1
plexInit::plexSetScreen1: scope:[plexInit]  from plexInit
  [97] phi()
  to:plexInit::@1
plexInit::@1: scope:[plexInit]  from plexInit::@1 plexInit::plexSetScreen1
  [98] (byte) plexInit::i#2 ← phi( plexInit::@1/(byte) plexInit::i#1 plexInit::plexSetScreen1/(byte) 0 )
  [99] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2
  [100] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2
  [101] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1
  to:plexInit::@return
plexInit::@return: scope:[plexInit]  from plexInit::@1
  [102] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(byte) BLACK
(byte*) BORDERCOL
(byte*) D011
(byte) GREEN
(byte) PLEX_COUNT
(byte[8]) PLEX_FREE_YPOS
(byte[PLEX_COUNT#0]) PLEX_PTR
(byte*) PLEX_SCREEN_PTR
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(word[PLEX_COUNT#0]) PLEX_XPOS
(byte[PLEX_COUNT#0]) PLEX_YPOS
(byte*) RASTER
(byte*) SCREEN
(byte*) SPRITE
(byte*) SPRITES_COLS
(byte*) SPRITES_ENABLE
(byte*) SPRITES_XMSB
(byte*) SPRITES_XPOS
(byte*) SPRITES_YPOS
(byte) VIC_DEN
(byte) VIC_RSEL
(byte) VIC_RST8
(byte[$100]) YSIN
(void()) init()
(byte~) init::$8 22.0
(byte) init::ss
(byte) init::ss#1 16.5
(byte) init::ss#2 16.5
(byte) init::sx
(byte) init::sx#1 16.5
(byte) init::sx#2 8.8
(word) init::xp
(word) init::xp#1 7.333333333333333
(word) init::xp#2 8.25
(void()) loop()
(byte~) loop::$6 202.0
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0 551.0
(byte) loop::rasterY
(byte) loop::sin_idx
(byte) loop::sin_idx#1 1.4666666666666666
(byte) loop::sin_idx#6 3.666666666666667
(byte) loop::ss
(byte) loop::ss#1 151.5
(byte) loop::ss#5 33.666666666666664
(byte) loop::sy
(byte) loop::sy#1 151.5
(byte) loop::sy#2 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 67.33333333333333
(byte) loop::y_idx#2 157.0
(byte~) loop::y_idx#4 22.0
(void()) main()
(void()) plexInit((byte*) plexInit::screen)
(byte) plexInit::i
(byte) plexInit::i#1 16.5
(byte) plexInit::i#2 22.0
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 2.0
(byte~) plexShowSprite::$2 4.0
(byte~) plexShowSprite::$3 4.0
(byte~) plexShowSprite::$5 4.0
(byte~) plexShowSprite::$9 4.0
(number~) plexShowSprite::plexFreeAdd1_$0
(byte~) plexShowSprite::plexFreeAdd1_$0#0 4.0
(number~) plexShowSprite::plexFreeAdd1_$1
(byte~) plexShowSprite::plexFreeAdd1_$1#0 4.0
(number~) plexShowSprite::plexFreeAdd1_$2
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(byte) plexSort::m
(byte) plexSort::m#1 151.5
(byte) plexSort::m#2 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 150.375
(bool~) plexSort::plexFreePrepare1_$0
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 151.5
(byte) plexSort::plexFreePrepare1_s#2 151.5
(byte) plexSort::s
(byte) plexSort::s#1 1368.3333333333335
(byte) plexSort::s#2 202.0
(byte) plexSort::s#3 2052.5
(byte~) plexSort::s#6 202.0
(byte) plex_free_next
(byte) plex_free_next#13 4.681818181818182
(byte) plex_free_next#17 20.599999999999998
(byte) plex_show_idx
(byte) plex_show_idx#15 11.444444444444443
(byte) plex_show_idx#42 4.541666666666665
(byte) plex_sprite_idx
(byte) plex_sprite_idx#15 10.299999999999999
(byte) plex_sprite_idx#42 4.863636363636363
(byte) plex_sprite_msb
(byte) plex_sprite_msb#16 20.599999999999998
(byte) plex_sprite_msb#3 2.0
(byte) plex_sprite_msb#42 4.28

Initial phi equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plex_free_next#17 plex_free_next#13 ]
[ plex_sprite_idx#42 plex_sprite_idx#15 ]
[ plex_show_idx#42 plex_show_idx#15 ]
[ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
[ loop::ss#5 loop::ss#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
Added variable loop::$6 to zero page equivalence class [ loop::$6 ]
Added variable loop::plexFreeNextYpos1_return#0 to zero page equivalence class [ loop::plexFreeNextYpos1_return#0 ]
Added variable plexShowSprite::plex_sprite_idx2#0 to zero page equivalence class [ plexShowSprite::plex_sprite_idx2#0 ]
Added variable plexShowSprite::plexFreeAdd1_ypos#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Added variable plexShowSprite::plexFreeAdd1_$0#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$0#0 ]
Added variable plexShowSprite::plexFreeAdd1_$1#0 to zero page equivalence class [ plexShowSprite::plexFreeAdd1_$1#0 ]
Added variable plexShowSprite::xpos_idx#0 to zero page equivalence class [ plexShowSprite::xpos_idx#0 ]
Added variable plexShowSprite::$11 to zero page equivalence class [ plexShowSprite::$11 ]
Added variable plexShowSprite::$2 to zero page equivalence class [ plexShowSprite::$2 ]
Added variable plexShowSprite::$3 to zero page equivalence class [ plexShowSprite::$3 ]
Added variable plexShowSprite::$9 to zero page equivalence class [ plexShowSprite::$9 ]
Added variable plexShowSprite::$5 to zero page equivalence class [ plexShowSprite::$5 ]
Added variable plexSort::nxt_idx#0 to zero page equivalence class [ plexSort::nxt_idx#0 ]
Added variable plexSort::nxt_y#0 to zero page equivalence class [ plexSort::nxt_y#0 ]
Added variable plexSort::s#2 to zero page equivalence class [ plexSort::s#2 ]
Added variable init::$8 to zero page equivalence class [ init::$8 ]
Complete equivalence classes
[ loop::sin_idx#6 loop::sin_idx#1 ]
[ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
[ loop::sy#2 loop::sy#1 ]
[ plex_free_next#17 plex_free_next#13 ]
[ plex_sprite_idx#42 plex_sprite_idx#15 ]
[ plex_show_idx#42 plex_show_idx#15 ]
[ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
[ loop::ss#5 loop::ss#1 ]
[ plexSort::m#2 plexSort::m#1 ]
[ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
[ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
[ init::sx#2 init::sx#1 ]
[ init::xp#2 init::xp#1 ]
[ init::ss#2 init::ss#1 ]
[ plexInit::i#2 plexInit::i#1 ]
[ loop::$6 ]
[ loop::plexFreeNextYpos1_return#0 ]
[ plexShowSprite::plex_sprite_idx2#0 ]
[ plexShowSprite::plexFreeAdd1_ypos#0 ]
[ plexShowSprite::plexFreeAdd1_$0#0 ]
[ plexShowSprite::plexFreeAdd1_$1#0 ]
[ plexShowSprite::xpos_idx#0 ]
[ plexShowSprite::$11 ]
[ plexShowSprite::$2 ]
[ plexShowSprite::$3 ]
[ plexShowSprite::$9 ]
[ plexShowSprite::$5 ]
[ plexSort::nxt_idx#0 ]
[ plexSort::nxt_y#0 ]
[ plexSort::s#2 ]
[ init::$8 ]
Allocated zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Allocated zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Allocated zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Allocated zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ]
Allocated zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Allocated zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ]
Allocated zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Allocated zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ]
Allocated zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ]
Allocated zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Allocated zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Allocated zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ]
Allocated zp ZP_WORD:14 [ init::xp#2 init::xp#1 ]
Allocated zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ]
Allocated zp ZP_BYTE:17 [ plexInit::i#2 plexInit::i#1 ]
Allocated zp ZP_BYTE:18 [ loop::$6 ]
Allocated zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ]
Allocated zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ]
Allocated zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Allocated zp ZP_BYTE:22 [ plexShowSprite::plexFreeAdd1_$0#0 ]
Allocated zp ZP_BYTE:23 [ plexShowSprite::plexFreeAdd1_$1#0 ]
Allocated zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ]
Allocated zp ZP_BYTE:25 [ plexShowSprite::$11 ]
Allocated zp ZP_BYTE:26 [ plexShowSprite::$2 ]
Allocated zp ZP_BYTE:27 [ plexShowSprite::$3 ]
Allocated zp ZP_BYTE:28 [ plexShowSprite::$9 ]
Allocated zp ZP_BYTE:29 [ plexShowSprite::$5 ]
Allocated zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ]
Allocated zp ZP_BYTE:31 [ plexSort::nxt_y#0 ]
Allocated zp ZP_BYTE:32 [ plexSort::s#2 ]
Allocated zp ZP_BYTE:33 [ init::$8 ]

INITIAL ASM
Target platform is c64basic
  // File Comments
// A simple usage of the flexible sprite multiplexer routine
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // Location of screen & sprites
  .label SCREEN = $400
  .label SPRITE = $2000
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  .label plex_sprite_msb = 8
  .label plex_free_next = 5
  .label plex_sprite_idx = 6
  .label plex_show_idx = 7
  // @begin
bbegin:
  jmp b1
  // @1
b1:
  // kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // [2] phi from @1 to @2 [phi:@1->@2]
b2_from_b1:
  jmp b2
  // @2
b2:
  // [3] call main 
  jsr main
  // [4] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
  // @end
bend:
  // main
main: {
    // asm { sei  }
    sei
    // [6] call init 
    jsr init
    // [7] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
    // main::@1
  b1:
    // [8] call loop 
    // [10] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
    // main::@return
  breturn:
    // [9] return 
    rts
}
  // loop
// The raster loop
loop: {
    .label _6 = $12
    .label y_idx = 3
    .label sy = 4
    .label sin_idx = 2
    .label plexFreeNextYpos1_return = $13
    .label ss = 9
    // [11] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
    // [11] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    jmp b1
    // loop::@1
  b1:
    jmp b2
    // loop::@2
  b2:
    // [12] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
    // loop::@3
  b3:
    // [13] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [14] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuz1=vbuz2 
    lda.z sin_idx
    sta.z y_idx
    // [15] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
    // [15] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sy
    // [15] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
    // [15] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
    // [15] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [15] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
    // loop::@4
  b4:
    // [16] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte[$100]) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz2 
    ldy.z y_idx
    lda YSIN,y
    ldy.z sy
    sta PLEX_YPOS,y
    // [17] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y_idx
    axs #-[8]
    stx.z y_idx
    // [18] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuz1=_inc_vbuz1 
    inc.z sy
    // [19] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z sy
    bne b4_from_b4
    jmp b5
    // loop::@5
  b5:
    // [20] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // [21] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [22] call plexSort 
    // [60] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b11
    // loop::@11
  b11:
    // [23] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp b6
    // loop::@6
  b6:
    // [24] (byte~) loop::$6 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 -- vbuz1=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    sta.z _6
    // [25] if((byte~) loop::$6!=(byte) 0) goto loop::@6 -- vbuz1_neq_0_then_la1 
    lda.z _6
    cmp #0
    bne b6
    // [26] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  b7_from_b6:
    // [26] phi (byte) loop::ss#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z ss
    // [26] phi (byte) plex_sprite_msb#42 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [26] phi (byte) plex_show_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [26] phi (byte) plex_sprite_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [26] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp b7
  // Show the sprites
    // [26] phi from loop::@12 to loop::@7 [phi:loop::@12->loop::@7]
  b7_from_b12:
    // [26] phi (byte) loop::ss#5 = (byte) loop::ss#1 [phi:loop::@12->loop::@7#0] -- register_copy 
    // [26] phi (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#16 [phi:loop::@12->loop::@7#1] -- register_copy 
    // [26] phi (byte) plex_show_idx#42 = (byte) plex_show_idx#15 [phi:loop::@12->loop::@7#2] -- register_copy 
    // [26] phi (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#15 [phi:loop::@12->loop::@7#3] -- register_copy 
    // [26] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@12->loop::@7#4] -- register_copy 
    jmp b7
    // loop::@7
  b7:
    // [27] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp plexFreeNextYpos1
    // loop::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [28] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    jmp b8
    // loop::@8
  b8:
    // [29] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc b8
    jmp b9
    // loop::@9
  b9:
    // [30] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [31] call plexShowSprite 
    jsr plexShowSprite
    jmp b12
    // loop::@12
  b12:
    // [32] (byte) loop::ss#1 ← ++ (byte) loop::ss#5 -- vbuz1=_inc_vbuz1 
    inc.z ss
    // [33] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z ss
    bne b7_from_b12
    jmp b10
    // loop::@10
  b10:
    // [34] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [11] phi from loop::@10 to loop::@1 [phi:loop::@10->loop::@1]
  b1_from_b10:
    // [11] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@10->loop::@1#0] -- register_copy 
    jmp b1
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label _2 = $1a
    .label _3 = $1b
    .label _5 = $1d
    .label _9 = $1c
    .label _11 = $19
    .label plex_sprite_idx2 = $14
    .label plexFreeAdd1_ypos = $15
    .label plexFreeAdd1__0 = $16
    .label plexFreeAdd1__1 = $17
    .label xpos_idx = $18
    // [35] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [36] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- vbuz1=pbuc1_derefidx_(pbuc2_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    ldx PLEX_YPOS,y
    stx.z plexFreeAdd1_ypos
    // [37] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z plexFreeAdd1_ypos
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [38] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuz1=vbuz2_plus_vbuc1 
    lax.z plexFreeAdd1_ypos
    axs #-[$15]
    stx.z plexFreeAdd1__0
    // [39] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z plexFreeAdd1__0
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [40] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z plex_free_next
    iny
    sty.z plexFreeAdd1__1
    // [41] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z plexFreeAdd1__1
    sta.z plex_free_next
    jmp b4
    // plexShowSprite::@4
  b4:
    // [42] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // [43] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    sta.z xpos_idx
    // [44] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z xpos_idx
    asl
    sta.z _11
    // [45] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuz1=_lo_pwuc1_derefidx_vbuz2 
    ldy.z _11
    lda PLEX_XPOS,y
    sta.z _2
    // [46] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z _2
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [47] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuz1=_hi_pwuc1_derefidx_vbuz2 
    ldy.z _11
    lda PLEX_XPOS+1,y
    sta.z _3
    // [48] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuz1_neq_0_then_la1 
    lda.z _3
    cmp #0
    bne b1
    jmp b3
    // plexShowSprite::@3
  b3:
    // [49] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 -- vbuz1=vbuc1_bxor_vbuz2 
    lda #$ff
    eor.z plex_sprite_msb
    sta.z _9
    // [50] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuz1 
    lda SPRITES_XMSB
    and.z _9
    sta SPRITES_XMSB
    jmp b2
    // plexShowSprite::@2
  b2:
    // [51] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1 -- vbuz1=vbuz2_plus_1 
    ldy.z plex_sprite_idx
    iny
    sty.z _5
    // [52] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuz2_band_vbuc1 
    lda #7
    and.z _5
    sta.z plex_sprite_idx
    // [53] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [54] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [55] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne b5_from_b2
    // [57] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  breturn_from_b2:
    // [57] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    jmp breturn
    // [56] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  b5_from_b2:
    jmp b5
    // plexShowSprite::@5
  b5:
    // [57] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  breturn_from_b5:
    // [57] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
    // plexShowSprite::@return
  breturn:
    // [58] return 
    rts
    // plexShowSprite::@1
  b1:
    // [59] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = $1e
    .label nxt_y = $1f
    .label m = $a
    .label s = $b
    .label s_2 = $20
    .label plexFreePrepare1_s = $c
    // [61] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
    // [61] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp b1
    // [61] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
    // [61] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
    // plexSort::@1
  b1:
    // [62] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [63] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [64] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b5
    // plexSort::@5
  b5:
    // [65] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuz1=vbuz2 
    lda.z m
    sta.z s
    // [66] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  b3_from_b5:
  b3_from_b6:
    // [66] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    jmp b3
    // plexSort::@3
  b3:
    // [67] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_vbuz1 
    ldy.z s
    lda PLEX_SORTED_IDX,y
    sta PLEX_SORTED_IDX+1,y
    // [68] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuz1=_dec_vbuz1 
    dec.z s
    // [69] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuz1_eq_vbuc1_then_la1 
    lda #$ff
    cmp.z s
    beq b4
    jmp b6
    // plexSort::@6
  b6:
    // [70] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z s
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b6
    jmp b4
    // plexSort::@4
  b4:
    // [71] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuz1=_inc_vbuz2 
    ldy.z s
    iny
    sty.z s_2
    // [72] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuz1=vbuz2 
    lda.z nxt_idx
    ldy.z s_2
    sta PLEX_SORTED_IDX,y
    jmp b2
    // plexSort::@2
  b2:
    // [73] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [74] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne b1_from_b2
    // [75] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b2:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [76] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
    // [76] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z plexFreePrepare1_s
    jmp plexFreePrepare1_b1
    // [76] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
    // [76] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
    // [77] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #0
    ldy.z plexFreePrepare1_s
    sta PLEX_FREE_YPOS,y
    // [78] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuz1=_inc_vbuz1 
    inc.z plexFreePrepare1_s
    // [79] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z plexFreePrepare1_s
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp breturn
    // plexSort::@return
  breturn:
    // [80] return 
    rts
}
  // init
// Initialize the program
init: {
    .label _8 = $21
    .label xp = $e
    .label sx = $d
    .label ss = $10
    // [81] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [82] call plexInit 
    // [96] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [83] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
    // [83] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [83] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z sx
    jmp b1
    // [83] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
    // [83] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [83] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
    // init::@1
  b1:
    // [84] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #SPRITE/$40
    ldy.z sx
    sta PLEX_PTR,y
    // [85] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z sx
    asl
    sta.z _8
    // [86] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 -- pwuc1_derefidx_vbuz1=vwuz2 
    ldy.z _8
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // [87] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // [88] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuz1=_inc_vbuz1 
    inc.z sx
    // [89] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z sx
    bne b1_from_b1
    jmp b2
    // init::@2
  b2:
    // [90] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [91] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    // [91] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta.z ss
    jmp b3
    // [91] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
    // [91] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
    // init::@3
  b3:
    // [92] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #GREEN
    ldy.z ss
    sta SPRITES_COLS,y
    // [93] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuz1=_inc_vbuz1 
    inc.z ss
    // [94] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #8
    cmp.z ss
    bne b3_from_b3
    jmp breturn
    // init::@return
  breturn:
    // [95] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    .label i = $11
    // [97] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [98] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
    // [98] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z i
    jmp b1
    // [98] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
    // [98] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
    // plexInit::@1
  b1:
    // [99] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuz1=vbuz1 
    ldy.z i
    tya
    sta PLEX_SORTED_IDX,y
    // [100] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuz1=_inc_vbuz1 
    inc.z i
    // [101] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z i
    bne b1_from_b1
    jmp breturn
    // plexInit::@return
  breturn:
    // [102] return 
    rts
}
  // File Data
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $100
YSIN:
.var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [12] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 [ loop::sin_idx#6 ] ( main:3::loop:8 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Statement [16] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte[$100]) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:3::loop:8 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ]
Statement [17] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:3::loop:8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [23] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:3::loop:8 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [24] (byte~) loop::$6 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 [ loop::sin_idx#1 loop::$6 ] ( main:3::loop:8 [ loop::sin_idx#1 loop::$6 ] ) always clobbers reg byte a 
Statement [27] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ( main:3::loop:8 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ]
Statement [34] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:3::loop:8 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [35] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 [ plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [42] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ]
Statement [44] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [45] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:25 [ plexShowSprite::$11 ]
Statement [47] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [49] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [50] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [59] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [67] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:31 [ plexSort::nxt_y#0 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
Statement [70] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [72] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [77] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
Statement [81] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:3::init:6 [ ] ) always clobbers reg byte a 
Statement [84] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:3::init:6 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ]
Statement [85] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$8 ] ( main:3::init:6 [ init::sx#2 init::xp#2 init::$8 ] ) always clobbers reg byte a 
Statement [86] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:3::init:6 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [87] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:3::init:6 [ init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [90] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:3::init:6 [ ] ) always clobbers reg byte a 
Statement [92] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:3::init:6 [ init::ss#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ]
Statement [12] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 [ loop::sin_idx#6 ] ( main:3::loop:8 [ loop::sin_idx#6 ] ) always clobbers reg byte a 
Statement [16] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte[$100]) YSIN#0 + (byte) loop::y_idx#2) [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ( main:3::loop:8 [ loop::sin_idx#6 loop::y_idx#2 loop::sy#2 ] ) always clobbers reg byte a 
Statement [17] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ( main:3::loop:8 [ loop::sin_idx#6 loop::sy#2 loop::y_idx#1 ] ) always clobbers reg byte a 
Statement [23] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:3::loop:8 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [24] (byte~) loop::$6 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 [ loop::sin_idx#1 loop::$6 ] ( main:3::loop:8 [ loop::sin_idx#1 loop::$6 ] ) always clobbers reg byte a 
Statement [27] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ( main:3::loop:8 [ loop::sin_idx#1 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 loop::ss#5 ] ) always clobbers reg byte a 
Statement [34] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 [ loop::sin_idx#1 ] ( main:3::loop:8 [ loop::sin_idx#1 ] ) always clobbers reg byte a 
Statement [35] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 [ plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_free_next#17 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [42] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 ] ) always clobbers reg byte a 
Statement [44] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 ] ) always clobbers reg byte a 
Statement [45] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::plex_sprite_idx2#0 plexShowSprite::$11 plexShowSprite::$2 ] ) always clobbers reg byte a 
Statement [47] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$3 ] ) always clobbers reg byte a 
Statement [49] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 plexShowSprite::$9 ] ) always clobbers reg byte a 
Statement [50] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [59] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 [ plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ( main:3::loop:8::plexShowSprite:31 [ loop::sin_idx#1 loop::ss#5 plex_sprite_idx#42 plex_show_idx#42 plex_sprite_msb#42 plex_free_next#13 ] ) always clobbers reg byte a 
Statement [64] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 ] ) always clobbers reg byte a 
Statement [67] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#3 ] ) always clobbers reg byte a 
Statement [70] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 [ plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 plexSort::nxt_idx#0 plexSort::nxt_y#0 plexSort::s#1 ] ) always clobbers reg byte a 
Statement [72] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 [ plexSort::m#2 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::m#2 ] ) always clobbers reg byte a 
Statement [77] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 [ plexSort::plexFreePrepare1_s#2 ] ( main:3::loop:8::plexSort:22 [ loop::sin_idx#1 plexSort::plexFreePrepare1_s#2 ] ) always clobbers reg byte a 
Statement [81] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 [ ] ( main:3::init:6 [ ] ) always clobbers reg byte a 
Statement [84] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 [ init::sx#2 init::xp#2 ] ( main:3::init:6 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [85] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 [ init::sx#2 init::xp#2 init::$8 ] ( main:3::init:6 [ init::sx#2 init::xp#2 init::$8 ] ) always clobbers reg byte a 
Statement [86] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 [ init::sx#2 init::xp#2 ] ( main:3::init:6 [ init::sx#2 init::xp#2 ] ) always clobbers reg byte a 
Statement [87] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 [ init::sx#2 init::xp#1 ] ( main:3::init:6 [ init::sx#2 init::xp#1 ] ) always clobbers reg byte a 
Statement [90] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff [ ] ( main:3::init:6 [ ] ) always clobbers reg byte a 
Statement [92] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 [ init::ss#2 ] ( main:3::init:6 [ init::ss#2 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] : zp ZP_BYTE:2 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] : zp ZP_BYTE:3 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] : zp ZP_BYTE:4 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] : zp ZP_BYTE:5 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] : zp ZP_BYTE:6 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] : zp ZP_BYTE:7 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] : zp ZP_BYTE:8 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] : zp ZP_BYTE:9 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] : zp ZP_BYTE:10 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] : zp ZP_BYTE:11 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] : zp ZP_BYTE:12 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ] : zp ZP_BYTE:13 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:14 [ init::xp#2 init::xp#1 ] : zp ZP_WORD:14 , 
Potential registers zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ] : zp ZP_BYTE:16 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:17 [ plexInit::i#2 plexInit::i#1 ] : zp ZP_BYTE:17 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:18 [ loop::$6 ] : zp ZP_BYTE:18 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] : zp ZP_BYTE:19 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] : zp ZP_BYTE:20 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ] : zp ZP_BYTE:21 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:22 [ plexShowSprite::plexFreeAdd1_$0#0 ] : zp ZP_BYTE:22 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:23 [ plexShowSprite::plexFreeAdd1_$1#0 ] : zp ZP_BYTE:23 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ] : zp ZP_BYTE:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:25 [ plexShowSprite::$11 ] : zp ZP_BYTE:25 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ plexShowSprite::$2 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ plexShowSprite::$3 ] : zp ZP_BYTE:27 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:28 [ plexShowSprite::$9 ] : zp ZP_BYTE:28 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:29 [ plexShowSprite::$5 ] : zp ZP_BYTE:29 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] : zp ZP_BYTE:30 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] : zp ZP_BYTE:31 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ plexSort::s#2 ] : zp ZP_BYTE:32 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:33 [ init::$8 ] : zp ZP_BYTE:33 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [plexSort] 3,622.83: zp ZP_BYTE:11 [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] 303: zp ZP_BYTE:12 [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] 202: zp ZP_BYTE:32 [ plexSort::s#2 ] 193.58: zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] 150.38: zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] 30.3: zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] 
Uplift Scope [loop] 551: zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] 252.5: zp ZP_BYTE:4 [ loop::sy#2 loop::sy#1 ] 246.33: zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 202: zp ZP_BYTE:18 [ loop::$6 ] 185.17: zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] 5.13: zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Uplift Scope [init] 33: zp ZP_BYTE:16 [ init::ss#2 init::ss#1 ] 25.3: zp ZP_BYTE:13 [ init::sx#2 init::sx#1 ] 22: zp ZP_BYTE:33 [ init::$8 ] 15.58: zp ZP_WORD:14 [ init::xp#2 init::xp#1 ] 
Uplift Scope [] 26.88: zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] 25.28: zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] 15.99: zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] 15.16: zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] 
Uplift Scope [plexInit] 38.5: zp ZP_BYTE:17 [ plexInit::i#2 plexInit::i#1 ] 
Uplift Scope [plexShowSprite] 4: zp ZP_BYTE:22 [ plexShowSprite::plexFreeAdd1_$0#0 ] 4: zp ZP_BYTE:23 [ plexShowSprite::plexFreeAdd1_$1#0 ] 4: zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ] 4: zp ZP_BYTE:26 [ plexShowSprite::$2 ] 4: zp ZP_BYTE:27 [ plexShowSprite::$3 ] 4: zp ZP_BYTE:28 [ plexShowSprite::$9 ] 4: zp ZP_BYTE:29 [ plexShowSprite::$5 ] 3: zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ] 2: zp ZP_BYTE:25 [ plexShowSprite::$11 ] 0.55: zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] 
Uplift Scope [main] 

Uplifting [plexSort] best 84432 combination reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ] reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ] zp ZP_BYTE:32 [ plexSort::s#2 ] zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] 
Limited combination testing to 10 combinations of 972 possible.
Uplifting [loop] best 83232 combination zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] reg byte y [ loop::sy#2 loop::sy#1 ] zp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] zp ZP_BYTE:18 [ loop::$6 ] zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Limited combination testing to 10 combinations of 1296 possible.
Uplifting [init] best 82982 combination reg byte x [ init::ss#2 init::ss#1 ] reg byte x [ init::sx#2 init::sx#1 ] zp ZP_BYTE:33 [ init::$8 ] zp ZP_WORD:14 [ init::xp#2 init::xp#1 ] 
Limited combination testing to 10 combinations of 36 possible.
Uplifting [] best 82982 combination zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] 
Limited combination testing to 10 combinations of 81 possible.
Uplifting [plexInit] best 82862 combination reg byte x [ plexInit::i#2 plexInit::i#1 ] 
Uplifting [plexShowSprite] best 82852 combination reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ] reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ] zp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ] zp ZP_BYTE:26 [ plexShowSprite::$2 ] zp ZP_BYTE:27 [ plexShowSprite::$3 ] zp ZP_BYTE:28 [ plexShowSprite::$9 ] zp ZP_BYTE:29 [ plexShowSprite::$5 ] zp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ] zp ZP_BYTE:25 [ plexShowSprite::$11 ] zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] 
Limited combination testing to 10 combinations of 589824 possible.
Uplifting [main] best 82852 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ]
Uplifting [loop] best 82852 combination zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:3 [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
Uplifting [loop] best 82122 combination reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:18 [ loop::$6 ]
Uplifting [loop] best 81522 combination reg byte a [ loop::$6 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:32 [ plexSort::s#2 ]
Uplifting [plexSort] best 80922 combination reg byte x [ plexSort::s#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ]
Uplifting [plexSort] best 80922 combination zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ]
Uplifting [loop] best 80922 combination zp ZP_BYTE:9 [ loop::ss#5 loop::ss#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:31 [ plexSort::nxt_y#0 ]
Uplifting [plexSort] best 80922 combination zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:30 [ plexSort::nxt_idx#0 ]
Uplifting [plexSort] best 80922 combination zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Uplifting [] best 80922 combination zp ZP_BYTE:8 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ]
Uplifting [] best 80922 combination zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:33 [ init::$8 ]
Uplifting [init] best 80882 combination reg byte a [ init::$8 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ]
Uplifting [] best 80882 combination zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ]
Uplifting [] best 80882 combination zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
Uplifting [loop] best 80882 combination zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:24 [ plexShowSprite::xpos_idx#0 ]
Uplifting [plexShowSprite] best 80876 combination reg byte a [ plexShowSprite::xpos_idx#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:26 [ plexShowSprite::$2 ]
Uplifting [plexShowSprite] best 80870 combination reg byte a [ plexShowSprite::$2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:27 [ plexShowSprite::$3 ]
Uplifting [plexShowSprite] best 80864 combination reg byte a [ plexShowSprite::$3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:28 [ plexShowSprite::$9 ]
Uplifting [plexShowSprite] best 80858 combination reg byte a [ plexShowSprite::$9 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:29 [ plexShowSprite::$5 ]
Uplifting [plexShowSprite] best 80852 combination reg byte x [ plexShowSprite::$5 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:21 [ plexShowSprite::plexFreeAdd1_ypos#0 ]
Uplifting [plexShowSprite] best 80843 combination reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:25 [ plexShowSprite::$11 ]
Uplifting [plexShowSprite] best 80836 combination reg byte x [ plexShowSprite::$11 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ]
Uplifting [plexShowSprite] best 80836 combination zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] 
Coalescing zero page register [ zp ZP_BYTE:10 [ plexSort::m#2 plexSort::m#1 ] ] with [ zp ZP_BYTE:5 [ plex_free_next#17 plex_free_next#13 ] ]
Coalescing zero page register [ zp ZP_BYTE:20 [ plexShowSprite::plex_sprite_idx2#0 ] ] with [ zp ZP_BYTE:19 [ loop::plexFreeNextYpos1_return#0 ] ]
Coalescing zero page register [ zp ZP_BYTE:30 [ plexSort::nxt_idx#0 ] ] with [ zp ZP_BYTE:6 [ plex_sprite_idx#42 plex_sprite_idx#15 ] ]
Coalescing zero page register [ zp ZP_BYTE:31 [ plexSort::nxt_y#0 ] ] with [ zp ZP_BYTE:7 [ plex_show_idx#42 plex_show_idx#15 ] ]
Allocated (was zp ZP_BYTE:8) zp ZP_BYTE:3 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
Allocated (was zp ZP_BYTE:9) zp ZP_BYTE:4 [ loop::ss#5 loop::ss#1 ]
Allocated (was zp ZP_BYTE:10) zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 plex_free_next#17 plex_free_next#13 ]
Allocated (was zp ZP_WORD:14) zp ZP_WORD:6 [ init::xp#2 init::xp#1 ]
Allocated (was zp ZP_BYTE:20) zp ZP_BYTE:8 [ plexShowSprite::plex_sprite_idx2#0 loop::plexFreeNextYpos1_return#0 ]
Allocated (was zp ZP_BYTE:30) zp ZP_BYTE:9 [ plexSort::nxt_idx#0 plex_sprite_idx#42 plex_sprite_idx#15 ]
Allocated (was zp ZP_BYTE:31) zp ZP_BYTE:10 [ plexSort::nxt_y#0 plex_show_idx#42 plex_show_idx#15 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// A simple usage of the flexible sprite multiplexer routine
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // Location of screen & sprites
  .label SCREEN = $400
  .label SPRITE = $2000
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  .label plex_sprite_msb = 3
  .label plex_free_next = 5
  .label plex_sprite_idx = 9
  .label plex_show_idx = $a
  // @begin
bbegin:
  jmp b1
  // @1
b1:
  // kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // [2] phi from @1 to @2 [phi:@1->@2]
b2_from_b1:
  jmp b2
  // @2
b2:
  // [3] call main 
  jsr main
  // [4] phi from @2 to @end [phi:@2->@end]
bend_from_b2:
  jmp bend
  // @end
bend:
  // main
main: {
    // asm { sei  }
    sei
    // [6] call init 
    jsr init
    // [7] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    jmp b1
    // main::@1
  b1:
    // [8] call loop 
    // [10] phi from main::@1 to loop [phi:main::@1->loop]
  loop_from_b1:
    jsr loop
    jmp breturn
    // main::@return
  breturn:
    // [9] return 
    rts
}
  // loop
// The raster loop
loop: {
    .label sin_idx = 2
    .label plexFreeNextYpos1_return = 8
    .label ss = 4
    // [11] phi from loop to loop::@1 [phi:loop->loop::@1]
  b1_from_loop:
    // [11] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    jmp b1
    // loop::@1
  b1:
    jmp b2
    // loop::@2
  b2:
    // [12] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    jmp b3
    // loop::@3
  b3:
    // [13] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [14] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [15] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
  b4_from_b3:
    // [15] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
    // [15] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    jmp b4
    // [15] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
  b4_from_b4:
    // [15] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [15] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    jmp b4
    // loop::@4
  b4:
    // [16] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte[$100]) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
    // [17] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
    // [18] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
    // [19] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4_from_b4
    jmp b5
    // loop::@5
  b5:
    // [20] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // [21] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [22] call plexSort 
    // [60] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
  plexSort_from_b5:
    jsr plexSort
    jmp b11
    // loop::@11
  b11:
    // [23] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp b6
    // loop::@6
  b6:
    // [24] (byte~) loop::$6 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    // [25] if((byte~) loop::$6!=(byte) 0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b6
    // [26] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
  b7_from_b6:
    // [26] phi (byte) loop::ss#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z ss
    // [26] phi (byte) plex_sprite_msb#42 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [26] phi (byte) plex_show_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [26] phi (byte) plex_sprite_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_sprite_idx
    // [26] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_free_next
    jmp b7
  // Show the sprites
    // [26] phi from loop::@12 to loop::@7 [phi:loop::@12->loop::@7]
  b7_from_b12:
    // [26] phi (byte) loop::ss#5 = (byte) loop::ss#1 [phi:loop::@12->loop::@7#0] -- register_copy 
    // [26] phi (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#16 [phi:loop::@12->loop::@7#1] -- register_copy 
    // [26] phi (byte) plex_show_idx#42 = (byte) plex_show_idx#15 [phi:loop::@12->loop::@7#2] -- register_copy 
    // [26] phi (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#15 [phi:loop::@12->loop::@7#3] -- register_copy 
    // [26] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@12->loop::@7#4] -- register_copy 
    jmp b7
    // loop::@7
  b7:
    // [27] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    jmp plexFreeNextYpos1
    // loop::plexFreeNextYpos1
  plexFreeNextYpos1:
    // [28] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    jmp b8
    // loop::@8
  b8:
    // [29] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc b8
    jmp b9
    // loop::@9
  b9:
    // [30] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [31] call plexShowSprite 
    jsr plexShowSprite
    jmp b12
    // loop::@12
  b12:
    // [32] (byte) loop::ss#1 ← ++ (byte) loop::ss#5 -- vbuz1=_inc_vbuz1 
    inc.z ss
    // [33] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z ss
    bne b7_from_b12
    jmp b10
    // loop::@10
  b10:
    // [34] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [11] phi from loop::@10 to loop::@1 [phi:loop::@10->loop::@1]
  b1_from_b10:
    // [11] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@10->loop::@1#0] -- register_copy 
    jmp b1
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = 8
    // [35] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // [36] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // [37] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    jmp plexFreeAdd1
    // plexShowSprite::plexFreeAdd1
  plexFreeAdd1:
    // [38] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // [39] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // [40] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // [41] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_free_next
    jmp b4
    // plexShowSprite::@4
  b4:
    // [42] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // [43] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // [44] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [45] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // [46] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // [47] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // [48] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
    jmp b3
    // plexShowSprite::@3
  b3:
    // [49] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // [50] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    jmp b2
    // plexShowSprite::@2
  b2:
    // [51] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // [52] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_sprite_idx
    // [53] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // [54] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // [55] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne b5_from_b2
    // [57] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
  breturn_from_b2:
    // [57] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    jmp breturn
    // [56] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
  b5_from_b2:
    jmp b5
    // plexShowSprite::@5
  b5:
    // [57] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
  breturn_from_b5:
    // [57] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    jmp breturn
    // plexShowSprite::@return
  breturn:
    // [58] return 
    rts
    // plexShowSprite::@1
  b1:
    // [59] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = 9
    .label nxt_y = $a
    .label m = 5
    // [61] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
  b1_from_plexSort:
    // [61] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    jmp b1
    // [61] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
  b1_from_b2:
    // [61] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    jmp b1
    // plexSort::@1
  b1:
    // [62] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // [63] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z nxt_idx
    lda PLEX_YPOS,y
    sta.z nxt_y
    // [64] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    lda.z nxt_y
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    jmp b5
    // plexSort::@5
  b5:
    // [65] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    ldx.z m
    // [66] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
  b3_from_b5:
  b3_from_b6:
    // [66] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    jmp b3
    // plexSort::@3
  b3:
    // [67] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // [68] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // [69] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq b4
    jmp b6
    // plexSort::@6
  b6:
    // [70] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3_from_b6
    jmp b4
    // plexSort::@4
  b4:
    // [71] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // [72] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    jmp b2
    // plexSort::@2
  b2:
    // [73] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [74] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne b1_from_b2
    // [75] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
  plexFreePrepare1_from_b2:
    jmp plexFreePrepare1
    // plexSort::plexFreePrepare1
  plexFreePrepare1:
    // [76] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1:
    // [76] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp plexFreePrepare1_b1
    // [76] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
  plexFreePrepare1_b1_from_plexFreePrepare1_b1:
    // [76] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    jmp plexFreePrepare1_b1
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
    // [77] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // [78] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [79] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1_from_plexFreePrepare1_b1
    jmp breturn
    // plexSort::@return
  breturn:
    // [80] return 
    rts
}
  // init
// Initialize the program
init: {
    .label xp = 6
    // [81] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // [82] call plexInit 
    // [96] phi from init to plexInit [phi:init->plexInit]
  plexInit_from_init:
    jsr plexInit
    // [83] phi from init to init::@1 [phi:init->init::@1]
  b1_from_init:
    // [83] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [83] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
    // [83] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
  b1_from_b1:
    // [83] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [83] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    jmp b1
    // init::@1
  b1:
    // [84] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
    // [85] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [86] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // [87] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // [88] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [89] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp b2
    // init::@2
  b2:
    // [90] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [91] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
  b3_from_b2:
    // [91] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b3
    // [91] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
  b3_from_b3:
    // [91] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    jmp b3
    // init::@3
  b3:
    // [92] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // [93] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
    // [94] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3_from_b3
    jmp breturn
    // init::@return
  breturn:
    // [95] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // [97] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
  plexSetScreen1_from_plexInit:
    jmp plexSetScreen1
    // plexInit::plexSetScreen1
  plexSetScreen1:
    // [98] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
  b1_from_plexSetScreen1:
    // [98] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
    // [98] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
  b1_from_b1:
    // [98] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    jmp b1
    // plexInit::@1
  b1:
    // [99] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // [100] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [101] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1_from_b1
    jmp breturn
    // plexInit::@return
  breturn:
    // [102] return 
    rts
}
  // File Data
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $100
YSIN:
.var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b4
Removing instruction jmp b5
Removing instruction jmp b11
Removing instruction jmp b6
Removing instruction jmp b7
Removing instruction jmp plexFreeNextYpos1
Removing instruction jmp b8
Removing instruction jmp b9
Removing instruction jmp b12
Removing instruction jmp b10
Removing instruction jmp plexFreeAdd1
Removing instruction jmp b4
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp b5
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b5
Removing instruction jmp b3
Removing instruction jmp b6
Removing instruction jmp b4
Removing instruction jmp b2
Removing instruction jmp plexFreePrepare1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp breturn
Removing instruction jmp plexSetScreen1
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Replacing instruction ldy.z nxt_idx with TAY
Removing instruction lda.z nxt_y
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b4_from_b4 with b4
Replacing label b7_from_b12 with b7
Replacing label b1 with b2
Replacing label b5_from_b2 with b5
Replacing label breturn with b5
Replacing label b3_from_b6 with b3
Replacing label b1_from_b2 with b1
Replacing label plexFreePrepare1_b1_from_plexFreePrepare1_b1 with plexFreePrepare1_b1
Replacing label b1_from_b1 with b1
Replacing label b3_from_b3 with b3
Replacing label b1_from_b1 with b1
Removing instruction b1:
Removing instruction b2_from_b1:
Removing instruction b2:
Removing instruction bend_from_b2:
Removing instruction b1_from_main:
Removing instruction loop_from_b1:
Removing instruction b1:
Removing instruction b4_from_b4:
Removing instruction b7_from_b12:
Removing instruction b5_from_b2:
Removing instruction breturn_from_b5:
Removing instruction breturn:
Removing instruction b1_from_b2:
Removing instruction b3_from_b5:
Removing instruction b3_from_b6:
Removing instruction plexFreePrepare1_from_b2:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1:
Removing instruction plexFreePrepare1_b1_from_plexFreePrepare1_b1:
Removing instruction b1_from_b1:
Removing instruction b3_from_b3:
Removing instruction plexSetScreen1_from_plexInit:
Removing instruction b1_from_plexSetScreen1:
Removing instruction b1_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction b1:
Removing instruction breturn:
Removing instruction b1_from_loop:
Removing instruction b3:
Removing instruction b4_from_b3:
Removing instruction b5:
Removing instruction plexSort_from_b5:
Removing instruction b11:
Removing instruction b7_from_b6:
Removing instruction plexFreeNextYpos1:
Removing instruction b9:
Removing instruction b12:
Removing instruction b10:
Removing instruction b1_from_b10:
Removing instruction plexFreeAdd1:
Removing instruction b4:
Removing instruction b3:
Removing instruction breturn_from_b2:
Removing instruction b1_from_plexSort:
Removing instruction b5:
Removing instruction b6:
Removing instruction plexFreePrepare1:
Removing instruction breturn:
Removing instruction plexInit_from_init:
Removing instruction b1_from_init:
Removing instruction b2:
Removing instruction b3_from_b2:
Removing instruction breturn:
Removing instruction plexSetScreen1:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Replacing jump to rts with rts in jmp b5
Succesful ASM optimization Pass5DoubleJumpElimination
Removing instruction jmp b4
Removing instruction jmp b7
Removing instruction jmp b1
Removing instruction jmp plexFreePrepare1_b1
Removing instruction jmp b1
Removing instruction jmp b3
Removing instruction jmp b1
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction ldx.z m
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @2
(label) @begin
(label) @end
(byte) BLACK
(const byte) BLACK#0 BLACK = (byte) 0
(byte*) BORDERCOL
(const byte*) BORDERCOL#0 BORDERCOL = (byte*) 53280
(byte*) D011
(const byte*) D011#0 D011 = (byte*) 53265
(byte) GREEN
(const byte) GREEN#0 GREEN = (byte) 5
(byte) PLEX_COUNT
(const byte) PLEX_COUNT#0 PLEX_COUNT = (byte) $20
(byte[8]) PLEX_FREE_YPOS
(const byte[8]) PLEX_FREE_YPOS#0 PLEX_FREE_YPOS = { fill( 8, 0) }
(byte[PLEX_COUNT#0]) PLEX_PTR
(const byte[PLEX_COUNT#0]) PLEX_PTR#0 PLEX_PTR = { fill( PLEX_COUNT#0, 0) }
(byte*) PLEX_SCREEN_PTR
(const byte*) PLEX_SCREEN_PTR#1 PLEX_SCREEN_PTR = (const byte*) SCREEN#0+(word) $3f8
(byte[PLEX_COUNT#0]) PLEX_SORTED_IDX
(const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 PLEX_SORTED_IDX = { fill( PLEX_COUNT#0, 0) }
(word[PLEX_COUNT#0]) PLEX_XPOS
(const word[PLEX_COUNT#0]) PLEX_XPOS#0 PLEX_XPOS = { fill( PLEX_COUNT#0, 0) }
(byte[PLEX_COUNT#0]) PLEX_YPOS
(const byte[PLEX_COUNT#0]) PLEX_YPOS#0 PLEX_YPOS = { fill( PLEX_COUNT#0, 0) }
(byte*) RASTER
(const byte*) RASTER#0 RASTER = (byte*) 53266
(byte*) SCREEN
(const byte*) SCREEN#0 SCREEN = (byte*) 1024
(byte*) SPRITE
(const byte*) SPRITE#0 SPRITE = (byte*) 8192
(byte*) SPRITES_COLS
(const byte*) SPRITES_COLS#0 SPRITES_COLS = (byte*) 53287
(byte*) SPRITES_ENABLE
(const byte*) SPRITES_ENABLE#0 SPRITES_ENABLE = (byte*) 53269
(byte*) SPRITES_XMSB
(const byte*) SPRITES_XMSB#0 SPRITES_XMSB = (byte*) 53264
(byte*) SPRITES_XPOS
(const byte*) SPRITES_XPOS#0 SPRITES_XPOS = (byte*) 53248
(byte*) SPRITES_YPOS
(const byte*) SPRITES_YPOS#0 SPRITES_YPOS = (byte*) 53249
(byte) VIC_DEN
(const byte) VIC_DEN#0 VIC_DEN = (byte) $10
(byte) VIC_RSEL
(const byte) VIC_RSEL#0 VIC_RSEL = (byte) 8
(byte) VIC_RST8
(const byte) VIC_RST8#0 VIC_RST8 = (byte) $80
(byte[$100]) YSIN
(const byte[$100]) YSIN#0 YSIN = kickasm {{ .var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))
 }}
(void()) init()
(byte~) init::$8 reg byte a 22.0
(label) init::@1
(label) init::@2
(label) init::@3
(label) init::@return
(byte) init::ss
(byte) init::ss#1 reg byte x 16.5
(byte) init::ss#2 reg byte x 16.5
(byte) init::sx
(byte) init::sx#1 reg byte x 16.5
(byte) init::sx#2 reg byte x 8.8
(word) init::xp
(word) init::xp#1 xp zp ZP_WORD:6 7.333333333333333
(word) init::xp#2 xp zp ZP_WORD:6 8.25
(void()) loop()
(byte~) loop::$6 reg byte a 202.0
(label) loop::@1
(label) loop::@10
(label) loop::@11
(label) loop::@12
(label) loop::@2
(label) loop::@3
(label) loop::@4
(label) loop::@5
(label) loop::@6
(label) loop::@7
(label) loop::@8
(label) loop::@9
(label) loop::plexFreeNextYpos1
(byte) loop::plexFreeNextYpos1_return
(byte) loop::plexFreeNextYpos1_return#0 plexFreeNextYpos1_return zp ZP_BYTE:8 551.0
(byte) loop::rasterY
(byte) loop::sin_idx
(byte) loop::sin_idx#1 sin_idx zp ZP_BYTE:2 1.4666666666666666
(byte) loop::sin_idx#6 sin_idx zp ZP_BYTE:2 3.666666666666667
(byte) loop::ss
(byte) loop::ss#1 ss zp ZP_BYTE:4 151.5
(byte) loop::ss#5 ss zp ZP_BYTE:4 33.666666666666664
(byte) loop::sy
(byte) loop::sy#1 reg byte y 151.5
(byte) loop::sy#2 reg byte y 101.0
(byte) loop::y_idx
(byte) loop::y_idx#1 reg byte x 67.33333333333333
(byte) loop::y_idx#2 reg byte x 157.0
(byte~) loop::y_idx#4 reg byte x 22.0
(void()) main()
(label) main::@1
(label) main::@return
(void()) plexInit((byte*) plexInit::screen)
(label) plexInit::@1
(label) plexInit::@return
(byte) plexInit::i
(byte) plexInit::i#1 reg byte x 16.5
(byte) plexInit::i#2 reg byte x 22.0
(label) plexInit::plexSetScreen1
(byte*~) plexInit::plexSetScreen1_$0
(byte*) plexInit::plexSetScreen1_screen
(byte*) plexInit::screen
(void()) plexShowSprite()
(byte~) plexShowSprite::$11 reg byte x 2.0
(byte~) plexShowSprite::$2 reg byte a 4.0
(byte~) plexShowSprite::$3 reg byte a 4.0
(byte~) plexShowSprite::$5 reg byte x 4.0
(byte~) plexShowSprite::$9 reg byte a 4.0
(label) plexShowSprite::@1
(label) plexShowSprite::@2
(label) plexShowSprite::@3
(label) plexShowSprite::@4
(label) plexShowSprite::@5
(label) plexShowSprite::@return
(label) plexShowSprite::plexFreeAdd1
(number~) plexShowSprite::plexFreeAdd1_$0
(byte~) plexShowSprite::plexFreeAdd1_$0#0 reg byte a 4.0
(number~) plexShowSprite::plexFreeAdd1_$1
(byte~) plexShowSprite::plexFreeAdd1_$1#0 reg byte x 4.0
(number~) plexShowSprite::plexFreeAdd1_$2
(byte) plexShowSprite::plexFreeAdd1_ypos
(byte) plexShowSprite::plexFreeAdd1_ypos#0 reg byte a 3.0
(byte) plexShowSprite::plex_sprite_idx2
(byte) plexShowSprite::plex_sprite_idx2#0 plex_sprite_idx2 zp ZP_BYTE:8 0.5454545454545454
(byte) plexShowSprite::xpos_idx
(byte) plexShowSprite::xpos_idx#0 reg byte a 4.0
(byte) plexShowSprite::ypos
(void()) plexSort()
(label) plexSort::@1
(label) plexSort::@2
(label) plexSort::@3
(label) plexSort::@4
(label) plexSort::@5
(label) plexSort::@6
(label) plexSort::@return
(byte) plexSort::m
(byte) plexSort::m#1 m zp ZP_BYTE:5 151.5
(byte) plexSort::m#2 m zp ZP_BYTE:5 42.08333333333333
(byte) plexSort::nxt_idx
(byte) plexSort::nxt_idx#0 nxt_idx zp ZP_BYTE:9 30.299999999999997
(byte) plexSort::nxt_y
(byte) plexSort::nxt_y#0 nxt_y zp ZP_BYTE:10 150.375
(label) plexSort::plexFreePrepare1
(bool~) plexSort::plexFreePrepare1_$0
(label) plexSort::plexFreePrepare1_@1
(byte) plexSort::plexFreePrepare1_s
(byte) plexSort::plexFreePrepare1_s#1 reg byte x 151.5
(byte) plexSort::plexFreePrepare1_s#2 reg byte x 151.5
(byte) plexSort::s
(byte) plexSort::s#1 reg byte x 1368.3333333333335
(byte) plexSort::s#2 reg byte x 202.0
(byte) plexSort::s#3 reg byte x 2052.5
(byte~) plexSort::s#6 reg byte x 202.0
(byte) plex_free_next
(byte) plex_free_next#13 plex_free_next zp ZP_BYTE:5 4.681818181818182
(byte) plex_free_next#17 plex_free_next zp ZP_BYTE:5 20.599999999999998
(byte) plex_show_idx
(byte) plex_show_idx#15 plex_show_idx zp ZP_BYTE:10 11.444444444444443
(byte) plex_show_idx#42 plex_show_idx zp ZP_BYTE:10 4.541666666666665
(byte) plex_sprite_idx
(byte) plex_sprite_idx#15 plex_sprite_idx zp ZP_BYTE:9 10.299999999999999
(byte) plex_sprite_idx#42 plex_sprite_idx zp ZP_BYTE:9 4.863636363636363
(byte) plex_sprite_msb
(byte) plex_sprite_msb#16 plex_sprite_msb zp ZP_BYTE:3 20.599999999999998
(byte) plex_sprite_msb#3 plex_sprite_msb zp ZP_BYTE:3 2.0
(byte) plex_sprite_msb#42 plex_sprite_msb zp ZP_BYTE:3 4.28

zp ZP_BYTE:2 [ loop::sin_idx#6 loop::sin_idx#1 ]
reg byte x [ loop::y_idx#2 loop::y_idx#1 loop::y_idx#4 ]
reg byte y [ loop::sy#2 loop::sy#1 ]
zp ZP_BYTE:3 [ plex_sprite_msb#42 plex_sprite_msb#16 plex_sprite_msb#3 ]
zp ZP_BYTE:4 [ loop::ss#5 loop::ss#1 ]
zp ZP_BYTE:5 [ plexSort::m#2 plexSort::m#1 plex_free_next#17 plex_free_next#13 ]
reg byte x [ plexSort::s#3 plexSort::s#1 plexSort::s#6 ]
reg byte x [ plexSort::plexFreePrepare1_s#2 plexSort::plexFreePrepare1_s#1 ]
reg byte x [ init::sx#2 init::sx#1 ]
zp ZP_WORD:6 [ init::xp#2 init::xp#1 ]
reg byte x [ init::ss#2 init::ss#1 ]
reg byte x [ plexInit::i#2 plexInit::i#1 ]
reg byte a [ loop::$6 ]
zp ZP_BYTE:8 [ plexShowSprite::plex_sprite_idx2#0 loop::plexFreeNextYpos1_return#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_ypos#0 ]
reg byte a [ plexShowSprite::plexFreeAdd1_$0#0 ]
reg byte x [ plexShowSprite::plexFreeAdd1_$1#0 ]
reg byte a [ plexShowSprite::xpos_idx#0 ]
reg byte x [ plexShowSprite::$11 ]
reg byte a [ plexShowSprite::$2 ]
reg byte a [ plexShowSprite::$3 ]
reg byte a [ plexShowSprite::$9 ]
reg byte x [ plexShowSprite::$5 ]
zp ZP_BYTE:9 [ plexSort::nxt_idx#0 plex_sprite_idx#42 plex_sprite_idx#15 ]
zp ZP_BYTE:10 [ plexSort::nxt_y#0 plex_show_idx#42 plex_show_idx#15 ]
reg byte x [ plexSort::s#2 ]
reg byte a [ init::$8 ]


FINAL ASSEMBLER
Score: 62204

  // File Comments
// A simple usage of the flexible sprite multiplexer routine
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SPRITES_XPOS = $d000
  .label SPRITES_YPOS = $d001
  .label SPRITES_XMSB = $d010
  .label RASTER = $d012
  .label SPRITES_ENABLE = $d015
  .label BORDERCOL = $d020
  .label SPRITES_COLS = $d027
  .label D011 = $d011
  .const VIC_RST8 = $80
  .const VIC_DEN = $10
  .const VIC_RSEL = 8
  // The colors of the C64
  .const BLACK = 0
  .const GREEN = 5
  // The number of sprites in the multiplexer
  .const PLEX_COUNT = $20
  // Location of screen & sprites
  .label SCREEN = $400
  .label SPRITE = $2000
  .label PLEX_SCREEN_PTR = SCREEN+$3f8
  .label plex_sprite_msb = 3
  .label plex_free_next = 5
  .label plex_sprite_idx = 9
  .label plex_show_idx = $a
  // @begin
  // @1
  // kickasm
  // kickasm(location (const byte*) SPRITE#0) {{ .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))     .for (var y=0; y<21; y++)         .for (var x=0;x<3; x++)             .byte pic.getSinglecolorByte(x,y)  }}
  // [2] phi from @1 to @2 [phi:@1->@2]
  // @2
  // [3] call main 
  // [4] phi from @2 to @end [phi:@2->@end]
  // @end
  // main
main: {
    // asm
    // asm { sei  }
    sei
    // init()
    // [6] call init 
    jsr init
    // [7] phi from main to main::@1 [phi:main->main::@1]
    // main::@1
    // loop()
    // [8] call loop 
    // [10] phi from main::@1 to loop [phi:main::@1->loop]
    jsr loop
    // main::@return
    // }
    // [9] return 
    rts
}
  // loop
// The raster loop
loop: {
    .label sin_idx = 2
    .label plexFreeNextYpos1_return = 8
    .label ss = 4
    // [11] phi from loop to loop::@1 [phi:loop->loop::@1]
    // [11] phi (byte) loop::sin_idx#6 = (byte) 0 [phi:loop->loop::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z sin_idx
    // loop::@1
    // loop::@2
  b2:
    // while(*RASTER!=$ff)
    // [12] if(*((const byte*) RASTER#0)!=(byte) $ff) goto loop::@2 -- _deref_pbuc1_neq_vbuc2_then_la1 
    lda #$ff
    cmp RASTER
    bne b2
    // loop::@3
    // (*BORDERCOL)++;
    // [13] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // [14] (byte~) loop::y_idx#4 ← (byte) loop::sin_idx#6 -- vbuxx=vbuz1 
    ldx.z sin_idx
    // [15] phi from loop::@3 to loop::@4 [phi:loop::@3->loop::@4]
    // [15] phi (byte) loop::sy#2 = (byte) 0 [phi:loop::@3->loop::@4#0] -- vbuyy=vbuc1 
    ldy #0
    // [15] phi (byte) loop::y_idx#2 = (byte~) loop::y_idx#4 [phi:loop::@3->loop::@4#1] -- register_copy 
    // [15] phi from loop::@4 to loop::@4 [phi:loop::@4->loop::@4]
    // [15] phi (byte) loop::sy#2 = (byte) loop::sy#1 [phi:loop::@4->loop::@4#0] -- register_copy 
    // [15] phi (byte) loop::y_idx#2 = (byte) loop::y_idx#1 [phi:loop::@4->loop::@4#1] -- register_copy 
    // loop::@4
  b4:
    // PLEX_YPOS[sy] = YSIN[y_idx]
    // [16] *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) loop::sy#2) ← *((const byte[$100]) YSIN#0 + (byte) loop::y_idx#2) -- pbuc1_derefidx_vbuyy=pbuc2_derefidx_vbuxx 
    lda YSIN,x
    sta PLEX_YPOS,y
    // y_idx += 8
    // [17] (byte) loop::y_idx#1 ← (byte) loop::y_idx#2 + (byte) 8 -- vbuxx=vbuxx_plus_vbuc1 
    txa
    axs #-[8]
    // for(byte sy: 0..PLEX_COUNT-1)
    // [18] (byte) loop::sy#1 ← ++ (byte) loop::sy#2 -- vbuyy=_inc_vbuyy 
    iny
    // [19] if((byte) loop::sy#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@4 -- vbuyy_neq_vbuc1_then_la1 
    cpy #PLEX_COUNT-1+1
    bne b4
    // loop::@5
    // sin_idx +=1
    // [20] (byte) loop::sin_idx#1 ← (byte) loop::sin_idx#6 + (byte) 1 -- vbuz1=vbuz1_plus_1 
    inc.z sin_idx
    // (*BORDERCOL)++;
    // [21] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // plexSort()
    // [22] call plexSort 
    // [60] phi from loop::@5 to plexSort [phi:loop::@5->plexSort]
    jsr plexSort
    // loop::@11
    // *BORDERCOL = BLACK
    // [23] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // loop::@6
  b6:
    // *D011&VIC_RST8
    // [24] (byte~) loop::$6 ← *((const byte*) D011#0) & (const byte) VIC_RST8#0 -- vbuaa=_deref_pbuc1_band_vbuc2 
    lda #VIC_RST8
    and D011
    // while((*D011&VIC_RST8)!=0)
    // [25] if((byte~) loop::$6!=(byte) 0) goto loop::@6 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b6
    // [26] phi from loop::@6 to loop::@7 [phi:loop::@6->loop::@7]
    // [26] phi (byte) loop::ss#5 = (byte) 0 [phi:loop::@6->loop::@7#0] -- vbuz1=vbuc1 
    lda #0
    sta.z ss
    // [26] phi (byte) plex_sprite_msb#42 = (byte) 1 [phi:loop::@6->loop::@7#1] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    // [26] phi (byte) plex_show_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#2] -- vbuz1=vbuc1 
    lda #0
    sta.z plex_show_idx
    // [26] phi (byte) plex_sprite_idx#42 = (byte) 0 [phi:loop::@6->loop::@7#3] -- vbuz1=vbuc1 
    sta.z plex_sprite_idx
    // [26] phi (byte) plex_free_next#17 = (byte) 0 [phi:loop::@6->loop::@7#4] -- vbuz1=vbuc1 
    sta.z plex_free_next
  // Show the sprites
    // [26] phi from loop::@12 to loop::@7 [phi:loop::@12->loop::@7]
    // [26] phi (byte) loop::ss#5 = (byte) loop::ss#1 [phi:loop::@12->loop::@7#0] -- register_copy 
    // [26] phi (byte) plex_sprite_msb#42 = (byte) plex_sprite_msb#16 [phi:loop::@12->loop::@7#1] -- register_copy 
    // [26] phi (byte) plex_show_idx#42 = (byte) plex_show_idx#15 [phi:loop::@12->loop::@7#2] -- register_copy 
    // [26] phi (byte) plex_sprite_idx#42 = (byte) plex_sprite_idx#15 [phi:loop::@12->loop::@7#3] -- register_copy 
    // [26] phi (byte) plex_free_next#17 = (byte) plex_free_next#13 [phi:loop::@12->loop::@7#4] -- register_copy 
    // loop::@7
  b7:
    // *BORDERCOL = BLACK
    // [27] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // loop::plexFreeNextYpos1
    // return PLEX_FREE_YPOS[plex_free_next];
    // [28] (byte) loop::plexFreeNextYpos1_return#0 ← *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z plex_free_next
    lda PLEX_FREE_YPOS,y
    sta.z plexFreeNextYpos1_return
    // loop::@8
  b8:
    // while(*RASTER<rasterY)
    // [29] if(*((const byte*) RASTER#0)<(byte) loop::plexFreeNextYpos1_return#0) goto loop::@8 -- _deref_pbuc1_lt_vbuz1_then_la1 
    lda RASTER
    cmp.z plexFreeNextYpos1_return
    bcc b8
    // loop::@9
    // (*BORDERCOL)++;
    // [30] *((const byte*) BORDERCOL#0) ← ++ *((const byte*) BORDERCOL#0) -- _deref_pbuc1=_inc__deref_pbuc1 
    inc BORDERCOL
    // plexShowSprite()
    // [31] call plexShowSprite 
    jsr plexShowSprite
    // loop::@12
    // for( byte ss: 0..PLEX_COUNT-1)
    // [32] (byte) loop::ss#1 ← ++ (byte) loop::ss#5 -- vbuz1=_inc_vbuz1 
    inc.z ss
    // [33] if((byte) loop::ss#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto loop::@7 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-1+1
    cmp.z ss
    bne b7
    // loop::@10
    // *BORDERCOL = BLACK
    // [34] *((const byte*) BORDERCOL#0) ← (const byte) BLACK#0 -- _deref_pbuc1=vbuc2 
    lda #BLACK
    sta BORDERCOL
    // [11] phi from loop::@10 to loop::@1 [phi:loop::@10->loop::@1]
    // [11] phi (byte) loop::sin_idx#6 = (byte) loop::sin_idx#1 [phi:loop::@10->loop::@1#0] -- register_copy 
    jmp b2
}
  // plexShowSprite
// Show the next sprite.
// plexSort() prepares showing the sprites
plexShowSprite: {
    .label plex_sprite_idx2 = 8
    // plex_sprite_idx2 = plex_sprite_idx*2
    // [35] (byte) plexShowSprite::plex_sprite_idx2#0 ← (byte) plex_sprite_idx#42 << (byte) 1 -- vbuz1=vbuz2_rol_1 
    lda.z plex_sprite_idx
    asl
    sta.z plex_sprite_idx2
    // ypos = PLEX_YPOS[PLEX_SORTED_IDX[plex_show_idx]]
    // [36] (byte) plexShowSprite::plexFreeAdd1_ypos#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- vbuaa=pbuc1_derefidx_(pbuc2_derefidx_vbuz1) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_YPOS,y
    // SPRITES_YPOS[plex_sprite_idx2] = ypos
    // [37] *((const byte*) SPRITES_YPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_YPOS,y
    // plexShowSprite::plexFreeAdd1
    // ypos+21
    // [38] (byte~) plexShowSprite::plexFreeAdd1_$0#0 ← (byte) plexShowSprite::plexFreeAdd1_ypos#0 + (byte) $15 -- vbuaa=vbuaa_plus_vbuc1 
    clc
    adc #$15
    // PLEX_FREE_YPOS[plex_free_next] =  ypos+21
    // [39] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plex_free_next#17) ← (byte~) plexShowSprite::plexFreeAdd1_$0#0 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_free_next
    sta PLEX_FREE_YPOS,y
    // plex_free_next+1
    // [40] (byte~) plexShowSprite::plexFreeAdd1_$1#0 ← (byte) plex_free_next#17 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_free_next
    inx
    // plex_free_next = (plex_free_next+1)&7
    // [41] (byte) plex_free_next#13 ← (byte~) plexShowSprite::plexFreeAdd1_$1#0 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_free_next
    // plexShowSprite::@4
    // PLEX_SCREEN_PTR[plex_sprite_idx] = PLEX_PTR[PLEX_SORTED_IDX[plex_show_idx]]
    // [42] *((const byte*) PLEX_SCREEN_PTR#1 + (byte) plex_sprite_idx#42) ← *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42)) -- pbuc1_derefidx_vbuz1=pbuc2_derefidx_(pbuc3_derefidx_vbuz2) 
    ldx.z plex_show_idx
    ldy PLEX_SORTED_IDX,x
    lda PLEX_PTR,y
    ldx.z plex_sprite_idx
    sta PLEX_SCREEN_PTR,x
    // xpos_idx = PLEX_SORTED_IDX[plex_show_idx]
    // [43] (byte) plexShowSprite::xpos_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plex_show_idx#42) -- vbuaa=pbuc1_derefidx_vbuz1 
    ldy.z plex_show_idx
    lda PLEX_SORTED_IDX,y
    // <PLEX_XPOS[xpos_idx]
    // [44] (byte~) plexShowSprite::$11 ← (byte) plexShowSprite::xpos_idx#0 << (byte) 1 -- vbuxx=vbuaa_rol_1 
    asl
    tax
    // [45] (byte~) plexShowSprite::$2 ← < *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_lo_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS,x
    // SPRITES_XPOS[plex_sprite_idx2] = <PLEX_XPOS[xpos_idx]
    // [46] *((const byte*) SPRITES_XPOS#0 + (byte) plexShowSprite::plex_sprite_idx2#0) ← (byte~) plexShowSprite::$2 -- pbuc1_derefidx_vbuz1=vbuaa 
    ldy.z plex_sprite_idx2
    sta SPRITES_XPOS,y
    // >PLEX_XPOS[xpos_idx]
    // [47] (byte~) plexShowSprite::$3 ← > *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) plexShowSprite::$11) -- vbuaa=_hi_pwuc1_derefidx_vbuxx 
    lda PLEX_XPOS+1,x
    // if(>PLEX_XPOS[xpos_idx]!=0)
    // [48] if((byte~) plexShowSprite::$3!=(byte) 0) goto plexShowSprite::@1 -- vbuaa_neq_0_then_la1 
    cmp #0
    bne b1
    // plexShowSprite::@3
    // $ff^plex_sprite_msb
    // [49] (byte~) plexShowSprite::$9 ← (byte) $ff ^ (byte) plex_sprite_msb#42 -- vbuaa=vbuc1_bxor_vbuz1 
    lda #$ff
    eor.z plex_sprite_msb
    // *SPRITES_XMSB &= ($ff^plex_sprite_msb)
    // [50] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) & (byte~) plexShowSprite::$9 -- _deref_pbuc1=_deref_pbuc1_band_vbuaa 
    and SPRITES_XMSB
    sta SPRITES_XMSB
    // plexShowSprite::@2
  b2:
    // plex_sprite_idx+1
    // [51] (byte~) plexShowSprite::$5 ← (byte) plex_sprite_idx#42 + (byte) 1 -- vbuxx=vbuz1_plus_1 
    ldx.z plex_sprite_idx
    inx
    // plex_sprite_idx = (plex_sprite_idx+1)&7
    // [52] (byte) plex_sprite_idx#15 ← (byte~) plexShowSprite::$5 & (byte) 7 -- vbuz1=vbuxx_band_vbuc1 
    lda #7
    sax.z plex_sprite_idx
    // plex_show_idx++;
    // [53] (byte) plex_show_idx#15 ← ++ (byte) plex_show_idx#42 -- vbuz1=_inc_vbuz1 
    inc.z plex_show_idx
    // plex_sprite_msb *=2
    // [54] (byte) plex_sprite_msb#3 ← (byte) plex_sprite_msb#42 << (byte) 1 -- vbuz1=vbuz1_rol_1 
    asl.z plex_sprite_msb
    // if(plex_sprite_msb==0)
    // [55] if((byte) plex_sprite_msb#3!=(byte) 0) goto plexShowSprite::@5 -- vbuz1_neq_0_then_la1 
    lda.z plex_sprite_msb
    cmp #0
    bne b5
    // [57] phi from plexShowSprite::@2 to plexShowSprite::@return [phi:plexShowSprite::@2->plexShowSprite::@return]
    // [57] phi (byte) plex_sprite_msb#16 = (byte) 1 [phi:plexShowSprite::@2->plexShowSprite::@return#0] -- vbuz1=vbuc1 
    lda #1
    sta.z plex_sprite_msb
    rts
    // [56] phi from plexShowSprite::@2 to plexShowSprite::@5 [phi:plexShowSprite::@2->plexShowSprite::@5]
    // plexShowSprite::@5
  b5:
    // [57] phi from plexShowSprite::@5 to plexShowSprite::@return [phi:plexShowSprite::@5->plexShowSprite::@return]
    // [57] phi (byte) plex_sprite_msb#16 = (byte) plex_sprite_msb#3 [phi:plexShowSprite::@5->plexShowSprite::@return#0] -- register_copy 
    // plexShowSprite::@return
    // }
    // [58] return 
    rts
    // plexShowSprite::@1
  b1:
    // *SPRITES_XMSB |= plex_sprite_msb
    // [59] *((const byte*) SPRITES_XMSB#0) ← *((const byte*) SPRITES_XMSB#0) | (byte) plex_sprite_msb#42 -- _deref_pbuc1=_deref_pbuc1_bor_vbuz1 
    lda SPRITES_XMSB
    ora.z plex_sprite_msb
    sta SPRITES_XMSB
    jmp b2
}
  // plexSort
// Ensure that the indices in PLEX_SORTED_IDX is sorted based on the y-positions in PLEX_YPOS
// Assumes that the positions are nearly sorted already (as each sprite just moves a bit)
// Uses an insertion sort:
// 1. Moves a marker (m) from the start to end of the array. Every time the marker moves forward all elements before the marker are sorted correctly.
// 2a. If the next element after the marker is larger that the current element
//     the marker can be moved forwards (as the sorting is correct).
// 2b. If the next element after the marker is smaller than the current element:
//     elements before the marker are shifted right one at a time until encountering one smaller than the current one.
//      It is then inserted at the spot. Now the marker can move forward.
plexSort: {
    .label nxt_idx = 9
    .label nxt_y = $a
    .label m = 5
    // [61] phi from plexSort to plexSort::@1 [phi:plexSort->plexSort::@1]
    // [61] phi (byte) plexSort::m#2 = (byte) 0 [phi:plexSort->plexSort::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z m
    // [61] phi from plexSort::@2 to plexSort::@1 [phi:plexSort::@2->plexSort::@1]
    // [61] phi (byte) plexSort::m#2 = (byte) plexSort::m#1 [phi:plexSort::@2->plexSort::@1#0] -- register_copy 
    // plexSort::@1
  b1:
    // nxt_idx = PLEX_SORTED_IDX[m+1]
    // [62] (byte) plexSort::nxt_idx#0 ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::m#2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy.z m
    lda PLEX_SORTED_IDX+1,y
    sta.z nxt_idx
    // nxt_y = PLEX_YPOS[nxt_idx]
    // [63] (byte) plexSort::nxt_y#0 ← *((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + (byte) plexSort::nxt_idx#0) -- vbuz1=pbuc1_derefidx_vbuz2 
    tay
    lda PLEX_YPOS,y
    sta.z nxt_y
    // if(nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[m]])
    // [64] if((byte) plexSort::nxt_y#0>=*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::m#2))) goto plexSort::@2 -- vbuz1_ge_pbuc1_derefidx_(pbuc2_derefidx_vbuz2)_then_la1 
    ldx.z m
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcs b2
    // plexSort::@5
    // [65] (byte~) plexSort::s#6 ← (byte) plexSort::m#2 -- vbuxx=vbuz1 
    // [66] phi from plexSort::@5 plexSort::@6 to plexSort::@3 [phi:plexSort::@5/plexSort::@6->plexSort::@3]
    // [66] phi (byte) plexSort::s#3 = (byte~) plexSort::s#6 [phi:plexSort::@5/plexSort::@6->plexSort::@3#0] -- register_copy 
    // plexSort::@3
  b3:
    // PLEX_SORTED_IDX[s+1] = PLEX_SORTED_IDX[s]
    // [67] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0+(byte) 1 + (byte) plexSort::s#3) ← *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#3) -- pbuc1_derefidx_vbuxx=pbuc2_derefidx_vbuxx 
    lda PLEX_SORTED_IDX,x
    sta PLEX_SORTED_IDX+1,x
    // s--;
    // [68] (byte) plexSort::s#1 ← -- (byte) plexSort::s#3 -- vbuxx=_dec_vbuxx 
    dex
    // while((s!=$ff) && (nxt_y<PLEX_YPOS[PLEX_SORTED_IDX[s]]))
    // [69] if((byte) plexSort::s#1==(byte) $ff) goto plexSort::@4 -- vbuxx_eq_vbuc1_then_la1 
    cpx #$ff
    beq b4
    // plexSort::@6
    // [70] if((byte) plexSort::nxt_y#0<*((const byte[PLEX_COUNT#0]) PLEX_YPOS#0 + *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#1))) goto plexSort::@3 -- vbuz1_lt_pbuc1_derefidx_(pbuc2_derefidx_vbuxx)_then_la1 
    lda.z nxt_y
    ldy PLEX_SORTED_IDX,x
    cmp PLEX_YPOS,y
    bcc b3
    // plexSort::@4
  b4:
    // s++;
    // [71] (byte) plexSort::s#2 ← ++ (byte) plexSort::s#1 -- vbuxx=_inc_vbuxx 
    inx
    // PLEX_SORTED_IDX[s] = nxt_idx
    // [72] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexSort::s#2) ← (byte) plexSort::nxt_idx#0 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z nxt_idx
    sta PLEX_SORTED_IDX,x
    // plexSort::@2
  b2:
    // for(byte m: 0..PLEX_COUNT-2)
    // [73] (byte) plexSort::m#1 ← ++ (byte) plexSort::m#2 -- vbuz1=_inc_vbuz1 
    inc.z m
    // [74] if((byte) plexSort::m#1!=(const byte) PLEX_COUNT#0-(byte) 2+(byte) 1) goto plexSort::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #PLEX_COUNT-2+1
    cmp.z m
    bne b1
    // [75] phi from plexSort::@2 to plexSort::plexFreePrepare1 [phi:plexSort::@2->plexSort::plexFreePrepare1]
    // plexSort::plexFreePrepare1
    // [76] phi from plexSort::plexFreePrepare1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1]
    // [76] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) 0 [phi:plexSort::plexFreePrepare1->plexSort::plexFreePrepare1_@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [76] phi from plexSort::plexFreePrepare1_@1 to plexSort::plexFreePrepare1_@1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1]
    // [76] phi (byte) plexSort::plexFreePrepare1_s#2 = (byte) plexSort::plexFreePrepare1_s#1 [phi:plexSort::plexFreePrepare1_@1->plexSort::plexFreePrepare1_@1#0] -- register_copy 
    // plexSort::plexFreePrepare1_@1
  plexFreePrepare1_b1:
    // PLEX_FREE_YPOS[s] = 0
    // [77] *((const byte[8]) PLEX_FREE_YPOS#0 + (byte) plexSort::plexFreePrepare1_s#2) ← (byte) 0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #0
    sta PLEX_FREE_YPOS,x
    // for( byte s: 0..7)
    // [78] (byte) plexSort::plexFreePrepare1_s#1 ← ++ (byte) plexSort::plexFreePrepare1_s#2 -- vbuxx=_inc_vbuxx 
    inx
    // [79] if((byte) plexSort::plexFreePrepare1_s#1!=(byte) 8) goto plexSort::plexFreePrepare1_@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne plexFreePrepare1_b1
    // plexSort::@return
    // }
    // [80] return 
    rts
}
  // init
// Initialize the program
init: {
    .label xp = 6
    // *D011 = VIC_DEN | VIC_RSEL | 3
    // [81] *((const byte*) D011#0) ← (const byte) VIC_DEN#0|(const byte) VIC_RSEL#0|(byte) 3 -- _deref_pbuc1=vbuc2 
    lda #VIC_DEN|VIC_RSEL|3
    sta D011
    // plexInit(SCREEN)
    // [82] call plexInit 
    // [96] phi from init to plexInit [phi:init->plexInit]
    jsr plexInit
    // [83] phi from init to init::@1 [phi:init->init::@1]
    // [83] phi (word) init::xp#2 = (byte) $20 [phi:init->init::@1#0] -- vwuz1=vbuc1 
    lda #<$20
    sta.z xp
    lda #>$20
    sta.z xp+1
    // [83] phi (byte) init::sx#2 = (byte) 0 [phi:init->init::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [83] phi from init::@1 to init::@1 [phi:init::@1->init::@1]
    // [83] phi (word) init::xp#2 = (word) init::xp#1 [phi:init::@1->init::@1#0] -- register_copy 
    // [83] phi (byte) init::sx#2 = (byte) init::sx#1 [phi:init::@1->init::@1#1] -- register_copy 
    // init::@1
  b1:
    // PLEX_PTR[sx] = (byte)(SPRITE/$40)
    // [84] *((const byte[PLEX_COUNT#0]) PLEX_PTR#0 + (byte) init::sx#2) ← (byte)(const byte*) SPRITE#0/(byte) $40 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #SPRITE/$40
    sta PLEX_PTR,x
    // PLEX_XPOS[sx] = xp
    // [85] (byte~) init::$8 ← (byte) init::sx#2 << (byte) 1 -- vbuaa=vbuxx_rol_1 
    txa
    asl
    // [86] *((const word[PLEX_COUNT#0]) PLEX_XPOS#0 + (byte~) init::$8) ← (word) init::xp#2 -- pwuc1_derefidx_vbuaa=vwuz1 
    tay
    lda.z xp
    sta PLEX_XPOS,y
    lda.z xp+1
    sta PLEX_XPOS+1,y
    // xp += 9
    // [87] (word) init::xp#1 ← (word) init::xp#2 + (byte) 9 -- vwuz1=vwuz1_plus_vbuc1 
    lda #9
    clc
    adc.z xp
    sta.z xp
    bcc !+
    inc.z xp+1
  !:
    // for(byte sx: 0..PLEX_COUNT-1)
    // [88] (byte) init::sx#1 ← ++ (byte) init::sx#2 -- vbuxx=_inc_vbuxx 
    inx
    // [89] if((byte) init::sx#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto init::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
    // init::@2
    // *SPRITES_ENABLE = $ff
    // [90] *((const byte*) SPRITES_ENABLE#0) ← (byte) $ff -- _deref_pbuc1=vbuc2 
    // Enable & initialize sprites
    lda #$ff
    sta SPRITES_ENABLE
    // [91] phi from init::@2 to init::@3 [phi:init::@2->init::@3]
    // [91] phi (byte) init::ss#2 = (byte) 0 [phi:init::@2->init::@3#0] -- vbuxx=vbuc1 
    ldx #0
    // [91] phi from init::@3 to init::@3 [phi:init::@3->init::@3]
    // [91] phi (byte) init::ss#2 = (byte) init::ss#1 [phi:init::@3->init::@3#0] -- register_copy 
    // init::@3
  b3:
    // SPRITES_COLS[ss] = GREEN
    // [92] *((const byte*) SPRITES_COLS#0 + (byte) init::ss#2) ← (const byte) GREEN#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #GREEN
    sta SPRITES_COLS,x
    // for(byte ss: 0..7)
    // [93] (byte) init::ss#1 ← ++ (byte) init::ss#2 -- vbuxx=_inc_vbuxx 
    inx
    // [94] if((byte) init::ss#1!=(byte) 8) goto init::@3 -- vbuxx_neq_vbuc1_then_la1 
    cpx #8
    bne b3
    // init::@return
    // }
    // [95] return 
    rts
}
  // plexInit
// Initialize the multiplexer data structures
plexInit: {
    // [97] phi from plexInit to plexInit::plexSetScreen1 [phi:plexInit->plexInit::plexSetScreen1]
    // plexInit::plexSetScreen1
    // [98] phi from plexInit::plexSetScreen1 to plexInit::@1 [phi:plexInit::plexSetScreen1->plexInit::@1]
    // [98] phi (byte) plexInit::i#2 = (byte) 0 [phi:plexInit::plexSetScreen1->plexInit::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [98] phi from plexInit::@1 to plexInit::@1 [phi:plexInit::@1->plexInit::@1]
    // [98] phi (byte) plexInit::i#2 = (byte) plexInit::i#1 [phi:plexInit::@1->plexInit::@1#0] -- register_copy 
    // plexInit::@1
  b1:
    // PLEX_SORTED_IDX[i] = i
    // [99] *((const byte[PLEX_COUNT#0]) PLEX_SORTED_IDX#0 + (byte) plexInit::i#2) ← (byte) plexInit::i#2 -- pbuc1_derefidx_vbuxx=vbuxx 
    txa
    sta PLEX_SORTED_IDX,x
    // for(byte i: 0..PLEX_COUNT-1)
    // [100] (byte) plexInit::i#1 ← ++ (byte) plexInit::i#2 -- vbuxx=_inc_vbuxx 
    inx
    // [101] if((byte) plexInit::i#1!=(const byte) PLEX_COUNT#0-(byte) 1+(byte) 1) goto plexInit::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #PLEX_COUNT-1+1
    bne b1
    // plexInit::@return
    // }
    // [102] return 
    rts
}
  // File Data
  // Contains the Y-position where each sprite is free again. PLEX_FREE_YPOS[s] holds the Y-position where sprite s is free to use again.
  PLEX_FREE_YPOS: .fill 8, 0
  .align $100
YSIN:
.var min = 50
    .var max = 250-21
    .var ampl = max-min;
    .for(var i=0;i<256;i++)
        .byte round(min+(ampl/2)+(ampl/2)*sin(toRadians(360*i/256)))

  // The x-positions of the multiplexer sprites ($000-$1ff)
  PLEX_XPOS: .fill 2*PLEX_COUNT, 0
  // The y-positions of the multiplexer sprites.
  PLEX_YPOS: .fill PLEX_COUNT, 0
  // The sprite pointers for the multiplexed sprites
  PLEX_PTR: .fill PLEX_COUNT, 0
  // Indexes of the plex-sprites sorted by sprite y-position. Each call to plexSort() will fix the sorting if changes to the Y-positions have ruined it.
  PLEX_SORTED_IDX: .fill PLEX_COUNT, 0
.pc = SPRITE "SPRITE"
  .var pic = LoadPicture("balloon.png", List().add($000000, $ffffff))
    .for (var y=0; y<21; y++)
        .for (var x=0;x<3; x++)
            .byte pic.getSinglecolorByte(x,y)


