// Tetris Game Implementation
import "c64"
import "memory"
import "keyboard"
import "sid"
import "pieces"

// The size of the playfield
const byte PLAYFIELD_LINES = 22;
const byte PLAYFIELD_COLS = 10;

// The playfield.  0 is empty non-zero is color. 
// The playfield is layed out line by line, meaning the first 10 bytes are line 1, the next 10 line 2 and so forth, 
byte[PLAYFIELD_LINES*PLAYFIELD_COLS] playfield;

// Pointers to the playfield address for each playfield line
byte*[PLAYFIELD_LINES] playfield_lines;

// Indixes into the playfield  for each playfield line
byte[PLAYFIELD_LINES+1] playfield_lines_idx;

// The current moving piece. Points to the start of the piece definition.
byte* current_piece = 0;

// The curent piece orientation - each piece have 4 orientations (00/$10/$20/$30). 
// The orientation chooses one of the 4 sub-graphics of the piece.
byte current_orientation = 0; 

// Pointer to the current piece in the current orientation. Updated each time current_orientation is updated.
byte* current_piece_gfx = 0;

// The color of the current piece
byte current_piece_color = 0;

// Position of top left corner of current moving piece on the playfield
byte current_xpos = 3;
byte current_ypos = 0;

// The rate of moving down the current piece (number of frames between moves if movedown is  not forced)
const byte current_movedown_slow = 50;

// The rate of moving down the current piece fast (number of frames between moves if movedown is not forced)
const byte current_movedown_fast = 5;

// Counts up to the next movedown of current piece
byte current_movedown_counter = 0;

void main() {
	sid_rnd_init();
	asm { sei }
	render_init();
	tables_init();
	spawn_current();
	render_playfield();
	render_current();
	while(true) { 
		// Wait for a frame to pass
		while(*RASTER!=$ff) {}
		while(*RASTER!=$fe) {}
		(*BORDERCOL)++;
		// Scan keyboard events
		keyboard_event_scan();
		byte key_event = keyboard_event_get();
		byte render = 0;
		render += play_move_down(key_event);
		render += play_move_leftright(key_event);
		render += play_move_rotate(key_event);
		if(render!=0) {
			render_playfield();
			render_current();
		}
		(*BORDERCOL)--;			
	}
}

// Move down the current piece 
// Return non-zero if a render is needed 
byte play_move_down(byte key_event) {
		// Handle moving down current piece	
		++current_movedown_counter;
		byte movedown = 0;
		// As soon as space is pressed move down once
		if(key_event==KEY_SPACE) {
			movedown++;
		} 
		// While space is held down move down faster
		if(keyboard_event_pressed(KEY_SPACE)!=0) {
			if(current_movedown_counter>=current_movedown_fast) {
				movedown++;
			}
		} 
		// Move down slowly otherwise
		if(current_movedown_counter>=current_movedown_slow) {
			movedown++;
		}
		// Attempt movedown 
		if(movedown!=0) {
			if(collision(current_xpos,current_ypos+1,current_orientation)==COLLISION_NONE) {
				// Move current piece down
				current_ypos++;
			} else {
				// Lock current piece 
				lock_current();
				// Check for new lines
				remove_lines();
				// Spawn a new piece
				spawn_current();
			}
			current_movedown_counter = 0;
			return 1;								
		}
		return 0;			
}

// Move left/right or rotate the current piece
// Return non-zero if a render is needed 
byte play_move_leftright(byte key_event) {
		// Handle keyboard events 
		if(key_event==KEY_COMMA) {
			if(collision(current_xpos-1,current_ypos,current_orientation)==COLLISION_NONE) {				
				current_xpos--;
				return 1;
			}
		} else if(key_event==KEY_DOT) {
			if(collision(current_xpos+1,current_ypos,current_orientation)==COLLISION_NONE) {				
				current_xpos++;
				return 1;
			}
		} 
		return 0;
}

// Rotate the current piece  based on key-presses
// Return non-zero if a render is needed 
byte play_move_rotate(byte key_event) {
	// Handle keyboard events 
	byte orientation = $80;
	if(key_event==KEY_Z) {
		orientation = (current_orientation-$10)&$3f;
	} else if(key_event==KEY_X) {
		orientation = (current_orientation+$10)&$3f;
	} else {
		return 0;
	}
	if(collision(current_xpos, current_ypos, orientation) == COLLISION_NONE) {
		current_orientation = orientation;
		current_piece_gfx = current_piece + current_orientation;
		return 1;
	}
	return 0;
}

// No collision
const byte COLLISION_NONE = 0;
// Playfield piece collision (cell on top of other cell on the playfield)
const byte COLLISION_PLAYFIELD = 1;
// Bottom collision (cell below bottom of the playfield)
const byte COLLISION_BOTTOM = 2;
// Left side collision (cell beyond the left side of the playfield)
const byte COLLISION_LEFT = 4;
// Right side collision (cell beyond the right side of the playfield)
const byte COLLISION_RIGHT = 8;

// Test if there is a collision between the current piece moved to (x, y) and anything on the playfield or the playfield boundaries
// Returns information about the type of the collision detected 
byte collision(byte xpos, byte ypos, byte orientation) {
	byte* piece_gfx = current_piece + orientation;
	byte i = 0;
	byte ypos2 = ypos<<1;
	for(byte l:0..3) {
		byte* playfield_line = playfield_lines[ypos2];
		byte col = xpos;
		for(byte c:0..3) {
			if(piece_gfx[i++]!=0) {
				if(ypos2>=2*PLAYFIELD_LINES) {
					// Below the playfield bottom
					return COLLISION_BOTTOM;
				}
				if((col&$80)!=0) {
					// Beyond left side of the playfield
					return COLLISION_LEFT;					
				}
				if(col>=PLAYFIELD_COLS) {
					// Beyond left side of the playfield
					return COLLISION_RIGHT;					
				}
				if(playfield_line[col]!=0) {
					// Collision with a playfield cell
					return COLLISION_PLAYFIELD;
				}
			}
			col++;
		}
		ypos2 += 2;		
	}
	return COLLISION_NONE;
}

// Lock the current piece onto the playfield
void lock_current() {
	byte i = 0;
	byte ypos2 = current_ypos<<1;
	for(byte l:0..3) {		
		byte* playfield_line = playfield_lines[ypos2];
		byte col = current_xpos;
		for(byte c:0..3) {
			if(current_piece_gfx[i++]!=0) {
				playfield_line[col] = current_piece_color;
			}
			col++;
		}
		ypos2 += 2;
	}
}

// Spawn a new piece
void spawn_current() {
	// Pick a random piece
	byte piece_idx = 7;
	while(piece_idx==7) {
		piece_idx = sid_rnd()&7;
	}
	current_piece = PIECES[piece_idx<<1];
	current_orientation = 0;
	current_piece_gfx = current_piece + current_orientation;
	current_xpos = 3;
	current_ypos = 0;
	current_piece_color = PIECES_COLORS[piece_idx];
}

// Look through the playfield for lines - and remove any lines found
// Utilizes two cursors on the playfield - one reading cells and one writing cells
// Whenever a full line is detected the writing cursor is instructed to write to the same line once more.  
void remove_lines() {
	// Start both cursors at the end of the playfield
	byte r = PLAYFIELD_LINES*PLAYFIELD_COLS-1;
	byte w = PLAYFIELD_LINES*PLAYFIELD_COLS-1;

	// Read all lines and rewrite them
	for(byte y:0..PLAYFIELD_LINES-1) {
		byte full = 1;
		for(byte x:0..PLAYFIELD_COLS-1) {
			byte c = playfield[r--];
			if(c==0) {
				full = 0;
			}
			playfield[w--] = c;
		}
		// If the line is full then re-write it.
		if(full==1) {						
			w = w + PLAYFIELD_COLS;
		}
	}

	// Write zeros in the rest of the lines
	while(w!=$ff) {
		playfield[w--] = 0;		
	}
}

// Initialize data tables 
void tables_init() {
	// Initialize the playfield line pointers;
	byte idx = 0;
	byte* pli = playfield;
	for(byte j:0..PLAYFIELD_LINES-1) {
		playfield_lines[j<<1] = pli;
		playfield_lines_idx[j] = idx;
		pli += PLAYFIELD_COLS;
		idx += PLAYFIELD_COLS;
	}
	playfield_lines_idx[PLAYFIELD_LINES] = PLAYFIELD_COLS*PLAYFIELD_LINES;

}

// The screen
byte* SCREEN = $400;	

// Pointers to the screen address for rendering each playfield line
byte*[PLAYFIELD_LINES+3] screen_lines;

// Initialize rendering
void render_init() {
	// Clear the screen
	fill(SCREEN,1000,$a0);
	fill(COLS,1000,BLACK);
	// Initialize the screen line pointers;
	byte* li = COLS + 40 + 15;
	for(byte i:0..PLAYFIELD_LINES+2) {
		screen_lines[i<<1] = li;
		li += 40;
	}
	// Prepare the playfield frame
	byte* line = COLS + 14;
	for(byte l:0..PLAYFIELD_LINES+1) {
		for(byte c:0..PLAYFIELD_COLS+1) {
			*(line+c) = DARK_GREY;
		}
		line +=40;
	}

}

// Render the static playfield on the screen
void render_playfield() {
	byte i = 0;
	for(byte l:0..PLAYFIELD_LINES-1) {		
		byte* line = screen_lines[l<<1];
		for(byte c:0..PLAYFIELD_COLS-1) {
			*(line++) = playfield[i++];
		}
	}	
}

// Render the current moving piece at position (current_xpos, current_ypos)
void render_current() {
	byte i = 0;
	byte ypos2 = current_ypos<<1;
	for(byte l:0..3) {		
		if(ypos2<2*PLAYFIELD_LINES) {
			byte* screen_line = screen_lines[ypos2];
			byte xpos = current_xpos;
			for(byte c:0..3) {
				byte current_cell = current_piece_gfx[i++];
				if(current_cell!=0) {
					if(xpos<PLAYFIELD_COLS) {
						screen_line[xpos] = current_piece_color;
					}
				}
				xpos++;
			}
		}
		ypos2 += 2;
	}
}