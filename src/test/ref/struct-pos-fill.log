Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  y#13 = phi( __start::@1/y#12 )
  idx#12 = phi( __start::@1/idx#11 )
  row#13 = phi( __start::@1/row#12 )
  x#14 = phi( __start::@1/x#13 )
  line#0 = 0
  to:main::@1
main::@1: scope:[main]  from main main::@5
  y#11 = phi( main/y#13, main::@5/y#0 )
  idx#10 = phi( main/idx#12, main::@5/idx#13 )
  row#11 = phi( main/row#13, main::@5/row#14 )
  x#11 = phi( main/x#14, main::@5/x#15 )
  line#6 = phi( main/line#0, main::@5/line#1 )
  main::$0 = line#6 < 8
  if(main::$0) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  line#13 = phi( main::@1/line#6 )
  y#14 = phi( main::@1/y#11 )
  idx#14 = phi( main::@1/idx#10 )
  x#6 = phi( main::@1/x#11 )
  x#0 = ++ x#6
  row#0 = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  line#11 = phi( main::@2/line#13, main::@4/line#14 )
  x#12 = phi( main::@2/x#0, main::@4/x#1 )
  y#10 = phi( main::@2/y#14, main::@4/y#5 )
  idx#9 = phi( main::@2/idx#14, main::@4/idx#0 )
  row#6 = phi( main::@2/row#0, main::@4/row#1 )
  main::$1 = row#6 < 8
  if(main::$1) goto main::@4
  to:main::@5
main::@4: scope:[main]  from main::@3
  line#14 = phi( main::@3/line#11 )
  row#7 = phi( main::@3/row#6 )
  x#7 = phi( main::@3/x#12 )
  y#5 = phi( main::@3/y#10 )
  idx#5 = phi( main::@3/idx#9 )
  main::$2 = idx#5 * SIZEOF_STRUCT_POS
  ((byte*)p+OFFSET_STRUCT_POS_Y)[main::$2] = y#5
  main::$3 = idx#5 * SIZEOF_STRUCT_POS
  ((byte*)p+OFFSET_STRUCT_POS_X)[main::$3] = x#7
  idx#0 = ++ idx#5
  x#1 = x#7 + XSPACE
  row#1 = ++ row#7
  to:main::@3
main::@5: scope:[main]  from main::@3
  idx#13 = phi( main::@3/idx#9 )
  row#14 = phi( main::@3/row#6 )
  x#15 = phi( main::@3/x#12 )
  line#7 = phi( main::@3/line#11 )
  y#6 = phi( main::@3/y#10 )
  y#0 = y#6 + YSPACE
  line#1 = ++ line#7
  to:main::@1
main::@return: scope:[main]  from main::@1
  y#7 = phi( main::@1/y#11 )
  idx#6 = phi( main::@1/idx#10 )
  row#8 = phi( main::@1/row#11 )
  x#8 = phi( main::@1/x#11 )
  line#8 = phi( main::@1/line#6 )
  line#2 = line#8
  x#2 = x#8
  row#2 = row#8
  idx#1 = idx#6
  y#1 = y#7
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#2 = 0
  line#3 = 0
  row#3 = 0
  x#3 = 0
  y#2 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  y#12 = phi( __start::__init1/y#2 )
  idx#11 = phi( __start::__init1/idx#2 )
  row#12 = phi( __start::__init1/row#3 )
  x#13 = phi( __start::__init1/x#3 )
  line#12 = phi( __start::__init1/line#3 )
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  y#8 = phi( __start::@1/y#1 )
  idx#7 = phi( __start::@1/idx#1 )
  row#9 = phi( __start::@1/row#2 )
  x#9 = phi( __start::@1/x#2 )
  line#9 = phi( __start::@1/line#2 )
  line#4 = line#9
  x#4 = x#9
  row#4 = row#9
  idx#3 = idx#7
  y#3 = y#8
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  y#9 = phi( __start::@2/y#3 )
  x#10 = phi( __start::@2/x#4 )
  row#10 = phi( __start::@2/row#4 )
  line#10 = phi( __start::@2/line#4 )
  idx#8 = phi( __start::@2/idx#3 )
  idx#4 = idx#8
  line#5 = line#10
  row#5 = row#10
  x#5 = x#10
  y#4 = y#9
  return 
  to:@return

SYMBOL TABLE SSA
const byte OFFSET_STRUCT_POS_X = 0
const byte OFFSET_STRUCT_POS_Y = 1
const byte SIZEOF_STRUCT_POS = 2
const byte XSPACE = $14
const byte YSPACE = $14
void __start()
byte idx
byte idx#0
byte idx#1
byte idx#10
byte idx#11
byte idx#12
byte idx#13
byte idx#14
byte idx#2
byte idx#3
byte idx#4
byte idx#5
byte idx#6
byte idx#7
byte idx#8
byte idx#9
byte line
byte line#0
byte line#1
byte line#10
byte line#11
byte line#12
byte line#13
byte line#14
byte line#2
byte line#3
byte line#4
byte line#5
byte line#6
byte line#7
byte line#8
byte line#9
void main()
bool~ main::$0
bool~ main::$1
byte~ main::$2
byte~ main::$3
const struct pos* p[$40]  = { fill( $40, 0) }
byte row
byte row#0
byte row#1
byte row#10
byte row#11
byte row#12
byte row#13
byte row#14
byte row#2
byte row#3
byte row#4
byte row#5
byte row#6
byte row#7
byte row#8
byte row#9
byte x
byte x#0
byte x#1
byte x#10
byte x#11
byte x#12
byte x#13
byte x#14
byte x#15
byte x#2
byte x#3
byte x#4
byte x#5
byte x#6
byte x#7
byte x#8
byte x#9
byte y
byte y#0
byte y#1
byte y#10
byte y#11
byte y#12
byte y#13
byte y#14
byte y#2
byte y#3
byte y#4
byte y#5
byte y#6
byte y#7
byte y#8
byte y#9

Adding number conversion cast (unumber) 0 in line#0 = 0
Adding number conversion cast (unumber) 8 in main::$0 = line#6 < 8
Adding number conversion cast (unumber) 0 in row#0 = 0
Adding number conversion cast (unumber) 8 in main::$1 = row#6 < 8
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast line#0 = (unumber)0
Inlining cast row#0 = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Simplifying constant integer cast 8
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type 0
Finalized unsigned number type 8
Finalized unsigned number type 0
Finalized unsigned number type 8
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias x#11 = x#6 x#8 x#2 
Alias idx#1 = idx#14 idx#10 idx#6 
Alias y#1 = y#14 y#11 y#7 
Alias line#13 = line#6 line#8 line#2 
Alias idx#13 = idx#5 idx#9 
Alias y#10 = y#5 y#6 
Alias x#12 = x#7 x#15 
Alias row#14 = row#7 row#6 
Alias line#11 = line#14 line#7 
Alias row#11 = row#8 row#2 
Alias line#12 = line#3 
Alias x#13 = x#3 
Alias row#12 = row#3 
Alias idx#11 = idx#2 
Alias y#12 = y#2 
Alias line#10 = line#4 line#9 line#5 
Alias x#10 = x#4 x#9 x#5 
Alias row#10 = row#4 row#9 row#5 
Alias idx#3 = idx#7 idx#8 idx#4 
Alias y#3 = y#8 y#9 y#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values x#14 x#13
Identical Phi Values row#13 row#12
Identical Phi Values idx#12 idx#11
Identical Phi Values y#13 y#12
Identical Phi Values y#10 y#1
Identical Phi Values line#11 line#13
Identical Phi Values line#10 line#13
Identical Phi Values x#10 x#11
Identical Phi Values row#10 row#11
Identical Phi Values idx#3 idx#1
Identical Phi Values y#3 y#1
Successful SSA optimization Pass2IdenticalPhiElimination
Identified duplicate assignment right side [14] main::$3 = idx#13 * SIZEOF_STRUCT_POS
Successful SSA optimization Pass2DuplicateRValueIdentification
Simple Condition main::$0 [4] if(line#13<8) goto main::@2
Simple Condition main::$1 [9] if(row#14<8) goto main::@4
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant line#0 = 0
Constant row#0 = 0
Constant idx#11 = 0
Constant line#12 = 0
Constant row#12 = 0
Constant x#13 = 0
Constant y#12 = 0
Successful SSA optimization Pass2ConstantIdentification
Simplifying expression containing zero (byte*)p in [13] ((byte*)p+OFFSET_STRUCT_POS_X)[main::$3] = x#12
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable - keeping the phi block row#11
Eliminating unused constant OFFSET_STRUCT_POS_X
Eliminating unused constant line#12
Successful SSA optimization PassNEliminateUnusedVars
Eliminating unused constant row#12
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Alias main::$3 = main::$2 
Successful SSA optimization Pass2AliasElimination
Rewriting multiplication to use shift [5] main::$3 = idx#13 * SIZEOF_STRUCT_POS
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings line#0
Inlining constant with var siblings row#0
Inlining constant with var siblings idx#11
Inlining constant with var siblings x#13
Inlining constant with var siblings y#12
Constant inlined x#13 = 0
Constant inlined idx#11 = 0
Constant inlined y#12 = 0
Constant inlined row#0 = 0
Constant inlined line#0 = 0
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant SIZEOF_STRUCT_POS
Successful SSA optimization PassNEliminateUnusedVars
Finalized unsigned number type $40
Finalized unsigned number type $40
Successful SSA optimization Pass2FinalizeAllNumbers
Adding NOP phi() at start of main
CALL GRAPH

Created 7 initial phi equivalence classes
Coalesced [5] idx#16 = idx#1
Coalesced [6] x#17 = x#0
Coalesced [11] line#15 = line#1
Coalesced [12] x#16 = x#12
Coalesced (already) [13] idx#15 = idx#13
Coalesced [14] y#15 = y#0
Coalesced [21] row#15 = row#1
Coalesced [22] idx#17 = idx#0
Coalesced [23] x#18 = x#1
Coalesced down to 5 phi equivalence classes
Adding NOP phi() at start of main

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [1] y#1 = phi( main/0, main::@5/y#0 )
  [1] idx#1 = phi( main/0, main::@5/idx#13 )
  [1] x#11 = phi( main/0, main::@5/x#12 )
  [1] line#13 = phi( main/0, main::@5/line#1 )
  [2] if(line#13<8) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@1
  [3] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [4] x#0 = ++ x#11
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [5] x#12 = phi( main::@2/x#0, main::@4/x#1 )
  [5] idx#13 = phi( main::@2/idx#1, main::@4/idx#0 )
  [5] row#14 = phi( main::@2/0, main::@4/row#1 )
  [6] if(row#14<8) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [7] y#0 = y#1 + YSPACE
  [8] line#1 = ++ line#13
  to:main::@1
main::@4: scope:[main]  from main::@3
  [9] main::$3 = idx#13 << 1
  [10] ((byte*)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1
  [11] ((byte*)p)[main::$3] = x#12
  [12] idx#0 = ++ idx#13
  [13] x#1 = x#12 + XSPACE
  [14] row#1 = ++ row#14
  to:main::@3


VARIABLE REGISTER WEIGHTS
byte idx
byte idx#0 67.33333333333333
byte idx#1 7.333333333333333
byte idx#13 46.42857142857143
byte line
byte line#1 22.0
byte line#13 2.75
void main()
byte~ main::$3 151.5
byte row
byte row#1 202.0
byte row#14 43.285714285714285
byte x
byte x#0 22.0
byte x#1 101.0
byte x#11 11.0
byte x#12 40.625
byte y
byte y#0 11.0
byte y#1 11.181818181818182

Initial phi equivalence classes
[ line#13 line#1 ]
[ x#11 x#12 x#0 x#1 ]
[ idx#1 idx#13 idx#0 ]
[ y#1 y#0 ]
[ row#14 row#1 ]
Added variable main::$3 to live range equivalence class [ main::$3 ]
Complete equivalence classes
[ line#13 line#1 ]
[ x#11 x#12 x#0 x#1 ]
[ idx#1 idx#13 idx#0 ]
[ y#1 y#0 ]
[ row#14 row#1 ]
[ main::$3 ]
Allocated zp[1]:2 [ line#13 line#1 ]
Allocated zp[1]:3 [ x#11 x#12 x#0 x#1 ]
Allocated zp[1]:4 [ idx#1 idx#13 idx#0 ]
Allocated zp[1]:5 [ y#1 y#0 ]
Allocated zp[1]:6 [ row#14 row#1 ]
Allocated zp[1]:7 [ main::$3 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [7] y#0 = y#1 + YSPACE [ line#13 x#12 idx#13 y#0 ] (  [ line#13 x#12 idx#13 y#0 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ line#13 line#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:3 [ x#11 x#12 x#0 x#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:4 [ idx#1 idx#13 idx#0 ]
Statement [9] main::$3 = idx#13 << 1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ y#1 y#0 ]
Removing always clobbered register reg byte a as potential for zp[1]:6 [ row#14 row#1 ]
Statement [10] ((byte*)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:7 [ main::$3 ]
Statement [11] ((byte*)p)[main::$3] = x#12 [ line#13 y#1 x#12 idx#13 row#14 ] (  [ line#13 y#1 x#12 idx#13 row#14 ] { }  ) always clobbers reg byte a 
Statement [13] x#1 = x#12 + XSPACE [ line#13 y#1 row#14 idx#0 x#1 ] (  [ line#13 y#1 row#14 idx#0 x#1 ] { }  ) always clobbers reg byte a 
Statement [7] y#0 = y#1 + YSPACE [ line#13 x#12 idx#13 y#0 ] (  [ line#13 x#12 idx#13 y#0 ] { }  ) always clobbers reg byte a 
Statement [9] main::$3 = idx#13 << 1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Statement [10] ((byte*)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] (  [ line#13 y#1 x#12 idx#13 row#14 main::$3 ] { }  ) always clobbers reg byte a 
Statement [11] ((byte*)p)[main::$3] = x#12 [ line#13 y#1 x#12 idx#13 row#14 ] (  [ line#13 y#1 x#12 idx#13 row#14 ] { }  ) always clobbers reg byte a 
Statement [13] x#1 = x#12 + XSPACE [ line#13 y#1 row#14 idx#0 x#1 ] (  [ line#13 y#1 row#14 idx#0 x#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ line#13 line#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[1]:3 [ x#11 x#12 x#0 x#1 ] : zp[1]:3 , reg byte x , reg byte y , 
Potential registers zp[1]:4 [ idx#1 idx#13 idx#0 ] : zp[1]:4 , reg byte x , reg byte y , 
Potential registers zp[1]:5 [ y#1 y#0 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[1]:6 [ row#14 row#1 ] : zp[1]:6 , reg byte x , reg byte y , 
Potential registers zp[1]:7 [ main::$3 ] : zp[1]:7 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [] 245.29: zp[1]:6 [ row#14 row#1 ] 174.62: zp[1]:3 [ x#11 x#12 x#0 x#1 ] 121.1: zp[1]:4 [ idx#1 idx#13 idx#0 ] 24.75: zp[1]:2 [ line#13 line#1 ] 22.18: zp[1]:5 [ y#1 y#0 ] 
Uplift Scope [main] 151.5: zp[1]:7 [ main::$3 ] 
Uplift Scope [pos] 

Uplifting [] best 7501 combination zp[1]:6 [ row#14 row#1 ] zp[1]:3 [ x#11 x#12 x#0 x#1 ] zp[1]:4 [ idx#1 idx#13 idx#0 ] zp[1]:2 [ line#13 line#1 ] zp[1]:5 [ y#1 y#0 ] 
Limited combination testing to 100 combinations of 243 possible.
Uplifting [main] best 6801 combination reg byte x [ main::$3 ] 
Uplifting [pos] best 6801 combination 
Attempting to uplift remaining variables inzp[1]:6 [ row#14 row#1 ]
Uplifting [] best 5901 combination reg byte y [ row#14 row#1 ] 
Attempting to uplift remaining variables inzp[1]:3 [ x#11 x#12 x#0 x#1 ]
Uplifting [] best 5901 combination zp[1]:3 [ x#11 x#12 x#0 x#1 ] 
Attempting to uplift remaining variables inzp[1]:4 [ idx#1 idx#13 idx#0 ]
Uplifting [] best 5901 combination zp[1]:4 [ idx#1 idx#13 idx#0 ] 
Attempting to uplift remaining variables inzp[1]:2 [ line#13 line#1 ]
Uplifting [] best 5901 combination zp[1]:2 [ line#13 line#1 ] 
Attempting to uplift remaining variables inzp[1]:5 [ y#1 y#0 ]
Uplifting [] best 5901 combination zp[1]:5 [ y#1 y#0 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 3
  .label idx = 4
  .label y = 5
  .label line = 2
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi y#1 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi idx#1 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // [1] phi x#11 = 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    lda #0
    sta.z x
    // [1] phi line#13 = 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    lda #0
    sta.z line
    jmp __b1
    // main::@1
  __b1:
    // [2] if(line#13<8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    jmp __breturn
    // main::@return
  __breturn:
    // [3] return 
    rts
    // main::@2
  __b2:
    // [4] x#0 = ++ x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
  __b3_from___b2:
    // [5] phi x#12 = x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi row#14 = 0 [phi:main::@2->main::@3#2] -- vbuyy=vbuc1 
    ldy #0
    jmp __b3
    // main::@3
  __b3:
    // [6] if(row#14<8) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #8
    bcc __b4
    jmp __b5
    // main::@5
  __b5:
    // [7] y#0 = y#1 + YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // [8] line#1 = ++ line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  __b1_from___b5:
    // [1] phi y#1 = y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi idx#1 = idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi x#11 = x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi line#13 = line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // [9] main::$3 = idx#13 << 1 -- vbuxx=vbuz1_rol_1 
    lda.z idx
    asl
    tax
    // [10] ((byte*)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z y
    sta p+OFFSET_STRUCT_POS_Y,x
    // [11] ((byte*)p)[main::$3] = x#12 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z x
    sta p,x
    // [12] idx#0 = ++ idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [13] x#1 = x#12 + XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // [14] row#1 = ++ row#14 -- vbuyy=_inc_vbuyy 
    iny
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
  __b3_from___b4:
    // [5] phi x#12 = x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi row#14 = row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
  p: .fill 2*$40, 0

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b3
Removing instruction jmp __b5
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction __b1_from_main:
Removing instruction __breturn:
Removing instruction __b3_from___b2:
Removing instruction __b5:
Removing instruction __b1_from___b5:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
const byte OFFSET_STRUCT_POS_Y = 1
const byte XSPACE = $14
const byte YSPACE = $14
byte idx
byte idx#0 idx zp[1]:4 67.33333333333333
byte idx#1 idx zp[1]:4 7.333333333333333
byte idx#13 idx zp[1]:4 46.42857142857143
byte line
byte line#1 line zp[1]:2 22.0
byte line#13 line zp[1]:2 2.75
void main()
byte~ main::$3 reg byte x 151.5
const struct pos* p[$40]  = { fill( $40, 0) }
byte row
byte row#1 reg byte y 202.0
byte row#14 reg byte y 43.285714285714285
byte x
byte x#0 x zp[1]:3 22.0
byte x#1 x zp[1]:3 101.0
byte x#11 x zp[1]:3 11.0
byte x#12 x zp[1]:3 40.625
byte y
byte y#0 y zp[1]:5 11.0
byte y#1 y zp[1]:5 11.181818181818182

zp[1]:2 [ line#13 line#1 ]
zp[1]:3 [ x#11 x#12 x#0 x#1 ]
zp[1]:4 [ idx#1 idx#13 idx#0 ]
zp[1]:5 [ y#1 y#0 ]
reg byte y [ row#14 row#1 ]
reg byte x [ main::$3 ]


FINAL ASSEMBLER
Score: 5181

  // File Comments
// Example of structs that can be optimized by going planar
// https://cc65.github.io/mailarchive/2010-09/8593.html?fbclid=IwAR1IF_cTdyWcFeKU93VfL2Un1EuLjkGh7O7dQ4EVj4kpJzJAj01dbmEFQt8
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .const OFFSET_STRUCT_POS_Y = 1
  .const XSPACE = $14
  .const YSPACE = $14
  .label x = 3
  .label idx = 4
  .label y = 5
  .label line = 2
  // main
main: {
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi y#1 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z y
    // [1] phi idx#1 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    sta.z idx
    // [1] phi x#11 = 0 [phi:main->main::@1#2] -- vbuz1=vbuc1 
    sta.z x
    // [1] phi line#13 = 0 [phi:main->main::@1#3] -- vbuz1=vbuc1 
    sta.z line
    // main::@1
  __b1:
    // for (line=0;line<8;++line)
    // [2] if(line#13<8) goto main::@2 -- vbuz1_lt_vbuc1_then_la1 
    lda.z line
    cmp #8
    bcc __b2
    // main::@return
    // }
    // [3] return 
    rts
    // main::@2
  __b2:
    // ++x;
    // [4] x#0 = ++ x#11 -- vbuz1=_inc_vbuz1 
    inc.z x
    // [5] phi from main::@2 to main::@3 [phi:main::@2->main::@3]
    // [5] phi x#12 = x#0 [phi:main::@2->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#1 [phi:main::@2->main::@3#1] -- register_copy 
    // [5] phi row#14 = 0 [phi:main::@2->main::@3#2] -- vbuyy=vbuc1 
    ldy #0
    // main::@3
  __b3:
    // for (row=0;row<8;++row)
    // [6] if(row#14<8) goto main::@4 -- vbuyy_lt_vbuc1_then_la1 
    cpy #8
    bcc __b4
    // main::@5
    // y+=YSPACE
    // [7] y#0 = y#1 + YSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z y
    axs #-[YSPACE]
    stx.z y
    // for (line=0;line<8;++line)
    // [8] line#1 = ++ line#13 -- vbuz1=_inc_vbuz1 
    inc.z line
    // [1] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [1] phi y#1 = y#0 [phi:main::@5->main::@1#0] -- register_copy 
    // [1] phi idx#1 = idx#13 [phi:main::@5->main::@1#1] -- register_copy 
    // [1] phi x#11 = x#12 [phi:main::@5->main::@1#2] -- register_copy 
    // [1] phi line#13 = line#1 [phi:main::@5->main::@1#3] -- register_copy 
    jmp __b1
    // main::@4
  __b4:
    // p[idx].y=y
    // [9] main::$3 = idx#13 << 1 -- vbuxx=vbuz1_rol_1 
    lda.z idx
    asl
    tax
    // [10] ((byte*)p+OFFSET_STRUCT_POS_Y)[main::$3] = y#1 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z y
    sta p+OFFSET_STRUCT_POS_Y,x
    // p[idx].x=x
    // [11] ((byte*)p)[main::$3] = x#12 -- pbuc1_derefidx_vbuxx=vbuz1 
    lda.z x
    sta p,x
    // ++idx;
    // [12] idx#0 = ++ idx#13 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // x+=XSPACE
    // [13] x#1 = x#12 + XSPACE -- vbuz1=vbuz1_plus_vbuc1 
    lax.z x
    axs #-[XSPACE]
    stx.z x
    // for (row=0;row<8;++row)
    // [14] row#1 = ++ row#14 -- vbuyy=_inc_vbuyy 
    iny
    // [5] phi from main::@4 to main::@3 [phi:main::@4->main::@3]
    // [5] phi x#12 = x#1 [phi:main::@4->main::@3#0] -- register_copy 
    // [5] phi idx#13 = idx#0 [phi:main::@4->main::@3#1] -- register_copy 
    // [5] phi row#14 = row#1 [phi:main::@4->main::@3#2] -- register_copy 
    jmp __b3
}
  // File Data
  p: .fill 2*$40, 0

