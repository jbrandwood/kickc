Fixing struct type size struct MOS6532_RIOT to 24
Fixing struct type SIZE_OF struct MOS6532_RIOT to 24
Fixing struct type SIZE_OF struct MOS6532_RIOT to 24
Inlined call call __init

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  idx#12 = phi( __start::@1/idx#11 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55
  to:main::@1
main::@1: scope:[main]  from main main::@9
  idx#10 = phi( main/idx#12, main::@9/idx#13 )
  main::$1 = 0 != 1
  if(main::$1) goto main::@2
  to:main::@return
main::@2: scope:[main]  from main::@1
  idx#14 = phi( main::@1/idx#10 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = 2
  *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  idx#9 = phi( main::@2/idx#14, main::@4/idx#15 )
  main::$2 = 0 != *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)
  if(main::$2) goto main::@4
  to:main::@5
main::@4: scope:[main]  from main::@3
  idx#15 = phi( main::@3/idx#9 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  to:main::@3
main::@5: scope:[main]  from main::@3
  idx#5 = phi( main::@3/idx#9 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0
  main::c#0 = SINTABLE[idx#5]
  idx#0 = ++ idx#5
  main::i#0 = 0
  to:main::@6
main::@6: scope:[main]  from main::@5 main::@7
  idx#18 = phi( main::@5/idx#0, main::@7/idx#19 )
  main::c#3 = phi( main::@5/main::c#0, main::@7/main::c#1 )
  main::i#2 = phi( main::@5/main::i#0, main::@7/main::i#1 )
  main::$0 = main::i#2 < $c0
  if(main::$0) goto main::@7
  to:main::@8
main::@7: scope:[main]  from main::@6
  idx#19 = phi( main::@6/idx#18 )
  main::i#3 = phi( main::@6/main::i#2 )
  main::c#2 = phi( main::@6/main::c#3 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = main::c#2
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = main::c#2
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = main::c#2
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = main::c#2
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE) = main::c#2
  main::c#1 = ++ main::c#2
  main::i#1 = ++ main::i#3
  to:main::@6
main::@8: scope:[main]  from main::@6
  idx#17 = phi( main::@6/idx#18 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0
  *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40
  to:main::@9
main::@9: scope:[main]  from main::@10 main::@8
  idx#13 = phi( main::@10/idx#16, main::@8/idx#17 )
  main::$3 = 0 != *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)
  if(main::$3) goto main::@10
  to:main::@1
main::@10: scope:[main]  from main::@9
  idx#16 = phi( main::@9/idx#13 )
  *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  to:main::@9
main::@return: scope:[main]  from main::@1
  idx#6 = phi( main::@1/idx#10 )
  idx#1 = idx#6
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  idx#2 = 0
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  idx#11 = phi( __start::__init1/idx#2 )
  call main
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  idx#7 = phi( __start::@1/idx#1 )
  idx#3 = idx#7
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  idx#8 = phi( __start::@2/idx#3 )
  idx#4 = idx#8
  return 
  to:@return

SYMBOL TABLE SSA
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK = 9
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF = 8
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE = $2a
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_PF0 = $d
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_PF1 = $e
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_PF2 = $f
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK = 1
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC = 0
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC = 2
__constant char OFFSET_STRUCT_MOS6532_RIOT_INTIM = 4
__constant char OFFSET_STRUCT_MOS6532_RIOT_TIM64T = $16
__constant struct MOS6532_RIOT * const RIOT = (struct MOS6532_RIOT *)$280
__constant const char SINTABLE[$100] = kickasm {{ .fill $100, round(127.5+127.5*sin(2*PI*i/256))
 }}
__constant struct ATARI_TIA_WRITE * const TIA = (struct ATARI_TIA_WRITE *)0
void __start()
char idx
char idx#0
char idx#1
char idx#10
char idx#11
char idx#12
char idx#13
char idx#14
char idx#15
char idx#16
char idx#17
char idx#18
char idx#19
char idx#2
char idx#3
char idx#4
char idx#5
char idx#6
char idx#7
char idx#8
char idx#9
void main()
bool main::$0
bool main::$1
bool main::$2
bool main::$3
char main::c
char main::c#0
char main::c#1
char main::c#2
char main::c#3
char main::i
char main::i#0
char main::i#1
char main::i#2
char main::i#3

Adding number conversion cast (unumber) $a0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0
Adding number conversion cast (unumber) $55 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55
Adding number conversion cast (unumber) $aa in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa
Adding number conversion cast (unumber) $55 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55
Adding number conversion cast (unumber) 2 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = 2
Adding number conversion cast (unumber) $29*$4c/$40 in *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = 0
Adding number conversion cast (unumber) 0 in main::$2 = 0 != *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0
Adding number conversion cast (unumber) $c0 in main::$0 = main::i#2 < $c0
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Adding number conversion cast (unumber) 2 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0
Adding number conversion cast (unumber) $1b*$4c/$40 in *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40
Adding number conversion cast (unumber) 0 in main::$3 = 0 != *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)
Adding number conversion cast (unumber) 0 in *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = (unumber)$a0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = (unumber)$55
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = (unumber)$aa
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = (unumber)$55
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = (unumber)2
Inlining cast *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = (unumber)$29*$4c/$40
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = (unumber)2
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = (unumber)0
Inlining cast *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = (unumber)$1b*$4c/$40
Inlining cast *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = (unumber)0
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (struct ATARI_TIA_WRITE *) 0
Simplifying constant pointer cast (struct MOS6532_RIOT *) 640
Simplifying constant integer cast $a0
Simplifying constant integer cast $55
Simplifying constant integer cast $aa
Simplifying constant integer cast $55
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast $c0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (char) $a0
Finalized unsigned number type (char) $55
Finalized unsigned number type (char) $aa
Finalized unsigned number type (char) $55
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) $c0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 2
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Finalized unsigned number type (char) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Alias idx#1 = idx#14 idx#10 idx#6 
Alias idx#15 = idx#9 idx#5 
Alias main::c#2 = main::c#3 
Alias main::i#2 = main::i#3 
Alias idx#17 = idx#19 idx#18 
Alias idx#13 = idx#16 
Alias idx#11 = idx#2 
Alias idx#3 = idx#7 idx#8 idx#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values idx#12 idx#11
Identical Phi Values idx#15 idx#1
Identical Phi Values idx#17 idx#0
Identical Phi Values idx#13 idx#17
Identical Phi Values idx#3 idx#1
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$1 [7] if(0!=1) goto main::@2
Simple Condition main::$2 [16] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@4
Simple Condition main::$0 [24] if(main::i#2<$c0) goto main::@7
Simple Condition main::$3 [39] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@10
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [9] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = (unumber)$29*$4c/$40
Constant right-side identified [36] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = (unumber)$1b*$4c/$40
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::i#0 = 0
Constant idx#11 = 0
Successful SSA optimization Pass2ConstantIdentification
if() condition always true - replacing block destination [7] if(0!=1) goto main::@2
Successful SSA optimization Pass2ConstantIfs
Simplifying expression containing zero (char *)TIA in [8] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = 2
Simplifying expression containing zero (char *)TIA in [13] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC) = 0
Successful SSA optimization PassNSimplifyExpressionWithZero
Removing unused block main::@return
Successful SSA optimization Pass2EliminateUnusedBlocks
Eliminating unused constant OFFSET_STRUCT_ATARI_TIA_WRITE_VSYNC
Successful SSA optimization PassNEliminateUnusedVars
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Inlining constant with var siblings main::i#0
Inlining constant with var siblings idx#11
Constant inlined main::i#0 = 0
Constant inlined idx#11 = 0
Successful SSA optimization Pass2ConstantInlining
Finalized unsigned number type (char) $f
Finalized unsigned number type (char) $f
Finalized unsigned number type (unsigned int) $100
Finalized unsigned number type (char) $29
Finalized unsigned number type (char) $4c
Finalized unsigned number type (char) $40
Finalized unsigned number type (char) $1b
Finalized unsigned number type (char) $4c
Finalized unsigned number type (char) $40
Successful SSA optimization PassNFinalizeNumberTypeConversions
Simplifying constant integer cast $29*$4c/$40
Simplifying constant integer cast $1b*$4c/$40
Successful SSA optimization PassNCastSimplification
Added new block during phi lifting main::@11(between main::@9 and main::@1)
CALL GRAPH

Created 3 initial phi equivalence classes
Coalesced [15] main::c#4 = main::c#0
Coalesced [23] idx#20 = idx#0
Coalesced [33] main::i#4 = main::i#1
Coalesced [34] main::c#5 = main::c#1
Coalesced down to 3 phi equivalence classes
Culled Empty Block label main::@11

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0
  [1] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55
  [2] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa
  [3] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55
  to:main::@1
main::@1: scope:[main]  from main main::@9
  [4] idx#1 = phi( main/0, main::@9/idx#0 )
  to:main::@2
main::@2: scope:[main]  from main::@1
  [5] *((char *)TIA) = 2
  [6] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40
  [7] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  [8] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  [9] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  [10] *((char *)TIA) = 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@4
  [11] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@3
  [12] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0
  [13] main::c#0 = SINTABLE[idx#1]
  [14] idx#0 = ++ idx#1
  to:main::@6
main::@6: scope:[main]  from main::@5 main::@7
  [15] main::c#2 = phi( main::@5/main::c#0, main::@7/main::c#1 )
  [15] main::i#2 = phi( main::@5/0, main::@7/main::i#1 )
  [16] if(main::i#2<$c0) goto main::@7
  to:main::@8
main::@8: scope:[main]  from main::@6
  [17] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  [18] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2
  [19] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0
  [20] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40
  to:main::@9
main::@9: scope:[main]  from main::@10 main::@8
  [21] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@10
  to:main::@1
main::@10: scope:[main]  from main::@9
  [22] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  to:main::@9
main::@7: scope:[main]  from main::@6
  [23] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  [24] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = main::c#2
  [25] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = main::c#2
  [26] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = main::c#2
  [27] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = main::c#2
  [28] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE) = main::c#2
  [29] main::c#1 = ++ main::c#2
  [30] main::i#1 = ++ main::i#2
  to:main::@6
main::@4: scope:[main]  from main::@3
  [31] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0
  to:main::@3


VARIABLE REGISTER WEIGHTS
char idx
char idx#0 // 6.588235294117648
char idx#1 // 11.181818181818182
void main()
char main::c
char main::c#0 // 11.0
char main::c#1 // 101.0
char main::c#2 // 89.75
char main::i
char main::i#1 // 202.0
char main::i#2 // 33.666666666666664

Initial phi equivalence classes
[ idx#1 idx#0 ]
[ main::i#2 main::i#1 ]
[ main::c#2 main::c#0 main::c#1 ]
Complete equivalence classes
[ idx#1 idx#0 ]
[ main::i#2 main::i#1 ]
[ main::c#2 main::c#0 main::c#1 ]
Allocated zp[1]:128 [ idx#1 idx#0 ]
Allocated zp[1]:129 [ main::i#2 main::i#1 ]
Allocated zp[1]:130 [ main::c#2 main::c#0 main::c#1 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [0] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [1] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((char *)TIA) = 2 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:128 [ idx#1 idx#0 ]
Statement [6] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [7] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [8] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [9] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [10] *((char *)TIA) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [11] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@4 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [12] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [17] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [18] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [19] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [20] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [21] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@10 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [22] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [23] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#0 main::i#2 main::c#2 ] (  [ idx#0 main::i#2 main::c#2 ] { }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:129 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:130 [ main::c#2 main::c#0 main::c#1 ]
Statement [31] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [0] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [1] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [2] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [3] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] *((char *)TIA) = 2 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [6] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [7] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [8] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [9] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [10] *((char *)TIA) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [11] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@4 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [12] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Statement [17] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [18] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [19] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [20] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [21] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@10 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [22] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#0 ] (  [ idx#0 ] { }  ) always clobbers reg byte a 
Statement [23] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#0 main::i#2 main::c#2 ] (  [ idx#0 main::i#2 main::c#2 ] { }  ) always clobbers reg byte a 
Statement [31] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 [ idx#1 ] (  [ idx#1 ] { }  ) always clobbers reg byte a 
Potential registers zp[1]:128 [ idx#1 idx#0 ] : zp[1]:128 , reg byte x , reg byte y , 
Potential registers zp[1]:129 [ main::i#2 main::i#1 ] : zp[1]:129 , reg byte x , reg byte y , 
Potential registers zp[1]:130 [ main::c#2 main::c#0 main::c#1 ] : zp[1]:130 , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 235.67: zp[1]:129 [ main::i#2 main::i#1 ] 201.75: zp[1]:130 [ main::c#2 main::c#0 main::c#1 ] 
Uplift Scope [] 17.77: zp[1]:128 [ idx#1 idx#0 ] 
Uplift Scope [ATARI_TIA_WRITE] 
Uplift Scope [ATARI_TIA_READ] 
Uplift Scope [MOS6532_RIOT] 

Uplifting [main] best 8959 combination reg byte y [ main::i#2 main::i#1 ] reg byte x [ main::c#2 main::c#0 main::c#1 ] 
Uplifting [] best 8959 combination zp[1]:128 [ idx#1 idx#0 ] 
Uplifting [ATARI_TIA_WRITE] best 8959 combination 
Uplifting [ATARI_TIA_READ] best 8959 combination 
Uplifting [MOS6532_RIOT] best 8959 combination 
Attempting to uplift remaining variables inzp[1]:128 [ idx#1 idx#0 ]
Uplifting [] best 8959 combination zp[1]:128 [ idx#1 idx#0 ] 

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Minimal Atari 2600 VCS Program
// Source: https://atariage.com/forums/blogs/entry/11109-step-1-generate-a-stable-display/
/// @file
/// Atari 2600 Registers and Constants
///
/// https://web.archive.org/web/20170215054248/http://www.atariguide.com/pdfs/Atari_2600_VCS_Domestic_Field_Service_Manual.pdf
  // Upstart
  // Atari 2600 VCS 2K ROM in A26 executable file
.file [name="atari2600-demo.a26", type="bin", segments="Code, Data, Vectors"]
.segmentdef Code [start=$f800,min=$f800,max=$fff9]
.segmentdef Data [startAfter="Code",max=$fff9]
.segmentdef Vectors [start=$fffa,max=$ffff]
.segment Vectors
.word main // NMI
.word main // RESET
.word main // IRQ
  // Global Constants & labels
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_PF0 = $d
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_PF1 = $e
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_PF2 = $f
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF = 8
  .const OFFSET_STRUCT_MOS6532_RIOT_TIM64T = $16
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC = 2
  .const OFFSET_STRUCT_MOS6532_RIOT_INTIM = 4
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK = 1
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK = 9
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE = $2a
  /// Atari TIA write registers
  .label TIA = 0
  /// Atari RIOT registers
  .label RIOT = $280
  // Counts frames
  .label idx = $80
.segment Code
  // main
main: {
    // [0] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0 -- _deref_pbuc1=vbuc2 
    lda #$a0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0
    // [1] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55 -- _deref_pbuc1=vbuc2 
    lda #$55
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1
    // [2] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2
    // [3] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55 -- _deref_pbuc1=vbuc2 
    lda #$55
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF
    // [4] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [4] phi idx#1 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    jmp __b1
    // main::@1
  __b1:
    jmp __b2
    // main::@2
  __b2:
    // [5] *((char *)TIA) = 2 -- _deref_pbuc1=vbuc2 
    // Vertical Sync
    // here we generate the signal that tells the TV to move the beam to the top of
    // the screen so we can start the next frame of video.
    // The Sync Signal must be on for 3 scanlines.
    lda #2
    sta TIA
    // [6] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40 -- _deref_pbuc1=vbuc2 
    // D1=1, turns on Vertical Sync signal
    lda #$29*$4c/$40
    sta RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T
    // [7] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // Set timer to wait 41 lines
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [8] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // Wait for Sync - halts CPU until end of 1st scanline of VSYNC
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [9] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // wait until end of 2nd scanline of VSYNC
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [10] *((char *)TIA) = 0 -- _deref_pbuc1=vbuc2 
    // wait until end of 3rd scanline of VSYNC
    lda #0
    sta TIA
    jmp __b3
  // Wait for the timer to run out
    // main::@3
  __b3:
    // [11] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@4 -- 0_neq__deref_pbuc1_then_la1 
    lda RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM
    bne __b4
    jmp __b5
    // main::@5
  __b5:
    // [12] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0 -- _deref_pbuc1=vbuc2 
    // Screen - display logic
    // Update the registers in TIA (the video chip) in order to generate what the player sees.
    // For now we're just going to output 192 colored scanlines lines so we have something to see.
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK
    // [13] main::c#0 = SINTABLE[idx#1] -- vbuxx=pbuc1_derefidx_vbuz1 
    // D1=1, turns off Vertical Blank signal (image output on)
    ldy.z idx
    ldx SINTABLE,y
    // [14] idx#0 = ++ idx#1 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [15] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
  __b6_from___b5:
    // [15] phi main::c#2 = main::c#0 [phi:main::@5->main::@6#0] -- register_copy 
    // [15] phi main::i#2 = 0 [phi:main::@5->main::@6#1] -- vbuyy=vbuc1 
    ldy #0
    jmp __b6
    // main::@6
  __b6:
    // [16] if(main::i#2<$c0) goto main::@7 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$c0
    bcc __b7
    jmp __b8
    // main::@8
  __b8:
    // [17] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // Start OverScan
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [18] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2 -- _deref_pbuc1=vbuc2 
    // Wait for SYNC (halts CPU until end of scanline)
    lda #2
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK
    // [19] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0 -- _deref_pbuc1=vbuc2 
    // D1=1 turns image output off
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK
    // [20] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40 -- _deref_pbuc1=vbuc2 
    // Set background color to black
    lda #$1b*$4c/$40
    sta RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T
    jmp __b9
  // Wait for the timer to run out
    // main::@9
  __b9:
    // [21] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@10 -- 0_neq__deref_pbuc1_then_la1 
    lda RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM
    bne __b10
    // [4] phi from main::@9 to main::@1 [phi:main::@9->main::@1]
  __b1_from___b9:
    // [4] phi idx#1 = idx#0 [phi:main::@9->main::@1#0] -- register_copy 
    jmp __b1
    // main::@10
  __b10:
    // [22] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    jmp __b9
    // main::@7
  __b7:
    // [23] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [24] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = main::c#2 -- _deref_pbuc1=vbuxx 
    // Wait for SYNC (halts CPU until end of scanline)
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK
    // [25] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = main::c#2 -- _deref_pbuc1=vbuxx 
    // Set background color
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0
    // [26] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = main::c#2 -- _deref_pbuc1=vbuxx 
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1
    // [27] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = main::c#2 -- _deref_pbuc1=vbuxx 
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2
    // [28] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE) = main::c#2 -- _deref_pbuc1=vbuxx 
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE
    // [29] main::c#1 = ++ main::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [30] main::i#1 = ++ main::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [15] phi from main::@7 to main::@6 [phi:main::@7->main::@6]
  __b6_from___b7:
    // [15] phi main::c#2 = main::c#1 [phi:main::@7->main::@6#0] -- register_copy 
    // [15] phi main::i#2 = main::i#1 [phi:main::@7->main::@6#1] -- register_copy 
    jmp __b6
    // main::@4
  __b4:
    // [31] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    jmp __b3
}
  // File Data
.segment Data
// Sine table
SINTABLE:
.fill $100, round(127.5+127.5*sin(2*PI*i/256))


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __b6
Removing instruction jmp __b8
Removing instruction jmp __b9
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #0
Removing instruction lda #0
Removing instruction lda #0
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label __b1 with __b2
Removing instruction __b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b5:
Removing instruction __b6_from___b5:
Removing instruction __b8:
Removing instruction __b1_from___b9:
Removing instruction __b6_from___b7:
Succesful ASM optimization Pass5UnusedLabelElimination
Replacing instruction ldy #0 with TAY

FINAL SYMBOL TABLE
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK = 9
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF = 8
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE = $2a
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_PF0 = $d
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_PF1 = $e
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_PF2 = $f
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK = 1
__constant char OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC = 2
__constant char OFFSET_STRUCT_MOS6532_RIOT_INTIM = 4
__constant char OFFSET_STRUCT_MOS6532_RIOT_TIM64T = $16
__constant struct MOS6532_RIOT * const RIOT = (struct MOS6532_RIOT *) 640
__constant const char SINTABLE[$100] = kickasm {{ .fill $100, round(127.5+127.5*sin(2*PI*i/256))
 }}
__constant struct ATARI_TIA_WRITE * const TIA = (struct ATARI_TIA_WRITE *) 0
char idx
char idx#0 // idx zp[1]:128 6.588235294117648
char idx#1 // idx zp[1]:128 11.181818181818182
void main()
char main::c
char main::c#0 // reg byte x 11.0
char main::c#1 // reg byte x 101.0
char main::c#2 // reg byte x 89.75
char main::i
char main::i#1 // reg byte y 202.0
char main::i#2 // reg byte y 33.666666666666664

zp[1]:128 [ idx#1 idx#0 ]
reg byte y [ main::i#2 main::i#1 ]
reg byte x [ main::c#2 main::c#0 main::c#1 ]


FINAL ASSEMBLER
Score: 7879

  // File Comments
// Minimal Atari 2600 VCS Program
// Source: https://atariage.com/forums/blogs/entry/11109-step-1-generate-a-stable-display/
/// @file
/// Atari 2600 Registers and Constants
///
/// https://web.archive.org/web/20170215054248/http://www.atariguide.com/pdfs/Atari_2600_VCS_Domestic_Field_Service_Manual.pdf
  // Upstart
  // Atari 2600 VCS 2K ROM in A26 executable file
.file [name="atari2600-demo.a26", type="bin", segments="Code, Data, Vectors"]
.segmentdef Code [start=$f800,min=$f800,max=$fff9]
.segmentdef Data [startAfter="Code",max=$fff9]
.segmentdef Vectors [start=$fffa,max=$ffff]
.segment Vectors
.word main // NMI
.word main // RESET
.word main // IRQ
  // Global Constants & labels
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_PF0 = $d
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_PF1 = $e
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_PF2 = $f
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF = 8
  .const OFFSET_STRUCT_MOS6532_RIOT_TIM64T = $16
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC = 2
  .const OFFSET_STRUCT_MOS6532_RIOT_INTIM = 4
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK = 1
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK = 9
  .const OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE = $2a
  /// Atari TIA write registers
  .label TIA = 0
  /// Atari RIOT registers
  .label RIOT = $280
  // Counts frames
  .label idx = $80
.segment Code
  // main
main: {
    // TIA->PF0 = 0b10100000
    // [0] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = $a0 -- _deref_pbuc1=vbuc2 
    lda #$a0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0
    // TIA->PF1 = 0b01010101
    // [1] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = $55 -- _deref_pbuc1=vbuc2 
    lda #$55
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1
    // TIA->PF2 = 0b10101010
    // [2] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = $aa -- _deref_pbuc1=vbuc2 
    lda #$aa
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2
    // TIA->COLUPF = 0x55
    // [3] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF) = $55 -- _deref_pbuc1=vbuc2 
    lda #$55
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUPF
    // [4] phi from main to main::@1 [phi:main->main::@1]
    // [4] phi idx#1 = 0 [phi:main->main::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z idx
    // main::@1
    // main::@2
  __b2:
    // TIA->VSYNC = 2
    // [5] *((char *)TIA) = 2 -- _deref_pbuc1=vbuc2 
    // Vertical Sync
    // here we generate the signal that tells the TV to move the beam to the top of
    // the screen so we can start the next frame of video.
    // The Sync Signal must be on for 3 scanlines.
    lda #2
    sta TIA
    // RIOT->TIM64T = (41*76)/64
    // [6] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $29*$4c/$40 -- _deref_pbuc1=vbuc2 
    // D1=1, turns on Vertical Sync signal
    lda #$29*$4c/$40
    sta RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T
    // TIA->WSYNC = 0
    // [7] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // Set timer to wait 41 lines
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [8] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // Wait for Sync - halts CPU until end of 1st scanline of VSYNC
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // [9] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // wait until end of 2nd scanline of VSYNC
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // TIA->VSYNC = 0
    // [10] *((char *)TIA) = 0 -- _deref_pbuc1=vbuc2 
    // wait until end of 3rd scanline of VSYNC
    sta TIA
  // Wait for the timer to run out
    // main::@3
  __b3:
    // while(RIOT->INTIM)
    // [11] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@4 -- 0_neq__deref_pbuc1_then_la1 
    lda RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM
    bne __b4
    // main::@5
    // TIA->VBLANK = 0
    // [12] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 0 -- _deref_pbuc1=vbuc2 
    // Screen - display logic
    // Update the registers in TIA (the video chip) in order to generate what the player sees.
    // For now we're just going to output 192 colored scanlines lines so we have something to see.
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK
    // char c = SINTABLE[idx++]
    // [13] main::c#0 = SINTABLE[idx#1] -- vbuxx=pbuc1_derefidx_vbuz1 
    // D1=1, turns off Vertical Blank signal (image output on)
    ldy.z idx
    ldx SINTABLE,y
    // [14] idx#0 = ++ idx#1 -- vbuz1=_inc_vbuz1 
    inc.z idx
    // [15] phi from main::@5 to main::@6 [phi:main::@5->main::@6]
    // [15] phi main::c#2 = main::c#0 [phi:main::@5->main::@6#0] -- register_copy 
    // [15] phi main::i#2 = 0 [phi:main::@5->main::@6#1] -- vbuyy=vbuc1 
    tay
    // main::@6
  __b6:
    // for(char i=0;i<192;i++)
    // [16] if(main::i#2<$c0) goto main::@7 -- vbuyy_lt_vbuc1_then_la1 
    cpy #$c0
    bcc __b7
    // main::@8
    // TIA->WSYNC = 0
    // [17] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    // Start OverScan
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // TIA->VBLANK = 2
    // [18] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK) = 2 -- _deref_pbuc1=vbuc2 
    // Wait for SYNC (halts CPU until end of scanline)
    lda #2
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_VBLANK
    // TIA->COLUBK = 0
    // [19] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = 0 -- _deref_pbuc1=vbuc2 
    // D1=1 turns image output off
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK
    // RIOT->TIM64T = (27*76)/64
    // [20] *((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T) = $1b*$4c/$40 -- _deref_pbuc1=vbuc2 
    // Set background color to black
    lda #$1b*$4c/$40
    sta RIOT+OFFSET_STRUCT_MOS6532_RIOT_TIM64T
  // Wait for the timer to run out
    // main::@9
  __b9:
    // while(RIOT->INTIM)
    // [21] if(0!=*((char *)RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM)) goto main::@10 -- 0_neq__deref_pbuc1_then_la1 
    lda RIOT+OFFSET_STRUCT_MOS6532_RIOT_INTIM
    bne __b10
    // [4] phi from main::@9 to main::@1 [phi:main::@9->main::@1]
    // [4] phi idx#1 = idx#0 [phi:main::@9->main::@1#0] -- register_copy 
    jmp __b2
    // main::@10
  __b10:
    // TIA->WSYNC = 0
    // [22] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    jmp __b9
    // main::@7
  __b7:
    // [23] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    // TIA->COLUBK = c
    // [24] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK) = main::c#2 -- _deref_pbuc1=vbuxx 
    // Wait for SYNC (halts CPU until end of scanline)
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_COLUBK
    // TIA->PF0 = c
    // [25] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0) = main::c#2 -- _deref_pbuc1=vbuxx 
    // Set background color
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF0
    // TIA->PF1 = c
    // [26] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1) = main::c#2 -- _deref_pbuc1=vbuxx 
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF1
    // TIA->PF2 = c
    // [27] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2) = main::c#2 -- _deref_pbuc1=vbuxx 
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_PF2
    // TIA->HMOVE = c
    // [28] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE) = main::c#2 -- _deref_pbuc1=vbuxx 
    stx TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_HMOVE
    // c++;
    // [29] main::c#1 = ++ main::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // for(char i=0;i<192;i++)
    // [30] main::i#1 = ++ main::i#2 -- vbuyy=_inc_vbuyy 
    iny
    // [15] phi from main::@7 to main::@6 [phi:main::@7->main::@6]
    // [15] phi main::c#2 = main::c#1 [phi:main::@7->main::@6#0] -- register_copy 
    // [15] phi main::i#2 = main::i#1 [phi:main::@7->main::@6#1] -- register_copy 
    jmp __b6
    // main::@4
  __b4:
    // TIA->WSYNC = 0
    // [31] *((char *)TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC) = 0 -- _deref_pbuc1=vbuc2 
    lda #0
    sta TIA+OFFSET_STRUCT_ATARI_TIA_WRITE_WSYNC
    jmp __b3
}
  // File Data
.segment Data
// Sine table
SINTABLE:
.fill $100, round(127.5+127.5*sin(2*PI*i/256))


