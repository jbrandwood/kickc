Fixing pointer array-indexing *((dword*) SCREEN + (number) 0)
Identified constant variable (dword*) SCREEN
Culled Empty Block (label) ifunc::@4
Culled Empty Block (label) ifunc::@5
Culled Empty Block (label) ifunc::@6
Culled Empty Block (label) ifunc::@7
Culled Empty Block (label) @1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@2

(dword()) ifunc((dword) ifunc::a)
ifunc: scope:[ifunc]  from main
  (dword) ifunc::a#2 ← phi( main/(dword) ifunc::a#0 )
  (dword) ifunc::x#0 ← (dword) 1
  (dword) ifunc::xsqr#0 ← (dword) 1
  (dword) ifunc::delta#0 ← (dword) 3
  to:ifunc::@1
ifunc::@1: scope:[ifunc]  from ifunc ifunc::@2
  (dword) ifunc::delta#3 ← phi( ifunc/(dword) ifunc::delta#0 ifunc::@2/(dword) ifunc::delta#1 )
  (dword) ifunc::x#5 ← phi( ifunc/(dword) ifunc::x#0 ifunc::@2/(dword) ifunc::x#1 )
  (dword) ifunc::a#1 ← phi( ifunc/(dword) ifunc::a#2 ifunc::@2/(dword) ifunc::a#3 )
  (dword) ifunc::xsqr#2 ← phi( ifunc/(dword) ifunc::xsqr#0 ifunc::@2/(dword) ifunc::xsqr#1 )
  (bool~) ifunc::$0 ← (dword) ifunc::xsqr#2 <= (dword) ifunc::a#1
  if((bool~) ifunc::$0) goto ifunc::@2
  to:ifunc::@3
ifunc::@2: scope:[ifunc]  from ifunc::@1
  (dword) ifunc::a#3 ← phi( ifunc::@1/(dword) ifunc::a#1 )
  (dword) ifunc::delta#2 ← phi( ifunc::@1/(dword) ifunc::delta#3 )
  (dword) ifunc::xsqr#3 ← phi( ifunc::@1/(dword) ifunc::xsqr#2 )
  (dword) ifunc::x#3 ← phi( ifunc::@1/(dword) ifunc::x#5 )
  (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3
  (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#3 + (dword) ifunc::delta#2
  (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (number) 2
  to:ifunc::@1
ifunc::@3: scope:[ifunc]  from ifunc::@1
  (dword) ifunc::x#4 ← phi( ifunc::@1/(dword) ifunc::x#5 )
  (dword) ifunc::x#2 ← -- (dword) ifunc::x#4
  (dword) ifunc::return#0 ← (dword) ifunc::x#2
  to:ifunc::@return
ifunc::@return: scope:[ifunc]  from ifunc::@3
  (dword) ifunc::return#3 ← phi( ifunc::@3/(dword) ifunc::return#0 )
  (dword) ifunc::return#1 ← (dword) ifunc::return#3
  return 
  to:@return

(void()) main()
main: scope:[main]  from @2
  (dword) ifunc::a#0 ← (number) 8
  call ifunc 
  (dword) ifunc::return#2 ← (dword) ifunc::return#1
  to:main::@1
main::@1: scope:[main]  from main
  (dword) ifunc::return#4 ← phi( main/(dword) ifunc::return#2 )
  (dword~) main::$0 ← (dword) ifunc::return#4
  (number~) main::$1 ← (number) 0 * (const byte) SIZEOF_DWORD
  *((const dword*) SCREEN + (number~) main::$1) ← (dword~) main::$0
  to:main::@return
main::@return: scope:[main]  from main::@1
  return 
  to:@return
@2: scope:[]  from @begin
  call main 
  to:@3
@3: scope:[]  from @2
  to:@end
@end: scope:[]  from @3

SYMBOL TABLE SSA
(label) @2
(label) @3
(label) @begin
(label) @end
(const dword*) SCREEN = (dword*)(number) $400
(const byte) SIZEOF_DWORD = (byte) 4
(dword()) ifunc((dword) ifunc::a)
(bool~) ifunc::$0
(label) ifunc::@1
(label) ifunc::@2
(label) ifunc::@3
(label) ifunc::@return
(dword) ifunc::a
(dword) ifunc::a#0
(dword) ifunc::a#1
(dword) ifunc::a#2
(dword) ifunc::a#3
(dword) ifunc::delta
(dword) ifunc::delta#0
(dword) ifunc::delta#1
(dword) ifunc::delta#2
(dword) ifunc::delta#3
(dword) ifunc::return
(dword) ifunc::return#0
(dword) ifunc::return#1
(dword) ifunc::return#2
(dword) ifunc::return#3
(dword) ifunc::return#4
(dword) ifunc::x
(dword) ifunc::x#0
(dword) ifunc::x#1
(dword) ifunc::x#2
(dword) ifunc::x#3
(dword) ifunc::x#4
(dword) ifunc::x#5
(dword) ifunc::xsqr
(dword) ifunc::xsqr#0
(dword) ifunc::xsqr#1
(dword) ifunc::xsqr#2
(dword) ifunc::xsqr#3
(void()) main()
(dword~) main::$0
(number~) main::$1
(label) main::@1
(label) main::@return

Adding number conversion cast (unumber) 2 in (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (number) 2
Adding number conversion cast (unumber) 8 in (dword) ifunc::a#0 ← (number) 8
Adding number conversion cast (unumber) 0 in (number~) main::$1 ← (number) 0 * (const byte) SIZEOF_DWORD
Adding number conversion cast (unumber) main::$1 in (number~) main::$1 ← (unumber)(number) 0 * (const byte) SIZEOF_DWORD
Successful SSA optimization PassNAddNumberTypeConversions
Inlining cast (dword) ifunc::a#0 ← (unumber)(number) 8
Successful SSA optimization Pass2InlineCast
Simplifying constant pointer cast (dword*) 1024
Simplifying constant integer cast 2
Simplifying constant integer cast 8
Simplifying constant integer cast 0
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 0
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) main::$1 ← (byte) 0 * (const byte) SIZEOF_DWORD
Alias (dword) ifunc::x#3 = (dword) ifunc::x#5 (dword) ifunc::x#4 
Alias (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#3 
Alias (dword) ifunc::delta#2 = (dword) ifunc::delta#3 
Alias (dword) ifunc::a#1 = (dword) ifunc::a#3 
Alias (dword) ifunc::return#0 = (dword) ifunc::x#2 (dword) ifunc::return#3 (dword) ifunc::return#1 
Alias (dword) ifunc::return#2 = (dword) ifunc::return#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (dword) ifunc::a#2 (dword) ifunc::a#0
Identical Phi Values (dword) ifunc::a#1 (dword) ifunc::a#2
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) ifunc::$0 [6] if((dword) ifunc::xsqr#2<=(dword) ifunc::a#0) goto ifunc::@2
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [22] (byte~) main::$1 ← (byte) 0 * (const byte) SIZEOF_DWORD
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const dword) ifunc::x#0 = 1
Constant (const dword) ifunc::xsqr#0 = 1
Constant (const dword) ifunc::delta#0 = 3
Constant (const dword) ifunc::a#0 = 8
Constant (const byte) main::$1 = 0*SIZEOF_DWORD
Successful SSA optimization Pass2ConstantIdentification
Rewriting conditional comparison [6] if((dword) ifunc::xsqr#2<=(const dword) ifunc::a#0) goto ifunc::@2
Simplifying constant evaluating to zero (byte) 0*(const byte) SIZEOF_DWORD in 
Successful SSA optimization PassNSimplifyConstantZero
Simplifying expression containing zero SCREEN in [23] *((const dword*) SCREEN + (const byte) main::$1) ← (dword~) main::$0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused constant (const byte) main::$1
Eliminating unused constant (const byte) SIZEOF_DWORD
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) ifunc::a#0+1 in if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(number) 1) goto ifunc::@2
Adding number conversion cast (unumber) 1 in if((dword) ifunc::xsqr#2<(unumber)(const dword) ifunc::a#0+(number) 1) goto ifunc::@2
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast (const dword) ifunc::a#0+(unumber)(number) 1
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inlining constant with var siblings (const dword) ifunc::x#0
Inlining constant with var siblings (const dword) ifunc::xsqr#0
Inlining constant with var siblings (const dword) ifunc::delta#0
Constant inlined ifunc::xsqr#0 = (dword) 1
Constant inlined ifunc::delta#0 = (dword) 3
Constant inlined ifunc::x#0 = (dword) 1
Successful SSA optimization Pass2ConstantInlining
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @2
Adding NOP phi() at start of @3
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of ifunc
CALL GRAPH
Calls in [] to main:2 
Calls in [main] to ifunc:6 

Created 3 initial phi equivalence classes
Coalesced [19] ifunc::xsqr#4 ← ifunc::xsqr#1
Coalesced [20] ifunc::x#6 ← ifunc::x#1
Coalesced [21] ifunc::delta#4 ← ifunc::delta#1
Coalesced down to 3 phi equivalence classes
Culled Empty Block (label) @3
Renumbering block @2 to @1
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of ifunc

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()

(void()) main()
main: scope:[main]  from @1
  [4] phi()
  [5] call ifunc 
  [6] (dword) ifunc::return#2 ← (dword) ifunc::return#0
  to:main::@1
main::@1: scope:[main]  from main
  [7] (dword~) main::$0 ← (dword) ifunc::return#2
  [8] *((const dword*) SCREEN) ← (dword~) main::$0
  to:main::@return
main::@return: scope:[main]  from main::@1
  [9] return 
  to:@return

(dword()) ifunc((dword) ifunc::a)
ifunc: scope:[ifunc]  from main
  [10] phi()
  to:ifunc::@1
ifunc::@1: scope:[ifunc]  from ifunc ifunc::@2
  [11] (dword) ifunc::delta#2 ← phi( ifunc/(dword) 3 ifunc::@2/(dword) ifunc::delta#1 )
  [11] (dword) ifunc::x#3 ← phi( ifunc/(dword) 1 ifunc::@2/(dword) ifunc::x#1 )
  [11] (dword) ifunc::xsqr#2 ← phi( ifunc/(dword) 1 ifunc::@2/(dword) ifunc::xsqr#1 )
  [12] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2
  to:ifunc::@3
ifunc::@3: scope:[ifunc]  from ifunc::@1
  [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
  to:ifunc::@return
ifunc::@return: scope:[ifunc]  from ifunc::@3
  [14] return 
  to:@return
ifunc::@2: scope:[ifunc]  from ifunc::@1
  [15] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3
  [16] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2
  [17] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2
  to:ifunc::@1


VARIABLE REGISTER WEIGHTS
(dword()) ifunc((dword) ifunc::a)
(dword) ifunc::a
(dword) ifunc::delta
(dword) ifunc::delta#1 22.0
(dword) ifunc::delta#2 8.25
(dword) ifunc::return
(dword) ifunc::return#0 1.3333333333333333
(dword) ifunc::return#2 4.0
(dword) ifunc::x
(dword) ifunc::x#1 7.333333333333333
(dword) ifunc::x#3 12.0
(dword) ifunc::xsqr
(dword) ifunc::xsqr#1 11.0
(dword) ifunc::xsqr#2 11.0
(void()) main()
(dword~) main::$0 4.0

Initial phi equivalence classes
[ ifunc::xsqr#2 ifunc::xsqr#1 ]
[ ifunc::x#3 ifunc::x#1 ]
[ ifunc::delta#2 ifunc::delta#1 ]
Added variable ifunc::return#2 to live range equivalence class [ ifunc::return#2 ]
Added variable main::$0 to live range equivalence class [ main::$0 ]
Added variable ifunc::return#0 to live range equivalence class [ ifunc::return#0 ]
Complete equivalence classes
[ ifunc::xsqr#2 ifunc::xsqr#1 ]
[ ifunc::x#3 ifunc::x#1 ]
[ ifunc::delta#2 ifunc::delta#1 ]
[ ifunc::return#2 ]
[ main::$0 ]
[ ifunc::return#0 ]
Allocated zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ]
Allocated zp[4]:6 [ ifunc::x#3 ifunc::x#1 ]
Allocated zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ]
Allocated zp[4]:14 [ ifunc::return#2 ]
Allocated zp[4]:18 [ main::$0 ]
Allocated zp[4]:22 [ ifunc::return#0 ]
Warning! Unknown fragment for statement [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
Missing ASM fragment Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2 
File /Users/jespergravgaard/c64/kickc/src/test/kc/sqr-delta.kc
Line 10
return --x;

INITIAL ASM
Target platform is c64basic / MOS6502X
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __0 = $12
    // [5] call ifunc 
    // [10] phi from main to ifunc [phi:main->ifunc]
  ifunc_from_main:
    jsr ifunc
    // [6] (dword) ifunc::return#2 ← (dword) ifunc::return#0 -- vduz1=vduz2 
    lda.z ifunc.return
    sta.z ifunc.return_1
    lda.z ifunc.return+1
    sta.z ifunc.return_1+1
    lda.z ifunc.return+2
    sta.z ifunc.return_1+2
    lda.z ifunc.return+3
    sta.z ifunc.return_1+3
    jmp __b1
    // main::@1
  __b1:
    // [7] (dword~) main::$0 ← (dword) ifunc::return#2 -- vduz1=vduz2 
    lda.z ifunc.return_1
    sta.z __0
    lda.z ifunc.return_1+1
    sta.z __0+1
    lda.z ifunc.return_1+2
    sta.z __0+2
    lda.z ifunc.return_1+3
    sta.z __0+3
    // [8] *((const dword*) SCREEN) ← (dword~) main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = $16
    .label return_1 = $e
    // [11] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
  __b1_from_ifunc:
    // [11] phi (dword) ifunc::delta#2 = (dword) 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [11] phi (dword) ifunc::x#3 = (dword) 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [11] phi (dword) ifunc::xsqr#2 = (dword) 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    jmp __b1
    // ifunc::@1
  __b1:
    // [12] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    jmp __b3
    // ifunc::@3
  __b3:
    // [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
    .assert "Missing ASM fragment Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2 ", 0, 1
    jmp __breturn
    // ifunc::@return
  __breturn:
    // [14] return 
    rts
    // ifunc::@2
  __b2:
    // [15] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // [16] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // [17] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [11] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
  __b1_from___b2:
    // [11] phi (dword) ifunc::delta#2 = (dword) ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [11] phi (dword) ifunc::x#3 = (dword) ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [11] phi (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

REGISTER UPLIFT POTENTIAL REGISTERS
Statement [6] (dword) ifunc::return#2 ← (dword) ifunc::return#0 [ ifunc::return#2 ] ( main:2 [ ifunc::return#2 ] ) always clobbers reg byte a 
Statement [7] (dword~) main::$0 ← (dword) ifunc::return#2 [ main::$0 ] ( main:2 [ main::$0 ] ) always clobbers reg byte a 
Statement [8] *((const dword*) SCREEN) ← (dword~) main::$0 [ ] ( main:2 [ ] ) always clobbers reg byte a 
Statement [12] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 [ ifunc::xsqr#2 ifunc::x#3 ifunc::delta#2 ] ( main:2::ifunc:5 [ ifunc::xsqr#2 ifunc::x#3 ifunc::delta#2 ] ) always clobbers reg byte a 
Potential register analysis [13] ifunc::return#0 ← -- ifunc::x#3 missing fragment Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2  allocation: zp[4]:22 [ ifunc::return#0 ] zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] 
MISSING FRAGMENTS
  Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2 
Statement [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 [ ifunc::return#0 ] ( main:2::ifunc:5 [ ifunc::return#0 ] ) always clobbers reg byte a reg byte x reg byte y 
Statement [16] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 [ ifunc::delta#2 ifunc::xsqr#1 ifunc::x#1 ] ( main:2::ifunc:5 [ ifunc::delta#2 ifunc::xsqr#1 ifunc::x#1 ] ) always clobbers reg byte a 
Statement [17] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 [ ifunc::xsqr#1 ifunc::x#1 ifunc::delta#1 ] ( main:2::ifunc:5 [ ifunc::xsqr#1 ifunc::x#1 ifunc::delta#1 ] ) always clobbers reg byte a 
Potential registers zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] : zp[4]:2 , 
Potential registers zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] : zp[4]:6 , 
Potential registers zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] : zp[4]:10 , 
Potential registers zp[4]:14 [ ifunc::return#2 ] : zp[4]:14 , 
Potential registers zp[4]:18 [ main::$0 ] : zp[4]:18 , 
Potential registers zp[4]:22 [ ifunc::return#0 ] : zp[4]:22 , 

REGISTER UPLIFT SCOPES
Uplift Scope [ifunc] 30.25: zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] 22: zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] 19.33: zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] 4: zp[4]:14 [ ifunc::return#2 ] 1.33: zp[4]:22 [ ifunc::return#0 ] 
Uplift Scope [main] 4: zp[4]:18 [ main::$0 ] 
Uplift Scope [] 

Warning! Unknown fragment for statement [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
Missing ASM fragment Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2 
File /Users/jespergravgaard/c64/kickc/src/test/kc/sqr-delta.kc
Line 10
return --x;
Uplifting [ifunc] best 2160 combination zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ] zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ] zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] zp[4]:14 [ ifunc::return#2 ] zp[4]:22 [ ifunc::return#0 ] 
Warning! Unknown fragment for statement [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
Missing ASM fragment Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2 
File /Users/jespergravgaard/c64/kickc/src/test/kc/sqr-delta.kc
Line 10
return --x;
Uplifting [main] best 2160 combination zp[4]:18 [ main::$0 ] 
Warning! Unknown fragment for statement [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3
Missing ASM fragment Fragment not found vduz1=_dec_vduz2. Attempted variations vduz1=_dec_vduz2 
File /Users/jespergravgaard/c64/kickc/src/test/kc/sqr-delta.kc
Line 10
return --x;
Uplifting [] best 2160 combination 
Coalescing zero page register [ zp[4]:6 [ ifunc::x#3 ifunc::x#1 ] ] with [ zp[4]:22 [ ifunc::return#0 ] ] - score: 1
Coalescing zero page register [ zp[4]:14 [ ifunc::return#2 ] ] with [ zp[4]:18 [ main::$0 ] ] - score: 1
Coalescing zero page register [ zp[4]:6 [ ifunc::x#3 ifunc::x#1 ifunc::return#0 ] ] with [ zp[4]:14 [ ifunc::return#2 main::$0 ] ] - score: 1

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(__bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // @begin
__bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
__b1_from___bbegin:
  jmp __b1
  // @1
__b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from___b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
__bend_from___b1:
  jmp __bend
  // @end
__bend:
  // main
main: {
    .label __0 = 6
    // [5] call ifunc 
    // [10] phi from main to ifunc [phi:main->ifunc]
  ifunc_from_main:
    jsr ifunc
    // [6] (dword) ifunc::return#2 ← (dword) ifunc::return#0
    jmp __b1
    // main::@1
  __b1:
    // [7] (dword~) main::$0 ← (dword) ifunc::return#2
    // [8] *((const dword*) SCREEN) ← (dword~) main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    jmp __breturn
    // main::@return
  __breturn:
    // [9] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = 6
    // [11] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
  __b1_from_ifunc:
    // [11] phi (dword) ifunc::delta#2 = (dword) 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [11] phi (dword) ifunc::x#3 = (dword) 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [11] phi (dword) ifunc::xsqr#2 = (dword) 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    jmp __b1
    // ifunc::@1
  __b1:
    // [12] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    jmp __b3
    // ifunc::@3
  __b3:
    // [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 -- vduz1=_dec_vduz1 
    lda.z return
    sec
    sbc #1
    sta.z return
    lda.z return+1
    sbc #0
    sta.z return+1
    lda.z return+2
    sbc #0
    sta.z return+2
    lda.z return+3
    sbc #0
    sta.z return+3
    jmp __breturn
    // ifunc::@return
  __breturn:
    // [14] return 
    rts
    // ifunc::@2
  __b2:
    // [15] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // [16] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // [17] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [11] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
  __b1_from___b2:
    // [11] phi (dword) ifunc::delta#2 = (dword) ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [11] phi (dword) ifunc::x#3 = (dword) ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [11] phi (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __bend
Removing instruction jmp __b1
Removing instruction jmp __breturn
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __bbegin with __b1
Removing instruction __bbegin:
Removing instruction __b1_from___bbegin:
Removing instruction main_from___b1:
Removing instruction __bend_from___b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __bend:
Removing instruction ifunc_from_main:
Removing instruction __b1:
Removing instruction __breturn:
Removing instruction __b1_from_ifunc:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction __b1_from___b2:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction __b1:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const dword*) SCREEN = (dword*) 1024
(dword()) ifunc((dword) ifunc::a)
(label) ifunc::@1
(label) ifunc::@2
(label) ifunc::@3
(label) ifunc::@return
(dword) ifunc::a
(const dword) ifunc::a#0 a = (byte) 8
(dword) ifunc::delta
(dword) ifunc::delta#1 delta zp[4]:10 22.0
(dword) ifunc::delta#2 delta zp[4]:10 8.25
(dword) ifunc::return
(dword) ifunc::return#0 return zp[4]:6 1.3333333333333333
(dword) ifunc::return#2 return zp[4]:6 4.0
(dword) ifunc::x
(dword) ifunc::x#1 x zp[4]:6 7.333333333333333
(dword) ifunc::x#3 x zp[4]:6 12.0
(dword) ifunc::xsqr
(dword) ifunc::xsqr#1 xsqr zp[4]:2 11.0
(dword) ifunc::xsqr#2 xsqr zp[4]:2 11.0
(void()) main()
(dword~) main::$0 zp[4]:6 4.0
(label) main::@1
(label) main::@return

zp[4]:2 [ ifunc::xsqr#2 ifunc::xsqr#1 ]
zp[4]:6 [ ifunc::x#3 ifunc::x#1 ifunc::return#0 ifunc::return#2 main::$0 ]
zp[4]:10 [ ifunc::delta#2 ifunc::delta#1 ]


FINAL ASSEMBLER
Score: 2065

  // File Comments
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label SCREEN = $400
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label __0 = 6
    // ifunc(8)
    // [5] call ifunc 
    // [10] phi from main to ifunc [phi:main->ifunc]
    jsr ifunc
    // ifunc(8)
    // [6] (dword) ifunc::return#2 ← (dword) ifunc::return#0
    // main::@1
    // [7] (dword~) main::$0 ← (dword) ifunc::return#2
    // SCREEN[0] = ifunc(8)
    // [8] *((const dword*) SCREEN) ← (dword~) main::$0 -- _deref_pduc1=vduz1 
    lda.z __0
    sta SCREEN
    lda.z __0+1
    sta SCREEN+1
    lda.z __0+2
    sta SCREEN+2
    lda.z __0+3
    sta SCREEN+3
    // main::@return
    // }
    // [9] return 
    rts
}
  // ifunc
ifunc: {
    .const a = 8
    .label x = 6
    .label xsqr = 2
    .label delta = $a
    .label return = 6
    // [11] phi from ifunc to ifunc::@1 [phi:ifunc->ifunc::@1]
    // [11] phi (dword) ifunc::delta#2 = (dword) 3 [phi:ifunc->ifunc::@1#0] -- vduz1=vduc1 
    lda #<3
    sta.z delta
    lda #>3
    sta.z delta+1
    lda #<3>>$10
    sta.z delta+2
    lda #>3>>$10
    sta.z delta+3
    // [11] phi (dword) ifunc::x#3 = (dword) 1 [phi:ifunc->ifunc::@1#1] -- vduz1=vduc1 
    lda #<1
    sta.z x
    lda #>1
    sta.z x+1
    lda #<1>>$10
    sta.z x+2
    lda #>1>>$10
    sta.z x+3
    // [11] phi (dword) ifunc::xsqr#2 = (dword) 1 [phi:ifunc->ifunc::@1#2] -- vduz1=vduc1 
    lda #<1
    sta.z xsqr
    lda #>1
    sta.z xsqr+1
    lda #<1>>$10
    sta.z xsqr+2
    lda #>1>>$10
    sta.z xsqr+3
    // ifunc::@1
  __b1:
    // while(xsqr <=a)
    // [12] if((dword) ifunc::xsqr#2<(const dword) ifunc::a#0+(byte) 1) goto ifunc::@2 -- vduz1_lt_vduc1_then_la1 
    lda.z xsqr+3
    cmp #>a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+2
    cmp #<a+1>>$10
    bcc __b2
    bne !+
    lda.z xsqr+1
    cmp #>a+1
    bcc __b2
    bne !+
    lda.z xsqr
    cmp #<a+1
    bcc __b2
  !:
    // ifunc::@3
    // return --x;
    // [13] (dword) ifunc::return#0 ← -- (dword) ifunc::x#3 -- vduz1=_dec_vduz1 
    lda.z return
    sec
    sbc #1
    sta.z return
    lda.z return+1
    sbc #0
    sta.z return+1
    lda.z return+2
    sbc #0
    sta.z return+2
    lda.z return+3
    sbc #0
    sta.z return+3
    // ifunc::@return
    // }
    // [14] return 
    rts
    // ifunc::@2
  __b2:
    // ++x;
    // [15] (dword) ifunc::x#1 ← ++ (dword) ifunc::x#3 -- vduz1=_inc_vduz1 
    inc.z x
    bne !+
    inc.z x+1
    bne !+
    inc.z x+2
    bne !+
    inc.z x+3
  !:
    // xsqr += delta
    // [16] (dword) ifunc::xsqr#1 ← (dword) ifunc::xsqr#2 + (dword) ifunc::delta#2 -- vduz1=vduz1_plus_vduz2 
    lda.z xsqr
    clc
    adc.z delta
    sta.z xsqr
    lda.z xsqr+1
    adc.z delta+1
    sta.z xsqr+1
    lda.z xsqr+2
    adc.z delta+2
    sta.z xsqr+2
    lda.z xsqr+3
    adc.z delta+3
    sta.z xsqr+3
    // delta += 2
    // [17] (dword) ifunc::delta#1 ← (dword) ifunc::delta#2 + (byte) 2 -- vduz1=vduz1_plus_vbuc1 
    lda.z delta
    clc
    adc #2
    sta.z delta
    bcc !+
    inc.z delta+1
    bne !+
    inc.z delta+2
    bne !+
    inc.z delta+3
  !:
    // [11] phi from ifunc::@2 to ifunc::@1 [phi:ifunc::@2->ifunc::@1]
    // [11] phi (dword) ifunc::delta#2 = (dword) ifunc::delta#1 [phi:ifunc::@2->ifunc::@1#0] -- register_copy 
    // [11] phi (dword) ifunc::x#3 = (dword) ifunc::x#1 [phi:ifunc::@2->ifunc::@1#1] -- register_copy 
    // [11] phi (dword) ifunc::xsqr#2 = (dword) ifunc::xsqr#1 [phi:ifunc::@2->ifunc::@1#2] -- register_copy 
    jmp __b1
}
  // File Data

