Inlined call call __init 

CONTROL FLOW GRAPH SSA

void main()
main: scope:[main]  from __start::@1
  main::$0 = CHARSET + 8
  main::charset#0 = main::$0
  main::c#0 = 0
  to:main::@1
main::@1: scope:[main]  from main main::@4
  main::charset#4 = phi( main/main::charset#0, main::@4/main::charset#1 )
  main::c#2 = phi( main/main::c#0, main::@4/main::c#1 )
  main::$4 = main::c#2 != 4
  if(main::$4) goto main::@2
  to:main::@3
main::@2: scope:[main]  from main::@1
  main::charset#2 = phi( main::@1/main::charset#4 )
  main::c#3 = phi( main::@1/main::c#2 )
  main::$7 = main::c#3 * SIZEOF_WORD
  gen_char3::dst#0 = main::charset#2
  gen_char3::spec#0 = charset_spec_row[main::$7]
  call gen_char3 
  to:main::@4
main::@4: scope:[main]  from main::@2
  main::c#4 = phi( main::@2/main::c#3 )
  main::charset#3 = phi( main::@2/main::charset#2 )
  main::$6 = main::charset#3 + 8
  main::charset#1 = main::$6
  main::c#1 = ++ main::c#4
  to:main::@1
main::@3: scope:[main]  from main::@1
  main::$8 = (word)SCREEN
  main::$1 = main::$8 / $40
  main::$9 = (word)CHARSET
  main::$2 = main::$9 / $400
  main::$3 = main::$1 | main::$2
  *VICII_MEMORY = (byte)main::$3
  to:main::@return
main::@return: scope:[main]  from main::@3
  return 
  to:@return

void gen_char3(byte* gen_char3::dst , word gen_char3::spec)
gen_char3: scope:[gen_char3]  from main::@2
  gen_char3::dst#6 = phi( main::@2/gen_char3::dst#0 )
  gen_char3::spec#6 = phi( main::@2/gen_char3::spec#0 )
  gen_char3::r#0 = 0
  to:gen_char3::@1
gen_char3::@1: scope:[gen_char3]  from gen_char3 gen_char3::@5
  gen_char3::r#6 = phi( gen_char3/gen_char3::r#0, gen_char3::@5/gen_char3::r#1 )
  gen_char3::dst#5 = phi( gen_char3/gen_char3::dst#6, gen_char3::@5/gen_char3::dst#1 )
  gen_char3::spec#4 = phi( gen_char3/gen_char3::spec#6, gen_char3::@5/gen_char3::spec#7 )
  gen_char3::b#0 = 0
  gen_char3::c#0 = 0
  to:gen_char3::@2
gen_char3::@2: scope:[gen_char3]  from gen_char3::@1 gen_char3::@3
  gen_char3::r#4 = phi( gen_char3::@1/gen_char3::r#6, gen_char3::@3/gen_char3::r#3 )
  gen_char3::dst#3 = phi( gen_char3::@1/gen_char3::dst#5, gen_char3::@3/gen_char3::dst#2 )
  gen_char3::c#3 = phi( gen_char3::@1/gen_char3::c#0, gen_char3::@3/gen_char3::c#1 )
  gen_char3::b#6 = phi( gen_char3::@1/gen_char3::b#0, gen_char3::@3/gen_char3::b#1 )
  gen_char3::spec#2 = phi( gen_char3::@1/gen_char3::spec#4, gen_char3::@3/gen_char3::spec#1 )
  gen_char3::$0 = byte1  gen_char3::spec#2
  gen_char3::$1 = gen_char3::$0 & $80
  gen_char3::$2 = gen_char3::$1 != 0
  gen_char3::$3 = ! gen_char3::$2
  if(gen_char3::$3) goto gen_char3::@3
  to:gen_char3::@4
gen_char3::@3: scope:[gen_char3]  from gen_char3::@2 gen_char3::@4
  gen_char3::r#3 = phi( gen_char3::@2/gen_char3::r#4, gen_char3::@4/gen_char3::r#5 )
  gen_char3::dst#2 = phi( gen_char3::@2/gen_char3::dst#3, gen_char3::@4/gen_char3::dst#4 )
  gen_char3::c#2 = phi( gen_char3::@2/gen_char3::c#3, gen_char3::@4/gen_char3::c#4 )
  gen_char3::spec#3 = phi( gen_char3::@2/gen_char3::spec#2, gen_char3::@4/gen_char3::spec#5 )
  gen_char3::b#3 = phi( gen_char3::@2/gen_char3::b#6, gen_char3::@4/gen_char3::b#2 )
  gen_char3::$5 = gen_char3::b#3 * 2
  gen_char3::b#1 = gen_char3::$5
  gen_char3::$6 = gen_char3::spec#3 * 2
  gen_char3::spec#1 = gen_char3::$6
  gen_char3::c#1 = gen_char3::c#2 + rangenext(0,2)
  gen_char3::$7 = gen_char3::c#1 != rangelast(0,2)
  if(gen_char3::$7) goto gen_char3::@2
  to:gen_char3::@5
gen_char3::@4: scope:[gen_char3]  from gen_char3::@2
  gen_char3::r#5 = phi( gen_char3::@2/gen_char3::r#4 )
  gen_char3::dst#4 = phi( gen_char3::@2/gen_char3::dst#3 )
  gen_char3::c#4 = phi( gen_char3::@2/gen_char3::c#3 )
  gen_char3::spec#5 = phi( gen_char3::@2/gen_char3::spec#2 )
  gen_char3::b#4 = phi( gen_char3::@2/gen_char3::b#6 )
  gen_char3::$4 = gen_char3::b#4 | 1
  gen_char3::b#2 = gen_char3::$4
  to:gen_char3::@3
gen_char3::@5: scope:[gen_char3]  from gen_char3::@3
  gen_char3::spec#7 = phi( gen_char3::@3/gen_char3::spec#1 )
  gen_char3::r#2 = phi( gen_char3::@3/gen_char3::r#3 )
  gen_char3::dst#1 = phi( gen_char3::@3/gen_char3::dst#2 )
  gen_char3::b#5 = phi( gen_char3::@3/gen_char3::b#1 )
  gen_char3::dst#1[gen_char3::r#2] = gen_char3::b#5
  gen_char3::r#1 = gen_char3::r#2 + rangenext(0,4)
  gen_char3::$8 = gen_char3::r#1 != rangelast(0,4)
  if(gen_char3::$8) goto gen_char3::@1
  to:gen_char3::@return
gen_char3::@return: scope:[gen_char3]  from gen_char3::@5
  return 
  to:@return

void __start()
__start: scope:[__start]  from
  to:__start::__init1
__start::__init1: scope:[__start]  from __start
  to:__start::@1
__start::@1: scope:[__start]  from __start::__init1
  call main 
  to:__start::@2
__start::@2: scope:[__start]  from __start::@1
  to:__start::@return
__start::@return: scope:[__start]  from __start::@2
  return 
  to:@return

SYMBOL TABLE SSA
constant byte* CHARSET = (byte*)$3000
constant byte* SCREEN = (byte*)$400
constant byte SIZEOF_WORD = 2
constant byte* VICII_MEMORY = (byte*)$d018
void __start()
constant word* charset_spec_row[]  = { $f7da, $f7de, $f24e, $d6de }
void gen_char3(byte* gen_char3::dst , word gen_char3::spec)
byte~ gen_char3::$0
number~ gen_char3::$1
bool~ gen_char3::$2
bool~ gen_char3::$3
number~ gen_char3::$4
number~ gen_char3::$5
number~ gen_char3::$6
bool~ gen_char3::$7
bool~ gen_char3::$8
byte gen_char3::b
byte gen_char3::b#0
byte gen_char3::b#1
byte gen_char3::b#2
byte gen_char3::b#3
byte gen_char3::b#4
byte gen_char3::b#5
byte gen_char3::b#6
byte gen_char3::c
byte gen_char3::c#0
byte gen_char3::c#1
byte gen_char3::c#2
byte gen_char3::c#3
byte gen_char3::c#4
byte* gen_char3::dst
byte* gen_char3::dst#0
byte* gen_char3::dst#1
byte* gen_char3::dst#2
byte* gen_char3::dst#3
byte* gen_char3::dst#4
byte* gen_char3::dst#5
byte* gen_char3::dst#6
byte gen_char3::r
byte gen_char3::r#0
byte gen_char3::r#1
byte gen_char3::r#2
byte gen_char3::r#3
byte gen_char3::r#4
byte gen_char3::r#5
byte gen_char3::r#6
word gen_char3::spec
word gen_char3::spec#0
word gen_char3::spec#1
word gen_char3::spec#2
word gen_char3::spec#3
word gen_char3::spec#4
word gen_char3::spec#5
word gen_char3::spec#6
word gen_char3::spec#7
void main()
byte*~ main::$0
number~ main::$1
number~ main::$2
number~ main::$3
bool~ main::$4
byte*~ main::$6
byte~ main::$7
word~ main::$8
word~ main::$9
byte main::c
byte main::c#0
byte main::c#1
byte main::c#2
byte main::c#3
byte main::c#4
byte* main::charset
byte* main::charset#0
byte* main::charset#1
byte* main::charset#2
byte* main::charset#3
byte* main::charset#4

Adding number conversion cast (unumber) 8 in main::$0 = CHARSET + 8
Adding number conversion cast (unumber) 4 in main::$4 = main::c#2 != 4
Adding number conversion cast (unumber) 8 in main::$6 = main::charset#3 + 8
Adding number conversion cast (unumber) $40 in main::$1 = main::$8 / $40
Adding number conversion cast (unumber) main::$1 in main::$1 = main::$8 / (unumber)$40
Adding number conversion cast (unumber) $400 in main::$2 = main::$9 / $400
Adding number conversion cast (unumber) main::$2 in main::$2 = main::$9 / (unumber)$400
Adding number conversion cast (unumber) main::$3 in main::$3 = main::$1 | main::$2
Adding number conversion cast (unumber) $80 in gen_char3::$1 = gen_char3::$0 & $80
Adding number conversion cast (unumber) gen_char3::$1 in gen_char3::$1 = gen_char3::$0 & (unumber)$80
Adding number conversion cast (unumber) 0 in gen_char3::$2 = gen_char3::$1 != 0
Adding number conversion cast (unumber) 2 in gen_char3::$5 = gen_char3::b#3 * 2
Adding number conversion cast (unumber) gen_char3::$5 in gen_char3::$5 = gen_char3::b#3 * (unumber)2
Adding number conversion cast (unumber) 2 in gen_char3::$6 = gen_char3::spec#3 * 2
Adding number conversion cast (unumber) gen_char3::$6 in gen_char3::$6 = gen_char3::spec#3 * (unumber)2
Adding number conversion cast (unumber) 1 in gen_char3::$4 = gen_char3::b#4 | 1
Adding number conversion cast (unumber) gen_char3::$4 in gen_char3::$4 = gen_char3::b#4 | (unumber)1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant pointer cast (byte*) 53272
Simplifying constant pointer cast (byte*) 1024
Simplifying constant pointer cast (byte*) 12288
Simplifying constant integer cast 8
Simplifying constant integer cast 4
Simplifying constant integer cast 8
Simplifying constant integer cast $40
Simplifying constant integer cast $400
Simplifying constant integer cast $80
Simplifying constant integer cast 0
Simplifying constant integer cast 2
Simplifying constant integer cast 2
Simplifying constant integer cast 1
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 8
Finalized unsigned number type (byte) $40
Finalized unsigned number type (word) $400
Finalized unsigned number type (byte) $80
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 1
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to word in main::$1 = main::$8 / $40
Inferred type updated to word in main::$2 = main::$9 / $400
Inferred type updated to word in main::$3 = main::$1 | main::$2
Inferred type updated to byte in gen_char3::$1 = gen_char3::$0 & $80
Inferred type updated to byte in gen_char3::$5 = gen_char3::b#3 * 2
Inferred type updated to word in gen_char3::$6 = gen_char3::spec#3 * 2
Inferred type updated to byte in gen_char3::$4 = gen_char3::b#4 | 1
Inversing boolean not [31] gen_char3::$3 = gen_char3::$1 == 0 from [30] gen_char3::$2 = gen_char3::$1 != 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias main::charset#0 = main::$0 
Alias main::c#2 = main::c#3 main::c#4 
Alias main::charset#2 = main::charset#4 main::charset#3 
Alias main::charset#1 = main::$6 
Alias gen_char3::b#1 = gen_char3::$5 gen_char3::b#5 
Alias gen_char3::spec#1 = gen_char3::$6 gen_char3::spec#7 
Alias gen_char3::b#4 = gen_char3::b#6 
Alias gen_char3::spec#2 = gen_char3::spec#5 
Alias gen_char3::c#3 = gen_char3::c#4 
Alias gen_char3::dst#3 = gen_char3::dst#4 
Alias gen_char3::r#4 = gen_char3::r#5 
Alias gen_char3::b#2 = gen_char3::$4 
Alias gen_char3::dst#1 = gen_char3::dst#2 
Alias gen_char3::r#2 = gen_char3::r#3 
Successful SSA optimization Pass2AliasElimination
Alias gen_char3::spec#2 = gen_char3::spec#3 
Alias gen_char3::c#2 = gen_char3::c#3 
Alias gen_char3::dst#1 = gen_char3::dst#3 
Alias gen_char3::r#2 = gen_char3::r#4 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values gen_char3::spec#6 gen_char3::spec#0
Identical Phi Values gen_char3::dst#6 gen_char3::dst#0
Identical Phi Values gen_char3::dst#1 gen_char3::dst#5
Identical Phi Values gen_char3::r#2 gen_char3::r#6
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values gen_char3::dst#5 gen_char3::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition main::$4 [4] if(main::c#2!=4) goto main::@2
Simple Condition gen_char3::$3 [27] if(gen_char3::$1==0) goto gen_char3::@3
Simple Condition gen_char3::$7 [33] if(gen_char3::c#1!=rangelast(0,2)) goto gen_char3::@2
Simple Condition gen_char3::$8 [38] if(gen_char3::r#1!=rangelast(0,4)) goto gen_char3::@1
Successful SSA optimization Pass2ConditionalJumpSimplification
Constant right-side identified [0] main::charset#0 = CHARSET + 8
Constant right-side identified [11] main::$8 = (word)SCREEN
Constant right-side identified [13] main::$9 = (word)CHARSET
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::charset#0 = CHARSET+8
Constant main::c#0 = 0
Constant main::$8 = (word)SCREEN
Constant main::$9 = (word)CHARSET
Constant gen_char3::r#0 = 0
Constant gen_char3::b#0 = 0
Constant gen_char3::c#0 = 0
Successful SSA optimization Pass2ConstantIdentification
Resolved ranged next value [31] gen_char3::c#1 = ++ gen_char3::c#2 to ++
Resolved ranged comparison value [33] if(gen_char3::c#1!=rangelast(0,2)) goto gen_char3::@2 to 3
Resolved ranged next value [36] gen_char3::r#1 = ++ gen_char3::r#6 to ++
Resolved ranged comparison value [38] if(gen_char3::r#1!=rangelast(0,4)) goto gen_char3::@1 to 5
Removing unused procedure __start
Removing unused procedure block __start
Removing unused procedure block __start::__init1
Removing unused procedure block __start::@1
Removing unused procedure block __start::@2
Removing unused procedure block __start::@return
Successful SSA optimization PassNEliminateEmptyStart
Adding number conversion cast (unumber) 3 in [22] if(gen_char3::c#1!=3) goto gen_char3::@2
Adding number conversion cast (unumber) 5 in [26] if(gen_char3::r#1!=5) goto gen_char3::@1
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 3
Simplifying constant integer cast 5
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) 5
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [8] main::$1 = main::$8 / $40
Constant right-side identified [9] main::$2 = main::$9 / $400
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::$1 = main::$8/$40
Constant main::$2 = main::$9/$400
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [8] main::$3 = main::$1 | main::$2
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant main::$3 = main::$1|main::$2
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte)main::$3 in [9] *VICII_MEMORY = (byte)main::$3
Successful SSA optimization Pass2ConstantValues
Rewriting multiplication to use shift [2] main::$7 = main::c#2 * SIZEOF_WORD
Rewriting multiplication to use shift [16] gen_char3::b#1 = gen_char3::b#3 * 2
Rewriting multiplication to use shift [17] gen_char3::spec#1 = gen_char3::spec#2 * 2
Successful SSA optimization Pass2MultiplyToShiftRewriting
Inlining constant with var siblings main::charset#0
Inlining constant with var siblings main::c#0
Inlining constant with var siblings gen_char3::r#0
Inlining constant with var siblings gen_char3::b#0
Inlining constant with var siblings gen_char3::c#0
Constant inlined gen_char3::r#0 = 0
Constant inlined gen_char3::b#0 = 0
Constant inlined main::c#0 = 0
Constant inlined gen_char3::c#0 = 0
Constant inlined main::$1 = (word)SCREEN/$40
Constant inlined main::$2 = (word)CHARSET/$400
Constant inlined main::charset#0 = CHARSET+8
Constant inlined main::$3 = (word)SCREEN/$40|(word)CHARSET/$400
Constant inlined main::$9 = (word)CHARSET
Constant inlined main::$8 = (word)SCREEN
Successful SSA optimization Pass2ConstantInlining
Eliminating unused constant SIZEOF_WORD
Successful SSA optimization PassNEliminateUnusedVars
Added new block during phi lifting gen_char3::@6(between gen_char3::@5 and gen_char3::@1)
Added new block during phi lifting gen_char3::@7(between gen_char3::@3 and gen_char3::@2)
Added new block during phi lifting gen_char3::@8(between gen_char3::@2 and gen_char3::@3)
Adding NOP phi() at start of main
CALL GRAPH
Calls in [main] to gen_char3:8 

Created 8 initial phi equivalence classes
Coalesced [11] main::c#5 = main::c#1
Coalesced [12] main::charset#5 = main::charset#1
Coalesced [13] gen_char3::spec#8 = gen_char3::spec#0
Coalesced [15] gen_char3::spec#10 = gen_char3::spec#4
Coalesced [21] gen_char3::b#9 = gen_char3::b#2
Coalesced [31] gen_char3::spec#9 = gen_char3::spec#1
Coalesced [32] gen_char3::r#7 = gen_char3::r#1
Coalesced (already) [33] gen_char3::spec#11 = gen_char3::spec#1
Coalesced [34] gen_char3::b#7 = gen_char3::b#1
Coalesced [35] gen_char3::c#5 = gen_char3::c#1
Coalesced [36] gen_char3::b#8 = gen_char3::b#4
Coalesced down to 6 phi equivalence classes
Culled Empty Block label gen_char3::@6
Culled Empty Block label gen_char3::@7
Culled Empty Block label gen_char3::@8
Adding NOP phi() at start of main
Adding NOP phi() at start of gen_char3

FINAL CONTROL FLOW GRAPH

void main()
main: scope:[main]  from
  [0] phi()
  to:main::@1
main::@1: scope:[main]  from main main::@4
  [1] main::charset#2 = phi( main/CHARSET+8, main::@4/main::charset#1 )
  [1] main::c#2 = phi( main/0, main::@4/main::c#1 )
  [2] if(main::c#2!=4) goto main::@2
  to:main::@3
main::@3: scope:[main]  from main::@1
  [3] *VICII_MEMORY = (byte)(word)SCREEN/$40|(word)CHARSET/$400
  to:main::@return
main::@return: scope:[main]  from main::@3
  [4] return 
  to:@return
main::@2: scope:[main]  from main::@1
  [5] main::$7 = main::c#2 << 1
  [6] gen_char3::dst#0 = main::charset#2
  [7] gen_char3::spec#0 = charset_spec_row[main::$7]
  [8] call gen_char3 
  to:main::@4
main::@4: scope:[main]  from main::@2
  [9] main::charset#1 = main::charset#2 + 8
  [10] main::c#1 = ++ main::c#2
  to:main::@1

void gen_char3(byte* gen_char3::dst , word gen_char3::spec)
gen_char3: scope:[gen_char3]  from main::@2
  [11] phi()
  to:gen_char3::@1
gen_char3::@1: scope:[gen_char3]  from gen_char3 gen_char3::@5
  [12] gen_char3::r#6 = phi( gen_char3/0, gen_char3::@5/gen_char3::r#1 )
  [12] gen_char3::spec#4 = phi( gen_char3/gen_char3::spec#0, gen_char3::@5/gen_char3::spec#1 )
  to:gen_char3::@2
gen_char3::@2: scope:[gen_char3]  from gen_char3::@1 gen_char3::@3
  [13] gen_char3::c#2 = phi( gen_char3::@1/0, gen_char3::@3/gen_char3::c#1 )
  [13] gen_char3::b#4 = phi( gen_char3::@1/0, gen_char3::@3/gen_char3::b#1 )
  [13] gen_char3::spec#2 = phi( gen_char3::@1/gen_char3::spec#4, gen_char3::@3/gen_char3::spec#1 )
  [14] gen_char3::$0 = byte1  gen_char3::spec#2
  [15] gen_char3::$1 = gen_char3::$0 & $80
  [16] if(gen_char3::$1==0) goto gen_char3::@3
  to:gen_char3::@4
gen_char3::@4: scope:[gen_char3]  from gen_char3::@2
  [17] gen_char3::b#2 = gen_char3::b#4 | 1
  to:gen_char3::@3
gen_char3::@3: scope:[gen_char3]  from gen_char3::@2 gen_char3::@4
  [18] gen_char3::b#3 = phi( gen_char3::@2/gen_char3::b#4, gen_char3::@4/gen_char3::b#2 )
  [19] gen_char3::b#1 = gen_char3::b#3 << 1
  [20] gen_char3::spec#1 = gen_char3::spec#2 << 1
  [21] gen_char3::c#1 = ++ gen_char3::c#2
  [22] if(gen_char3::c#1!=3) goto gen_char3::@2
  to:gen_char3::@5
gen_char3::@5: scope:[gen_char3]  from gen_char3::@3
  [23] gen_char3::dst#0[gen_char3::r#6] = gen_char3::b#1
  [24] gen_char3::r#1 = ++ gen_char3::r#6
  [25] if(gen_char3::r#1!=5) goto gen_char3::@1
  to:gen_char3::@return
gen_char3::@return: scope:[gen_char3]  from gen_char3::@5
  [26] return 
  to:@return


VARIABLE REGISTER WEIGHTS
void gen_char3(byte* gen_char3::dst , word gen_char3::spec)
byte~ gen_char3::$0 200002.0
byte~ gen_char3::$1 200002.0
byte gen_char3::b
byte gen_char3::b#1 52500.75
byte gen_char3::b#2 200002.0
byte gen_char3::b#3 300003.0
byte gen_char3::b#4 75000.75
byte gen_char3::c
byte gen_char3::c#1 150001.5
byte gen_char3::c#2 25000.25
byte* gen_char3::dst
byte* gen_char3::dst#0 588.9411764705882
byte gen_char3::r
byte gen_char3::r#1 15001.5
byte gen_char3::r#6 2500.25
word gen_char3::spec
word gen_char3::spec#0 56.0
word gen_char3::spec#1 35000.5
word gen_char3::spec#2 44286.28571428572
word gen_char3::spec#4 20103.0
void main()
byte~ main::$7 11.0
byte main::c
byte main::c#1 22.0
byte main::c#2 6.285714285714286
byte* main::charset
byte* main::charset#1 11.0
byte* main::charset#2 5.5

Initial phi equivalence classes
[ main::c#2 main::c#1 ]
[ main::charset#2 main::charset#1 ]
[ gen_char3::r#6 gen_char3::r#1 ]
[ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
[ gen_char3::c#2 gen_char3::c#1 ]
[ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Added variable main::$7 to live range equivalence class [ main::$7 ]
Added variable gen_char3::dst#0 to live range equivalence class [ gen_char3::dst#0 ]
Added variable gen_char3::$0 to live range equivalence class [ gen_char3::$0 ]
Added variable gen_char3::$1 to live range equivalence class [ gen_char3::$1 ]
Complete equivalence classes
[ main::c#2 main::c#1 ]
[ main::charset#2 main::charset#1 ]
[ gen_char3::r#6 gen_char3::r#1 ]
[ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
[ gen_char3::c#2 gen_char3::c#1 ]
[ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
[ main::$7 ]
[ gen_char3::dst#0 ]
[ gen_char3::$0 ]
[ gen_char3::$1 ]
Allocated zp[1]:2 [ main::c#2 main::c#1 ]
Allocated zp[2]:3 [ main::charset#2 main::charset#1 ]
Allocated zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Allocated zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
Allocated zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ]
Allocated zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
Allocated zp[1]:10 [ main::$7 ]
Allocated zp[2]:11 [ gen_char3::dst#0 ]
Allocated zp[1]:13 [ gen_char3::$0 ]
Allocated zp[1]:14 [ gen_char3::$1 ]
REGISTER UPLIFT POTENTIAL REGISTERS
Statement [3] *VICII_MEMORY = (byte)(word)SCREEN/$40|(word)CHARSET/$400 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] main::$7 = main::c#2 << 1 [ main::c#2 main::charset#2 main::$7 ] (  [ main::c#2 main::charset#2 main::$7 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:2 [ main::c#2 main::c#1 ]
Statement [6] gen_char3::dst#0 = main::charset#2 [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] (  [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:10 [ main::$7 ]
Statement [7] gen_char3::spec#0 = charset_spec_row[main::$7] [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] (  [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [9] main::charset#1 = main::charset#2 + 8 [ main::c#2 main::charset#1 ] (  [ main::c#2 main::charset#1 ] { }  ) always clobbers reg byte a 
Statement [17] gen_char3::b#2 = gen_char3::b#4 | 1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ( gen_char3:8 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Removing always clobbered register reg byte a as potential for zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ]
Statement [3] *VICII_MEMORY = (byte)(word)SCREEN/$40|(word)CHARSET/$400 [ ] (  [ ] { }  ) always clobbers reg byte a 
Statement [5] main::$7 = main::c#2 << 1 [ main::c#2 main::charset#2 main::$7 ] (  [ main::c#2 main::charset#2 main::$7 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [6] gen_char3::dst#0 = main::charset#2 [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] (  [ main::c#2 main::charset#2 main::$7 gen_char3::dst#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [7] gen_char3::spec#0 = charset_spec_row[main::$7] [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] (  [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::spec#0 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Statement [9] main::charset#1 = main::charset#2 + 8 [ main::c#2 main::charset#1 ] (  [ main::c#2 main::charset#1 ] { }  ) always clobbers reg byte a 
Statement [17] gen_char3::b#2 = gen_char3::b#4 | 1 [ gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] ( gen_char3:8 [ main::c#2 main::charset#2 gen_char3::dst#0 gen_char3::r#6 gen_char3::spec#2 gen_char3::c#2 gen_char3::b#2 ] { { gen_char3::dst#0 = main::charset#2 } }  ) always clobbers reg byte a 
Potential registers zp[1]:2 [ main::c#2 main::c#1 ] : zp[1]:2 , reg byte x , reg byte y , 
Potential registers zp[2]:3 [ main::charset#2 main::charset#1 ] : zp[2]:3 , 
Potential registers zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] : zp[1]:5 , reg byte x , reg byte y , 
Potential registers zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] : zp[2]:6 , 
Potential registers zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ] : zp[1]:8 , reg byte x , reg byte y , 
Potential registers zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] : zp[1]:9 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:10 [ main::$7 ] : zp[1]:10 , reg byte x , reg byte y , 
Potential registers zp[2]:11 [ gen_char3::dst#0 ] : zp[2]:11 , 
Potential registers zp[1]:13 [ gen_char3::$0 ] : zp[1]:13 , reg byte a , reg byte x , reg byte y , 
Potential registers zp[1]:14 [ gen_char3::$1 ] : zp[1]:14 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [gen_char3] 627,506.5: zp[1]:9 [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] 200,002: zp[1]:13 [ gen_char3::$0 ] 200,002: zp[1]:14 [ gen_char3::$1 ] 175,001.75: zp[1]:8 [ gen_char3::c#2 gen_char3::c#1 ] 99,445.79: zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] 17,501.75: zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] 588.94: zp[2]:11 [ gen_char3::dst#0 ] 
Uplift Scope [main] 28.29: zp[1]:2 [ main::c#2 main::c#1 ] 16.5: zp[2]:3 [ main::charset#2 main::charset#1 ] 11: zp[1]:10 [ main::$7 ] 
Uplift Scope [] 

Uplifting [gen_char3] best 61700 combination reg byte y [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ] reg byte a [ gen_char3::$0 ] reg byte a [ gen_char3::$1 ] reg byte x [ gen_char3::c#2 gen_char3::c#1 ] zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ] zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] zp[2]:11 [ gen_char3::dst#0 ] 
Limited combination testing to 100 combinations of 576 possible.
Uplifting [main] best 61660 combination zp[1]:2 [ main::c#2 main::c#1 ] zp[2]:3 [ main::charset#2 main::charset#1 ] reg byte x [ main::$7 ] 
Uplifting [] best 61660 combination 
Attempting to uplift remaining variables inzp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
Uplifting [gen_char3] best 61660 combination zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ] 
Attempting to uplift remaining variables inzp[1]:2 [ main::c#2 main::c#1 ]
Uplifting [main] best 61660 combination zp[1]:2 [ main::c#2 main::c#1 ] 
Coalescing zero page register [ zp[2]:3 [ main::charset#2 main::charset#1 ] ] with [ zp[2]:11 [ gen_char3::dst#0 ] ] - score: 1

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
  // Commodore 64 PRG executable file
.file [name="norom-charset.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label VICII_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
.segment Code
  // main
main: {
    .label charset = 3
    .label c = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
  __b1_from_main:
    // [1] phi main::charset#2 = CHARSET+8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [1] phi main::c#2 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    jmp __b1
    // main::@1
  __b1:
    // [2] if(main::c#2!=4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    jmp __b3
    // main::@3
  __b3:
    // [3] *VICII_MEMORY = (byte)(word)SCREEN/$40|(word)CHARSET/$400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VICII_MEMORY
    jmp __breturn
    // main::@return
  __breturn:
    // [4] return 
    rts
    // main::@2
  __b2:
    // [5] main::$7 = main::c#2 << 1 -- vbuxx=vbuz1_rol_1 
    lda.z c
    asl
    tax
    // [6] gen_char3::dst#0 = main::charset#2
    // [7] gen_char3::spec#0 = charset_spec_row[main::$7] -- vwuz1=pwuc1_derefidx_vbuxx 
    lda charset_spec_row,x
    sta.z gen_char3.spec
    lda charset_spec_row+1,x
    sta.z gen_char3.spec+1
    // [8] call gen_char3 
    // [11] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
  gen_char3_from___b2:
    jsr gen_char3
    jmp __b4
    // main::@4
  __b4:
    // [9] main::charset#1 = main::charset#2 + 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // [10] main::c#1 = ++ main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [1] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
  __b1_from___b4:
    // [1] phi main::charset#2 = main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [1] phi main::c#2 = main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zp(3) dst, word zp(6) spec)
gen_char3: {
    .label dst = 3
    .label spec = 6
    .label r = 5
    // [12] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
  __b1_from_gen_char3:
    // [12] phi gen_char3::r#6 = 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [12] phi gen_char3::spec#4 = gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // [12] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
  __b1_from___b5:
    // [12] phi gen_char3::r#6 = gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [12] phi gen_char3::spec#4 = gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    jmp __b1
    // gen_char3::@1
  __b1:
    // [13] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
  __b2_from___b1:
    // [13] phi gen_char3::c#2 = 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [13] phi gen_char3::b#4 = 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // [13] phi gen_char3::spec#2 = gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // [13] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
  __b2_from___b3:
    // [13] phi gen_char3::c#2 = gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [13] phi gen_char3::b#4 = gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [13] phi gen_char3::spec#2 = gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    jmp __b2
    // gen_char3::@2
  __b2:
    // [14] gen_char3::$0 = byte1  gen_char3::spec#2 -- vbuaa=_byte1_vwuz1 
    lda.z spec+1
    // [15] gen_char3::$1 = gen_char3::$0 & $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // [16] if(gen_char3::$1==0) goto gen_char3::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3_from___b2
    jmp __b4
    // gen_char3::@4
  __b4:
    // [17] gen_char3::b#2 = gen_char3::b#4 | 1 -- vbuyy=vbuyy_bor_vbuc1 
    tya
    ora #1
    tay
    // [18] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
  __b3_from___b2:
  __b3_from___b4:
    // [18] phi gen_char3::b#3 = gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    jmp __b3
    // gen_char3::@3
  __b3:
    // [19] gen_char3::b#1 = gen_char3::b#3 << 1 -- vbuyy=vbuyy_rol_1 
    tya
    asl
    tay
    // [20] gen_char3::spec#1 = gen_char3::spec#2 << 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // [21] gen_char3::c#1 = ++ gen_char3::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [22] if(gen_char3::c#1!=3) goto gen_char3::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #3
    bne __b2_from___b3
    jmp __b5
    // gen_char3::@5
  __b5:
    // [23] gen_char3::dst#0[gen_char3::r#6] = gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuyy 
    tya
    ldy.z r
    sta (dst),y
    // [24] gen_char3::r#1 = ++ gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [25] if(gen_char3::r#1!=5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1_from___b5
    jmp __breturn
    // gen_char3::@return
  __breturn:
    // [26] return 
    rts
}
  // File Data
.segment Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

ASSEMBLER OPTIMIZATIONS
Removing instruction jmp __b1
Removing instruction jmp __b3
Removing instruction jmp __breturn
Removing instruction jmp __b4
Removing instruction jmp __b1
Removing instruction jmp __b2
Removing instruction jmp __b4
Removing instruction jmp __b3
Removing instruction jmp __b5
Removing instruction jmp __breturn
Succesful ASM optimization Pass5NextJumpElimination
Replacing label __b3_from___b2 with __b3
Replacing label __b2_from___b3 with __b2
Replacing label __b1_from___b5 with __b1
Removing instruction __b1_from___b5:
Removing instruction __b2_from___b1:
Removing instruction __b2_from___b3:
Removing instruction __b3_from___b2:
Removing instruction __b3_from___b4:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction __b1_from_main:
Removing instruction __b3:
Removing instruction __breturn:
Removing instruction gen_char3_from___b2:
Removing instruction __b4:
Removing instruction __b1_from___b4:
Removing instruction __b1_from_gen_char3:
Removing instruction __b4:
Removing instruction __b5:
Removing instruction __breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Removing instruction jmp __b1
Removing instruction jmp __b2
Succesful ASM optimization Pass5NextJumpElimination

FINAL SYMBOL TABLE
constant byte* CHARSET = (byte*) 12288
constant byte* SCREEN = (byte*) 1024
constant byte* VICII_MEMORY = (byte*) 53272
constant word* charset_spec_row[]  = { $f7da, $f7de, $f24e, $d6de }
void gen_char3(byte* gen_char3::dst , word gen_char3::spec)
byte~ gen_char3::$0 reg byte a 200002.0
byte~ gen_char3::$1 reg byte a 200002.0
byte gen_char3::b
byte gen_char3::b#1 reg byte y 52500.75
byte gen_char3::b#2 reg byte y 200002.0
byte gen_char3::b#3 reg byte y 300003.0
byte gen_char3::b#4 reg byte y 75000.75
byte gen_char3::c
byte gen_char3::c#1 reg byte x 150001.5
byte gen_char3::c#2 reg byte x 25000.25
byte* gen_char3::dst
byte* gen_char3::dst#0 dst zp[2]:3 588.9411764705882
byte gen_char3::r
byte gen_char3::r#1 r zp[1]:5 15001.5
byte gen_char3::r#6 r zp[1]:5 2500.25
word gen_char3::spec
word gen_char3::spec#0 spec zp[2]:6 56.0
word gen_char3::spec#1 spec zp[2]:6 35000.5
word gen_char3::spec#2 spec zp[2]:6 44286.28571428572
word gen_char3::spec#4 spec zp[2]:6 20103.0
void main()
byte~ main::$7 reg byte x 11.0
byte main::c
byte main::c#1 c zp[1]:2 22.0
byte main::c#2 c zp[1]:2 6.285714285714286
byte* main::charset
byte* main::charset#1 charset zp[2]:3 11.0
byte* main::charset#2 charset zp[2]:3 5.5

zp[1]:2 [ main::c#2 main::c#1 ]
zp[2]:3 [ main::charset#2 main::charset#1 gen_char3::dst#0 ]
zp[1]:5 [ gen_char3::r#6 gen_char3::r#1 ]
zp[2]:6 [ gen_char3::spec#2 gen_char3::spec#4 gen_char3::spec#0 gen_char3::spec#1 ]
reg byte x [ gen_char3::c#2 gen_char3::c#1 ]
reg byte y [ gen_char3::b#3 gen_char3::b#4 gen_char3::b#1 gen_char3::b#2 ]
reg byte x [ main::$7 ]
reg byte a [ gen_char3::$0 ]
reg byte a [ gen_char3::$1 ]


FINAL ASSEMBLER
Score: 45574

  // File Comments
// Generate a charset based on a 5x3 pattern stored in 2 bytes
  // Upstart
  // Commodore 64 PRG executable file
.file [name="norom-charset.prg", type="prg", segments="Program"]
.segmentdef Program [segments="Basic, Code, Data"]
.segmentdef Basic [start=$0801]
.segmentdef Code [start=$80d]
.segmentdef Data [startAfter="Code"]
.segment Basic
:BasicUpstart(main)
  // Global Constants & labels
  .label VICII_MEMORY = $d018
  .label SCREEN = $400
  .label CHARSET = $3000
.segment Code
  // main
main: {
    .label charset = 3
    .label c = 2
    // [1] phi from main to main::@1 [phi:main->main::@1]
    // [1] phi main::charset#2 = CHARSET+8 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<CHARSET+8
    sta.z charset
    lda #>CHARSET+8
    sta.z charset+1
    // [1] phi main::c#2 = 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta.z c
    // main::@1
  __b1:
    // for(byte c=0;c!=4;c++)
    // [2] if(main::c#2!=4) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #4
    cmp.z c
    bne __b2
    // main::@3
    // *VICII_MEMORY = (byte)(((word)SCREEN/$40)|((word)CHARSET/$400))
    // [3] *VICII_MEMORY = (byte)(word)SCREEN/$40|(word)CHARSET/$400 -- _deref_pbuc1=vbuc2 
    lda #SCREEN/$40|CHARSET/$400
    sta VICII_MEMORY
    // main::@return
    // }
    // [4] return 
    rts
    // main::@2
  __b2:
    // gen_char3(charset, charset_spec_row[c])
    // [5] main::$7 = main::c#2 << 1 -- vbuxx=vbuz1_rol_1 
    lda.z c
    asl
    tax
    // [6] gen_char3::dst#0 = main::charset#2
    // [7] gen_char3::spec#0 = charset_spec_row[main::$7] -- vwuz1=pwuc1_derefidx_vbuxx 
    lda charset_spec_row,x
    sta.z gen_char3.spec
    lda charset_spec_row+1,x
    sta.z gen_char3.spec+1
    // [8] call gen_char3 
    // [11] phi from main::@2 to gen_char3 [phi:main::@2->gen_char3]
    jsr gen_char3
    // main::@4
    // charset = charset+8
    // [9] main::charset#1 = main::charset#2 + 8 -- pbuz1=pbuz1_plus_vbuc1 
    lda #8
    clc
    adc.z charset
    sta.z charset
    bcc !+
    inc.z charset+1
  !:
    // for(byte c=0;c!=4;c++)
    // [10] main::c#1 = ++ main::c#2 -- vbuz1=_inc_vbuz1 
    inc.z c
    // [1] phi from main::@4 to main::@1 [phi:main::@4->main::@1]
    // [1] phi main::charset#2 = main::charset#1 [phi:main::@4->main::@1#0] -- register_copy 
    // [1] phi main::c#2 = main::c#1 [phi:main::@4->main::@1#1] -- register_copy 
    jmp __b1
}
  // gen_char3
// Generate one 5x3 character from a 16-bit char spec
// The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
// gen_char3(byte* zp(3) dst, word zp(6) spec)
gen_char3: {
    .label dst = 3
    .label spec = 6
    .label r = 5
    // [12] phi from gen_char3 to gen_char3::@1 [phi:gen_char3->gen_char3::@1]
    // [12] phi gen_char3::r#6 = 0 [phi:gen_char3->gen_char3::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta.z r
    // [12] phi gen_char3::spec#4 = gen_char3::spec#0 [phi:gen_char3->gen_char3::@1#1] -- register_copy 
    // [12] phi from gen_char3::@5 to gen_char3::@1 [phi:gen_char3::@5->gen_char3::@1]
    // [12] phi gen_char3::r#6 = gen_char3::r#1 [phi:gen_char3::@5->gen_char3::@1#0] -- register_copy 
    // [12] phi gen_char3::spec#4 = gen_char3::spec#1 [phi:gen_char3::@5->gen_char3::@1#1] -- register_copy 
    // gen_char3::@1
  __b1:
    // [13] phi from gen_char3::@1 to gen_char3::@2 [phi:gen_char3::@1->gen_char3::@2]
    // [13] phi gen_char3::c#2 = 0 [phi:gen_char3::@1->gen_char3::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [13] phi gen_char3::b#4 = 0 [phi:gen_char3::@1->gen_char3::@2#1] -- vbuyy=vbuc1 
    ldy #0
    // [13] phi gen_char3::spec#2 = gen_char3::spec#4 [phi:gen_char3::@1->gen_char3::@2#2] -- register_copy 
    // [13] phi from gen_char3::@3 to gen_char3::@2 [phi:gen_char3::@3->gen_char3::@2]
    // [13] phi gen_char3::c#2 = gen_char3::c#1 [phi:gen_char3::@3->gen_char3::@2#0] -- register_copy 
    // [13] phi gen_char3::b#4 = gen_char3::b#1 [phi:gen_char3::@3->gen_char3::@2#1] -- register_copy 
    // [13] phi gen_char3::spec#2 = gen_char3::spec#1 [phi:gen_char3::@3->gen_char3::@2#2] -- register_copy 
    // gen_char3::@2
  __b2:
    // BYTE1(spec)
    // [14] gen_char3::$0 = byte1  gen_char3::spec#2 -- vbuaa=_byte1_vwuz1 
    lda.z spec+1
    // BYTE1(spec)&$80
    // [15] gen_char3::$1 = gen_char3::$0 & $80 -- vbuaa=vbuaa_band_vbuc1 
    and #$80
    // if((BYTE1(spec)&$80)!=0)
    // [16] if(gen_char3::$1==0) goto gen_char3::@3 -- vbuaa_eq_0_then_la1 
    cmp #0
    beq __b3
    // gen_char3::@4
    // b = b|1
    // [17] gen_char3::b#2 = gen_char3::b#4 | 1 -- vbuyy=vbuyy_bor_vbuc1 
    tya
    ora #1
    tay
    // [18] phi from gen_char3::@2 gen_char3::@4 to gen_char3::@3 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3]
    // [18] phi gen_char3::b#3 = gen_char3::b#4 [phi:gen_char3::@2/gen_char3::@4->gen_char3::@3#0] -- register_copy 
    // gen_char3::@3
  __b3:
    // b = b*2
    // [19] gen_char3::b#1 = gen_char3::b#3 << 1 -- vbuyy=vbuyy_rol_1 
    tya
    asl
    tay
    // spec = spec*2
    // [20] gen_char3::spec#1 = gen_char3::spec#2 << 1 -- vwuz1=vwuz1_rol_1 
    asl.z spec
    rol.z spec+1
    // for(byte c: 0..2 )
    // [21] gen_char3::c#1 = ++ gen_char3::c#2 -- vbuxx=_inc_vbuxx 
    inx
    // [22] if(gen_char3::c#1!=3) goto gen_char3::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #3
    bne __b2
    // gen_char3::@5
    // dst[r] = b
    // [23] gen_char3::dst#0[gen_char3::r#6] = gen_char3::b#1 -- pbuz1_derefidx_vbuz2=vbuyy 
    tya
    ldy.z r
    sta (dst),y
    // for(byte r : 0..4 )
    // [24] gen_char3::r#1 = ++ gen_char3::r#6 -- vbuz1=_inc_vbuz1 
    inc.z r
    // [25] if(gen_char3::r#1!=5) goto gen_char3::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #5
    cmp.z r
    bne __b1
    // gen_char3::@return
    // }
    // [26] return 
    rts
}
  // File Data
.segment Data
  // Stores chars as 15 bits (in 2 bytes) specifying the 3x5
  // The 5x3 char is stored as 5x 3-bit rows followed by a zero. %aaabbbcc cdddeee0
  charset_spec_row: .word $f7da, $f7de, $f24e, $d6de

