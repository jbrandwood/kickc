Resolved forward reference mulf_sqr1 to (byte[$200]) mulf_sqr1
Resolved forward reference mulf_sqr2 to (byte[$200]) mulf_sqr2
Fixing pointer addition (word*~) bsearch16u::$7 ← (word*) bsearch16u::items + (byte~) bsearch16u::$6
Fixing pointer addition (word*~) bsearch16u::$15 ← (word*) bsearch16u::pivot + (number) 1
Fixing pointer addition (word*~) bsearch16u::$1 ← (word*) bsearch16u::items - (number) 1
Fixing pointer array-indexing *((word*) utoa::digit_values + (byte) utoa::digit)
Fixing pointer array-indexing *((dword*) ultoa::digit_values + (byte) ultoa::digit)
Warning! Adding boolean cast to non-boolean condition *((byte*) strcpy::src)
Identified constant variable (byte*) HEAP_TOP
Identified constant variable (byte) init_screen::WHITE
Identified constant variable (signed byte*) ap
Identified constant variable (signed byte*) bp
Identified constant variable (signed byte*) cp
Culled Empty Block (label) @1
Culled Empty Block (label) @2
Culled Empty Block (label) memset::@7
Culled Empty Block (label) memset::@6
Culled Empty Block (label) memset::@8
Culled Empty Block (label) memset::@9
Culled Empty Block (label) memset::@3
Culled Empty Block (label) @3
Culled Empty Block (label) @4
Culled Empty Block (label) @5
Culled Empty Block (label) @6
Culled Empty Block (label) @7
Culled Empty Block (label) @8
Culled Empty Block (label) @9
Culled Empty Block (label) @10
Culled Empty Block (label) @11
Culled Empty Block (label) @13
Culled Empty Block (label) @14
Culled Empty Block (label) @15
Culled Empty Block (label) @16
Culled Empty Block (label) @17
Culled Empty Block (label) @18
Culled Empty Block (label) @19
Culled Empty Block (label) @20
Culled Empty Block (label) print_sbyte_at::@4
Culled Empty Block (label) @21
Culled Empty Block (label) @22
Culled Empty Block (label) @23
Culled Empty Block (label) @24
Culled Empty Block (label) @25
Culled Empty Block (label) @26
Culled Empty Block (label) @27
Culled Empty Block (label) @28
Culled Empty Block (label) @30
Culled Empty Block (label) @31
Culled Empty Block (label) @32
Culled Empty Block (label) @33
Culled Empty Block (label) @34
Culled Empty Block (label) @35
Culled Empty Block (label) main::@6
Culled Empty Block (label) @37
Culled Empty Block (label) init_screen::@4
Culled Empty Block (label) fmul8::@1

CONTROL FLOW GRAPH SSA
@begin: scope:[]  from
  to:@12
memset: scope:[memset]  from print_cls
  (byte) memset::c#4 ← phi( print_cls/(byte) memset::c#0 )
  (void*) memset::str#3 ← phi( print_cls/(void*) memset::str#0 )
  (word) memset::num#1 ← phi( print_cls/(word) memset::num#0 )
  (bool~) memset::$0 ← (word) memset::num#1 > (number) 0
  (bool~) memset::$1 ← ! (bool~) memset::$0
  if((bool~) memset::$1) goto memset::@1
  to:memset::@2
memset::@1: scope:[memset]  from memset memset::@4
  (void*) memset::str#1 ← phi( memset/(void*) memset::str#3 memset::@4/(void*) memset::str#4 )
  (void*) memset::return#0 ← (void*) memset::str#1
  to:memset::@return
memset::@2: scope:[memset]  from memset
  (byte) memset::c#3 ← phi( memset/(byte) memset::c#4 )
  (word) memset::num#2 ← phi( memset/(word) memset::num#1 )
  (void*) memset::str#2 ← phi( memset/(void*) memset::str#3 )
  (byte*~) memset::$2 ← ((byte*)) (void*) memset::str#2
  (byte*~) memset::$3 ← (byte*~) memset::$2 + (word) memset::num#2
  (byte*) memset::end#0 ← (byte*~) memset::$3
  (byte*) memset::dst#0 ← ((byte*)) (void*) memset::str#2
  to:memset::@4
memset::@4: scope:[memset]  from memset::@2 memset::@5
  (byte) memset::c#2 ← phi( memset::@2/(byte) memset::c#3 memset::@5/(byte) memset::c#1 )
  (void*) memset::str#4 ← phi( memset::@2/(void*) memset::str#2 memset::@5/(void*) memset::str#5 )
  (byte*) memset::end#1 ← phi( memset::@2/(byte*) memset::end#0 memset::@5/(byte*) memset::end#2 )
  (byte*) memset::dst#2 ← phi( memset::@2/(byte*) memset::dst#0 memset::@5/(byte*) memset::dst#1 )
  (bool~) memset::$4 ← (byte*) memset::dst#2 != (byte*) memset::end#1
  if((bool~) memset::$4) goto memset::@5
  to:memset::@1
memset::@5: scope:[memset]  from memset::@4
  (void*) memset::str#5 ← phi( memset::@4/(void*) memset::str#4 )
  (byte*) memset::end#2 ← phi( memset::@4/(byte*) memset::end#1 )
  (byte*) memset::dst#3 ← phi( memset::@4/(byte*) memset::dst#2 )
  (byte) memset::c#1 ← phi( memset::@4/(byte) memset::c#2 )
  *((byte*) memset::dst#3) ← (byte) memset::c#1
  (byte*) memset::dst#1 ← ++ (byte*) memset::dst#3
  to:memset::@4
memset::@return: scope:[memset]  from memset::@1
  (void*) memset::return#3 ← phi( memset::@1/(void*) memset::return#0 )
  (void*) memset::return#1 ← (void*) memset::return#3
  return 
  to:@return
@12: scope:[]  from @begin
  (byte*) print_screen#0 ← ((byte*)) (number) $400
  to:@29
print_sbyte_at: scope:[print_sbyte_at]  from main::@1 main::@10 main::@3
  (byte*) print_sbyte_at::at#6 ← phi( main::@1/(byte*) print_sbyte_at::at#0 main::@10/(byte*) print_sbyte_at::at#2 main::@3/(byte*) print_sbyte_at::at#1 )
  (signed byte) print_sbyte_at::b#4 ← phi( main::@1/(signed byte) print_sbyte_at::b#1 main::@10/(signed byte) print_sbyte_at::b#3 main::@3/(signed byte) print_sbyte_at::b#2 )
  (bool~) print_sbyte_at::$0 ← (signed byte) print_sbyte_at::b#4 < (number) 0
  if((bool~) print_sbyte_at::$0) goto print_sbyte_at::@1
  to:print_sbyte_at::@3
print_sbyte_at::@1: scope:[print_sbyte_at]  from print_sbyte_at
  (signed byte) print_sbyte_at::b#7 ← phi( print_sbyte_at/(signed byte) print_sbyte_at::b#4 )
  (byte*) print_sbyte_at::at#3 ← phi( print_sbyte_at/(byte*) print_sbyte_at::at#6 )
  (byte) print_char_at::ch#0 ← (byte) '-'
  (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  call print_char_at 
  to:print_sbyte_at::@5
print_sbyte_at::@5: scope:[print_sbyte_at]  from print_sbyte_at::@1
  (byte*) print_sbyte_at::at#7 ← phi( print_sbyte_at::@1/(byte*) print_sbyte_at::at#3 )
  (signed byte) print_sbyte_at::b#5 ← phi( print_sbyte_at::@1/(signed byte) print_sbyte_at::b#7 )
  (signed byte~) print_sbyte_at::$6 ← - (signed byte) print_sbyte_at::b#5
  (signed byte) print_sbyte_at::b#0 ← (signed byte~) print_sbyte_at::$6
  to:print_sbyte_at::@2
print_sbyte_at::@3: scope:[print_sbyte_at]  from print_sbyte_at
  (signed byte) print_sbyte_at::b#9 ← phi( print_sbyte_at/(signed byte) print_sbyte_at::b#4 )
  (byte*) print_sbyte_at::at#4 ← phi( print_sbyte_at/(byte*) print_sbyte_at::at#6 )
  (byte) print_char_at::ch#1 ← (byte) ' '
  (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#4
  call print_char_at 
  to:print_sbyte_at::@6
print_sbyte_at::@6: scope:[print_sbyte_at]  from print_sbyte_at::@3
  (byte*) print_sbyte_at::at#8 ← phi( print_sbyte_at::@3/(byte*) print_sbyte_at::at#4 )
  (signed byte) print_sbyte_at::b#8 ← phi( print_sbyte_at::@3/(signed byte) print_sbyte_at::b#9 )
  to:print_sbyte_at::@2
print_sbyte_at::@2: scope:[print_sbyte_at]  from print_sbyte_at::@5 print_sbyte_at::@6
  (byte*) print_sbyte_at::at#5 ← phi( print_sbyte_at::@5/(byte*) print_sbyte_at::at#7 print_sbyte_at::@6/(byte*) print_sbyte_at::at#8 )
  (signed byte) print_sbyte_at::b#6 ← phi( print_sbyte_at::@5/(signed byte) print_sbyte_at::b#0 print_sbyte_at::@6/(signed byte) print_sbyte_at::b#8 )
  (byte~) print_sbyte_at::$1 ← ((byte)) (signed byte) print_sbyte_at::b#6
  (byte*~) print_sbyte_at::$2 ← (byte*) print_sbyte_at::at#5 + (number) 1
  (byte) print_byte_at::b#0 ← (byte~) print_sbyte_at::$1
  (byte*) print_byte_at::at#0 ← (byte*~) print_sbyte_at::$2
  call print_byte_at 
  to:print_sbyte_at::@7
print_sbyte_at::@7: scope:[print_sbyte_at]  from print_sbyte_at::@2
  to:print_sbyte_at::@return
print_sbyte_at::@return: scope:[print_sbyte_at]  from print_sbyte_at::@7
  return 
  to:@return
@29: scope:[]  from @12
  (byte*) print_screen#7 ← phi( @12/(byte*) print_screen#0 )
  (byte[]) print_hextab#0 ← (const string) $0
  to:@36
print_byte_at: scope:[print_byte_at]  from print_sbyte_at::@2
  (byte*) print_byte_at::at#1 ← phi( print_sbyte_at::@2/(byte*) print_byte_at::at#0 )
  (byte) print_byte_at::b#1 ← phi( print_sbyte_at::@2/(byte) print_byte_at::b#0 )
  (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#1 >> (number) 4
  (byte) print_char_at::ch#2 ← *((byte[]) print_hextab#0 + (byte~) print_byte_at::$0)
  (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#1
  call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  (byte*) print_byte_at::at#2 ← phi( print_byte_at/(byte*) print_byte_at::at#1 )
  (byte) print_byte_at::b#2 ← phi( print_byte_at/(byte) print_byte_at::b#1 )
  (number~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (number) $f
  (byte*~) print_byte_at::$3 ← (byte*) print_byte_at::at#2 + (number) 1
  (byte) print_char_at::ch#3 ← *((byte[]) print_hextab#0 + (number~) print_byte_at::$2)
  (byte*) print_char_at::at#3 ← (byte*~) print_byte_at::$3
  call print_char_at 
  to:print_byte_at::@2
print_byte_at::@2: scope:[print_byte_at]  from print_byte_at::@1
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@2
  return 
  to:@return
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1 print_sbyte_at::@1 print_sbyte_at::@3
  (byte*) print_char_at::at#4 ← phi( print_byte_at/(byte*) print_char_at::at#2 print_byte_at::@1/(byte*) print_char_at::at#3 print_sbyte_at::@1/(byte*) print_char_at::at#0 print_sbyte_at::@3/(byte*) print_char_at::at#1 )
  (byte) print_char_at::ch#4 ← phi( print_byte_at/(byte) print_char_at::ch#2 print_byte_at::@1/(byte) print_char_at::ch#3 print_sbyte_at::@1/(byte) print_char_at::ch#0 print_sbyte_at::@3/(byte) print_char_at::ch#1 )
  *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  return 
  to:@return
print_cls: scope:[print_cls]  from init_screen
  (byte*) print_screen#1 ← phi( init_screen/(byte*) print_screen#2 )
  (void*) memset::str#0 ← (void*)(byte*) print_screen#1
  (byte) memset::c#0 ← (byte) ' '
  (word) memset::num#0 ← (number) $3e8
  call memset 
  (void*) memset::return#2 ← (void*) memset::return#1
  to:print_cls::@1
print_cls::@1: scope:[print_cls]  from print_cls
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls::@1
  return 
  to:@return
@36: scope:[]  from @29
  (byte*) print_screen#6 ← phi( @29/(byte*) print_screen#7 )
  (signed byte[]) vals#0 ← { (number) -$5f, (number) -$40, (number) -$20, (number) -$10, (number) 0, (number) $10, (number) $20, (number) $40, (number) $5f }
  to:@38
main: scope:[main]  from @39
  (byte*) print_screen#3 ← phi( @39/(byte*) print_screen#4 )
  call init_screen 
  to:main::@7
main::@7: scope:[main]  from main
  (byte*) main::at_line#0 ← ((byte*)) (number) $400
  (byte*~) main::$1 ← (byte*) main::at_line#0 + (number) 4
  (byte*) main::at#0 ← (byte*~) main::$1
  (byte) main::k#0 ← (byte) 0
  to:main::@1
main::@1: scope:[main]  from main::@7 main::@8
  (byte*) main::at_line#7 ← phi( main::@7/(byte*) main::at_line#0 main::@8/(byte*) main::at_line#5 )
  (byte*) main::at#4 ← phi( main::@7/(byte*) main::at#0 main::@8/(byte*) main::at#1 )
  (byte) main::k#2 ← phi( main::@7/(byte) main::k#0 main::@8/(byte) main::k#1 )
  (signed byte) print_sbyte_at::b#1 ← *((signed byte[]) vals#0 + (byte) main::k#2)
  (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4
  call print_sbyte_at 
  to:main::@8
main::@8: scope:[main]  from main::@1
  (byte*) main::at_line#5 ← phi( main::@1/(byte*) main::at_line#7 )
  (byte) main::k#3 ← phi( main::@1/(byte) main::k#2 )
  (byte*) main::at#5 ← phi( main::@1/(byte*) main::at#4 )
  (byte*) main::at#1 ← (byte*) main::at#5 + (number) 4
  (byte) main::k#1 ← (byte) main::k#3 + rangenext(0,8)
  (bool~) main::$3 ← (byte) main::k#1 != rangelast(0,8)
  if((bool~) main::$3) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@8
  (byte*) main::at_line#3 ← phi( main::@8/(byte*) main::at_line#5 )
  (byte) main::i#0 ← (byte) 0
  to:main::@3
main::@3: scope:[main]  from main::@2 main::@5
  (byte) main::i#2 ← phi( main::@2/(byte) main::i#0 main::@5/(byte) main::i#1 )
  (byte*) main::at_line#2 ← phi( main::@2/(byte*) main::at_line#3 main::@5/(byte*) main::at_line#4 )
  (byte*) main::at_line#1 ← (byte*) main::at_line#2 + (number) $28
  (byte*) main::at#2 ← (byte*) main::at_line#1
  (signed byte) print_sbyte_at::b#2 ← *((signed byte[]) vals#0 + (byte) main::i#2)
  (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2
  call print_sbyte_at 
  to:main::@9
main::@9: scope:[main]  from main::@3
  (byte*) main::at_line#10 ← phi( main::@3/(byte*) main::at_line#1 )
  (byte) main::i#6 ← phi( main::@3/(byte) main::i#2 )
  (byte*) main::at#9 ← phi( main::@3/(byte*) main::at#2 )
  (byte) main::j#0 ← (byte) 0
  to:main::@4
main::@4: scope:[main]  from main::@11 main::@9
  (byte*) main::at_line#9 ← phi( main::@11/(byte*) main::at_line#6 main::@9/(byte*) main::at_line#10 )
  (byte) main::j#2 ← phi( main::@11/(byte) main::j#1 main::@9/(byte) main::j#0 )
  (byte) main::i#3 ← phi( main::@11/(byte) main::i#5 main::@9/(byte) main::i#6 )
  (byte*) main::at#6 ← phi( main::@11/(byte*) main::at#8 main::@9/(byte*) main::at#9 )
  (byte*) main::at#3 ← (byte*) main::at#6 + (number) 4
  (signed byte) fmul8::a#0 ← *((signed byte[]) vals#0 + (byte) main::i#3)
  (signed byte) fmul8::b#0 ← *((signed byte[]) vals#0 + (byte) main::j#2)
  call fmul8 
  (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#2
  to:main::@10
main::@10: scope:[main]  from main::@4
  (byte*) main::at_line#8 ← phi( main::@4/(byte*) main::at_line#9 )
  (byte) main::i#7 ← phi( main::@4/(byte) main::i#3 )
  (byte) main::j#4 ← phi( main::@4/(byte) main::j#2 )
  (byte*) main::at#7 ← phi( main::@4/(byte*) main::at#3 )
  (signed byte) fmul8::return#3 ← phi( main::@4/(signed byte) fmul8::return#0 )
  (signed byte~) main::$5 ← (signed byte) fmul8::return#3
  (signed byte) main::r#0 ← (signed byte~) main::$5
  (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0
  (byte*) print_sbyte_at::at#2 ← (byte*) main::at#7
  call print_sbyte_at 
  to:main::@11
main::@11: scope:[main]  from main::@10
  (byte*) main::at_line#6 ← phi( main::@10/(byte*) main::at_line#8 )
  (byte) main::i#5 ← phi( main::@10/(byte) main::i#7 )
  (byte*) main::at#8 ← phi( main::@10/(byte*) main::at#7 )
  (byte) main::j#3 ← phi( main::@10/(byte) main::j#4 )
  (byte) main::j#1 ← (byte) main::j#3 + rangenext(0,8)
  (bool~) main::$7 ← (byte) main::j#1 != rangelast(0,8)
  if((bool~) main::$7) goto main::@4
  to:main::@5
main::@5: scope:[main]  from main::@11
  (byte*) main::at_line#4 ← phi( main::@11/(byte*) main::at_line#6 )
  (byte) main::i#4 ← phi( main::@11/(byte) main::i#5 )
  (byte) main::i#1 ← (byte) main::i#4 + rangenext(0,8)
  (bool~) main::$8 ← (byte) main::i#1 != rangelast(0,8)
  if((bool~) main::$8) goto main::@3
  to:main::@return
main::@return: scope:[main]  from main::@5
  return 
  to:@return
init_screen: scope:[init_screen]  from main
  (byte*) print_screen#2 ← phi( main/(byte*) print_screen#3 )
  call print_cls 
  to:init_screen::@5
init_screen::@5: scope:[init_screen]  from init_screen
  (byte*) init_screen::COLS#0 ← ((byte*)) (number) $d800
  (byte) init_screen::WHITE#0 ← (number) 1
  (byte) init_screen::l#0 ← (byte) 0
  to:init_screen::@1
init_screen::@1: scope:[init_screen]  from init_screen::@1 init_screen::@5
  (byte) init_screen::l#2 ← phi( init_screen::@1/(byte) init_screen::l#1 init_screen::@5/(byte) init_screen::l#0 )
  (byte*) init_screen::COLS#2 ← phi( init_screen::@1/(byte*) init_screen::COLS#2 init_screen::@5/(byte*) init_screen::COLS#0 )
  *((byte*) init_screen::COLS#2 + (byte) init_screen::l#2) ← (byte) init_screen::WHITE#0
  (byte) init_screen::l#1 ← (byte) init_screen::l#2 + rangenext(0,$27)
  (bool~) init_screen::$1 ← (byte) init_screen::l#1 != rangelast(0,$27)
  if((bool~) init_screen::$1) goto init_screen::@1
  to:init_screen::@2
init_screen::@2: scope:[init_screen]  from init_screen::@1
  (byte*) init_screen::COLS#4 ← phi( init_screen::@1/(byte*) init_screen::COLS#2 )
  (byte) init_screen::m#0 ← (byte) 0
  to:init_screen::@3
init_screen::@3: scope:[init_screen]  from init_screen::@2 init_screen::@3
  (byte) init_screen::m#2 ← phi( init_screen::@2/(byte) init_screen::m#0 init_screen::@3/(byte) init_screen::m#1 )
  (byte*) init_screen::COLS#3 ← phi( init_screen::@2/(byte*) init_screen::COLS#4 init_screen::@3/(byte*) init_screen::COLS#1 )
  *((byte*) init_screen::COLS#3 + (number) 0) ← (byte) init_screen::WHITE#0
  *((byte*) init_screen::COLS#3 + (number) 1) ← (byte) init_screen::WHITE#0
  *((byte*) init_screen::COLS#3 + (number) 2) ← (byte) init_screen::WHITE#0
  *((byte*) init_screen::COLS#3 + (number) 3) ← (byte) init_screen::WHITE#0
  (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (number) $28
  (byte) init_screen::m#1 ← (byte) init_screen::m#2 + rangenext(0,$18)
  (bool~) init_screen::$2 ← (byte) init_screen::m#1 != rangelast(0,$18)
  if((bool~) init_screen::$2) goto init_screen::@3
  to:init_screen::@return
init_screen::@return: scope:[init_screen]  from init_screen::@3
  return 
  to:@return
@38: scope:[]  from @36
  (byte*) print_screen#5 ← phi( @36/(byte*) print_screen#6 )
  (signed byte*) ap#0 ← ((signed byte*)) (number) $fd
  (signed byte*) bp#0 ← ((signed byte*)) (number) $fe
  (signed byte*) cp#0 ← ((signed byte*)) (number) $ff
  to:@39
fmul8: scope:[fmul8]  from main::@4
  (signed byte) fmul8::b#1 ← phi( main::@4/(signed byte) fmul8::b#0 )
  (signed byte) fmul8::a#1 ← phi( main::@4/(signed byte) fmul8::a#0 )
  *((signed byte*) ap#0) ← (signed byte) fmul8::a#1
  *((signed byte*) bp#0) ← (signed byte) fmul8::b#1
  asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
  (signed byte) fmul8::return#1 ← *((signed byte*) cp#0)
  to:fmul8::@return
fmul8::@return: scope:[fmul8]  from fmul8
  (signed byte) fmul8::return#4 ← phi( fmul8/(signed byte) fmul8::return#1 )
  (signed byte) fmul8::return#2 ← (signed byte) fmul8::return#4
  return 
  to:@return
@39: scope:[]  from @38
  (byte*) print_screen#4 ← phi( @38/(byte*) print_screen#5 )
  (byte[$200]) mulf_sqr1#0 ← kickasm {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }
 }}
  (byte[$200]) mulf_sqr2#0 ← kickasm {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }
 }}
  call main 
  to:@40
@40: scope:[]  from @39
  to:@end
@end: scope:[]  from @40

SYMBOL TABLE SSA
(const string) $0 = (string) "0123456789abcdef"
(label) @12
(label) @29
(label) @36
(label) @38
(label) @39
(label) @40
(label) @begin
(label) @end
(const byte) RADIX::BINARY = (number) 2
(const byte) RADIX::DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL = (number) 8
(signed byte*) ap
(signed byte*) ap#0
(signed byte*) bp
(signed byte*) bp#0
(signed byte*) cp
(signed byte*) cp#0
(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
(label) fmul8::@return
(signed byte) fmul8::a
(signed byte) fmul8::a#0
(signed byte) fmul8::a#1
(signed byte) fmul8::b
(signed byte) fmul8::b#0
(signed byte) fmul8::b#1
(signed byte) fmul8::return
(signed byte) fmul8::return#0
(signed byte) fmul8::return#1
(signed byte) fmul8::return#2
(signed byte) fmul8::return#3
(signed byte) fmul8::return#4
(void()) init_screen()
(bool~) init_screen::$1
(bool~) init_screen::$2
(label) init_screen::@1
(label) init_screen::@2
(label) init_screen::@3
(label) init_screen::@5
(label) init_screen::@return
(byte*) init_screen::COLS
(byte*) init_screen::COLS#0
(byte*) init_screen::COLS#1
(byte*) init_screen::COLS#2
(byte*) init_screen::COLS#3
(byte*) init_screen::COLS#4
(byte) init_screen::WHITE
(byte) init_screen::WHITE#0
(byte) init_screen::l
(byte) init_screen::l#0
(byte) init_screen::l#1
(byte) init_screen::l#2
(byte) init_screen::m
(byte) init_screen::m#0
(byte) init_screen::m#1
(byte) init_screen::m#2
(void()) main()
(byte*~) main::$1
(bool~) main::$3
(signed byte~) main::$5
(bool~) main::$7
(bool~) main::$8
(label) main::@1
(label) main::@10
(label) main::@11
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@7
(label) main::@8
(label) main::@9
(label) main::@return
(byte*) main::at
(byte*) main::at#0
(byte*) main::at#1
(byte*) main::at#2
(byte*) main::at#3
(byte*) main::at#4
(byte*) main::at#5
(byte*) main::at#6
(byte*) main::at#7
(byte*) main::at#8
(byte*) main::at#9
(byte*) main::at_line
(byte*) main::at_line#0
(byte*) main::at_line#1
(byte*) main::at_line#10
(byte*) main::at_line#2
(byte*) main::at_line#3
(byte*) main::at_line#4
(byte*) main::at_line#5
(byte*) main::at_line#6
(byte*) main::at_line#7
(byte*) main::at_line#8
(byte*) main::at_line#9
(byte) main::i
(byte) main::i#0
(byte) main::i#1
(byte) main::i#2
(byte) main::i#3
(byte) main::i#4
(byte) main::i#5
(byte) main::i#6
(byte) main::i#7
(byte) main::j
(byte) main::j#0
(byte) main::j#1
(byte) main::j#2
(byte) main::j#3
(byte) main::j#4
(byte) main::k
(byte) main::k#0
(byte) main::k#1
(byte) main::k#2
(byte) main::k#3
(signed byte) main::r
(signed byte) main::r#0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(bool~) memset::$0
(bool~) memset::$1
(byte*~) memset::$2
(byte*~) memset::$3
(bool~) memset::$4
(label) memset::@1
(label) memset::@2
(label) memset::@4
(label) memset::@5
(label) memset::@return
(byte) memset::c
(byte) memset::c#0
(byte) memset::c#1
(byte) memset::c#2
(byte) memset::c#3
(byte) memset::c#4
(byte*) memset::dst
(byte*) memset::dst#0
(byte*) memset::dst#1
(byte*) memset::dst#2
(byte*) memset::dst#3
(byte*) memset::end
(byte*) memset::end#0
(byte*) memset::end#1
(byte*) memset::end#2
(word) memset::num
(word) memset::num#0
(word) memset::num#1
(word) memset::num#2
(void*) memset::return
(void*) memset::return#0
(void*) memset::return#1
(void*) memset::return#2
(void*) memset::return#3
(void*) memset::str
(void*) memset::str#0
(void*) memset::str#1
(void*) memset::str#2
(void*) memset::str#3
(void*) memset::str#4
(void*) memset::str#5
(byte[$200]) mulf_sqr1
(byte[$200]) mulf_sqr1#0
(byte[$200]) mulf_sqr2
(byte[$200]) mulf_sqr2#0
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0
(number~) print_byte_at::$2
(byte*~) print_byte_at::$3
(label) print_byte_at::@1
(label) print_byte_at::@2
(label) print_byte_at::@return
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0
(byte*) print_byte_at::at#1
(byte*) print_byte_at::at#2
(byte) print_byte_at::b
(byte) print_byte_at::b#0
(byte) print_byte_at::b#1
(byte) print_byte_at::b#2
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0
(byte*) print_char_at::at#1
(byte*) print_char_at::at#2
(byte*) print_char_at::at#3
(byte*) print_char_at::at#4
(byte) print_char_at::ch
(byte) print_char_at::ch#0
(byte) print_char_at::ch#1
(byte) print_char_at::ch#2
(byte) print_char_at::ch#3
(byte) print_char_at::ch#4
(void()) print_cls()
(label) print_cls::@1
(label) print_cls::@return
(byte[]) print_hextab
(byte[]) print_hextab#0
(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
(bool~) print_sbyte_at::$0
(byte~) print_sbyte_at::$1
(byte*~) print_sbyte_at::$2
(signed byte~) print_sbyte_at::$6
(label) print_sbyte_at::@1
(label) print_sbyte_at::@2
(label) print_sbyte_at::@3
(label) print_sbyte_at::@5
(label) print_sbyte_at::@6
(label) print_sbyte_at::@7
(label) print_sbyte_at::@return
(byte*) print_sbyte_at::at
(byte*) print_sbyte_at::at#0
(byte*) print_sbyte_at::at#1
(byte*) print_sbyte_at::at#2
(byte*) print_sbyte_at::at#3
(byte*) print_sbyte_at::at#4
(byte*) print_sbyte_at::at#5
(byte*) print_sbyte_at::at#6
(byte*) print_sbyte_at::at#7
(byte*) print_sbyte_at::at#8
(signed byte) print_sbyte_at::b
(signed byte) print_sbyte_at::b#0
(signed byte) print_sbyte_at::b#1
(signed byte) print_sbyte_at::b#2
(signed byte) print_sbyte_at::b#3
(signed byte) print_sbyte_at::b#4
(signed byte) print_sbyte_at::b#5
(signed byte) print_sbyte_at::b#6
(signed byte) print_sbyte_at::b#7
(signed byte) print_sbyte_at::b#8
(signed byte) print_sbyte_at::b#9
(byte*) print_screen
(byte*) print_screen#0
(byte*) print_screen#1
(byte*) print_screen#2
(byte*) print_screen#3
(byte*) print_screen#4
(byte*) print_screen#5
(byte*) print_screen#6
(byte*) print_screen#7
(signed byte[]) vals
(signed byte[]) vals#0

Adding number conversion cast (unumber) 0 in (bool~) memset::$0 ← (word) memset::num#1 > (number) 0
Adding number conversion cast (snumber) 0 in (bool~) print_sbyte_at::$0 ← (signed byte) print_sbyte_at::b#4 < (number) 0
Adding number conversion cast (unumber) 1 in (byte*~) print_sbyte_at::$2 ← (byte*) print_sbyte_at::at#5 + (number) 1
Adding number conversion cast (unumber) 4 in (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#1 >> (number) 4
Adding number conversion cast (unumber) $f in (number~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (number) $f
Adding number conversion cast (unumber) print_byte_at::$2 in (number~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (unumber)(number) $f
Adding number conversion cast (unumber) 1 in (byte*~) print_byte_at::$3 ← (byte*) print_byte_at::at#2 + (number) 1
Adding number conversion cast (unumber) $3e8 in (word) memset::num#0 ← (number) $3e8
Adding number conversion cast (unumber) 4 in (byte*~) main::$1 ← (byte*) main::at_line#0 + (number) 4
Adding number conversion cast (unumber) 4 in (byte*) main::at#1 ← (byte*) main::at#5 + (number) 4
Adding number conversion cast (unumber) $28 in (byte*) main::at_line#1 ← (byte*) main::at_line#2 + (number) $28
Adding number conversion cast (unumber) 4 in (byte*) main::at#3 ← (byte*) main::at#6 + (number) 4
Adding number conversion cast (unumber) 1 in (byte) init_screen::WHITE#0 ← (number) 1
Adding number conversion cast (unumber) 0 in *((byte*) init_screen::COLS#3 + (number) 0) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) 1 in *((byte*) init_screen::COLS#3 + (number) 1) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) 2 in *((byte*) init_screen::COLS#3 + (number) 2) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) 3 in *((byte*) init_screen::COLS#3 + (number) 3) ← (byte) init_screen::WHITE#0
Adding number conversion cast (unumber) $28 in (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (number) $28
Successful SSA optimization PassNAddNumberTypeConversions
Added casts to value list in (signed byte[]) vals#0 ← (signed byte[]){ (signed byte)(number) -$5f, (signed byte)(number) -$40, (signed byte)(number) -$20, (signed byte)(number) -$10, (signed byte)(number) 0, (signed byte)(number) $10, (signed byte)(number) $20, (signed byte)(number) $40, (signed byte)(number) $5f }
Successful SSA optimization PassNAddInitializerValueListTypeCasts
Inlining cast (byte*~) memset::$2 ← (byte*)(void*) memset::str#2
Inlining cast (byte*) memset::dst#0 ← (byte*)(void*) memset::str#2
Inlining cast (byte*) print_screen#0 ← (byte*)(number) $400
Inlining cast (byte~) print_sbyte_at::$1 ← (byte)(signed byte) print_sbyte_at::b#6
Inlining cast (word) memset::num#0 ← (unumber)(number) $3e8
Inlining cast (byte*) main::at_line#0 ← (byte*)(number) $400
Inlining cast (byte*) init_screen::COLS#0 ← (byte*)(number) $d800
Inlining cast (byte) init_screen::WHITE#0 ← (unumber)(number) 1
Inlining cast (signed byte*) ap#0 ← (signed byte*)(number) $fd
Inlining cast (signed byte*) bp#0 ← (signed byte*)(number) $fe
Inlining cast (signed byte*) cp#0 ← (signed byte*)(number) $ff
Successful SSA optimization Pass2InlineCast
Simplifying constant integer cast 0
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 4
Simplifying constant integer cast $f
Simplifying constant integer cast 1
Simplifying constant integer cast $3e8
Simplifying constant integer cast -$5f
Simplifying constant integer cast -$40
Simplifying constant integer cast -$20
Simplifying constant integer cast -$10
Simplifying constant integer cast 0
Simplifying constant integer cast $10
Simplifying constant integer cast $20
Simplifying constant integer cast $40
Simplifying constant integer cast $5f
Simplifying constant pointer cast (byte*) 1024
Simplifying constant integer cast 4
Simplifying constant integer cast 4
Simplifying constant integer cast $28
Simplifying constant integer cast 4
Simplifying constant pointer cast (byte*) 55296
Simplifying constant integer cast 1
Simplifying constant integer cast 0
Simplifying constant integer cast 1
Simplifying constant integer cast 2
Simplifying constant integer cast 3
Simplifying constant integer cast $28
Simplifying constant pointer cast (signed byte*) 253
Simplifying constant pointer cast (signed byte*) 254
Simplifying constant pointer cast (signed byte*) 255
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 0
Finalized signed number type (signed byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $f
Finalized unsigned number type (byte) 1
Finalized unsigned number type (word) $3e8
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) 4
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 0
Finalized unsigned number type (byte) 1
Finalized unsigned number type (byte) 2
Finalized unsigned number type (byte) 3
Finalized unsigned number type (byte) $28
Successful SSA optimization PassNFinalizeNumberTypeConversions
Inferred type updated to byte in (unumber~) print_byte_at::$2 ← (byte) print_byte_at::b#2 & (byte) $f
Inversing boolean not [2] (bool~) memset::$1 ← (word) memset::num#1 <= (byte) 0 from [1] (bool~) memset::$0 ← (word) memset::num#1 > (byte) 0
Successful SSA optimization Pass2UnaryNotSimplification
Alias (void*) memset::return#0 = (void*) memset::str#1 (void*) memset::return#3 (void*) memset::return#1 
Alias (void*) memset::str#2 = (void*) memset::str#3 
Alias (word) memset::num#1 = (word) memset::num#2 
Alias (byte) memset::c#3 = (byte) memset::c#4 
Alias (byte*) memset::end#0 = (byte*~) memset::$3 
Alias (byte) memset::c#1 = (byte) memset::c#2 
Alias (byte*) memset::dst#2 = (byte*) memset::dst#3 
Alias (byte*) memset::end#1 = (byte*) memset::end#2 
Alias (void*) memset::str#4 = (void*) memset::str#5 
Alias (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#6 (byte*) print_sbyte_at::at#7 (byte*) print_sbyte_at::at#4 (byte*) print_sbyte_at::at#8 
Alias (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#7 (signed byte) print_sbyte_at::b#5 (signed byte) print_sbyte_at::b#9 (signed byte) print_sbyte_at::b#8 
Alias (signed byte) print_sbyte_at::b#0 = (signed byte~) print_sbyte_at::$6 
Alias (byte) print_byte_at::b#0 = (byte~) print_sbyte_at::$1 
Alias (byte*) print_byte_at::at#0 = (byte*~) print_sbyte_at::$2 
Alias (byte*) print_screen#0 = (byte*) print_screen#7 (byte*) print_screen#6 (byte*) print_screen#5 (byte*) print_screen#4 
Alias (byte) print_byte_at::b#1 = (byte) print_byte_at::b#2 
Alias (byte*) print_byte_at::at#1 = (byte*) print_byte_at::at#2 
Alias (byte*) print_char_at::at#3 = (byte*~) print_byte_at::$3 
Alias (byte*) main::at#0 = (byte*~) main::$1 
Alias (byte*) main::at#4 = (byte*) main::at#5 
Alias (byte) main::k#2 = (byte) main::k#3 
Alias (byte*) main::at_line#3 = (byte*) main::at_line#5 (byte*) main::at_line#7 
Alias (byte*) main::at#2 = (byte*) main::at_line#1 (byte*) main::at#9 (byte*) main::at_line#10 
Alias (byte) main::i#2 = (byte) main::i#6 
Alias (signed byte) fmul8::return#0 = (signed byte) fmul8::return#3 
Alias (byte*) main::at#3 = (byte*) main::at#7 (byte*) main::at#8 
Alias (byte) main::j#2 = (byte) main::j#4 (byte) main::j#3 
Alias (byte) main::i#3 = (byte) main::i#7 (byte) main::i#5 (byte) main::i#4 
Alias (byte*) main::at_line#4 = (byte*) main::at_line#8 (byte*) main::at_line#9 (byte*) main::at_line#6 
Alias (signed byte) main::r#0 = (signed byte~) main::$5 
Alias (byte*) init_screen::COLS#2 = (byte*) init_screen::COLS#4 
Alias (signed byte) fmul8::return#1 = (signed byte) fmul8::return#4 (signed byte) fmul8::return#2 
Successful SSA optimization Pass2AliasElimination
Alias (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#5 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (word) memset::num#1 (word) memset::num#0
Identical Phi Values (void*) memset::str#2 (void*) memset::str#0
Identical Phi Values (byte) memset::c#3 (byte) memset::c#0
Identical Phi Values (byte*) memset::end#1 (byte*) memset::end#0
Identical Phi Values (void*) memset::str#4 (void*) memset::str#2
Identical Phi Values (byte) memset::c#1 (byte) memset::c#3
Identical Phi Values (byte) print_byte_at::b#1 (byte) print_byte_at::b#0
Identical Phi Values (byte*) print_byte_at::at#1 (byte*) print_byte_at::at#0
Identical Phi Values (byte*) print_screen#1 (byte*) print_screen#2
Identical Phi Values (byte*) print_screen#3 (byte*) print_screen#0
Identical Phi Values (byte*) main::at_line#3 (byte*) main::at_line#0
Identical Phi Values (byte) main::i#3 (byte) main::i#2
Identical Phi Values (byte*) main::at_line#4 (byte*) main::at#2
Identical Phi Values (byte*) print_screen#2 (byte*) print_screen#3
Identical Phi Values (byte*) init_screen::COLS#2 (byte*) init_screen::COLS#0
Identical Phi Values (signed byte) fmul8::a#1 (signed byte) fmul8::a#0
Identical Phi Values (signed byte) fmul8::b#1 (signed byte) fmul8::b#0
Successful SSA optimization Pass2IdenticalPhiElimination
Identical Phi Values (void*) memset::return#0 (void*) memset::str#0
Successful SSA optimization Pass2IdenticalPhiElimination
Simple Condition (bool~) memset::$1 [3] if((word) memset::num#0<=(byte) 0) goto memset::@1
Simple Condition (bool~) memset::$4 [13] if((byte*) memset::dst#2!=(byte*) memset::end#0) goto memset::@5
Simple Condition (bool~) print_sbyte_at::$0 [23] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1
Simple Condition (bool~) main::$3 [83] if((byte) main::k#1!=rangelast(0,8)) goto main::@1
Simple Condition (bool~) main::$7 [109] if((byte) main::j#1!=rangelast(0,8)) goto main::@4
Simple Condition (bool~) main::$8 [113] if((byte) main::i#1!=rangelast(0,8)) goto main::@3
Simple Condition (bool~) init_screen::$1 [124] if((byte) init_screen::l#1!=rangelast(0,$27)) goto init_screen::@1
Simple Condition (bool~) init_screen::$2 [135] if((byte) init_screen::m#1!=rangelast(0,$18)) goto init_screen::@3
Successful SSA optimization Pass2ConditionalJumpSimplification
Identified constant from value list (signed byte[]) { (signed byte) -$5f, (signed byte) -$40, (signed byte) -$20, (signed byte) -$10, (signed byte) 0, (signed byte) $10, (signed byte) $20, (signed byte) $40, (signed byte) $5f }
Successful SSA optimization Pass2ConstantInitializerValueLists
Constant (const byte*) print_screen#0 = (byte*) 1024
Constant (const byte) print_char_at::ch#0 = '-'
Constant (const byte) print_char_at::ch#1 = ' '
Constant (const byte[]) print_hextab#0 = $0
Constant (const byte) memset::c#0 = ' '
Constant (const word) memset::num#0 = $3e8
Constant (const signed byte[]) vals#0 = { -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f }
Constant (const byte*) main::at_line#0 = (byte*) 1024
Constant (const byte) main::k#0 = 0
Constant (const byte) main::i#0 = 0
Constant (const byte) main::j#0 = 0
Constant (const byte*) init_screen::COLS#0 = (byte*) 55296
Constant (const byte) init_screen::WHITE#0 = 1
Constant (const byte) init_screen::l#0 = 0
Constant (const byte) init_screen::m#0 = 0
Constant (const signed byte*) ap#0 = (signed byte*) 253
Constant (const signed byte*) bp#0 = (signed byte*) 254
Constant (const signed byte*) cp#0 = (signed byte*) 255
Constant (const byte[$200]) mulf_sqr1#0 = kickasm {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }
 }}
Constant (const byte[$200]) mulf_sqr2#0 = kickasm {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }
 }}
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (void*)print_screen#0 in [61] (void*) memset::str#0 ← (void*)(const byte*) print_screen#0
Successful SSA optimization Pass2ConstantValues
if() condition always false - eliminating [3] if((const word) memset::num#0<=(byte) 0) goto memset::@1
Successful SSA optimization Pass2ConstantIfs
Resolved ranged next value [81] main::k#1 ← ++ main::k#2 to ++
Resolved ranged comparison value [83] if(main::k#1!=rangelast(0,8)) goto main::@1 to (number) 9
Resolved ranged next value [107] main::j#1 ← ++ main::j#2 to ++
Resolved ranged comparison value [109] if(main::j#1!=rangelast(0,8)) goto main::@4 to (number) 9
Resolved ranged next value [111] main::i#1 ← ++ main::i#2 to ++
Resolved ranged comparison value [113] if(main::i#1!=rangelast(0,8)) goto main::@3 to (number) 9
Resolved ranged next value [122] init_screen::l#1 ← ++ init_screen::l#2 to ++
Resolved ranged comparison value [124] if(init_screen::l#1!=rangelast(0,$27)) goto init_screen::@1 to (number) $28
Resolved ranged next value [133] init_screen::m#1 ← ++ init_screen::m#2 to ++
Resolved ranged comparison value [135] if(init_screen::m#1!=rangelast(0,$18)) goto init_screen::@3 to (number) $19
Simplifying expression containing zero init_screen::COLS#3 in [128] *((byte*) init_screen::COLS#3 + (byte) 0) ← (const byte) init_screen::WHITE#0
Successful SSA optimization PassNSimplifyExpressionWithZero
Eliminating unused variable (void*) memset::return#2 and assignment [34] (void*) memset::return#2 ← (void*) memset::str#0
Successful SSA optimization PassNEliminateUnusedVars
Adding number conversion cast (unumber) 9 in if((byte) main::k#1!=(number) 9) goto main::@1
Adding number conversion cast (unumber) 9 in if((byte) main::j#1!=(number) 9) goto main::@4
Adding number conversion cast (unumber) 9 in if((byte) main::i#1!=(number) 9) goto main::@3
Adding number conversion cast (unumber) $28 in if((byte) init_screen::l#1!=(number) $28) goto init_screen::@1
Adding number conversion cast (unumber) $19 in if((byte) init_screen::m#1!=(number) $19) goto init_screen::@3
Successful SSA optimization PassNAddNumberTypeConversions
Simplifying constant integer cast 9
Simplifying constant integer cast 9
Simplifying constant integer cast 9
Simplifying constant integer cast $28
Simplifying constant integer cast $19
Successful SSA optimization PassNCastSimplification
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) 9
Finalized unsigned number type (byte) $28
Finalized unsigned number type (byte) $19
Successful SSA optimization PassNFinalizeNumberTypeConversions
Constant right-side identified [36] (byte*) main::at#0 ← (const byte*) main::at_line#0 + (byte) 4
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const void*) memset::str#0 = (void*)print_screen#0
Constant (const byte*) main::at#0 = main::at_line#0+4
Successful SSA optimization Pass2ConstantIdentification
Constant value identified (byte*)memset::str#0 in [0] (byte*~) memset::$2 ← (byte*)(const void*) memset::str#0
Constant value identified (byte*)memset::str#0 in [2] (byte*) memset::dst#0 ← (byte*)(const void*) memset::str#0
Successful SSA optimization Pass2ConstantValues
Constant (const byte*) memset::$2 = (byte*)memset::str#0
Constant (const byte*) memset::dst#0 = (byte*)memset::str#0
Successful SSA optimization Pass2ConstantIdentification
Constant right-side identified [0] (byte*) memset::end#0 ← (const byte*) memset::$2 + (const word) memset::num#0
Successful SSA optimization Pass2ConstantRValueConsolidation
Constant (const byte*) memset::end#0 = memset::$2+memset::num#0
Successful SSA optimization Pass2ConstantIdentification
Successful SSA optimization Pass2LoopHeadConstantIdentification
Alias (byte*) memset::dst#1 = (byte*) memset::dst#2 
Successful SSA optimization Pass2AliasElimination
Identical Phi Values (byte*) memset::dst#5 (const byte*) memset::dst#0
Successful SSA optimization Pass2IdenticalPhiElimination
if() condition always true - replacing block destination [82] if((const byte*) memset::dst#0!=(const byte*) memset::end#0) goto memset::@5
Successful SSA optimization Pass2ConstantIfs
Inlining constant with var siblings (const byte*) memset::dst#0
Inlining constant with var siblings (const byte) print_char_at::ch#0
Inlining constant with var siblings (const byte) print_char_at::ch#1
Inlining constant with var siblings (const byte*) main::at_line#0
Inlining constant with var siblings (const byte) main::k#0
Inlining constant with var siblings (const byte) main::i#0
Inlining constant with var siblings (const byte) main::j#0
Inlining constant with var siblings (const byte*) main::at#0
Inlining constant with var siblings (const byte*) init_screen::COLS#0
Inlining constant with var siblings (const byte) init_screen::l#0
Inlining constant with var siblings (const byte) init_screen::m#0
Constant inlined $0 = (const byte[]) print_hextab#0
Constant inlined main::at#0 = (byte*) 1024+(byte) 4
Constant inlined memset::$2 = (byte*)(const void*) memset::str#0
Constant inlined print_char_at::ch#0 = (byte) '-'
Constant inlined init_screen::m#0 = (byte) 0
Constant inlined print_char_at::ch#1 = (byte) ' '
Constant inlined init_screen::l#0 = (byte) 0
Constant inlined main::i#0 = (byte) 0
Constant inlined memset::dst#0 = (byte*)(const void*) memset::str#0
Constant inlined main::k#0 = (byte) 0
Constant inlined main::j#0 = (byte) 0
Constant inlined main::at_line#0 = (byte*) 1024
Constant inlined init_screen::COLS#0 = (byte*) 55296
Successful SSA optimization Pass2ConstantInlining
Added new block during phi lifting memset::@10(between memset::@4 and memset::@5)
Added new block during phi lifting main::@12(between main::@8 and main::@1)
Added new block during phi lifting main::@13(between main::@5 and main::@3)
Added new block during phi lifting main::@14(between main::@11 and main::@4)
Added new block during phi lifting init_screen::@6(between init_screen::@1 and init_screen::@1)
Added new block during phi lifting init_screen::@7(between init_screen::@3 and init_screen::@3)
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @12
Adding NOP phi() at start of @29
Adding NOP phi() at start of @36
Adding NOP phi() at start of @38
Adding NOP phi() at start of @39
Adding NOP phi() at start of @40
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of main::@7
Adding NOP phi() at start of main::@2
Adding NOP phi() at start of print_sbyte_at::@7
Adding NOP phi() at start of print_byte_at::@2
Adding NOP phi() at start of init_screen
Adding NOP phi() at start of init_screen::@5
Adding NOP phi() at start of init_screen::@2
Adding NOP phi() at start of print_cls
Adding NOP phi() at start of print_cls::@1
Adding NOP phi() at start of memset
Adding NOP phi() at start of memset::@2
Adding NOP phi() at start of memset::@4_1
Adding NOP phi() at start of memset::@1
CALL GRAPH
Calls in [] to main:6 
Calls in [main] to init_screen:10 print_sbyte_at:17 print_sbyte_at:28 fmul8:34 print_sbyte_at:41 
Calls in [print_sbyte_at] to print_char_at:57 print_byte_at:62 print_char_at:67 
Calls in [print_byte_at] to print_char_at:78 print_char_at:84 
Calls in [init_screen] to print_cls:93 
Calls in [print_cls] to memset:113 

Created 15 initial phi equivalence classes
Coalesced [15] print_sbyte_at::b#10 ← print_sbyte_at::b#1
Coalesced [16] print_sbyte_at::at#9 ← print_sbyte_at::at#0
Coalesced [26] print_sbyte_at::b#12 ← print_sbyte_at::b#2
Coalesced [27] print_sbyte_at::at#11 ← print_sbyte_at::at#1
Not coalescing [29] main::at#12 ← main::at#2
Coalesced [39] print_sbyte_at::b#11 ← print_sbyte_at::b#3
Coalesced [40] print_sbyte_at::at#10 ← print_sbyte_at::at#2
Coalesced [47] main::at_line#11 ← main::at#2
Coalesced [48] main::i#8 ← main::i#1
Coalesced [49] main::at#11 ← main::at#3
Coalesced [50] main::j#5 ← main::j#1
Coalesced [51] main::k#4 ← main::k#1
Coalesced [52] main::at#10 ← main::at#1
Coalesced [56] print_char_at::at#8 ← print_char_at::at#1
Coalesced [58] print_sbyte_at::b#14 ← print_sbyte_at::b#4
Coalesced [66] print_char_at::at#7 ← print_char_at::at#0
Coalesced [69] print_sbyte_at::b#13 ← print_sbyte_at::b#0
Coalesced [76] print_char_at::ch#5 ← print_char_at::ch#2
Coalesced [77] print_char_at::at#5 ← print_char_at::at#2
Coalesced [82] print_char_at::ch#6 ← print_char_at::ch#3
Coalesced [83] print_char_at::at#6 ← print_char_at::at#3
Coalesced [109] init_screen::COLS#5 ← init_screen::COLS#1
Coalesced [110] init_screen::m#3 ← init_screen::m#1
Coalesced [111] init_screen::l#3 ← init_screen::l#1
Coalesced [125] memset::dst#6 ← memset::dst#1
Coalesced down to 14 phi equivalence classes
Culled Empty Block (label) @12
Culled Empty Block (label) @29
Culled Empty Block (label) @36
Culled Empty Block (label) @38
Culled Empty Block (label) @40
Culled Empty Block (label) main::@7
Culled Empty Block (label) main::@2
Culled Empty Block (label) main::@13
Culled Empty Block (label) main::@14
Culled Empty Block (label) main::@12
Culled Empty Block (label) print_sbyte_at::@6
Culled Empty Block (label) print_sbyte_at::@7
Culled Empty Block (label) print_byte_at::@2
Culled Empty Block (label) init_screen::@5
Culled Empty Block (label) init_screen::@2
Culled Empty Block (label) init_screen::@7
Culled Empty Block (label) init_screen::@6
Culled Empty Block (label) print_cls::@1
Culled Empty Block (label) memset::@2
Culled Empty Block (label) memset::@4_1
Culled Empty Block (label) memset::@1
Culled Empty Block (label) memset::@10
Renumbering block @39 to @1
Renumbering block memset::@4 to memset::@1
Renumbering block memset::@5 to memset::@2
Renumbering block print_sbyte_at::@5 to print_sbyte_at::@4
Renumbering block main::@3 to main::@2
Renumbering block main::@4 to main::@3
Renumbering block main::@5 to main::@4
Renumbering block main::@8 to main::@5
Renumbering block main::@9 to main::@6
Renumbering block main::@10 to main::@7
Renumbering block main::@11 to main::@8
Renumbering block init_screen::@3 to init_screen::@2
Adding NOP phi() at start of @begin
Adding NOP phi() at start of @1
Adding NOP phi() at start of @end
Adding NOP phi() at start of main
Adding NOP phi() at start of init_screen
Adding NOP phi() at start of print_cls
Adding NOP phi() at start of memset

FINAL CONTROL FLOW GRAPH
@begin: scope:[]  from
  [0] phi()
  to:@1
@1: scope:[]  from @begin
  [1] phi()
  [2] call main 
  to:@end
@end: scope:[]  from @1
  [3] phi()
main: scope:[main]  from @1
  [4] phi()
  [5] call init_screen 
  to:main::@1
main::@1: scope:[main]  from main main::@5
  [6] (byte*) main::at#4 ← phi( main/(byte*) 1024+(byte) 4 main::@5/(byte*) main::at#1 )
  [6] (byte) main::k#2 ← phi( main/(byte) 0 main::@5/(byte) main::k#1 )
  [7] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2)
  [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4
  [9] call print_sbyte_at 
  to:main::@5
main::@5: scope:[main]  from main::@1
  [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4
  [11] (byte) main::k#1 ← ++ (byte) main::k#2
  [12] if((byte) main::k#1!=(byte) 9) goto main::@1
  to:main::@2
main::@2: scope:[main]  from main::@4 main::@5
  [13] (byte) main::i#2 ← phi( main::@5/(byte) 0 main::@4/(byte) main::i#1 )
  [13] (byte*) main::at_line#2 ← phi( main::@5/(byte*) 1024 main::@4/(byte*) main::at#2 )
  [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28
  [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2)
  [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2
  [17] call print_sbyte_at 
  to:main::@6
main::@6: scope:[main]  from main::@2
  [18] (byte*~) main::at#12 ← (byte*) main::at#2
  to:main::@3
main::@3: scope:[main]  from main::@6 main::@8
  [19] (byte) main::j#2 ← phi( main::@8/(byte) main::j#1 main::@6/(byte) 0 )
  [19] (byte*) main::at#6 ← phi( main::@8/(byte*) main::at#3 main::@6/(byte*~) main::at#12 )
  [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4
  [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2)
  [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2)
  [23] call fmul8 
  [24] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
  to:main::@7
main::@7: scope:[main]  from main::@3
  [25] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
  [26] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0
  [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3
  [28] call print_sbyte_at 
  to:main::@8
main::@8: scope:[main]  from main::@7
  [29] (byte) main::j#1 ← ++ (byte) main::j#2
  [30] if((byte) main::j#1!=(byte) 9) goto main::@3
  to:main::@4
main::@4: scope:[main]  from main::@8
  [31] (byte) main::i#1 ← ++ (byte) main::i#2
  [32] if((byte) main::i#1!=(byte) 9) goto main::@2
  to:main::@return
main::@return: scope:[main]  from main::@4
  [33] return 
  to:@return
print_sbyte_at: scope:[print_sbyte_at]  from main::@1 main::@2 main::@7
  [34] (byte*) print_sbyte_at::at#3 ← phi( main::@1/(byte*) print_sbyte_at::at#0 main::@7/(byte*) print_sbyte_at::at#2 main::@2/(byte*) print_sbyte_at::at#1 )
  [34] (signed byte) print_sbyte_at::b#4 ← phi( main::@1/(signed byte) print_sbyte_at::b#1 main::@7/(signed byte) print_sbyte_at::b#3 main::@2/(signed byte) print_sbyte_at::b#2 )
  [35] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1
  to:print_sbyte_at::@3
print_sbyte_at::@3: scope:[print_sbyte_at]  from print_sbyte_at
  [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
  [37] call print_char_at 
  to:print_sbyte_at::@2
print_sbyte_at::@2: scope:[print_sbyte_at]  from print_sbyte_at::@3 print_sbyte_at::@4
  [38] (signed byte) print_sbyte_at::b#6 ← phi( print_sbyte_at::@4/(signed byte) print_sbyte_at::b#0 print_sbyte_at::@3/(signed byte) print_sbyte_at::b#4 )
  [39] (byte) print_byte_at::b#0 ← (byte)(signed byte) print_sbyte_at::b#6
  [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1
  [41] call print_byte_at 
  to:print_sbyte_at::@return
print_sbyte_at::@return: scope:[print_sbyte_at]  from print_sbyte_at::@2
  [42] return 
  to:@return
print_sbyte_at::@1: scope:[print_sbyte_at]  from print_sbyte_at
  [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
  [44] call print_char_at 
  to:print_sbyte_at::@4
print_sbyte_at::@4: scope:[print_sbyte_at]  from print_sbyte_at::@1
  [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4
  to:print_sbyte_at::@2
print_char_at: scope:[print_char_at]  from print_byte_at print_byte_at::@1 print_sbyte_at::@1 print_sbyte_at::@3
  [46] (byte*) print_char_at::at#4 ← phi( print_byte_at/(byte*) print_char_at::at#2 print_byte_at::@1/(byte*) print_char_at::at#3 print_sbyte_at::@1/(byte*) print_char_at::at#0 print_sbyte_at::@3/(byte*) print_char_at::at#1 )
  [46] (byte) print_char_at::ch#4 ← phi( print_byte_at/(byte) print_char_at::ch#2 print_byte_at::@1/(byte) print_char_at::ch#3 print_sbyte_at::@1/(byte) '-' print_sbyte_at::@3/(byte) ' ' )
  [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4
  to:print_char_at::@return
print_char_at::@return: scope:[print_char_at]  from print_char_at
  [48] return 
  to:@return
print_byte_at: scope:[print_byte_at]  from print_sbyte_at::@2
  [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4
  [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0)
  [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
  [52] call print_char_at 
  to:print_byte_at::@1
print_byte_at::@1: scope:[print_byte_at]  from print_byte_at
  [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f
  [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1
  [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2)
  [56] call print_char_at 
  to:print_byte_at::@return
print_byte_at::@return: scope:[print_byte_at]  from print_byte_at::@1
  [57] return 
  to:@return
fmul8: scope:[fmul8]  from main::@3
  [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0
  [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0
  asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
  [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0)
  to:fmul8::@return
fmul8::@return: scope:[fmul8]  from fmul8
  [62] return 
  to:@return
init_screen: scope:[init_screen]  from main
  [63] phi()
  [64] call print_cls 
  to:init_screen::@1
init_screen::@1: scope:[init_screen]  from init_screen init_screen::@1
  [65] (byte) init_screen::l#2 ← phi( init_screen::@1/(byte) init_screen::l#1 init_screen/(byte) 0 )
  [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0
  [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2
  [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1
  to:init_screen::@2
init_screen::@2: scope:[init_screen]  from init_screen::@1 init_screen::@2
  [69] (byte) init_screen::m#2 ← phi( init_screen::@1/(byte) 0 init_screen::@2/(byte) init_screen::m#1 )
  [69] (byte*) init_screen::COLS#3 ← phi( init_screen::@1/(byte*) 55296 init_screen::@2/(byte*) init_screen::COLS#1 )
  [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0
  [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0
  [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0
  [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0
  [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28
  [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2
  [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2
  to:init_screen::@return
init_screen::@return: scope:[init_screen]  from init_screen::@2
  [77] return 
  to:@return
print_cls: scope:[print_cls]  from init_screen
  [78] phi()
  [79] call memset 
  to:print_cls::@return
print_cls::@return: scope:[print_cls]  from print_cls
  [80] return 
  to:@return
memset: scope:[memset]  from print_cls
  [81] phi()
  to:memset::@2
memset::@2: scope:[memset]  from memset memset::@1
  [82] (byte*) memset::dst#4 ← phi( memset::@1/(byte*) memset::dst#1 memset/(byte*)(const void*) memset::str#0 )
  [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0
  [84] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#4
  to:memset::@1
memset::@1: scope:[memset]  from memset::@2
  [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2
  to:memset::@return
memset::@return: scope:[memset]  from memset::@1
  [86] return 
  to:@return


VARIABLE REGISTER WEIGHTS
(signed byte*) ap
(signed byte*) bp
(signed byte*) cp
(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
(signed byte) fmul8::a
(signed byte) fmul8::a#0 51.5
(signed byte) fmul8::b
(signed byte) fmul8::b#0 51.5
(signed byte) fmul8::return
(signed byte) fmul8::return#0 202.0
(signed byte) fmul8::return#1 34.33333333333333
(void()) init_screen()
(byte*) init_screen::COLS
(byte*) init_screen::COLS#1 7.333333333333333
(byte*) init_screen::COLS#3 13.2
(byte) init_screen::WHITE
(byte) init_screen::l
(byte) init_screen::l#1 16.5
(byte) init_screen::l#2 16.5
(byte) init_screen::m
(byte) init_screen::m#1 16.5
(byte) init_screen::m#2 3.6666666666666665
(void()) main()
(byte*) main::at
(byte*) main::at#1 7.333333333333333
(byte*~) main::at#12 22.0
(byte*) main::at#2 2.3157894736842106
(byte*) main::at#3 27.545454545454547
(byte*) main::at#4 8.25
(byte*) main::at#6 213.0
(byte*) main::at_line
(byte*) main::at_line#2 22.0
(byte) main::i
(byte) main::i#1 16.5
(byte) main::i#2 7.444444444444445
(byte) main::j
(byte) main::j#1 151.5
(byte) main::j#2 30.299999999999997
(byte) main::k
(byte) main::k#1 16.5
(byte) main::k#2 6.6000000000000005
(signed byte) main::r
(signed byte) main::r#0 202.0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(byte) memset::c
(byte*) memset::dst
(byte*) memset::dst#1 16.5
(byte*) memset::dst#4 16.5
(byte*) memset::end
(word) memset::num
(void*) memset::return
(void*) memset::str
(byte[$200]) mulf_sqr1
(byte[$200]) mulf_sqr2
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0 4.0
(byte~) print_byte_at::$2 2.0
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0 1.0
(byte) print_byte_at::b
(byte) print_byte_at::b#0 1.0
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(byte*) print_char_at::at
(byte*) print_char_at::at#0 4.0
(byte*) print_char_at::at#1 4.0
(byte*) print_char_at::at#2 4.0
(byte*) print_char_at::at#3 2.0
(byte*) print_char_at::at#4 10.0
(byte) print_char_at::ch
(byte) print_char_at::ch#2 2.0
(byte) print_char_at::ch#3 4.0
(byte) print_char_at::ch#4 6.0
(void()) print_cls()
(byte[]) print_hextab
(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
(byte*) print_sbyte_at::at
(byte*) print_sbyte_at::at#0 22.0
(byte*) print_sbyte_at::at#1 22.0
(byte*) print_sbyte_at::at#2 202.0
(byte*) print_sbyte_at::at#3 14.333333333333329
(signed byte) print_sbyte_at::b
(signed byte) print_sbyte_at::b#0 4.0
(signed byte) print_sbyte_at::b#1 11.0
(signed byte) print_sbyte_at::b#2 11.0
(signed byte) print_sbyte_at::b#3 101.0
(signed byte) print_sbyte_at::b#4 21.499999999999993
(signed byte) print_sbyte_at::b#6 4.0
(byte*) print_screen
(signed byte[]) vals

Initial phi equivalence classes
[ main::k#2 main::k#1 ]
[ main::at#4 main::at#1 ]
[ main::at_line#2 main::at#2 ]
[ main::i#2 main::i#1 ]
[ main::at#6 main::at#3 main::at#12 ]
[ main::j#2 main::j#1 ]
[ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ]
[ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
[ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
[ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ]
[ init_screen::l#2 init_screen::l#1 ]
[ init_screen::COLS#3 init_screen::COLS#1 ]
[ init_screen::m#2 init_screen::m#1 ]
[ memset::dst#4 memset::dst#1 ]
Added variable fmul8::a#0 to zero page equivalence class [ fmul8::a#0 ]
Added variable fmul8::b#0 to zero page equivalence class [ fmul8::b#0 ]
Added variable fmul8::return#0 to zero page equivalence class [ fmul8::return#0 ]
Added variable main::r#0 to zero page equivalence class [ main::r#0 ]
Added variable print_byte_at::b#0 to zero page equivalence class [ print_byte_at::b#0 ]
Added variable print_byte_at::at#0 to zero page equivalence class [ print_byte_at::at#0 ]
Added variable print_byte_at::$0 to zero page equivalence class [ print_byte_at::$0 ]
Added variable print_byte_at::$2 to zero page equivalence class [ print_byte_at::$2 ]
Added variable fmul8::return#1 to zero page equivalence class [ fmul8::return#1 ]
Complete equivalence classes
[ main::k#2 main::k#1 ]
[ main::at#4 main::at#1 ]
[ main::at_line#2 main::at#2 ]
[ main::i#2 main::i#1 ]
[ main::at#6 main::at#3 main::at#12 ]
[ main::j#2 main::j#1 ]
[ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ]
[ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
[ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
[ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ]
[ init_screen::l#2 init_screen::l#1 ]
[ init_screen::COLS#3 init_screen::COLS#1 ]
[ init_screen::m#2 init_screen::m#1 ]
[ memset::dst#4 memset::dst#1 ]
[ fmul8::a#0 ]
[ fmul8::b#0 ]
[ fmul8::return#0 ]
[ main::r#0 ]
[ print_byte_at::b#0 ]
[ print_byte_at::at#0 ]
[ print_byte_at::$0 ]
[ print_byte_at::$2 ]
[ fmul8::return#1 ]
Allocated zp ZP_BYTE:2 [ main::k#2 main::k#1 ]
Allocated zp ZP_WORD:3 [ main::at#4 main::at#1 ]
Allocated zp ZP_WORD:5 [ main::at_line#2 main::at#2 ]
Allocated zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Allocated zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ]
Allocated zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Allocated zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ]
Allocated zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Allocated zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Allocated zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ]
Allocated zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ]
Allocated zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ]
Allocated zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ]
Allocated zp ZP_WORD:21 [ memset::dst#4 memset::dst#1 ]
Allocated zp ZP_BYTE:23 [ fmul8::a#0 ]
Allocated zp ZP_BYTE:24 [ fmul8::b#0 ]
Allocated zp ZP_BYTE:25 [ fmul8::return#0 ]
Allocated zp ZP_BYTE:26 [ main::r#0 ]
Allocated zp ZP_BYTE:27 [ print_byte_at::b#0 ]
Allocated zp ZP_WORD:28 [ print_byte_at::at#0 ]
Allocated zp ZP_BYTE:30 [ print_byte_at::$0 ]
Allocated zp ZP_BYTE:31 [ print_byte_at::$2 ]
Allocated zp ZP_BYTE:32 [ fmul8::return#1 ]

INITIAL ASM
Target platform is c64basic
  // File Comments
// Seriously fast multiply 8-bit version (8bit*8bit=8bit)
// Multiplies two signed 8-bit numbers and results in an 8-bit number
// C=A*B, A in [-64;64], B in [-96;95], C in [-96;95] - 64 acts a 1 (X*64=X)
// Uses the formula a*b = (a+b)^2/4 - (a-b)^2/4
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label print_screen = $400
  // Pointers to a, b and c=a*b
  .label ap = $fd
  .label bp = $fe
  .label cp = $ff
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label at = 3
    .label k = 2
    .label at_2 = 5
    .label at_3 = 8
    .label r = $1a
    .label j = $a
    .label i = 7
    .label at_line = 5
    .label at_6 = 8
    .label at_12 = 8
    // [5] call init_screen 
    // [63] phi from main to init_screen [phi:main->init_screen]
  init_screen_from_main:
    jsr init_screen
    // [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    // [6] phi (byte*) main::at#4 = (byte*) 1024+(byte) 4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400+4
    sta at
    lda #>$400+4
    sta at+1
    // [6] phi (byte) main::k#2 = (byte) 0 [phi:main->main::@1#1] -- vbuz1=vbuc1 
    lda #0
    sta k
    jmp b1
    // [6] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  b1_from_b5:
    // [6] phi (byte*) main::at#4 = (byte*) main::at#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [6] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp b1
    // main::@1
  b1:
    // [7] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy k
    lda vals,y
    sta print_sbyte_at.b
    // [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
    // [9] call print_sbyte_at 
    // [34] phi from main::@1 to print_sbyte_at [phi:main::@1->print_sbyte_at]
  print_sbyte_at_from_b1:
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#0 [phi:main::@1->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#1 [phi:main::@1->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b5
    // main::@5
  b5:
    // [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
    // [11] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuz1=_inc_vbuz1 
    inc k
    // [12] if((byte) main::k#1!=(byte) 9) goto main::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp k
    bne b1_from_b5
    // [13] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
    // [13] phi (byte) main::i#2 = (byte) 0 [phi:main::@5->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    // [13] phi (byte*) main::at_line#2 = (byte*) 1024 [phi:main::@5->main::@2#1] -- pbuz1=pbuc1 
    lda #<$400
    sta at_line
    lda #>$400
    sta at_line+1
    jmp b2
    // [13] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  b2_from_b4:
    // [13] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@2#0] -- register_copy 
    // [13] phi (byte*) main::at_line#2 = (byte*) main::at#2 [phi:main::@4->main::@2#1] -- register_copy 
    jmp b2
    // main::@2
  b2:
    // [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc at_2
    sta at_2
    bcc !+
    inc at_2+1
  !:
    // [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta print_sbyte_at.b
    // [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta print_sbyte_at.at
    lda at_2+1
    sta print_sbyte_at.at+1
    // [17] call print_sbyte_at 
    // [34] phi from main::@2 to print_sbyte_at [phi:main::@2->print_sbyte_at]
  print_sbyte_at_from_b2:
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#1 [phi:main::@2->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#2 [phi:main::@2->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b6
    // main::@6
  b6:
    // [18] (byte*~) main::at#12 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta at_12
    lda at_2+1
    sta at_12+1
    // [19] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  b3_from_b6:
    // [19] phi (byte) main::j#2 = (byte) 0 [phi:main::@6->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta j
    // [19] phi (byte*) main::at#6 = (byte*~) main::at#12 [phi:main::@6->main::@3#1] -- register_copy 
    jmp b3
    // [19] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  b3_from_b8:
    // [19] phi (byte) main::j#2 = (byte) main::j#1 [phi:main::@8->main::@3#0] -- register_copy 
    // [19] phi (byte*) main::at#6 = (byte*) main::at#3 [phi:main::@8->main::@3#1] -- register_copy 
    jmp b3
    // main::@3
  b3:
    // [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at_3
    sta at_3
    bcc !+
    inc at_3+1
  !:
    // [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta fmul8.a
    // [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy j
    lda vals,y
    sta fmul8.b
    // [23] call fmul8 
    jsr fmul8
    // [24] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1 -- vbsz1=vbsz2 
    lda fmul8.return_1
    sta fmul8.return
    jmp b7
    // main::@7
  b7:
    // [25] (signed byte) main::r#0 ← (signed byte) fmul8::return#0 -- vbsz1=vbsz2 
    lda fmul8.return
    sta r
    // [26] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0 -- vbsz1=vbsz2 
    lda r
    sta print_sbyte_at.b
    // [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 -- pbuz1=pbuz2 
    lda at_3
    sta print_sbyte_at.at
    lda at_3+1
    sta print_sbyte_at.at+1
    // [28] call print_sbyte_at 
    // [34] phi from main::@7 to print_sbyte_at [phi:main::@7->print_sbyte_at]
  print_sbyte_at_from_b7:
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#2 [phi:main::@7->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#3 [phi:main::@7->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b8
    // main::@8
  b8:
    // [29] (byte) main::j#1 ← ++ (byte) main::j#2 -- vbuz1=_inc_vbuz1 
    inc j
    // [30] if((byte) main::j#1!=(byte) 9) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp j
    bne b3_from_b8
    jmp b4
    // main::@4
  b4:
    // [31] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [32] if((byte) main::i#1!=(byte) 9) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp i
    bne b2_from_b4
    jmp breturn
    // main::@return
  breturn:
    // [33] return 
    rts
}
  // print_sbyte_at
// Print a signed byte as hex at a specific screen position
// print_sbyte_at(signed byte zeropage($d) b, byte* zeropage($b) at)
print_sbyte_at: {
    .label b = $d
    .label at = $b
    // [35] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1 -- vbsz1_lt_0_then_la1 
    lda b
    bmi b1
    jmp b3
    // print_sbyte_at::@3
  b3:
    // [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
    // [37] call print_char_at 
    // [46] phi from print_sbyte_at::@3 to print_char_at [phi:print_sbyte_at::@3->print_char_at]
  print_char_at_from_b3:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#1 [phi:print_sbyte_at::@3->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) ' ' [phi:print_sbyte_at::@3->print_char_at#1] -- vbuz1=vbuc1 
    lda #' '
    sta print_char_at.ch
    jsr print_char_at
    // [38] phi from print_sbyte_at::@3 print_sbyte_at::@4 to print_sbyte_at::@2 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2]
  b2_from_b3:
  b2_from_b4:
    // [38] phi (signed byte) print_sbyte_at::b#6 = (signed byte) print_sbyte_at::b#4 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2#0] -- register_copy 
    jmp b2
    // print_sbyte_at::@2
  b2:
    // [39] (byte) print_byte_at::b#0 ← (byte)(signed byte) print_sbyte_at::b#6 -- vbuz1=vbuz2 
    lda b
    sta print_byte_at.b
    // [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_byte_at.at
    lda at+1
    adc #0
    sta print_byte_at.at+1
    // [41] call print_byte_at 
    jsr print_byte_at
    jmp breturn
    // print_sbyte_at::@return
  breturn:
    // [42] return 
    rts
    // print_sbyte_at::@1
  b1:
    // [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
    // [44] call print_char_at 
    // [46] phi from print_sbyte_at::@1 to print_char_at [phi:print_sbyte_at::@1->print_char_at]
  print_char_at_from_b1:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#0 [phi:print_sbyte_at::@1->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) '-' [phi:print_sbyte_at::@1->print_char_at#1] -- vbuz1=vbuc1 
    lda #'-'
    sta print_char_at.ch
    jsr print_char_at
    jmp b4
    // print_sbyte_at::@4
  b4:
    // [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 -- vbsz1=_neg_vbsz1 
    lda b
    eor #$ff
    clc
    adc #1
    sta b
    jmp b2_from_b4
}
  // print_char_at
// Print a single char
// print_char_at(byte zeropage($e) ch, byte* zeropage($f) at)
print_char_at: {
    .label at = $f
    .label ch = $e
    // [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
    jmp breturn
    // print_char_at::@return
  breturn:
    // [48] return 
    rts
}
  // print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte zeropage($1b) b, byte* zeropage($1c) at)
print_byte_at: {
    .label _0 = $1e
    .label _2 = $1f
    .label b = $1b
    .label at = $1c
    // [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4 -- vbuz1=vbuz2_ror_4 
    lda b
    lsr
    lsr
    lsr
    lsr
    sta _0
    // [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy _0
    lda print_hextab,y
    sta print_char_at.ch
    // [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 -- pbuz1=pbuz2 
    lda at
    sta print_char_at.at
    lda at+1
    sta print_char_at.at+1
    // [52] call print_char_at 
    // [46] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  print_char_at_from_print_byte_at:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#2 [phi:print_byte_at->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#2 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp b1
    // print_byte_at::@1
  b1:
    // [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f -- vbuz1=vbuz2_band_vbuc1 
    lda #$f
    and b
    sta _2
    // [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 -- pbuz1=pbuz2_plus_1 
    lda at
    clc
    adc #1
    sta print_char_at.at
    lda at+1
    adc #0
    sta print_char_at.at+1
    // [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuz2 
    ldy _2
    lda print_hextab,y
    sta print_char_at.ch
    // [56] call print_char_at 
    // [46] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  print_char_at_from_b1:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#3 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#3 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp breturn
    // print_byte_at::@return
  breturn:
    // [57] return 
    rts
}
  // fmul8
// fmul8(signed byte zeropage($17) a, signed byte zeropage($18) b)
fmul8: {
    .label a = $17
    .label b = $18
    .label return = $19
    .label return_1 = $20
    // [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0 -- _deref_pbsc1=vbsz1 
    lda a
    sta ap
    // [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0 -- _deref_pbsc1=vbsz1 
    lda b
    sta bp
    // asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
    lda ap
    sta A1+1
    eor #$ff
    sta A2+1
    ldx bp
    sec
  A1:
    lda mulf_sqr1,x
  A2:
    sbc mulf_sqr2,x
    sta cp
    // [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0) -- vbsz1=_deref_pbsc1 
    lda cp
    sta return_1
    jmp breturn
    // fmul8::@return
  breturn:
    // [62] return 
    rts
}
  // init_screen
init_screen: {
    .const WHITE = 1
    .label l = $11
    .label COLS = $12
    .label m = $14
    // [64] call print_cls 
    // [78] phi from init_screen to print_cls [phi:init_screen->print_cls]
  print_cls_from_init_screen:
    jsr print_cls
    // [65] phi from init_screen to init_screen::@1 [phi:init_screen->init_screen::@1]
  b1_from_init_screen:
    // [65] phi (byte) init_screen::l#2 = (byte) 0 [phi:init_screen->init_screen::@1#0] -- vbuz1=vbuc1 
    lda #0
    sta l
    jmp b1
    // [65] phi from init_screen::@1 to init_screen::@1 [phi:init_screen::@1->init_screen::@1]
  b1_from_b1:
    // [65] phi (byte) init_screen::l#2 = (byte) init_screen::l#1 [phi:init_screen::@1->init_screen::@1#0] -- register_copy 
    jmp b1
    // init_screen::@1
  b1:
    // [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 -- pbuc1_derefidx_vbuz1=vbuc2 
    lda #WHITE
    ldy l
    sta $d800,y
    // [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2 -- vbuz1=_inc_vbuz1 
    inc l
    // [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1 -- vbuz1_neq_vbuc1_then_la1 
    lda #$28
    cmp l
    bne b1_from_b1
    // [69] phi from init_screen::@1 to init_screen::@2 [phi:init_screen::@1->init_screen::@2]
  b2_from_b1:
    // [69] phi (byte) init_screen::m#2 = (byte) 0 [phi:init_screen::@1->init_screen::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta m
    // [69] phi (byte*) init_screen::COLS#3 = (byte*) 55296 [phi:init_screen::@1->init_screen::@2#1] -- pbuz1=pbuc1 
    lda #<$d800
    sta COLS
    lda #>$d800
    sta COLS+1
    jmp b2
    // [69] phi from init_screen::@2 to init_screen::@2 [phi:init_screen::@2->init_screen::@2]
  b2_from_b2:
    // [69] phi (byte) init_screen::m#2 = (byte) init_screen::m#1 [phi:init_screen::@2->init_screen::@2#0] -- register_copy 
    // [69] phi (byte*) init_screen::COLS#3 = (byte*) init_screen::COLS#1 [phi:init_screen::@2->init_screen::@2#1] -- register_copy 
    jmp b2
    // init_screen::@2
  b2:
    // [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 -- _deref_pbuz1=vbuc1 
    lda #WHITE
    ldy #0
    sta (COLS),y
    // [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #1
    sta (COLS),y
    // [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #2
    sta (COLS),y
    // [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #3
    sta (COLS),y
    // [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc COLS
    sta COLS
    bcc !+
    inc COLS+1
  !:
    // [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2 -- vbuz1=_inc_vbuz1 
    inc m
    // [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #$19
    cmp m
    bne b2_from_b2
    jmp breturn
    // init_screen::@return
  breturn:
    // [77] return 
    rts
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // [79] call memset 
    // [81] phi from print_cls to memset [phi:print_cls->memset]
  memset_from_print_cls:
    jsr memset
    jmp breturn
    // print_cls::@return
  breturn:
    // [80] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $3e8
    .label str = print_screen
    .label end = str+num
    .label dst = $15
    // [82] phi from memset to memset::@2 [phi:memset->memset::@2]
  b2_from_memset:
    // [82] phi (byte*) memset::dst#4 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@2#0] -- pbuz1=pbuc1 
    lda #<str
    sta dst
    lda #>str
    sta dst+1
    jmp b2
    // [82] phi from memset::@1 to memset::@2 [phi:memset::@1->memset::@2]
  b2_from_b1:
    // [82] phi (byte*) memset::dst#4 = (byte*) memset::dst#1 [phi:memset::@1->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [84] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#4 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
    jmp b1
    // memset::@1
  b1:
    // [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda dst+1
    cmp #>end
    bne b2_from_b1
    lda dst
    cmp #<end
    bne b2_from_b1
    jmp breturn
    // memset::@return
  breturn:
    // [86] return 
    rts
}
  // File Data
  print_hextab: .text "0123456789abcdef"
  vals: .byte -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f
  // mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
  // f(x) = >(( x * x ))
  .align $100
mulf_sqr1:
.for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }

  // g(x) =  >((( 1 - x ) * ( 1 - x )))
  .align $100
mulf_sqr2:
.for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }


REGISTER UPLIFT POTENTIAL REGISTERS
Statement [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ( main:2 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:2 [ main::k#2 main::k#1 ]
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Statement [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 [ main::k#2 main::at#1 ] ( main:2 [ main::k#2 main::at#1 ] ) always clobbers reg byte a 
Statement [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 [ main::i#2 main::at#2 ] ( main:2 [ main::i#2 main::at#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Statement [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ( main:2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ) always clobbers reg byte a 
Statement [18] (byte*~) main::at#12 ← (byte*) main::at#2 [ main::i#2 main::at#2 main::at#12 ] ( main:2 [ main::i#2 main::at#2 main::at#12 ] ) always clobbers reg byte a 
Statement [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Statement [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ) always clobbers reg byte a 
Statement [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 [ print_byte_at::b#0 print_byte_at::at#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:27 [ print_byte_at::b#0 ]
Statement [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 [ print_sbyte_at::at#3 print_sbyte_at::b#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::at#3 print_sbyte_at::b#0 ] ) always clobbers reg byte a 
Statement [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 [ ] ( main:2::print_sbyte_at:9::print_char_at:37 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:17::print_char_at:37 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:28::print_char_at:37 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:9::print_char_at:44 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:17::print_char_at:44 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:28::print_char_at:44 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:9::print_byte_at:41::print_char_at:52 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:17::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:28::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:9::print_byte_at:41::print_char_at:56 [ main::k#2 main::at#4 ] main:2::print_sbyte_at:17::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 ] main:2::print_sbyte_at:28::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:2 [ main::k#2 main::k#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:27 [ print_byte_at::b#0 ]
Statement [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4 [ print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 [ print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Statement [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f [ print_byte_at::at#0 print_byte_at::$2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::at#0 print_byte_at::$2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::at#0 print_byte_at::$2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::at#0 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 [ print_char_at::at#3 print_byte_at::$2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_char_at::at#3 print_byte_at::$2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_char_at::at#3 print_byte_at::$2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_char_at::at#3 print_byte_at::$2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:31 [ print_byte_at::$2 ]
Statement asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  } always clobbers reg byte a reg byte x 
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Removing always clobbered register reg byte x as potential for zp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Statement [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 [ init_screen::l#2 ] ( main:2::init_screen:5 [ init_screen::l#2 ] ) always clobbers reg byte a 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ]
Statement [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Removing always clobbered register reg byte a as potential for zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ]
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ]
Statement [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 [ init_screen::m#2 init_screen::COLS#1 ] ( main:2::init_screen:5 [ init_screen::m#2 init_screen::COLS#1 ] ) always clobbers reg byte a 
Statement [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0 [ memset::dst#4 ] ( main:2::init_screen:5::print_cls:64::memset:79 [ memset::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#1 ] ( main:2::init_screen:5::print_cls:64::memset:79 [ memset::dst#1 ] ) always clobbers reg byte a 
Statement [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ( main:2 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ) always clobbers reg byte a 
Statement [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 [ main::k#2 main::at#1 ] ( main:2 [ main::k#2 main::at#1 ] ) always clobbers reg byte a 
Statement [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 [ main::i#2 main::at#2 ] ( main:2 [ main::i#2 main::at#2 ] ) always clobbers reg byte a 
Statement [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ( main:2 [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ) always clobbers reg byte y 
Statement [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ( main:2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ) always clobbers reg byte a 
Statement [18] (byte*~) main::at#12 ← (byte*) main::at#2 [ main::i#2 main::at#2 main::at#12 ] ( main:2 [ main::i#2 main::at#2 main::at#12 ] ) always clobbers reg byte a 
Statement [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a 
Statement [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ) always clobbers reg byte y 
Statement [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ) always clobbers reg byte y 
Removing always clobbered register reg byte y as potential for zp ZP_BYTE:23 [ fmul8::a#0 ]
Statement [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ) always clobbers reg byte a 
Statement [30] if((byte) main::j#1!=(byte) 9) goto main::@3 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ( main:2 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ) always clobbers reg byte a 
Statement [32] if((byte) main::i#1!=(byte) 9) goto main::@2 [ main::at#2 main::i#1 ] ( main:2 [ main::at#2 main::i#1 ] ) always clobbers reg byte a 
Statement [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 [ print_byte_at::b#0 print_byte_at::at#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 [ print_sbyte_at::at#3 print_sbyte_at::b#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::at#3 print_sbyte_at::b#0 ] ) always clobbers reg byte a 
Statement [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 [ ] ( main:2::print_sbyte_at:9::print_char_at:37 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:17::print_char_at:37 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:28::print_char_at:37 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:9::print_char_at:44 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:17::print_char_at:44 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:28::print_char_at:44 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:9::print_byte_at:41::print_char_at:52 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:17::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:28::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:9::print_byte_at:41::print_char_at:56 [ main::k#2 main::at#4 ] main:2::print_sbyte_at:17::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 ] main:2::print_sbyte_at:28::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a reg byte y 
Statement [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4 [ print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 [ print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ) always clobbers reg byte a 
Statement [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f [ print_byte_at::at#0 print_byte_at::$2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::at#0 print_byte_at::$2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::at#0 print_byte_at::$2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::at#0 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 [ print_char_at::at#3 print_byte_at::$2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_char_at::at#3 print_byte_at::$2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_char_at::at#3 print_byte_at::$2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_char_at::at#3 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  } always clobbers reg byte a reg byte x 
Statement [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 [ init_screen::l#2 ] ( main:2::init_screen:5 [ init_screen::l#2 ] ) always clobbers reg byte a 
Statement [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 [ init_screen::m#2 init_screen::COLS#1 ] ( main:2::init_screen:5 [ init_screen::m#2 init_screen::COLS#1 ] ) always clobbers reg byte a 
Statement [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0 [ memset::dst#4 ] ( main:2::init_screen:5::print_cls:64::memset:79 [ memset::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#1 ] ( main:2::init_screen:5::print_cls:64::memset:79 [ memset::dst#1 ] ) always clobbers reg byte a 
Statement [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ( main:2 [ main::k#2 main::at#4 print_sbyte_at::b#1 print_sbyte_at::at#0 ] ) always clobbers reg byte a 
Statement [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 [ main::k#2 main::at#1 ] ( main:2 [ main::k#2 main::at#1 ] ) always clobbers reg byte a 
Statement [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 [ main::i#2 main::at#2 ] ( main:2 [ main::i#2 main::at#2 ] ) always clobbers reg byte a 
Statement [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ( main:2 [ main::i#2 main::at#2 print_sbyte_at::b#2 ] ) always clobbers reg byte y 
Statement [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ( main:2 [ main::i#2 main::at#2 print_sbyte_at::b#2 print_sbyte_at::at#1 ] ) always clobbers reg byte a 
Statement [18] (byte*~) main::at#12 ← (byte*) main::at#2 [ main::i#2 main::at#2 main::at#12 ] ( main:2 [ main::i#2 main::at#2 main::at#12 ] ) always clobbers reg byte a 
Statement [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a 
Statement [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 ] ) always clobbers reg byte y 
Statement [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 fmul8::a#0 fmul8::b#0 ] ) always clobbers reg byte y 
Statement [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ( main:2 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#3 print_sbyte_at::at#2 ] ) always clobbers reg byte a 
Statement [30] if((byte) main::j#1!=(byte) 9) goto main::@3 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ( main:2 [ main::i#2 main::at#2 main::at#3 main::j#1 ] ) always clobbers reg byte a 
Statement [32] if((byte) main::i#1!=(byte) 9) goto main::@2 [ main::at#2 main::i#1 ] ( main:2 [ main::at#2 main::i#1 ] ) always clobbers reg byte a 
Statement [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#1 ] ) always clobbers reg byte a 
Statement [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 [ print_byte_at::b#0 print_byte_at::at#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 ] ) always clobbers reg byte a 
Statement [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3 [ print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 print_char_at::at#0 ] ) always clobbers reg byte a 
Statement [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 [ print_sbyte_at::at#3 print_sbyte_at::b#0 ] ( main:2::print_sbyte_at:9 [ main::k#2 main::at#4 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:2::print_sbyte_at:17 [ main::i#2 main::at#2 print_sbyte_at::at#3 print_sbyte_at::b#0 ] main:2::print_sbyte_at:28 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::at#3 print_sbyte_at::b#0 ] ) always clobbers reg byte a 
Statement [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 [ ] ( main:2::print_sbyte_at:9::print_char_at:37 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:17::print_char_at:37 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:28::print_char_at:37 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:9::print_char_at:44 [ main::k#2 main::at#4 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:17::print_char_at:44 [ main::i#2 main::at#2 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:28::print_char_at:44 [ main::i#2 main::at#2 main::j#2 main::at#3 print_sbyte_at::b#4 print_sbyte_at::at#3 ] main:2::print_sbyte_at:9::print_byte_at:41::print_char_at:52 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:17::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:28::print_byte_at:41::print_char_at:52 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 ] main:2::print_sbyte_at:9::print_byte_at:41::print_char_at:56 [ main::k#2 main::at#4 ] main:2::print_sbyte_at:17::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 ] main:2::print_sbyte_at:28::print_byte_at:41::print_char_at:56 [ main::i#2 main::at#2 main::j#2 main::at#3 ] ) always clobbers reg byte a reg byte y 
Statement [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4 [ print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 print_byte_at::$0 ] ) always clobbers reg byte a 
Statement [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0 [ print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::b#0 print_byte_at::at#0 print_char_at::ch#2 print_char_at::at#2 ] ) always clobbers reg byte a 
Statement [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f [ print_byte_at::at#0 print_byte_at::$2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_byte_at::at#0 print_byte_at::$2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_byte_at::at#0 print_byte_at::$2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_byte_at::at#0 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 [ print_char_at::at#3 print_byte_at::$2 ] ( main:2::print_sbyte_at:9::print_byte_at:41 [ main::k#2 main::at#4 print_char_at::at#3 print_byte_at::$2 ] main:2::print_sbyte_at:17::print_byte_at:41 [ main::i#2 main::at#2 print_char_at::at#3 print_byte_at::$2 ] main:2::print_sbyte_at:28::print_byte_at:41 [ main::i#2 main::at#2 main::j#2 main::at#3 print_char_at::at#3 print_byte_at::$2 ] ) always clobbers reg byte a 
Statement asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  } always clobbers reg byte a reg byte x 
Statement [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 [ init_screen::l#2 ] ( main:2::init_screen:5 [ init_screen::l#2 ] ) always clobbers reg byte a 
Statement [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 [ init_screen::COLS#3 init_screen::m#2 ] ( main:2::init_screen:5 [ init_screen::COLS#3 init_screen::m#2 ] ) always clobbers reg byte a reg byte y 
Statement [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 [ init_screen::m#2 init_screen::COLS#1 ] ( main:2::init_screen:5 [ init_screen::m#2 init_screen::COLS#1 ] ) always clobbers reg byte a 
Statement [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0 [ memset::dst#4 ] ( main:2::init_screen:5::print_cls:64::memset:79 [ memset::dst#4 ] ) always clobbers reg byte a reg byte y 
Statement [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2 [ memset::dst#1 ] ( main:2::init_screen:5::print_cls:64::memset:79 [ memset::dst#1 ] ) always clobbers reg byte a 
Potential registers zp ZP_BYTE:2 [ main::k#2 main::k#1 ] : zp ZP_BYTE:2 , reg byte x , 
Potential registers zp ZP_WORD:3 [ main::at#4 main::at#1 ] : zp ZP_WORD:3 , 
Potential registers zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] : zp ZP_WORD:5 , 
Potential registers zp ZP_BYTE:7 [ main::i#2 main::i#1 ] : zp ZP_BYTE:7 , 
Potential registers zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ] : zp ZP_WORD:8 , 
Potential registers zp ZP_BYTE:10 [ main::j#2 main::j#1 ] : zp ZP_BYTE:10 , 
Potential registers zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] : zp ZP_WORD:11 , 
Potential registers zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] : zp ZP_BYTE:13 , reg byte x , 
Potential registers zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] : zp ZP_BYTE:14 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] : zp ZP_WORD:15 , 
Potential registers zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ] : zp ZP_BYTE:17 , reg byte x , reg byte y , 
Potential registers zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] : zp ZP_WORD:18 , 
Potential registers zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ] : zp ZP_BYTE:20 , reg byte x , 
Potential registers zp ZP_WORD:21 [ memset::dst#4 memset::dst#1 ] : zp ZP_WORD:21 , 
Potential registers zp ZP_BYTE:23 [ fmul8::a#0 ] : zp ZP_BYTE:23 , reg byte a , reg byte x , 
Potential registers zp ZP_BYTE:24 [ fmul8::b#0 ] : zp ZP_BYTE:24 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:25 [ fmul8::return#0 ] : zp ZP_BYTE:25 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:26 [ main::r#0 ] : zp ZP_BYTE:26 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:27 [ print_byte_at::b#0 ] : zp ZP_BYTE:27 , reg byte x , 
Potential registers zp ZP_WORD:28 [ print_byte_at::at#0 ] : zp ZP_WORD:28 , 
Potential registers zp ZP_BYTE:30 [ print_byte_at::$0 ] : zp ZP_BYTE:30 , reg byte a , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:31 [ print_byte_at::$2 ] : zp ZP_BYTE:31 , reg byte x , reg byte y , 
Potential registers zp ZP_BYTE:32 [ fmul8::return#1 ] : zp ZP_BYTE:32 , reg byte a , reg byte x , reg byte y , 

REGISTER UPLIFT SCOPES
Uplift Scope [main] 262.55: zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ] 202: zp ZP_BYTE:26 [ main::r#0 ] 181.8: zp ZP_BYTE:10 [ main::j#2 main::j#1 ] 24.32: zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] 23.94: zp ZP_BYTE:7 [ main::i#2 main::i#1 ] 23.1: zp ZP_BYTE:2 [ main::k#2 main::k#1 ] 15.58: zp ZP_WORD:3 [ main::at#4 main::at#1 ] 
Uplift Scope [print_sbyte_at] 260.33: zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] 152.5: zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] 
Uplift Scope [fmul8] 202: zp ZP_BYTE:25 [ fmul8::return#0 ] 51.5: zp ZP_BYTE:23 [ fmul8::a#0 ] 51.5: zp ZP_BYTE:24 [ fmul8::b#0 ] 34.33: zp ZP_BYTE:32 [ fmul8::return#1 ] 
Uplift Scope [init_screen] 33: zp ZP_BYTE:17 [ init_screen::l#2 init_screen::l#1 ] 20.53: zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] 20.17: zp ZP_BYTE:20 [ init_screen::m#2 init_screen::m#1 ] 
Uplift Scope [print_char_at] 24: zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] 12: zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] 
Uplift Scope [memset] 33: zp ZP_WORD:21 [ memset::dst#4 memset::dst#1 ] 
Uplift Scope [print_byte_at] 4: zp ZP_BYTE:30 [ print_byte_at::$0 ] 2: zp ZP_BYTE:31 [ print_byte_at::$2 ] 1: zp ZP_BYTE:27 [ print_byte_at::b#0 ] 1: zp ZP_WORD:28 [ print_byte_at::at#0 ] 
Uplift Scope [RADIX] 
Uplift Scope [print_cls] 
Uplift Scope [] 

Uplifting [main] best 13547 combination zp ZP_WORD:8 [ main::at#6 main::at#3 main::at#12 ] reg byte a [ main::r#0 ] zp ZP_BYTE:10 [ main::j#2 main::j#1 ] zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] zp ZP_BYTE:7 [ main::i#2 main::i#1 ] reg byte x [ main::k#2 main::k#1 ] zp ZP_WORD:3 [ main::at#4 main::at#1 ] 
Uplifting [print_sbyte_at] best 13547 combination zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] 
Uplifting [fmul8] best 12040 combination reg byte a [ fmul8::return#0 ] reg byte a [ fmul8::a#0 ] reg byte x [ fmul8::b#0 ] reg byte a [ fmul8::return#1 ] 
Limited combination testing to 100 combinations of 192 possible.
Uplifting [init_screen] best 11830 combination reg byte x [ init_screen::l#2 init_screen::l#1 ] zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] reg byte x [ init_screen::m#2 init_screen::m#1 ] 
Uplifting [print_char_at] best 11830 combination zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] 
Uplifting [memset] best 11830 combination zp ZP_WORD:21 [ memset::dst#4 memset::dst#1 ] 
Uplifting [print_byte_at] best 11822 combination reg byte a [ print_byte_at::$0 ] reg byte y [ print_byte_at::$2 ] zp ZP_BYTE:27 [ print_byte_at::b#0 ] zp ZP_WORD:28 [ print_byte_at::at#0 ] 
Uplifting [RADIX] best 11822 combination 
Uplifting [print_cls] best 11822 combination 
Uplifting [] best 11822 combination 
Attempting to uplift remaining variables inzp ZP_BYTE:10 [ main::j#2 main::j#1 ]
Uplifting [main] best 11822 combination zp ZP_BYTE:10 [ main::j#2 main::j#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ]
Uplifting [print_sbyte_at] best 11822 combination zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:7 [ main::i#2 main::i#1 ]
Uplifting [main] best 11822 combination zp ZP_BYTE:7 [ main::i#2 main::i#1 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Uplifting [print_char_at] best 11822 combination zp ZP_BYTE:14 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ] 
Attempting to uplift remaining variables inzp ZP_BYTE:27 [ print_byte_at::b#0 ]
Uplifting [print_byte_at] best 11822 combination zp ZP_BYTE:27 [ print_byte_at::b#0 ] 
Coalescing zero page register [ zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 ] ] with [ zp ZP_WORD:15 [ print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] ] - score: 2
Coalescing zero page register [ zp ZP_WORD:11 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 ] ] with [ zp ZP_WORD:28 [ print_byte_at::at#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_BYTE:13 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 ] ] with [ zp ZP_BYTE:27 [ print_byte_at::b#0 ] ] - score: 1
Coalescing zero page register [ zp ZP_WORD:18 [ init_screen::COLS#3 init_screen::COLS#1 ] ] with [ zp ZP_WORD:3 [ main::at#4 main::at#1 ] ]
Coalescing zero page register [ zp ZP_WORD:21 [ memset::dst#4 memset::dst#1 ] ] with [ zp ZP_WORD:5 [ main::at_line#2 main::at#2 ] ]
Allocated (was zp ZP_BYTE:7) zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
Allocated (was zp ZP_WORD:8) zp ZP_WORD:3 [ main::at#6 main::at#3 main::at#12 ]
Allocated (was zp ZP_BYTE:10) zp ZP_BYTE:5 [ main::j#2 main::j#1 ]
Allocated (was zp ZP_WORD:11) zp ZP_WORD:6 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 print_byte_at::at#0 ]
Allocated (was zp ZP_BYTE:13) zp ZP_BYTE:8 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 print_byte_at::b#0 ]
Allocated (was zp ZP_BYTE:14) zp ZP_BYTE:9 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
Allocated (was zp ZP_WORD:18) zp ZP_WORD:10 [ init_screen::COLS#3 init_screen::COLS#1 main::at#4 main::at#1 ]
Allocated (was zp ZP_WORD:21) zp ZP_WORD:12 [ memset::dst#4 memset::dst#1 main::at_line#2 main::at#2 ]

ASSEMBLER BEFORE OPTIMIZATION
  // File Comments
// Seriously fast multiply 8-bit version (8bit*8bit=8bit)
// Multiplies two signed 8-bit numbers and results in an 8-bit number
// C=A*B, A in [-64;64], B in [-96;95], C in [-96;95] - 64 acts a 1 (X*64=X)
// Uses the formula a*b = (a+b)^2/4 - (a-b)^2/4
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(bbegin)
.pc = $80d "Program"
  // Global Constants & labels
  .label print_screen = $400
  // Pointers to a, b and c=a*b
  .label ap = $fd
  .label bp = $fe
  .label cp = $ff
  // @begin
bbegin:
  // [1] phi from @begin to @1 [phi:@begin->@1]
b1_from_bbegin:
  jmp b1
  // @1
b1:
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
main_from_b1:
  jsr main
  // [3] phi from @1 to @end [phi:@1->@end]
bend_from_b1:
  jmp bend
  // @end
bend:
  // main
main: {
    .label at = $a
    .label at_2 = $c
    .label at_3 = 3
    .label j = 5
    .label i = 2
    .label at_line = $c
    .label at_6 = 3
    .label at_12 = 3
    // [5] call init_screen 
    // [63] phi from main to init_screen [phi:main->init_screen]
  init_screen_from_main:
    jsr init_screen
    // [6] phi from main to main::@1 [phi:main->main::@1]
  b1_from_main:
    // [6] phi (byte*) main::at#4 = (byte*) 1024+(byte) 4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400+4
    sta at
    lda #>$400+4
    sta at+1
    // [6] phi (byte) main::k#2 = (byte) 0 [phi:main->main::@1#1] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
    // [6] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
  b1_from_b5:
    // [6] phi (byte*) main::at#4 = (byte*) main::at#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [6] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@5->main::@1#1] -- register_copy 
    jmp b1
    // main::@1
  b1:
    // [7] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2) -- vbsz1=pbsc1_derefidx_vbuxx 
    lda vals,x
    sta print_sbyte_at.b
    // [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
    // [9] call print_sbyte_at 
    // [34] phi from main::@1 to print_sbyte_at [phi:main::@1->print_sbyte_at]
  print_sbyte_at_from_b1:
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#0 [phi:main::@1->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#1 [phi:main::@1->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b5
    // main::@5
  b5:
    // [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
    // [11] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuxx=_inc_vbuxx 
    inx
    // [12] if((byte) main::k#1!=(byte) 9) goto main::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #9
    bne b1_from_b5
    // [13] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
  b2_from_b5:
    // [13] phi (byte) main::i#2 = (byte) 0 [phi:main::@5->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    // [13] phi (byte*) main::at_line#2 = (byte*) 1024 [phi:main::@5->main::@2#1] -- pbuz1=pbuc1 
    lda #<$400
    sta at_line
    lda #>$400
    sta at_line+1
    jmp b2
    // [13] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
  b2_from_b4:
    // [13] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@2#0] -- register_copy 
    // [13] phi (byte*) main::at_line#2 = (byte*) main::at#2 [phi:main::@4->main::@2#1] -- register_copy 
    jmp b2
    // main::@2
  b2:
    // [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc at_2
    sta at_2
    bcc !+
    inc at_2+1
  !:
    // [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta print_sbyte_at.b
    // [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta print_sbyte_at.at
    lda at_2+1
    sta print_sbyte_at.at+1
    // [17] call print_sbyte_at 
    // [34] phi from main::@2 to print_sbyte_at [phi:main::@2->print_sbyte_at]
  print_sbyte_at_from_b2:
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#1 [phi:main::@2->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#2 [phi:main::@2->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b6
    // main::@6
  b6:
    // [18] (byte*~) main::at#12 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta at_12
    lda at_2+1
    sta at_12+1
    // [19] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
  b3_from_b6:
    // [19] phi (byte) main::j#2 = (byte) 0 [phi:main::@6->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta j
    // [19] phi (byte*) main::at#6 = (byte*~) main::at#12 [phi:main::@6->main::@3#1] -- register_copy 
    jmp b3
    // [19] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
  b3_from_b8:
    // [19] phi (byte) main::j#2 = (byte) main::j#1 [phi:main::@8->main::@3#0] -- register_copy 
    // [19] phi (byte*) main::at#6 = (byte*) main::at#3 [phi:main::@8->main::@3#1] -- register_copy 
    jmp b3
    // main::@3
  b3:
    // [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at_3
    sta at_3
    bcc !+
    inc at_3+1
  !:
    // [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsaa=pbsc1_derefidx_vbuz1 
    ldy i
    lda vals,y
    // [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy j
    ldx vals,y
    // [23] call fmul8 
    jsr fmul8
    // [24] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
    jmp b7
    // main::@7
  b7:
    // [25] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
    // [26] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0 -- vbsz1=vbsaa 
    sta print_sbyte_at.b
    // [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 -- pbuz1=pbuz2 
    lda at_3
    sta print_sbyte_at.at
    lda at_3+1
    sta print_sbyte_at.at+1
    // [28] call print_sbyte_at 
    // [34] phi from main::@7 to print_sbyte_at [phi:main::@7->print_sbyte_at]
  print_sbyte_at_from_b7:
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#2 [phi:main::@7->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#3 [phi:main::@7->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    jmp b8
    // main::@8
  b8:
    // [29] (byte) main::j#1 ← ++ (byte) main::j#2 -- vbuz1=_inc_vbuz1 
    inc j
    // [30] if((byte) main::j#1!=(byte) 9) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp j
    bne b3_from_b8
    jmp b4
    // main::@4
  b4:
    // [31] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [32] if((byte) main::i#1!=(byte) 9) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp i
    bne b2_from_b4
    jmp breturn
    // main::@return
  breturn:
    // [33] return 
    rts
}
  // print_sbyte_at
// Print a signed byte as hex at a specific screen position
// print_sbyte_at(signed byte zeropage(8) b, byte* zeropage(6) at)
print_sbyte_at: {
    .label b = 8
    .label at = 6
    // [35] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1 -- vbsz1_lt_0_then_la1 
    lda b
    bmi b1
    jmp b3
    // print_sbyte_at::@3
  b3:
    // [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
    // [37] call print_char_at 
    // [46] phi from print_sbyte_at::@3 to print_char_at [phi:print_sbyte_at::@3->print_char_at]
  print_char_at_from_b3:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#1 [phi:print_sbyte_at::@3->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) ' ' [phi:print_sbyte_at::@3->print_char_at#1] -- vbuz1=vbuc1 
    lda #' '
    sta print_char_at.ch
    jsr print_char_at
    // [38] phi from print_sbyte_at::@3 print_sbyte_at::@4 to print_sbyte_at::@2 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2]
  b2_from_b3:
  b2_from_b4:
    // [38] phi (signed byte) print_sbyte_at::b#6 = (signed byte) print_sbyte_at::b#4 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2#0] -- register_copy 
    jmp b2
    // print_sbyte_at::@2
  b2:
    // [39] (byte) print_byte_at::b#0 ← (byte)(signed byte) print_sbyte_at::b#6
    // [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_byte_at.at
    bne !+
    inc print_byte_at.at+1
  !:
    // [41] call print_byte_at 
    jsr print_byte_at
    jmp breturn
    // print_sbyte_at::@return
  breturn:
    // [42] return 
    rts
    // print_sbyte_at::@1
  b1:
    // [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
    // [44] call print_char_at 
    // [46] phi from print_sbyte_at::@1 to print_char_at [phi:print_sbyte_at::@1->print_char_at]
  print_char_at_from_b1:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#0 [phi:print_sbyte_at::@1->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) '-' [phi:print_sbyte_at::@1->print_char_at#1] -- vbuz1=vbuc1 
    lda #'-'
    sta print_char_at.ch
    jsr print_char_at
    jmp b4
    // print_sbyte_at::@4
  b4:
    // [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 -- vbsz1=_neg_vbsz1 
    lda b
    eor #$ff
    clc
    adc #1
    sta b
    jmp b2_from_b4
}
  // print_char_at
// Print a single char
// print_char_at(byte zeropage(9) ch, byte* zeropage(6) at)
print_char_at: {
    .label at = 6
    .label ch = 9
    // [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
    jmp breturn
    // print_char_at::@return
  breturn:
    // [48] return 
    rts
}
  // print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte zeropage(8) b, byte* zeropage(6) at)
print_byte_at: {
    .label b = 8
    .label at = 6
    // [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda b
    lsr
    lsr
    lsr
    lsr
    // [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda print_hextab,y
    sta print_char_at.ch
    // [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
    // [52] call print_char_at 
    // [46] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
  print_char_at_from_print_byte_at:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#2 [phi:print_byte_at->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#2 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp b1
    // print_byte_at::@1
  b1:
    // [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and b
    tay
    // [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_char_at.at
    bne !+
    inc print_char_at.at+1
  !:
    // [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuyy 
    lda print_hextab,y
    sta print_char_at.ch
    // [56] call print_char_at 
    // [46] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
  print_char_at_from_b1:
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#3 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#3 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    jmp breturn
    // print_byte_at::@return
  breturn:
    // [57] return 
    rts
}
  // fmul8
// fmul8(signed byte register(A) a, signed byte register(X) b)
fmul8: {
    // [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0 -- _deref_pbsc1=vbsaa 
    sta ap
    // [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0 -- _deref_pbsc1=vbsxx 
    txa
    sta bp
    // asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
    lda ap
    sta A1+1
    eor #$ff
    sta A2+1
    ldx bp
    sec
  A1:
    lda mulf_sqr1,x
  A2:
    sbc mulf_sqr2,x
    sta cp
    // [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0) -- vbsaa=_deref_pbsc1 
    lda cp
    jmp breturn
    // fmul8::@return
  breturn:
    // [62] return 
    rts
}
  // init_screen
init_screen: {
    .const WHITE = 1
    .label COLS = $a
    // [64] call print_cls 
    // [78] phi from init_screen to print_cls [phi:init_screen->print_cls]
  print_cls_from_init_screen:
    jsr print_cls
    // [65] phi from init_screen to init_screen::@1 [phi:init_screen->init_screen::@1]
  b1_from_init_screen:
    // [65] phi (byte) init_screen::l#2 = (byte) 0 [phi:init_screen->init_screen::@1#0] -- vbuxx=vbuc1 
    ldx #0
    jmp b1
    // [65] phi from init_screen::@1 to init_screen::@1 [phi:init_screen::@1->init_screen::@1]
  b1_from_b1:
    // [65] phi (byte) init_screen::l#2 = (byte) init_screen::l#1 [phi:init_screen::@1->init_screen::@1#0] -- register_copy 
    jmp b1
    // init_screen::@1
  b1:
    // [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #WHITE
    sta $d800,x
    // [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne b1_from_b1
    // [69] phi from init_screen::@1 to init_screen::@2 [phi:init_screen::@1->init_screen::@2]
  b2_from_b1:
    // [69] phi (byte) init_screen::m#2 = (byte) 0 [phi:init_screen::@1->init_screen::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [69] phi (byte*) init_screen::COLS#3 = (byte*) 55296 [phi:init_screen::@1->init_screen::@2#1] -- pbuz1=pbuc1 
    lda #<$d800
    sta COLS
    lda #>$d800
    sta COLS+1
    jmp b2
    // [69] phi from init_screen::@2 to init_screen::@2 [phi:init_screen::@2->init_screen::@2]
  b2_from_b2:
    // [69] phi (byte) init_screen::m#2 = (byte) init_screen::m#1 [phi:init_screen::@2->init_screen::@2#0] -- register_copy 
    // [69] phi (byte*) init_screen::COLS#3 = (byte*) init_screen::COLS#1 [phi:init_screen::@2->init_screen::@2#1] -- register_copy 
    jmp b2
    // init_screen::@2
  b2:
    // [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 -- _deref_pbuz1=vbuc1 
    lda #WHITE
    ldy #0
    sta (COLS),y
    // [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #1
    sta (COLS),y
    // [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #2
    sta (COLS),y
    // [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    lda #WHITE
    ldy #3
    sta (COLS),y
    // [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc COLS
    sta COLS
    bcc !+
    inc COLS+1
  !:
    // [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2 -- vbuxx=_inc_vbuxx 
    inx
    // [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$19
    bne b2_from_b2
    jmp breturn
    // init_screen::@return
  breturn:
    // [77] return 
    rts
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // [79] call memset 
    // [81] phi from print_cls to memset [phi:print_cls->memset]
  memset_from_print_cls:
    jsr memset
    jmp breturn
    // print_cls::@return
  breturn:
    // [80] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $3e8
    .label str = print_screen
    .label end = str+num
    .label dst = $c
    // [82] phi from memset to memset::@2 [phi:memset->memset::@2]
  b2_from_memset:
    // [82] phi (byte*) memset::dst#4 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@2#0] -- pbuz1=pbuc1 
    lda #<str
    sta dst
    lda #>str
    sta dst+1
    jmp b2
    // [82] phi from memset::@1 to memset::@2 [phi:memset::@1->memset::@2]
  b2_from_b1:
    // [82] phi (byte*) memset::dst#4 = (byte*) memset::dst#1 [phi:memset::@1->memset::@2#0] -- register_copy 
    jmp b2
    // memset::@2
  b2:
    // [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // [84] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#4 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
    jmp b1
    // memset::@1
  b1:
    // [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda dst+1
    cmp #>end
    bne b2_from_b1
    lda dst
    cmp #<end
    bne b2_from_b1
    jmp breturn
    // memset::@return
  breturn:
    // [86] return 
    rts
}
  // File Data
  print_hextab: .text "0123456789abcdef"
  vals: .byte -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f
  // mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
  // f(x) = >(( x * x ))
  .align $100
mulf_sqr1:
.for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }

  // g(x) =  >((( 1 - x ) * ( 1 - x )))
  .align $100
mulf_sqr2:
.for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }


ASSEMBLER OPTIMIZATIONS
Removing instruction jmp b1
Removing instruction jmp bend
Removing instruction jmp b1
Removing instruction jmp b5
Removing instruction jmp b2
Removing instruction jmp b6
Removing instruction jmp b3
Removing instruction jmp b7
Removing instruction jmp b8
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b3
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp b4
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp breturn
Removing instruction jmp breturn
Removing instruction jmp b2
Removing instruction jmp b1
Removing instruction jmp breturn
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda cp
Removing instruction lda #WHITE
Removing instruction lda #WHITE
Removing instruction lda #WHITE
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Replacing label b1_from_b5 with b1
Replacing label b3_from_b8 with b3
Replacing label b2_from_b4 with b2
Replacing label b2_from_b4 with b2
Replacing label b1_from_b1 with b1
Replacing label b2_from_b2 with b2
Replacing label b2_from_b1 with b2
Replacing label b2_from_b1 with b2
Removing instruction b1_from_bbegin:
Removing instruction b1:
Removing instruction main_from_b1:
Removing instruction bend_from_b1:
Removing instruction b1_from_b5:
Removing instruction b2_from_b4:
Removing instruction b3_from_b8:
Removing instruction print_char_at_from_b3:
Removing instruction b2_from_b3:
Removing instruction b2_from_b4:
Removing instruction print_char_at_from_b1:
Removing instruction b1_from_b1:
Removing instruction b2_from_b2:
Removing instruction b2_from_b1:
Succesful ASM optimization Pass5RedundantLabelElimination
Removing instruction bend:
Removing instruction init_screen_from_main:
Removing instruction b1_from_main:
Removing instruction print_sbyte_at_from_b1:
Removing instruction b5:
Removing instruction b2_from_b5:
Removing instruction print_sbyte_at_from_b2:
Removing instruction b6:
Removing instruction b3_from_b6:
Removing instruction b7:
Removing instruction print_sbyte_at_from_b7:
Removing instruction b8:
Removing instruction b4:
Removing instruction breturn:
Removing instruction b3:
Removing instruction breturn:
Removing instruction b4:
Removing instruction breturn:
Removing instruction print_char_at_from_print_byte_at:
Removing instruction b1:
Removing instruction print_char_at_from_b1:
Removing instruction breturn:
Removing instruction breturn:
Removing instruction print_cls_from_init_screen:
Removing instruction b1_from_init_screen:
Removing instruction b2_from_b1:
Removing instruction breturn:
Removing instruction memset_from_print_cls:
Removing instruction breturn:
Removing instruction b2_from_memset:
Removing instruction b1:
Removing instruction breturn:
Succesful ASM optimization Pass5UnusedLabelElimination
Updating BasicUpstart to call main directly
Removing instruction jsr main
Succesful ASM optimization Pass5SkipBegin
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b3
Removing instruction jmp b1
Removing instruction jmp b2
Removing instruction jmp b2
Succesful ASM optimization Pass5NextJumpElimination
Removing instruction lda #9
Succesful ASM optimization Pass5UnnecesaryLoadElimination
Removing instruction bbegin:
Succesful ASM optimization Pass5UnusedLabelElimination

FINAL SYMBOL TABLE
(label) @1
(label) @begin
(label) @end
(const byte) RADIX::BINARY BINARY = (number) 2
(const byte) RADIX::DECIMAL DECIMAL = (number) $a
(const byte) RADIX::HEXADECIMAL HEXADECIMAL = (number) $10
(const byte) RADIX::OCTAL OCTAL = (number) 8
(signed byte*) ap
(const signed byte*) ap#0 ap = (signed byte*) 253
(signed byte*) bp
(const signed byte*) bp#0 bp = (signed byte*) 254
(signed byte*) cp
(const signed byte*) cp#0 cp = (signed byte*) 255
(signed byte()) fmul8((signed byte) fmul8::a , (signed byte) fmul8::b)
(label) fmul8::@return
(signed byte) fmul8::a
(signed byte) fmul8::a#0 reg byte a 51.5
(signed byte) fmul8::b
(signed byte) fmul8::b#0 reg byte x 51.5
(signed byte) fmul8::return
(signed byte) fmul8::return#0 reg byte a 202.0
(signed byte) fmul8::return#1 reg byte a 34.33333333333333
(void()) init_screen()
(label) init_screen::@1
(label) init_screen::@2
(label) init_screen::@return
(byte*) init_screen::COLS
(byte*) init_screen::COLS#1 COLS zp ZP_WORD:10 7.333333333333333
(byte*) init_screen::COLS#3 COLS zp ZP_WORD:10 13.2
(byte) init_screen::WHITE
(const byte) init_screen::WHITE#0 WHITE = (byte) 1
(byte) init_screen::l
(byte) init_screen::l#1 reg byte x 16.5
(byte) init_screen::l#2 reg byte x 16.5
(byte) init_screen::m
(byte) init_screen::m#1 reg byte x 16.5
(byte) init_screen::m#2 reg byte x 3.6666666666666665
(void()) main()
(label) main::@1
(label) main::@2
(label) main::@3
(label) main::@4
(label) main::@5
(label) main::@6
(label) main::@7
(label) main::@8
(label) main::@return
(byte*) main::at
(byte*) main::at#1 at zp ZP_WORD:10 7.333333333333333
(byte*~) main::at#12 at#12 zp ZP_WORD:3 22.0
(byte*) main::at#2 at#2 zp ZP_WORD:12 2.3157894736842106
(byte*) main::at#3 at#3 zp ZP_WORD:3 27.545454545454547
(byte*) main::at#4 at zp ZP_WORD:10 8.25
(byte*) main::at#6 at#6 zp ZP_WORD:3 213.0
(byte*) main::at_line
(byte*) main::at_line#2 at_line zp ZP_WORD:12 22.0
(byte) main::i
(byte) main::i#1 i zp ZP_BYTE:2 16.5
(byte) main::i#2 i zp ZP_BYTE:2 7.444444444444445
(byte) main::j
(byte) main::j#1 j zp ZP_BYTE:5 151.5
(byte) main::j#2 j zp ZP_BYTE:5 30.299999999999997
(byte) main::k
(byte) main::k#1 reg byte x 16.5
(byte) main::k#2 reg byte x 6.6000000000000005
(signed byte) main::r
(signed byte) main::r#0 reg byte a 202.0
(void*()) memset((void*) memset::str , (byte) memset::c , (word) memset::num)
(label) memset::@1
(label) memset::@2
(label) memset::@return
(byte) memset::c
(const byte) memset::c#0 c = (byte) ' '
(byte*) memset::dst
(byte*) memset::dst#1 dst zp ZP_WORD:12 16.5
(byte*) memset::dst#4 dst zp ZP_WORD:12 16.5
(byte*) memset::end
(const byte*) memset::end#0 end = (byte*)(const void*) memset::str#0+(const word) memset::num#0
(word) memset::num
(const word) memset::num#0 num = (word) $3e8
(void*) memset::return
(void*) memset::str
(const void*) memset::str#0 str = (void*)(const byte*) print_screen#0
(byte[$200]) mulf_sqr1
(const byte[$200]) mulf_sqr1#0 mulf_sqr1 = kickasm {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }
 }}
(byte[$200]) mulf_sqr2
(const byte[$200]) mulf_sqr2#0 mulf_sqr2 = kickasm {{ .for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }
 }}
(void()) print_byte_at((byte) print_byte_at::b , (byte*) print_byte_at::at)
(byte~) print_byte_at::$0 reg byte a 4.0
(byte~) print_byte_at::$2 reg byte y 2.0
(label) print_byte_at::@1
(label) print_byte_at::@return
(byte*) print_byte_at::at
(byte*) print_byte_at::at#0 at zp ZP_WORD:6 1.0
(byte) print_byte_at::b
(byte) print_byte_at::b#0 b zp ZP_BYTE:8 1.0
(void()) print_char_at((byte) print_char_at::ch , (byte*) print_char_at::at)
(label) print_char_at::@return
(byte*) print_char_at::at
(byte*) print_char_at::at#0 at zp ZP_WORD:6 4.0
(byte*) print_char_at::at#1 at zp ZP_WORD:6 4.0
(byte*) print_char_at::at#2 at zp ZP_WORD:6 4.0
(byte*) print_char_at::at#3 at zp ZP_WORD:6 2.0
(byte*) print_char_at::at#4 at zp ZP_WORD:6 10.0
(byte) print_char_at::ch
(byte) print_char_at::ch#2 ch zp ZP_BYTE:9 2.0
(byte) print_char_at::ch#3 ch zp ZP_BYTE:9 4.0
(byte) print_char_at::ch#4 ch zp ZP_BYTE:9 6.0
(void()) print_cls()
(label) print_cls::@return
(byte[]) print_hextab
(const byte[]) print_hextab#0 print_hextab = (string) "0123456789abcdef"
(void()) print_sbyte_at((signed byte) print_sbyte_at::b , (byte*) print_sbyte_at::at)
(label) print_sbyte_at::@1
(label) print_sbyte_at::@2
(label) print_sbyte_at::@3
(label) print_sbyte_at::@4
(label) print_sbyte_at::@return
(byte*) print_sbyte_at::at
(byte*) print_sbyte_at::at#0 at zp ZP_WORD:6 22.0
(byte*) print_sbyte_at::at#1 at zp ZP_WORD:6 22.0
(byte*) print_sbyte_at::at#2 at zp ZP_WORD:6 202.0
(byte*) print_sbyte_at::at#3 at zp ZP_WORD:6 14.333333333333329
(signed byte) print_sbyte_at::b
(signed byte) print_sbyte_at::b#0 b zp ZP_BYTE:8 4.0
(signed byte) print_sbyte_at::b#1 b zp ZP_BYTE:8 11.0
(signed byte) print_sbyte_at::b#2 b zp ZP_BYTE:8 11.0
(signed byte) print_sbyte_at::b#3 b zp ZP_BYTE:8 101.0
(signed byte) print_sbyte_at::b#4 b zp ZP_BYTE:8 21.499999999999993
(signed byte) print_sbyte_at::b#6 b zp ZP_BYTE:8 4.0
(byte*) print_screen
(const byte*) print_screen#0 print_screen = (byte*) 1024
(signed byte[]) vals
(const signed byte[]) vals#0 vals = { (signed byte) -$5f, (signed byte) -$40, (signed byte) -$20, (signed byte) -$10, (signed byte) 0, (signed byte) $10, (signed byte) $20, (signed byte) $40, (signed byte) $5f }

reg byte x [ main::k#2 main::k#1 ]
zp ZP_BYTE:2 [ main::i#2 main::i#1 ]
zp ZP_WORD:3 [ main::at#6 main::at#3 main::at#12 ]
zp ZP_BYTE:5 [ main::j#2 main::j#1 ]
zp ZP_WORD:6 [ print_sbyte_at::at#3 print_sbyte_at::at#0 print_sbyte_at::at#2 print_sbyte_at::at#1 print_char_at::at#4 print_char_at::at#2 print_char_at::at#3 print_char_at::at#0 print_char_at::at#1 print_byte_at::at#0 ]
zp ZP_BYTE:8 [ print_sbyte_at::b#6 print_sbyte_at::b#0 print_sbyte_at::b#4 print_sbyte_at::b#1 print_sbyte_at::b#3 print_sbyte_at::b#2 print_byte_at::b#0 ]
zp ZP_BYTE:9 [ print_char_at::ch#4 print_char_at::ch#2 print_char_at::ch#3 ]
reg byte x [ init_screen::l#2 init_screen::l#1 ]
zp ZP_WORD:10 [ init_screen::COLS#3 init_screen::COLS#1 main::at#4 main::at#1 ]
reg byte x [ init_screen::m#2 init_screen::m#1 ]
zp ZP_WORD:12 [ memset::dst#4 memset::dst#1 main::at_line#2 main::at#2 ]
reg byte a [ fmul8::a#0 ]
reg byte x [ fmul8::b#0 ]
reg byte a [ fmul8::return#0 ]
reg byte a [ main::r#0 ]
reg byte a [ print_byte_at::$0 ]
reg byte y [ print_byte_at::$2 ]
reg byte a [ fmul8::return#1 ]


FINAL ASSEMBLER
Score: 10016

  // File Comments
// Seriously fast multiply 8-bit version (8bit*8bit=8bit)
// Multiplies two signed 8-bit numbers and results in an 8-bit number
// C=A*B, A in [-64;64], B in [-96;95], C in [-96;95] - 64 acts a 1 (X*64=X)
// Uses the formula a*b = (a+b)^2/4 - (a-b)^2/4
// See the following for information about the method
// - http://codebase64.org/doku.php?id=base:seriously_fast_multiplication 
// - http://codebase64.org/doku.php?id=magazines:chacking16
  // Upstart
.pc = $801 "Basic"
:BasicUpstart(main)
.pc = $80d "Program"
  // Global Constants & labels
  .label print_screen = $400
  // Pointers to a, b and c=a*b
  .label ap = $fd
  .label bp = $fe
  .label cp = $ff
  // @begin
  // [1] phi from @begin to @1 [phi:@begin->@1]
  // @1
  // [2] call main 
  // [4] phi from @1 to main [phi:@1->main]
  // [3] phi from @1 to @end [phi:@1->@end]
  // @end
  // main
main: {
    .label at = $a
    .label at_2 = $c
    .label at_3 = 3
    .label j = 5
    .label i = 2
    .label at_line = $c
    .label at_6 = 3
    .label at_12 = 3
    // init_screen()
    // [5] call init_screen 
    // [63] phi from main to init_screen [phi:main->init_screen]
    jsr init_screen
    // [6] phi from main to main::@1 [phi:main->main::@1]
    // [6] phi (byte*) main::at#4 = (byte*) 1024+(byte) 4 [phi:main->main::@1#0] -- pbuz1=pbuc1 
    lda #<$400+4
    sta at
    lda #>$400+4
    sta at+1
    // [6] phi (byte) main::k#2 = (byte) 0 [phi:main->main::@1#1] -- vbuxx=vbuc1 
    ldx #0
    // [6] phi from main::@5 to main::@1 [phi:main::@5->main::@1]
    // [6] phi (byte*) main::at#4 = (byte*) main::at#1 [phi:main::@5->main::@1#0] -- register_copy 
    // [6] phi (byte) main::k#2 = (byte) main::k#1 [phi:main::@5->main::@1#1] -- register_copy 
    // main::@1
  b1:
    // print_sbyte_at(vals[k], at)
    // [7] (signed byte) print_sbyte_at::b#1 ← *((const signed byte[]) vals#0 + (byte) main::k#2) -- vbsz1=pbsc1_derefidx_vbuxx 
    lda vals,x
    sta print_sbyte_at.b
    // [8] (byte*) print_sbyte_at::at#0 ← (byte*) main::at#4 -- pbuz1=pbuz2 
    lda at
    sta print_sbyte_at.at
    lda at+1
    sta print_sbyte_at.at+1
    // [9] call print_sbyte_at 
    // [34] phi from main::@1 to print_sbyte_at [phi:main::@1->print_sbyte_at]
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#0 [phi:main::@1->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#1 [phi:main::@1->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    // main::@5
    // at += 4
    // [10] (byte*) main::at#1 ← (byte*) main::at#4 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at
    sta at
    bcc !+
    inc at+1
  !:
    // for(byte k: 0..8)
    // [11] (byte) main::k#1 ← ++ (byte) main::k#2 -- vbuxx=_inc_vbuxx 
    inx
    // [12] if((byte) main::k#1!=(byte) 9) goto main::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #9
    bne b1
    // [13] phi from main::@5 to main::@2 [phi:main::@5->main::@2]
    // [13] phi (byte) main::i#2 = (byte) 0 [phi:main::@5->main::@2#0] -- vbuz1=vbuc1 
    lda #0
    sta i
    // [13] phi (byte*) main::at_line#2 = (byte*) 1024 [phi:main::@5->main::@2#1] -- pbuz1=pbuc1 
    lda #<$400
    sta at_line
    lda #>$400
    sta at_line+1
    // [13] phi from main::@4 to main::@2 [phi:main::@4->main::@2]
    // [13] phi (byte) main::i#2 = (byte) main::i#1 [phi:main::@4->main::@2#0] -- register_copy 
    // [13] phi (byte*) main::at_line#2 = (byte*) main::at#2 [phi:main::@4->main::@2#1] -- register_copy 
    // main::@2
  b2:
    // at_line +=40
    // [14] (byte*) main::at#2 ← (byte*) main::at_line#2 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc at_2
    sta at_2
    bcc !+
    inc at_2+1
  !:
    // print_sbyte_at(vals[i], at)
    // [15] (signed byte) print_sbyte_at::b#2 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsz1=pbsc1_derefidx_vbuz2 
    ldy i
    lda vals,y
    sta print_sbyte_at.b
    // [16] (byte*) print_sbyte_at::at#1 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta print_sbyte_at.at
    lda at_2+1
    sta print_sbyte_at.at+1
    // [17] call print_sbyte_at 
    // [34] phi from main::@2 to print_sbyte_at [phi:main::@2->print_sbyte_at]
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#1 [phi:main::@2->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#2 [phi:main::@2->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    // main::@6
    // [18] (byte*~) main::at#12 ← (byte*) main::at#2 -- pbuz1=pbuz2 
    lda at_2
    sta at_12
    lda at_2+1
    sta at_12+1
    // [19] phi from main::@6 to main::@3 [phi:main::@6->main::@3]
    // [19] phi (byte) main::j#2 = (byte) 0 [phi:main::@6->main::@3#0] -- vbuz1=vbuc1 
    lda #0
    sta j
    // [19] phi (byte*) main::at#6 = (byte*~) main::at#12 [phi:main::@6->main::@3#1] -- register_copy 
    // [19] phi from main::@8 to main::@3 [phi:main::@8->main::@3]
    // [19] phi (byte) main::j#2 = (byte) main::j#1 [phi:main::@8->main::@3#0] -- register_copy 
    // [19] phi (byte*) main::at#6 = (byte*) main::at#3 [phi:main::@8->main::@3#1] -- register_copy 
    // main::@3
  b3:
    // at += 4
    // [20] (byte*) main::at#3 ← (byte*) main::at#6 + (byte) 4 -- pbuz1=pbuz1_plus_vbuc1 
    lda #4
    clc
    adc at_3
    sta at_3
    bcc !+
    inc at_3+1
  !:
    // fmul8(vals[i], vals[j])
    // [21] (signed byte) fmul8::a#0 ← *((const signed byte[]) vals#0 + (byte) main::i#2) -- vbsaa=pbsc1_derefidx_vbuz1 
    ldy i
    lda vals,y
    // [22] (signed byte) fmul8::b#0 ← *((const signed byte[]) vals#0 + (byte) main::j#2) -- vbsxx=pbsc1_derefidx_vbuz1 
    ldy j
    ldx vals,y
    // [23] call fmul8 
    jsr fmul8
    // [24] (signed byte) fmul8::return#0 ← (signed byte) fmul8::return#1
    // main::@7
    // r = fmul8(vals[i], vals[j])
    // [25] (signed byte) main::r#0 ← (signed byte) fmul8::return#0
    // print_sbyte_at(r, at)
    // [26] (signed byte) print_sbyte_at::b#3 ← (signed byte) main::r#0 -- vbsz1=vbsaa 
    sta print_sbyte_at.b
    // [27] (byte*) print_sbyte_at::at#2 ← (byte*) main::at#3 -- pbuz1=pbuz2 
    lda at_3
    sta print_sbyte_at.at
    lda at_3+1
    sta print_sbyte_at.at+1
    // [28] call print_sbyte_at 
    // [34] phi from main::@7 to print_sbyte_at [phi:main::@7->print_sbyte_at]
    // [34] phi (byte*) print_sbyte_at::at#3 = (byte*) print_sbyte_at::at#2 [phi:main::@7->print_sbyte_at#0] -- register_copy 
    // [34] phi (signed byte) print_sbyte_at::b#4 = (signed byte) print_sbyte_at::b#3 [phi:main::@7->print_sbyte_at#1] -- register_copy 
    jsr print_sbyte_at
    // main::@8
    // for(byte j: 0..8)
    // [29] (byte) main::j#1 ← ++ (byte) main::j#2 -- vbuz1=_inc_vbuz1 
    inc j
    // [30] if((byte) main::j#1!=(byte) 9) goto main::@3 -- vbuz1_neq_vbuc1_then_la1 
    lda #9
    cmp j
    bne b3
    // main::@4
    // for(byte i: 0..8)
    // [31] (byte) main::i#1 ← ++ (byte) main::i#2 -- vbuz1=_inc_vbuz1 
    inc i
    // [32] if((byte) main::i#1!=(byte) 9) goto main::@2 -- vbuz1_neq_vbuc1_then_la1 
    cmp i
    bne b2
    // main::@return
    // }
    // [33] return 
    rts
}
  // print_sbyte_at
// Print a signed byte as hex at a specific screen position
// print_sbyte_at(signed byte zeropage(8) b, byte* zeropage(6) at)
print_sbyte_at: {
    .label b = 8
    .label at = 6
    // if(b<0)
    // [35] if((signed byte) print_sbyte_at::b#4<(signed byte) 0) goto print_sbyte_at::@1 -- vbsz1_lt_0_then_la1 
    lda b
    bmi b1
    // print_sbyte_at::@3
    // print_char_at(' ', at)
    // [36] (byte*) print_char_at::at#1 ← (byte*) print_sbyte_at::at#3
    // [37] call print_char_at 
    // [46] phi from print_sbyte_at::@3 to print_char_at [phi:print_sbyte_at::@3->print_char_at]
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#1 [phi:print_sbyte_at::@3->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) ' ' [phi:print_sbyte_at::@3->print_char_at#1] -- vbuz1=vbuc1 
    lda #' '
    sta print_char_at.ch
    jsr print_char_at
    // [38] phi from print_sbyte_at::@3 print_sbyte_at::@4 to print_sbyte_at::@2 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2]
    // [38] phi (signed byte) print_sbyte_at::b#6 = (signed byte) print_sbyte_at::b#4 [phi:print_sbyte_at::@3/print_sbyte_at::@4->print_sbyte_at::@2#0] -- register_copy 
    // print_sbyte_at::@2
  b2:
    // print_byte_at((byte)b, at+1)
    // [39] (byte) print_byte_at::b#0 ← (byte)(signed byte) print_sbyte_at::b#6
    // [40] (byte*) print_byte_at::at#0 ← (byte*) print_sbyte_at::at#3 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_byte_at.at
    bne !+
    inc print_byte_at.at+1
  !:
    // [41] call print_byte_at 
    jsr print_byte_at
    // print_sbyte_at::@return
    // }
    // [42] return 
    rts
    // print_sbyte_at::@1
  b1:
    // print_char_at('-', at)
    // [43] (byte*) print_char_at::at#0 ← (byte*) print_sbyte_at::at#3
    // [44] call print_char_at 
    // [46] phi from print_sbyte_at::@1 to print_char_at [phi:print_sbyte_at::@1->print_char_at]
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#0 [phi:print_sbyte_at::@1->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) '-' [phi:print_sbyte_at::@1->print_char_at#1] -- vbuz1=vbuc1 
    lda #'-'
    sta print_char_at.ch
    jsr print_char_at
    // print_sbyte_at::@4
    // b = -b
    // [45] (signed byte) print_sbyte_at::b#0 ← - (signed byte) print_sbyte_at::b#4 -- vbsz1=_neg_vbsz1 
    lda b
    eor #$ff
    clc
    adc #1
    sta b
    jmp b2
}
  // print_char_at
// Print a single char
// print_char_at(byte zeropage(9) ch, byte* zeropage(6) at)
print_char_at: {
    .label at = 6
    .label ch = 9
    // *(at) = ch
    // [47] *((byte*) print_char_at::at#4) ← (byte) print_char_at::ch#4 -- _deref_pbuz1=vbuz2 
    lda ch
    ldy #0
    sta (at),y
    // print_char_at::@return
    // }
    // [48] return 
    rts
}
  // print_byte_at
// Print a byte as HEX at a specific position
// print_byte_at(byte zeropage(8) b, byte* zeropage(6) at)
print_byte_at: {
    .label b = 8
    .label at = 6
    // b>>4
    // [49] (byte~) print_byte_at::$0 ← (byte) print_byte_at::b#0 >> (byte) 4 -- vbuaa=vbuz1_ror_4 
    lda b
    lsr
    lsr
    lsr
    lsr
    // print_char_at(print_hextab[b>>4], at)
    // [50] (byte) print_char_at::ch#2 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$0) -- vbuz1=pbuc1_derefidx_vbuaa 
    tay
    lda print_hextab,y
    sta print_char_at.ch
    // [51] (byte*) print_char_at::at#2 ← (byte*) print_byte_at::at#0
    // [52] call print_char_at 
    // [46] phi from print_byte_at to print_char_at [phi:print_byte_at->print_char_at]
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#2 [phi:print_byte_at->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#2 [phi:print_byte_at->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_byte_at::@1
    // b&$f
    // [53] (byte~) print_byte_at::$2 ← (byte) print_byte_at::b#0 & (byte) $f -- vbuyy=vbuz1_band_vbuc1 
    lda #$f
    and b
    tay
    // print_char_at(print_hextab[b&$f], at+1)
    // [54] (byte*) print_char_at::at#3 ← (byte*) print_byte_at::at#0 + (byte) 1 -- pbuz1=pbuz1_plus_1 
    inc print_char_at.at
    bne !+
    inc print_char_at.at+1
  !:
    // [55] (byte) print_char_at::ch#3 ← *((const byte[]) print_hextab#0 + (byte~) print_byte_at::$2) -- vbuz1=pbuc1_derefidx_vbuyy 
    lda print_hextab,y
    sta print_char_at.ch
    // [56] call print_char_at 
    // [46] phi from print_byte_at::@1 to print_char_at [phi:print_byte_at::@1->print_char_at]
    // [46] phi (byte*) print_char_at::at#4 = (byte*) print_char_at::at#3 [phi:print_byte_at::@1->print_char_at#0] -- register_copy 
    // [46] phi (byte) print_char_at::ch#4 = (byte) print_char_at::ch#3 [phi:print_byte_at::@1->print_char_at#1] -- register_copy 
    jsr print_char_at
    // print_byte_at::@return
    // }
    // [57] return 
    rts
}
  // fmul8
// fmul8(signed byte register(A) a, signed byte register(X) b)
fmul8: {
    // *ap = a
    // [58] *((const signed byte*) ap#0) ← (signed byte) fmul8::a#0 -- _deref_pbsc1=vbsaa 
    sta ap
    // *bp = b
    // [59] *((const signed byte*) bp#0) ← (signed byte) fmul8::b#0 -- _deref_pbsc1=vbsxx 
    txa
    sta bp
    // asm
    // asm { ldaap staA1+1 eor#$ff staA2+1 ldxbp sec A1: ldamulf_sqr1,x A2: sbcmulf_sqr2,x stacp  }
    lda ap
    sta A1+1
    eor #$ff
    sta A2+1
    ldx bp
    sec
  A1:
    lda mulf_sqr1,x
  A2:
    sbc mulf_sqr2,x
    sta cp
    // return *cp;
    // [61] (signed byte) fmul8::return#1 ← *((const signed byte*) cp#0) -- vbsaa=_deref_pbsc1 
    // fmul8::@return
    // }
    // [62] return 
    rts
}
  // init_screen
init_screen: {
    .const WHITE = 1
    .label COLS = $a
    // print_cls()
    // [64] call print_cls 
    // [78] phi from init_screen to print_cls [phi:init_screen->print_cls]
    jsr print_cls
    // [65] phi from init_screen to init_screen::@1 [phi:init_screen->init_screen::@1]
    // [65] phi (byte) init_screen::l#2 = (byte) 0 [phi:init_screen->init_screen::@1#0] -- vbuxx=vbuc1 
    ldx #0
    // [65] phi from init_screen::@1 to init_screen::@1 [phi:init_screen::@1->init_screen::@1]
    // [65] phi (byte) init_screen::l#2 = (byte) init_screen::l#1 [phi:init_screen::@1->init_screen::@1#0] -- register_copy 
    // init_screen::@1
  b1:
    // COLS[l] = WHITE
    // [66] *((byte*) 55296 + (byte) init_screen::l#2) ← (const byte) init_screen::WHITE#0 -- pbuc1_derefidx_vbuxx=vbuc2 
    lda #WHITE
    sta $d800,x
    // for(byte l: 0..39)
    // [67] (byte) init_screen::l#1 ← ++ (byte) init_screen::l#2 -- vbuxx=_inc_vbuxx 
    inx
    // [68] if((byte) init_screen::l#1!=(byte) $28) goto init_screen::@1 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$28
    bne b1
    // [69] phi from init_screen::@1 to init_screen::@2 [phi:init_screen::@1->init_screen::@2]
    // [69] phi (byte) init_screen::m#2 = (byte) 0 [phi:init_screen::@1->init_screen::@2#0] -- vbuxx=vbuc1 
    ldx #0
    // [69] phi (byte*) init_screen::COLS#3 = (byte*) 55296 [phi:init_screen::@1->init_screen::@2#1] -- pbuz1=pbuc1 
    lda #<$d800
    sta COLS
    lda #>$d800
    sta COLS+1
    // [69] phi from init_screen::@2 to init_screen::@2 [phi:init_screen::@2->init_screen::@2]
    // [69] phi (byte) init_screen::m#2 = (byte) init_screen::m#1 [phi:init_screen::@2->init_screen::@2#0] -- register_copy 
    // [69] phi (byte*) init_screen::COLS#3 = (byte*) init_screen::COLS#1 [phi:init_screen::@2->init_screen::@2#1] -- register_copy 
    // init_screen::@2
  b2:
    // COLS[0] = WHITE
    // [70] *((byte*) init_screen::COLS#3) ← (const byte) init_screen::WHITE#0 -- _deref_pbuz1=vbuc1 
    lda #WHITE
    ldy #0
    sta (COLS),y
    // COLS[1] = WHITE
    // [71] *((byte*) init_screen::COLS#3 + (byte) 1) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    ldy #1
    sta (COLS),y
    // COLS[2] = WHITE
    // [72] *((byte*) init_screen::COLS#3 + (byte) 2) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    ldy #2
    sta (COLS),y
    // COLS[3] = WHITE
    // [73] *((byte*) init_screen::COLS#3 + (byte) 3) ← (const byte) init_screen::WHITE#0 -- pbuz1_derefidx_vbuc1=vbuc2 
    ldy #3
    sta (COLS),y
    // COLS += 40
    // [74] (byte*) init_screen::COLS#1 ← (byte*) init_screen::COLS#3 + (byte) $28 -- pbuz1=pbuz1_plus_vbuc1 
    lda #$28
    clc
    adc COLS
    sta COLS
    bcc !+
    inc COLS+1
  !:
    // for(byte m: 0..24)
    // [75] (byte) init_screen::m#1 ← ++ (byte) init_screen::m#2 -- vbuxx=_inc_vbuxx 
    inx
    // [76] if((byte) init_screen::m#1!=(byte) $19) goto init_screen::@2 -- vbuxx_neq_vbuc1_then_la1 
    cpx #$19
    bne b2
    // init_screen::@return
    // }
    // [77] return 
    rts
}
  // print_cls
// Clear the screen. Also resets current line/char cursor.
print_cls: {
    // memset(print_screen, ' ', 1000)
    // [79] call memset 
    // [81] phi from print_cls to memset [phi:print_cls->memset]
    jsr memset
    // print_cls::@return
    // }
    // [80] return 
    rts
}
  // memset
// Copies the character c (an unsigned char) to the first num characters of the object pointed to by the argument str.
memset: {
    .const c = ' '
    .const num = $3e8
    .label str = print_screen
    .label end = str+num
    .label dst = $c
    // [82] phi from memset to memset::@2 [phi:memset->memset::@2]
    // [82] phi (byte*) memset::dst#4 = (byte*)(const void*) memset::str#0 [phi:memset->memset::@2#0] -- pbuz1=pbuc1 
    lda #<str
    sta dst
    lda #>str
    sta dst+1
    // [82] phi from memset::@1 to memset::@2 [phi:memset::@1->memset::@2]
    // [82] phi (byte*) memset::dst#4 = (byte*) memset::dst#1 [phi:memset::@1->memset::@2#0] -- register_copy 
    // memset::@2
  b2:
    // *dst = c
    // [83] *((byte*) memset::dst#4) ← (const byte) memset::c#0 -- _deref_pbuz1=vbuc1 
    lda #c
    ldy #0
    sta (dst),y
    // for(char* dst = str; dst!=end; dst++)
    // [84] (byte*) memset::dst#1 ← ++ (byte*) memset::dst#4 -- pbuz1=_inc_pbuz1 
    inc dst
    bne !+
    inc dst+1
  !:
    // memset::@1
    // [85] if((byte*) memset::dst#1!=(const byte*) memset::end#0) goto memset::@2 -- pbuz1_neq_pbuc1_then_la1 
    lda dst+1
    cmp #>end
    bne b2
    lda dst
    cmp #<end
    bne b2
    // memset::@return
    // }
    // [86] return 
    rts
}
  // File Data
  print_hextab: .text "0123456789abcdef"
  vals: .byte -$5f, -$40, -$20, -$10, 0, $10, $20, $40, $5f
  // mulf_sqr tables will contain f(x)=int(x*x) and g(x) = f(1-x).
  // f(x) = >(( x * x ))
  .align $100
mulf_sqr1:
.for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((i*i)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((i-256)*(i-256))/256) }
    	.if(i>351) { .byte round(((512-i)*(512-i))/256) }
    }

  // g(x) =  >((( 1 - x ) * ( 1 - x )))
  .align $100
mulf_sqr2:
.for(var i=0;i<$200;i++) {
    	.if(i<=159) { .byte round((-i-1)*(-i-1)/256) }
    	.if(i>159 && i<=351 ) { .byte round(((255-i)*(255-i))/256) }
    	.if(i>351) { .byte round(((i-511)*(i-511))/256) }  
    }


