// Memory Layout and Shared Data

// Address of the first screen
const byte* PLAYFIELD_SCREEN_1 = $0400;
// Address of the second screen
const byte* PLAYFIELD_SCREEN_2 = $2c00;
// Screen Sprite pointers on screen 1
const byte* PLAYFIELD_SPRITE_PTRS_1 = (PLAYFIELD_SCREEN_1+SPRITE_PTRS);
// Screen Sprite pointers on screen 2
const byte* PLAYFIELD_SPRITE_PTRS_2 = (PLAYFIELD_SCREEN_2+SPRITE_PTRS);
// Address of the original playscreen chars
const byte* PLAYFIELD_SCREEN_ORIGINAL = $1800;
// Address of the sprites covering the playfield
const byte* PLAYFIELD_SPRITES = $2000;
// Address of the charset
const byte* PLAYFIELD_CHARSET = $2800;

// The size of the playfield
const byte PLAYFIELD_LINES = 22;
const byte PLAYFIELD_COLS = 10;

// The playfield.  0 is empty non-zero is color.
// The playfield is layed out line by line, meaning the first 10 bytes are line 1, the next 10 line 2 and so forth,
byte[PLAYFIELD_LINES*PLAYFIELD_COLS] playfield;

// Pointer to the current piece in the current orientation. Updated each time current_orientation is updated.
byte* current_piece_gfx;

// The char of the current piece
byte current_piece_char;

// Position of top left corner of current moving piece on the playfield
byte current_xpos;
byte current_ypos;

// The screen currently being rendered to. $00 for screen 1 / $40 for screen 2.
byte render_screen_render = $40;
// The screen currently to show next to the user. $00 for screen 1 / $40 for screen 2.
byte render_screen_show = 0;
// The screen currently being showed to the user. $00 for screen 1 / $40 for screen 2.
volatile byte render_screen_showing = 0;
